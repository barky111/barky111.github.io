<!DOCTYPE html>
<html lang="en">
	<script src="script/barky_main.js"></script>
	<script src="script/site.js"></script>
	<script src="script/barky_strings.js"></script>
	<script src="script/barky_graphics.js"></script>
	<script>
		document.write(head);
		document.querySelector("title").innerHTML = "canvas tools";
	</script>
	<head>
		<style>
			body {
				background: #fffae3;
				color: black;
			}
		</style>
	</head>
	<body>
	<script>
	function paintbucket(context, xpos, ypos, newcolor) {
	// moved from reusables
		let fillstyletemp = context.fillStyle;
		if(newcolor) {
			context.fillStyle = newcolor;
		};
		let oldcolor = "rgb(" + context.getImageData(xpos, ypos, 1, 1).data[0] + "," + context.getImageData(xpos, ypos, 1, 1).data[1] + "," + context.getImageData(xpos, ypos, 1, 1).data[2] + ")";
		let outlinex = [];
		let outliney = [];
		outlinex[0] = xpos;
		outliney[0] = ypos;
		context.fillRect(outlinex[0], outliney[0], 1, 1);
		if(("rgb(" + context.getImageData(xpos, ypos, 1, 1).data[0] + "," + context.getImageData(xpos, ypos, 1, 1).data[1] + "," + context.getImageData(xpos, ypos, 1, 1).data[2] + ")")===oldcolor) {
			context.fillStyle = fillstyletemp;
			return;
		};
		let oldoutlinex = [];
		let oldoutliney = [];
		let currentcolor = "";
		let stepstocorner = 0;
		let stepstoallcorners = 0;
		for(pbi1 = 0; pbi1 < 4; pbi1++){
			if(pbi1===0) {
				stepstocorner = Math.abs(0 - xpos) + Math.abs(0 - ypos);
			}
			else if(pbi1===1) {
				stepstocorner = Math.abs((context.canvas.width - 1) - xpos) + Math.abs(0 - ypos);
			}
			else if(pbi1===2) {
				stepstocorner = Math.abs(0 - xpos) + Math.abs((context.canvas.height - 1) - ypos);
			}
			else if(pbi1===3) {
				stepstocorner = Math.abs((context.canvas.width - 1) - xpos) + Math.abs((context.canvas.height - 1) - ypos);
			}
			else {
				console.log("this shouldn't happen");
			};
			if(stepstocorner > stepstoallcorners) {
				stepstoallcorners = stepstocorner;
			};
		}
		for(pbi1 = 0; outlinex.length > 0 && outliney.length > 0 && pbi1 < stepstoallcorners; pbi1++){
			oldoutlinex = outlinex;
			oldoutliney = outliney;
			outlinex = [];
			outliney = [];
			for(pbi2 = 0; pbi2 < 4; pbi2++){
				for(pbi3 = 0; pbi3 < oldoutlinex.length; pbi3++){
					outlinex[(pbi2*oldoutlinex.length + pbi3)] = oldoutlinex[pbi3];
					outliney[(pbi2*oldoutliney.length + pbi3)] = oldoutliney[pbi3];
					if(pbi2===0) {
						outlinex[(pbi2*oldoutlinex.length + pbi3)] += 1;
					}
					else if(pbi2===1) {
						outlinex[(pbi2*oldoutlinex.length + pbi3)] -= 1;
					}
					else if(pbi2===2) {
						outliney[(pbi2*oldoutliney.length + pbi3)] += 1;
					}
					else if(pbi2===3) {
						outliney[(pbi2*oldoutliney.length + pbi3)] -= 1;
					}
					else {
						console.log("this shouldn't happen.");
					};
				}
			}
			for(pbi2 = 0; pbi2 < outlinex.length; pbi2++){
				for(pbi3 = 0; pbi3 < pbi2; pbi3++){
					if(outlinex[pbi2]===outlinex[pbi3] && outliney[pbi2]===outliney[pbi3]) {
						pbi3 += pbi2;
						outlinex.splice(pbi2, 1);
						outliney.splice(pbi2, 1);
						pbi2 -= 1;
					};
				}
			}
			for(pbi2 = 0; pbi2 < outlinex.length; pbi2++){
				if((0 <= outlinex[pbi2] < context.canvas.width) && (0 <= outliney[pbi2] < context.canvas.height)) {
					currentcolor = "rgb(" + context.getImageData(outlinex[pbi2], outliney[pbi2], 1, 1).data[0] + "," + context.getImageData(outlinex[pbi2], outliney[pbi2], 1, 1).data[1] + "," + context.getImageData(outlinex[pbi2], outliney[pbi2], 1, 1).data[2] + ")";
					if(currentcolor===oldcolor) {
						context.fillRect(outlinex[pbi2], outliney[pbi2], 1, 1);
					}
					else {
						outlinex.splice(pbi2, 1);
						outliney.splice(pbi2, 1);
						pbi2 -= 1;
					};
				};
			}
		}
		context.fillStyle = fillstyletemp;
	}
	function numofdigits(value) {
	// returns an array with the number of digits before and after the decimal
	// point.
	// =
	// moved to reusables
		value = "" + value;
		if(value.includes(".")) {
			return [value.indexOf("."), value.length - (value.indexOf(".") + 1)];
		}
		else {
			return [value.length, 0];
		};
	}
	function numalign(values, skiprightspaces) {
	// adds spaces to the beginning and/or end of each number so they all line
	// up.
	// - values should be an array of numbers.
	// =
	// moved to reusables
		let i1 = 0;
		let maxleftdigits = "x";
		let maxrightdigits = "x";
		for (i1 = 0; i1 < values.length; i1++) {
			if(maxleftdigits === "x" || numofdigits(values[i1])[0] > maxleftdigits) {
				maxleftdigits = numofdigits(values[i1])[0];
			};
			if(maxrightdigits === "x" || numofdigits(values[i1])[1] > maxrightdigits) {
				maxrightdigits = numofdigits(values[i1])[1];
			};
		}
		for (i1 = 0; i1 < values.length; i1++) {
			if(numofdigits(values[i1])[0] < maxleftdigits) {
				values[i1] = " ".repeat(maxleftdigits - numofdigits(values[i1])[0]) + values[i1];
			}
			else {
				values[i1] = "" + values[i1];
			};
			if(!skiprightspaces && numofdigits(values[i1])[1] < maxrightdigits) {
				values[i1] = values[i1] + " ".repeat(maxrightdigits - numofdigits(values[i1])[1]);
			};
		}
		return values;
	}
	function converttime(input, fromnumbers, amount, shush) {
	// only accepts XX:XX[a/p] format. this is not how javascript writes
	// dates, it's how i write dates.
	// - fromnumbers: if this is true, it'll use the input as a number
	//   and convert to the time string instead.
	// - amount: if this is true, it'll assume you're converting not a
	//   time, but an amount of hours, minutes, and seconds.
	//   - it accepts XhXXmXXs, XhXXm, XmXXs, Xh, Xm, and Xs.
	//   - NOTE: it returns the seconds, not minutes! also, if you're
	//     converting *to* a time amount, it will always write the seconds.
	// - gotta make sure to test this... i always screw up with
	//   functions like this, somehow.
	//   - takes way longer than you'd think, too.
	// - NOTE: it gets rid of "~" at the beginning, and it can process +/-
	//   at the beginning
	// =
	// moved from reusables
		let i1 = 0;
		let i2 = 0;
		if(!fromnumbers && input.startsWith("~")) {
			input = input.slice(1);
		};
		if(amount) {
			if(fromnumbers) {
				let negative = false;
				if(input < 0) {
					input *= -1;
					negative = true;
				};
				let seconds = (input%60).toString();
				let minutes = Math.floor(input/60);
				let hours = Math.floor(minutes/60).toString();
				minutes = (minutes%60).toString();
				minutes = "0".repeat(2 - minutes.length) + minutes;
				seconds = "0".repeat(2 - seconds.length) + seconds;
				let output = hours + "h" + minutes + "m" + seconds + "s";
				// example: 0h03m56s
				if(hours === "0") {
					output = output.slice(2);
					if(minutes === "00") {
						output = output.slice(3);
						if(seconds === "00") {
							output = output.slice(1);
						}
						else if(seconds.slice(0, 1) === "0") {
							output = output.slice(1);
						};
					}
					else if(minutes.slice(0, 1) === "0") {
						output = output.slice(1);
					};
				};
				return (negative ? "-" : "") + output;
			}
			else {
				let negative = false;
				if(input[0] === "+") {
					input = input.slice(1);
				}
				else if(input[0] === "-") {
					input = input.slice(1);
					negative = true;
				};
				let nums = {};
				let slicestart = 0;
				for (i1 = 0; i1 < input.length; i1++) {
					if("hms".includes(input[i1])) {
						nums[input[i1]] = Number(input.slice(slicestart, i1));
						if(slicestart !== 0 && i1 - slicestart !== 2) {
						// only the largest type is allowed to have as many
						// digits as it wants. (ex: 1h7m is invalid, 1m100s
						// is invalid)
							if(!shush) {
								console.log("invalid input.");
							}
							return;
						}
						slicestart = i1 + 1;
					}
					else if(i1 === input.length - 1) {
					// it should end with one of those.
						if(!shush) {
							console.log("invalid input.");
						}
						return;
					}
					else if(!"0123456789".includes(input[i1])) {
					// it should only be numbers and h/m/s.
						if(!shush) {
							console.log("invalid input.");
						}
						return;
					}
				}
				nums.h ??= 0;
				nums.m ??= 0;
				nums.s ??= 0;
				return (negative ? -1 : 1)*(nums.h*60*60 + nums.m*60 + nums.s);
			};
		}
		else {
			if(fromnumbers) {
				input %= 24*60;
				let ampm = "";
				if(input >= 12*60) {
					input -= 12*60;
					ampm += "p";
				};
				let hours = Math.floor(input/60).toString();
				let minutes = (input%60).toString();
				if(hours === "0") {
					hours = "12";
				};
				hours = "0".repeat(2 - hours.length) + hours;
				return hours + ":" + minutes + ampm;
			}
			else {
				let hours = Number( input.slice(0, input.indexOf(":")) );
				let minutes = Number( input.slice(input.indexOf(":") + 1, -1) );
				if(
				!input.includes(":")
				||
				(input.slice(-1) !== "a" && input.slice(-1) !== "p")
				||
				!hours || !Number.isInteger(hours) || hours < 1 || hours > 12
				||
				!input.slice(input.indexOf(":") + 1, -1) || !Number.isInteger(minutes) || minutes < 0 || minutes >= 60
				) {
					// hours shouldn't be zero, though that's valid in some
					// systems (also empty space can be number-converted to
					// 0 and i don't feel like dealing with it. except i
					// already did for minutes.)
					if(!shush) {
						console.log("invalid converttime input.");
					};
					return;
				};
				if(hours === 12) {
					hours = 0;
				};
				return hours * 60 + minutes + (input.slice(-1) === "p" ? 12*60 : 0);
			};
		};
	};
	function getcolor(context, x, y, rgbaformat) {
	// doesn't include alpha
		if(
			x < 0
			||
			x >= context.canvas.width
			||
			y < 0
			||
			y >= context.canvas.height
		) {
			return "";
			// out of bounds
		};
		var returnvalue = "rgba(";
		returnvalue += context.getImageData(x, y, 1, 1).data[0] + ", ";
		returnvalue += context.getImageData(x, y, 1, 1).data[1] + ", ";
		returnvalue += context.getImageData(x, y, 1, 1).data[2] + ", ";
		returnvalue += context.getImageData(x, y, 1, 1).data[3]/255 + ")";
		if(!rgbaformat) {
			returnvalue = colortohex(context, returnvalue);
		}
		return returnvalue;
	}
	function colortohex(context, color) {
		var fillstyletemp = context.fillStyle;
		context.fillStyle = color;
		var returnvalue = context.fillStyle;
		context.fillStyle = fillstyletemp;
		return returnvalue;
	}
	function hsvtorgb(h, s, v, returncolor) {
	// returncolor: if true, it'll return an "rgb(x, y, z)" string instead of an
	// array of rgb values
	// - seems to work.
		let maxvalue = Math.round(255*v/100);
		let minvalue = Math.round(maxvalue*(1 - s/100));
		let color1 = Math.floor(((h + 60)%360)/120);
		// the r/g/b that has the highest value
		// the turning points for which is color1 should be the secondary
		// colors: yellow, cyan, and magenta
		// - 300 to 60 = red
		// - 60 to 180 = green
		// - 180 to 300 = blue
		let color2 = (color1 + (h%120 < 60 ? 1 : 2))%3;
		// the r/g/b that has the second highest value
		let secondary = Math.abs((h + 60)%120 - 120/2) * 1/(.5*120);
		// the fraction of the way color2 is between the highest and lowest
		// - i need to properly figure out the math for scaling a triangle wave
		//   to a particular wavelength/height sometime, this is always hard to
		//   wrap my head around
		// - or i could just do it right now... apparently. what the hell, the
		//   last time i tried this i couldn't figure it out at all.
		//   - Math.abs(x%w - w/2) * h/(.5*w)
		let rgb = [minvalue, minvalue, minvalue];
		rgb[color1] = maxvalue;
		rgb[color2] = Math.round(minvalue + secondary*(maxvalue - minvalue));
		/*
		console.log("minvalue: " + minvalue);
		console.log("maxvalue: " + maxvalue);
		console.log("color1: " + color1);
		console.log("color2: " + color2);
		console.log("secondary: " + secondary);
		//*/
		if(returncolor) {
			return "rgb(" + rgb.join(", ") + ")";
		}
		else {
			return rgb;
		};
		// value
		// 0: red		rg	0	01 <
		// 30: orange	rg	50	01 <
		// 60: yellow	gr	100	10
		// 90: lime		gr	50	10
		// 120: green	gb	0	12 <
		// 150: mint	gb	50	12 <
		// 180: cyan	bg	100	21
		// 210: azure	bg	50	21
		// 240: blue	br	0	20 <
		// 270: purple	br	50	20 <
		// 300: magenta	rb	100	02
		// 330: viored	rb	50	02
		// color2 is color1 + 2, or + 1 if h%120 < 60
	}
	function colormath(ctx, color0, color1, place) {
		let i1 = 0;
		place = Math.max(0, Math.min(place, 1));
		if(typeof color0 === "string") {
			color0 = Color.rgb(ctx, color0);
		}
		if(typeof color1 === "string") {
			color1 = Color.rgb(ctx, color1);
		}
		if((color0.length === 4) !== (color1.length === 4)) {
			color0[3] ??= 255;
			color1[3] ??= 255;
		};
		let newcolor = [];
		for(i1 = 0; i1 < color0.length; i1++) {
			newcolor[i1] = color1[i1]*place + color0[i1]*(1 - place);
			if(i1 === 3) {
				newcolor[i1] /= 255;
			};
		}
		return "rgb" + (newcolor.length === 3 ? "a" : "") + "(" + newcolor.join() + ")";
	};
	function gethsv(color, ctx) {
	// ctx is used to convert the color if it isn't in hexadecimal format. (for
	// whatever reason, there is no built-in function for this.)
		let rgb = Color.rgb(ctx, color).slice(0, 3);
		let sorted = structuredClone(rgb);
		sorted.sort((a, b) => a - b);
		let v = 100*sorted[2]/255;
		let s = (
			sorted[2] === 0
			// zero value means saturation can't be calculated without divide by
			// zero errors
			?
			0
			:
			100*(1 - sorted[0]/sorted[2])
		);
		if(sorted[0] === sorted[1]) {
		// primary color or neutral
			if(sorted[1] === sorted[2] || sorted[2] === rgb[0]) {
			// neutral or red
				return [0, s, v];
			}
			else if(sorted[2] === rgb[1]) {
			// green
				return [120, s, v];
			}
			else if(sorted[2] === rgb[2]) {
			// blue
				return [240, s, v];
			}
		}
		else if(sorted[1] === sorted[2]) {
		// secondary color
			if(sorted[2] === rgb[0] && sorted[2] === rgb[1]) {
			// yellow
				return [60, s, v];
			}
			else if(sorted[2] === rgb[1] && sorted[2] === rgb[2]) {
			// cyan
				return [180, s, v];
			}
			else if(sorted[2] === rgb[2] && sorted[2] === rgb[0]) {
			// magenta
				return [300, s, v];
			}
		}
		else {
			let i1 = 0;
			let primary = null;
			let secondary = null;
			for(i1 = 0; i1 < 3; i1++) {
				if(sorted[2] === rgb[i1]) {
					primary = i1;
				};
				if(sorted[1] === rgb[i1]) {
					secondary = i1;
				};
			}
			let sign = [null, 1, -1][posmod(secondary - primary, 3)];
			let ratio = (sorted[1] - sorted[0])/(sorted[2] - sorted[0]);
			// lower means it's closer to the primary hue, higher means it's
			// closer to the secondary hue
			let h = posmod(120*primary + 60*sign*ratio, 360);
			return [h, s, v];
		};
	}
	function colorgradient(colorA, colorB, value) {
	// 0 is colorA, 1 is colorB. both have to be in hexadecimal form
		if(value <= 0) {
			return colorA;
		}
		else if(value >= 1) {
			return colorA;
		}
		else {
			let newcolor = [
				(1 - value)*parseInt(colorA.slice(1, 3), 16) + value*parseInt(colorB.slice(1, 3), 16),
				(1 - value)*parseInt(colorA.slice(3, 5), 16) + value*parseInt(colorB.slice(3, 5), 16),
				(1 - value)*parseInt(colorA.slice(5, 7), 16) + value*parseInt(colorB.slice(5, 7), 16)
			];
			newcolor = [
				Math.min(Math.max(0, Math.floor(newcolor[0])), 255),
				Math.min(Math.max(0, Math.floor(newcolor[1])), 255),
				Math.min(Math.max(0, Math.floor(newcolor[2])), 255)
			];
			return "rgb(" + newcolor.join(",") + ")";
		}
	}
	function get2dline(x1, y1, x2, y2) {
	// standard form. Ax + By + C = 0. this is A, B, and C.
		//(y1 - y2)x + (x2 - x1)y + (x1*y2 - x2*y1) = 0
		let line = get2dangle(x2 - x1, y2 - y1);
		line = [
			Math.cos(line + Math.PI/2),
			Math.sin(line + Math.PI/2)
		];
		line[2] = -(x1*line[0] + y1*line[1]);
		return line;
	}
	function fourpointintersect(x1, y1, x2, y2, x3, y3, x4, y4, shush, segmentsintersect) {
	// finds the intersection between a line that crosses point 1 and point
	// 2 and a line that cross point 3 and point 4, returning it as an array
	// - shush: returns a string of what went wrong instead of logging an error
	// - segmentsintersect: makes it add another item to the array, a boolean
	//   for whether the intersection is within the line segments specified.
		let i1 = 0;
		if((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {
			if(shush) {
				return "point";
			}
			else {
				console.log("invalid input. one or both lines begin and end at the same point.");
				return;
			};
		}
		let lineA = get2dline(x1, y1, x2, y2, true);
		let lineB = get2dline(x3, y3, x4, y4, true);
		//let temp = new Line(x1, y1, 0, [posmod(get2dangle(lineA[0], lineA[1]) + Math.PI/2, 2*Math.PI), 0]).planeintersect(new Plane(lineB[0], lineB[1], 0, lineB[2])).slice(0, 2);
		//console.log(temp);
		//return temp;
		let x = null;
		let y = null;
		if(lineA[0]/lineA[1] === lineB[0]/lineB[1]) {
		// same slope
			if(lineA[2] === lineB[2]) {
			// average all points
				x = ((x1 + x2)/2 + (x3 + x4)/2)/2;
				y = ((y1 + y2)/2 + (y3 + y4)/2)/2;
				return [x, y];
			}
			else {
				if(shush) {
					return "parallel";
				}
				else {
					console.log("lines are parallel.");
					return;
				};
			};
		};
		y = (lineA[0]*lineB[2] - lineB[0]*lineA[2])/(lineB[0]*lineA[1] - lineA[0]*lineB[1]);
		x = [
			-(lineA[1]*y + lineA[2])/lineA[0],
			-(lineB[1]*y + lineB[2])/lineB[0]
		];
		if(!shush && Math.abs(x[0] - x[1]) > .0000000001) {
			console.log(x);
		}
		x = x[0];
		if(segmentsintersect) {
			let temp = (
				Math.min(x1, x2) <= x && x <= Math.max(x1, x2)
				&&
				Math.min(y1, y2) <= y && y <= Math.max(y1, y2)
				&&
				Math.min(x3, x4) <= x && x <= Math.max(x3, x4)
				&&
				Math.min(y3, y4) <= y && y <= Math.max(y3, y4)
			);
			return [x, y, temp];
		}
		else {
			return [x, y];
		};
	}
	//function finddistance(x1, y1, x2, y2) {
	//	return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
	//}
	// just use Math.hypot((x2 - x1), (y2 - y1))
	function mathgcf(numbers, shush) {
	// numbers: an array.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		if(numbers.includes(0)) {
			return 0;
		}
		_numbers = [];
		for (i1 = 0; i1 < numbers.length; i1++) {
			if(typeof numbers[i1] !== "number" || !Number.isInteger(numbers[i1])) {
				if(!shush) {
					console.log("invalid input, they must all be integers");
					console.log(numbers[i1]);
				};
				return;
			};
			_numbers[i1] = Math.abs(numbers[i1]);
		}
		let lowest = Math.min(..._numbers);
		let temp = false;
		//*
		let denom = 0;
		for (i1 = 1; i1 <= lowest/2; i1++) {
			denom = lowest/i1;
			if(Number.isInteger(denom)) {
				temp = true;
				for (i2 = 0; i2 < _numbers.length; i2++) {
					temp = _numbers[i2]%denom === 0;
					if(!temp) {
						i2 += _numbers.length;
					};
				}
				if(temp) {
					return denom;
				};
			}
		}
		return 1;
		//*/
		/*
		for (i1 = lowest; i1 >= 1; i1--) {
			temp = true;
			for (i2 = 0; i2 < _numbers.length; i2++) {
				temp = _numbers[i2]%i1 === 0;
				if(!temp) {
					i2 += _numbers.length;
				};
			}
			if(temp) {
				return i1;
			};
		}
		//*/
	};
	function mathlcd(numbers, shush) {
		let gcf = mathgcf(numbers, shush);
		let lcd = gcf;
		let i1 = 0;
		for (i1 = 0; i1 < numbers.length; i1++) {
			lcd *= numbers[i1]/gcf;
		};
		return Math.abs(lcd);
	};
	class Shape2d {
	// this is more than just a way of defining a spline, it's also a way of
	// defining a shape that's a mix of splines, straight lines, and
	// quarter/eighth curves.
	// - fyi this used to be called "Spline" but i changed it before changing it
	//   becomes a pain in the ass. i'm pretty sure i got all references to it,
	//   but maybe i missed something in my notes or comments somewhere...
	//   - i searched "spline" to replace it, so i'm confident i got all the
	//     ones that matter. but still.
	// - TODO
	//   - give draw a "slice" parameter
	//   - make it possible to draw any kind of circular or elliptical arc
	//     - use that to make it possible to rotate the shape.
	//       - gather all non-elbow coordinates and indexes, run revolve on
	//         them, replace the numbers, and add a "rotate" parameter that
	//         everything responds to
		constructor(points, close, fineness) {
		// - points: an array of objects. the structure is:
		//   - x, y: coordinates
		//   - elbow: object property defining the connection from this point to
		//     the next. a spline, quarter-curve, or eighth-curve. NOTE if there
		//     is no elbow property, the connection will be straight.
		//     - if the elbow does not have a fineness property, the fineness
		//       parameter will be used. if that is absent, it will have a
		//       fineness of 16.
		//     - if it's "in" or "out", it's a quarter-circle.
		//       - if it's out and the line connecting the points has a
		//         negative slope, (visually, i mean... ignore that +y is
		//         down and -y is up in programming) it's a line that
		//         curves up then left
		//       - out and positive, left then down
		//       - in and negative, down then right
		//       - in and positive, right then up
		//     - if it's "u", "d", "l", or "r", it's an eighth curve
		//       - the letter indicates which cardinal direction it's
		//         mostly pointing towards. for a positive slope, "r"
		//         would mean right then up/right, "u" would mean up then
		//         up/right
		//   - the structure of Shape2d is exactly the same, except for:
		//     - path: all of the points a drawing of this shape should connect,
		//       in one big list.
		//       - it's an array of coordinate arrays. it's unstructured.
		//       - it's a getter, so make sure to copy it to a temp if you're
		//         gonna be referencing it a lot.
		//     - close: a boolean storing whether to connect the first and last
		//       point.
		//     - fineness: number used when a point does not have a fineness
		//       number of its own
		//     - rotation: object
		//       - angle: amount that get path rotates things by, measured in
		//         radians
		//       - x, y: fulcrum that get path rotates things by
		//   =
		//   - simplified:
		//     - x, y
		//     - elbow:
		//       - straight line if absent
		//       - x, y (spline)
		//       - fineness
		//       - direction (in/out: quarter curve, u/r/d/l: eighth curve)
		//     - and the properties the constructor adds are path, close, fineness
		// - alternatively, points can be an array or arrays. in that case,
		//   every other point will be treated as an elbow, and if a [2] number
		//   exists, that will be used as a fineness number.
		// - close: boolean. if true, the last point will be connected to the
		//   first.
		// - fineness: this will be saved into the object and used whenever for
		//   the number of lines per spline or curve if the elbow does not
		//   specify.
			if(noargumentscheck([points, close, fineness])) {
			// create an empty object that another object's contents can be
			// pasted into
				return;
			}
			let i1 = 0;
			let i2 = 0;
			if(!fineness) {
				fineness = points.hasOwnProperty("fineness") ? points.fineness : 16;
			};
			if((close ?? null) === null) {
				close = points.hasOwnProperty("close") ? points.close : false;
			};
			let inputtype = "";
			let length = Array.isArray(points) ? points.length : objarraylength(points);
			for(i1 = 0; i1 < length; i1++) {
				if(typeof points[i1] === "object") {
					if(Array.isArray(points[i1])) {
						if(!inputtype) {
							inputtype = "array";
						}
						else if(inputtype !== "array") {
							console.log("invalid input, points is a mix of arrays and objects");
							return;
						};
					}
					else {
						if(!inputtype) {
							inputtype = "object";
						}
						else if(inputtype !== "object") {
							console.log("invalid input, points is a mix of arrays and objects");
							return;
						};
					}
				}
				else {
					console.log("invalid input, at least one point isn't an array or object");
					return;
				};
			}
			let _points = {};
			if(inputtype === "array") {
				for (i1 = 0; i1 < length; i1 += 2) {
					_points[i1] = {
						x: points[i1][0],
						y: points[i1][1],
					};
					if(i1 + 1 < length) {
						_points[i1].elbow = {
							x: points[i1 + 1][0],
							y: points[i1 + 1][1],
						}
						if(points[i1 + 1][2] || points[i1 + 1][2] === 0) {
							_points[i1].elbow.fineness = points[i1][2];
						};
					};
				}
			}
			else if(inputtype === "object") {
				_points = structuredClone(points);
			}
			else if(compareobject(points, [])) {
				this.fineness = fineness;
				this.closed = !!closed;
				this.rotate = {
					angle: 0,
					x: 0,
					y: 0,
				};
				return;
			}
			else {
				console.log("invalid input, couldn't figure out if points are arrays or objects.");
				return;
			};
			if(Array.isArray(_points)) {
				_points = structuredClone(arraytoobject(_points))
			};
			_points.fineness = fineness;
			_points.closed = close;
			_points.rotate = {
				angle: 0,
				x: 0,
				y: 0,
			}
			for (i1 in _points) {
				this[i1] = structuredClone(_points[i1]);
			};
			//this = structuredClone(_points);
			//return _points;
			//
			// all properly formatted now.
			// - it's an object of objects
			// - fineness and elbow are present and defined
			// - closed is there
			// yes, that's all. path is a getter, meaning running it makes it
			// calculate where all the points should be.
		}
		get path() {
		// this should go without saying but, don't run this more than you have
		// to. save it to a temp or something.
			let i1 = 0;
			let i2 = 0;
			let path = [];
			//
			let prev = null;
			let next = null;
			//let intersections = [];
			let arraylength = objarraylength(this);
			let temp = [];
			let fineness = 0;
			const eighthdim = [1 - Math.cos(2*Math.PI/8), Math.sin(2*Math.PI/8)];
			// dimensions of an arc from 0 to 45
			for (i1 = 0; i1 < arraylength; i1++) {
				path[path.length] = [this[i1].x, this[i1].y];
				if(this.closed) {
					prev = structuredClone(this[posmod(i1, arraylength)]);
					next = structuredClone(this[posmod(i1 + 1, arraylength)]);
				}
				else {
					prev = structuredClone(this[i1]);
					next = structuredClone(this[i1 + 1]);
				};
				prev ??= null;
				next ??= null;
				// right now it's prev/next point, singular...
				if(
					!this[i1].hasOwnProperty("elbow")
					||
					(
						prev !== null
						&&
						next !== null
						&&
						this[i1].elbow.hasOwnProperty("direction")
						&&
						(
							Math.abs(next.x - prev.x) === 0
							||
							Math.abs(next.y - prev.y) === 0
						)
					)
					||
					(
						i1 === arraylength - 1
						&&
						!this.closed
					)
				) {
				// skip all the elbow code.
				// - if it's a quarter or eighth curve and either coordinate
				//   distance is zero, it'll screw up the logic, and it'll just
				//   make a straight line anyway.
				// - if it's not closed and this is the last point, there's no
				//   next point to connect to.
				}
				else {
					fineness = (this[i1].elbow.hasOwnProperty("fineness") ? this[i1].elbow.fineness : this.fineness);
					// use the overall fineness if none exists for this point.
					if(this[i1].elbow.hasOwnProperty("x") && this[i1].elbow.hasOwnProperty("y")) {
					// spline
					// - there are a lot of ways things can go tits up with a
					//   spline, because of the mathematical limits of
					//   fourpointintersect.
					//   - if the elbow falls on the same line as the previous
					//     and next point, lines will count as parallel
					//   - if the previous and next point are on the same
					//     coordinates, same thing.
					//   - if the elbow is directly on one or both, you get
					//     the point error.
					//   - however, in all of those cases, it still needs to
					//     draw something. picture a spline's angle narrowing
					//     and narrowing until it closes. it doesn't make
					//     sense for it to draw a line from prev to the
					//     elbow to the next, and it doesn't make sense
					//     for it to skip the elbow either. my aim is to use
					//     the Shape2d class in an interactive gui, and either
					//     of those would make it look glitchy and awful.
					//     oh fuck it, for now i'm just gonna use
					//     Math.SQRT1_2. that's close enough. i don't feel
					//     like figuring out what different fineness levels
					//     should translate to. fuck you
					//     - TODO
						temp = [structuredClone(prev), structuredClone(next)];
						prev = [];
						// equidistant points from the previous point to the
						// elbow (including the previous point, but not the
						// elbow)
						next = [];
						// equidistant points from the elbow to the next
						// point
						let intersections = [];
						temp[2] = fourpointintersect(temp[0].x, temp[0].y, this[i1].elbow.x, this[i1].elbow.y, this[i1].elbow.x, this[i1].elbow.y, temp[1].x, temp[1].y, true);
						//
						if(temp[2] === "point") {
							// don't add anything. the elbow is either on the
							// previous point, the next point, or both.
						}
						else if(temp[2] === "parallel") {
							if(temp[0].x === temp[1].x && temp[0].y === temp[1].y) {
								// if the previous and next point are on the same
								// coordinates.
								let temp2 = [
								temp[0].x*Math.SQRT1_2 + this[i1].elbow.x*(1 - Math.SQRT1_2),
								temp[0].y*Math.SQRT1_2 + this[i1].elbow.y*(1 - Math.SQRT1_2)
								];
								path[path.length] = structuredClone(temp2);
								// technically this should change a little
								// bit based on fineness but. fuck yuou
							}
							else {
								// the elbow falls on the same line as the previous
								// and next point
								let temp2 = null;
								if(Math.hypot(temp[1].x - this[i1].elbow.x, temp[1].y - this[i1].elbow.y) < Math.hypot(temp[0].x - this[i1].elbow.x, temp[0].y - this[i1].elbow.y)) {
									temp2 = [temp[1].x, temp[1].y];
								}
								else {
									temp2 = [temp[0].x, temp[0].y];
								};
								// use whichever point is closer.
								temp2 = [
								temp2[0]*Math.SQRT1_2 + this[i1].elbow.x*(1 - Math.SQRT1_2),
								temp2[1]*Math.SQRT1_2 + this[i1].elbow.y*(1 - Math.SQRT1_2)
								];
								path[path.length] = structuredClone(temp2);
							};
						}
						else {
							for (i2 = 0; i2 < fineness; i2++) {
								prev[i2] = [
								temp[0].x*(fineness - i2) + this[i1].elbow.x*i2,
								temp[0].y*(fineness - i2) + this[i1].elbow.y*i2
								];
								prev[i2][0] /= fineness;
								prev[i2][1] /= fineness;
								//
								next[i2] = [
								this[i1].elbow.x*(fineness - (i2 + 1)) + temp[1].x*(i2 + 1),
								this[i1].elbow.y*(fineness - (i2 + 1)) + temp[1].y*(i2 + 1),
								];
								next[i2][0] /= fineness;
								next[i2][1] /= fineness;
								if(i2 > 0) {
									intersections[i2 - 1] = fourpointintersect(
										prev[i2][0], prev[i2][1],
										next[i2][0], next[i2][1],
										prev[i2 - 1][0], prev[i2 - 1][1],
										next[i2 - 1][0], next[i2 - 1][1]
									);
								};
							}
							path = path.concat(intersections);
						};
					}
					else if(this[i1].elbow.hasOwnProperty("direction")) {
						let center = [null, null];
						let radii = [null, null];
						let arcstart = null;
						let ccw = false;
						// this stores which angle the previous point is
						// and which the next point is.
						// - ccw stands for counterclockwise
						if(["in", "out"].includes(this[i1].elbow.direction)) {
						// quarter
							radii = [Math.abs(next.x - prev.x), Math.abs(next.y - prev.y)];
							let relation = [Math.sign(next.x - prev.x), Math.sign(next.y - prev.y)];
							if(![-1, 1].includes(relation[0]) || ![-1, 1].includes(relation[1])) {
								console.log("this shouldn't happen");
							};
							relation = "u d"[(relation[1] + 1)] + "l r"[(relation[0] + 1)];
							let section = ["dl", "ul", "ur", "dr"].indexOf(relation);
							// if you're confused by the order here, relation is
							// where the next point is, but section is which
							// quarter of the circle you're using.
							let invert = invertboolean(this[i1].elbow.direction === "in", section < 2);
							// invert is whether, if this was a quarter on a
							// full ellipse, the in/out would make it concave
							// instead.
							if(invert) {
								section = (section + 2)%4;
							}
							center = invertboolean(section%2 === 0, invert) ? [next.x, prev.y] : [prev.x, next.y];
							for(i2 = (invert ? fineness - 1 : 1); 0 < i2 && i2 < fineness; i2 += (invert ? -1 : 1)) {
								let angle = (section + i2/fineness)%4;
								angle = 2*Math.PI*angle/4;
								let temp = [
									Math.cos(angle),
									Math.sin(angle)
								];
								path[path.length] = [
									center[0] + radii[0]*temp[0],
									center[1] + radii[1]*temp[1]
								];
							};
						}
						else if(["u", "d", "l", "r"].includes(this[i1].elbow.direction)) {
						// eighth
							radii = [];
							center = [];
							if(this[i1].elbow.direction === "u" || this[i1].elbow.direction === "d") {
								// y is the longer dimension, at least in the
								// eighthdim version
								radii[0] = Math.abs(next.x - prev.x)/eighthdim[0];
								//if eighthdim[0] = xdist/radius
								// eighthdim[0]*xradius = xdist
								// xradius = xdist/eighthdim[0]
								radii[1] = radii[0]*Math.abs(next.y - prev.y)*eighthdim[0]/(Math.abs(next.x - prev.x)*eighthdim[1]);
								//if yradius/xradius = (ydist/xdist)/(eighthdim[1]/eighthdim[0])
								// yradius = xradius*(ydist/xdist)/(eighthdim[1]/eighthdim[0])
								// simplified, that's
								// yradius = xradius*ydist*eighthdim[0]/(xdist*eighthdim[1])
							}
							else if(this[i1].elbow.direction === "l" || this[i1].elbow.direction === "r") {
								// remember, eighthdim[0] is the shorter dimension, so that should be y
								radii[1] = Math.abs(next.y - prev.y)/eighthdim[0];
								//if eighthdim[0] = ydist/radius
								// eighthdim[0]*yradius = ydist
								// yradius = ydist/eighthdim[0]
								radii[0] = radii[1]*Math.abs(next.x - prev.x)*eighthdim[0]/(Math.abs(next.y - prev.y)*eighthdim[1]);
								//if yradius/xradius = (ydist/xdist)/(eighthdim[0]/eighthdim[1])
								// xradius/yradius = (eighthdim[0]/eighthdim[1])/(ydist/xdist)
								// xradius = yradius*(eighthdim[0]/eighthdim[1])/(ydist/xdist)
								// simplified, that's
								// xradius = yradius*xdist*eighthdim[0]/(ydist*eighthdim[1])
							}
							else {
								console.log("this shouldn't happen");
							};
							let clockplace = [];
							const directions = ["u", "r", "d", "l"];
							clockplace[0] = directions.indexOf(this[i1].elbow.direction);
							clockplace[0] = (4 + 2*clockplace[0])%8;
							// 4 6 0 2
							clockplace[1] = (clockplace[0] + 3)%8;
							// 7 1 3 5
							let relation = [Math.sign(next.x - prev.x), Math.sign(next.y - prev.y)];
							switch (relation[0]) {
								case -1:
								relation[0] = "l";
								break;
								case 1:
								relation[0] = "r";
								break;
								default:
								console.log("this shouldn't happen");
								break;
							};
							switch (relation[1]) {
								case -1:
								relation[1] = "u";
								break;
								case 1:
								relation[1] = "d";
								break;
								default:
								console.log("this shouldn't happen");
								break;
							};
							relation = relation[1] + relation[0];
							ccw = relation.includes( directions[( directions.indexOf(this[i1].elbow.direction) + 3 )%directions.length] );
							if(invertboolean(relation.includes(directions[( directions.indexOf(this[i1].elbow.direction) + 2 )%directions.length]), ccw)) {
								clockplace = clockplace[1];
								// go with the choice clockwise of the
								// three-sector gap
							}
							else {
								clockplace = clockplace[0];
								// go with the choice counterclockwise of the
								// three-sector gap
							};
							arcstart = (clockplace + (ccw ? 1 : 0))%8;
							center = structuredClone(invertboolean(clockplace%2 === 1, ccw) ? next : prev);
							// choose the previous or next point this way
							clockplace = (clockplace + 1)%8;
							clockplace = Math.floor(clockplace/2);
							// clockplace has served its purpose
							switch (clockplace) {
								case 0:
								center = [center.x - radii[0], center.y];
								//console.log("subtract x");
								break;
								case 1:
								center = [center.x, center.y - radii[1]];
								//console.log("subtract y");
								break;
								case 2:
								center = [center.x + radii[0], center.y];
								//console.log("add x");
								break;
								case 3:
								center = [center.x, center.y + radii[1]];
								//console.log("add y");
								break;
								default:
								console.log("this shouldn't happen");
								break;
							};
							let angle = 0;
							//console.log(JSON.stringify({relation,arcstart,ccw,center,radii}));
							for(i2 = 1; i2 < fineness; i2++) {
								angle = 2*Math.PI*(arcstart + (ccw ? -1 : 1)*i2/fineness)/8;
								path[path.length] = [
								center[0] + radii[0]*Math.cos(angle),
								center[1] + radii[1]*Math.sin(angle)
								];
							};
							// the shit i put up with, i swear to god.
							// - this may be squeaky clean but good god was
							//   it a pain in the ass. i had to take out
							//   scratch paper and navigate stupid mental
							//   pretzel knots for literally two hours
							//   - "clockplace" comes from me drawing a
							//     circle, dividing it into eighths, and
							//     writing which relation/direction
							//     combination should be associated with
							//     which (treating the area outside the
							//     sector as counterclockwise)
							// - it probably could've taken less time if i
							//   just copied down all the data that helped
							//   me figure out to conditionals for each of
							//   the 16 possible relation/direction
							//   combinations
							// - but that'd be prone to mistakes and any
							//   mistake would be utter hell to identify and
							//   fix
							// - i'm gonna rewrite the quarter section
							//   around this
							//
							// this doesn't work yet, but it's almost there, i
							// think.
							// - might have to revisit the diagrams that i wrote
							//   on paper, like a caveman
							// -
						}
						else {
							console.log("invalid .direction.");
						};
					}
					else {
						console.log("invalid elbow point.");
					};
				};
			} // i1
			if(this.rotate.angle) {
				for(i1 = 0; i1 < path.length; i1++) {
					path[i1][2] = 0;
					path[i1] = revolve(this.rotate.angle, path[i1], [this.rotate.x, this.rotate.y, 0], "xy");
					path[i1] = [path[i1][0], path[i1][1]];
				}
			};
			return path;
		}
		draw(ctx, x, y, weight, fill, path) {
		// path: if specified, it'll use this instead. good for keeping it from
		// calculating path too many times.
			if(!path) {
				path = structuredClone(this.path);
			};
			// define this before because if i use this.path directly, it might
			// be running through that whole function every time it's brought up
			_2dPoly.draw(ctx, path, (fill ? "fill" : "stroke"), weight, [x, y], (this.closed ? false : "skiplaststroke"));
		}
		pathfraction(fraction) {
		// 0 is the beginning of the path, 1 is the end. (or beginning
		// again, if it's closed.) returns the x and y of that point.
			let i1 = 0;
			let i2 = 0;
			let path = structuredClone(this.path);
			if(this.closed) {
				fraction = posmod(fraction, 1);
			}
			else {
				fraction = Math.max(0, fraction);
				fraction = Math.min(1, fraction);
			};
			if(fraction === 0) {
				return path[0];
			}
			else if(fraction === 1) {
				return path[path.length - 1];
			};
			let dist = [];
			let total = 0;
			for (i1 = 0; i1 < path.length - 1; i1++) {
				dist[i1] = Math.hypot(path[i1 + 1][0] - path[i1][0], path[i1 + 1][1] - path[i1][1]);
				total += dist[i1];
			}
			if(this.closed) {
				dist[path.length - 1] = Math.hypot(path[0][0] - path[path.length - 1][0], path[0][1] - path[path.length - 1][1]);
				total += dist[path.length - 1];
			};
			fraction *= total;
			for (i1 = 0; i1 < dist.length; i1++) {
				if(fraction >= dist[i1]) {
					fraction -= dist[i1];
				}
				else {
					fraction /= dist[i1];
					return [
						fraction*path[(i1 + 1)%dist.length][0] + (1 - fraction)*path[i1][0],
						fraction*path[(i1 + 1)%dist.length][1] + (1 - fraction)*path[i1][1]
					];
				};
			}
		}
		get length() {
			let i1 = 0;
			let path = structuredClone(this.path);
			let total = 0;
			for (i1 = 0; i1 < path.length - 1; i1++) {
				total += Math.hypot(path[i1 + 1][0] - path[i1][0], path[i1 + 1][1] - path[i1][1]);
			}
			if(this.closed) {
				total += Math.hypot(path[0][0] - path[path.length - 1][0], path[0][1] - path[path.length - 1][1]);
			};
			return total;
		}
		tangent(relativeto, inorout) {
		// returns a slice of the .path between the two points that the
		// relativeto point tangents.
		// - relativeto: coordinates of the point you're tangenting to
		//   - obviously, it will not work properly if this is inside the path. my best
		//     guess of what would happen is that unless inorout is in, it will draw
		//     nothing except maybe a single side in the opposite direction of the
		//     closest path point, and if it's out it will draw everything except that
			let i1 = 0;
			let i2 = 0;
			relativeto ??= [0, 0];
			//increment ??= 1;
			inorout ??= "out";
			let path = structuredClone(this.path);
			let length = this.length;
			let offset = [];
			let closestindex = null;
			let closestdist = null;
			let temp = 0;
			for (i1 = 0; i1 < path.length; i1++) {
				temp = Math.hypot(path[i1][0] - relativeto[0], path[i1][1] - relativeto[1]);
				if(closestindex === null || temp > closestdist) {
					closestindex = i1;
					closestdist = temp;
				};
				/*
				if(increment && (this.closed || i1 === path.length - 1)) {
					offset[i1] = (i1 === 0 ? 0 : offset[i1 - 1]) + Math.hypot(path[(i1 + 1)%path.length][0] - path[i1][0], path[(i1 + 1)%path.length][1] - path[i1][1]);
					offset[i1] %= increment;
				};
				//*/
			}
			// offset 0 is the length from point 0 of the path to point 1. offset 1 is
			// point 0 to 2, 3 is point 0 to 3. etcetera
			// - they're remaindered by increment too
			// - why? because it bothers me for all the increment checks to start right
			//   at the relevant point, when if i actually ran a pathfraction thing for
			//   each position, it'd start at point 0.
			let closestrelangle = get2dangle(path[closestindex][0] - relativeto[0], path[closestindex][1] - relativeto[1], true);
			// this is the angle the closest path point has relative to the relativeto
			// point, it'll be used later...
			let lowestangle = null;
			let startindex = null;
			let highestangle = null;
			let endindex = null;
			for (i1 = 0; i1 < path.length; i1++) {
				temp = get2dangle(path[i1][0] - relativeto[0], path[i1][1] - relativeto[1], true);
				temp = posmod(temp, 2*Math.PI) - Math.PI;
				// now it should be an angle number between -1/2 a circumference and 1/2
				// a circumference
				if(startindex === null || temp < lowestangle) {
					startindex = i1;
					lowestangle = temp;
				};
				if(endindex === null || temp > highestangle) {
					endindex = i1;
					highestangle = temp;
				};
			}
			startindex = [startindex, endindex];
			endindex = Math.max(...startindex);
			startindex = Math.min(...startindex);
			// startindex and end index are the most clockwise and counterclockwise
			// indexes.
			//
			// insideavg
			// outsideavg
			let innerrecord = null;
			let outerrecord = null;
			// that is, record for furthest from the relativeto point.
			temp = 0;
			for (i1 = 0; i1 < path.length; i1++) {
				temp = Math.hypot(path[i1][0] - relativeto[0], path[i1][1] - relativeto[1]);
				if(i1 > startindex && i1 < endindex) {
					if(innerrecord === null || temp > innerrecord) {
						innerrecord = temp;
					};
				};
				if(i1 < startindex || i1 > endindex) {
					if(outerrecord === null || temp > outerrecord) {
						outerrecord = temp;
					};
				};
			}
			temp = [
				(path[startindex][0] + path[endindex][0])/2,
				(path[startindex][1] + path[endindex][1])/2
			];
			temp = Math.hypot(temp[0] - relativeto[0], temp[1] - relativeto[1]);
			innerrecord ??= temp;
			outerrecord ??= temp;
			// if there were no points between them, use the halfway point
			// -
			// innerrecord and outerrecord are the records for highest distance
			// from the relativeto, for the points between the start and end
			// index and outside them, respectively. NOTE this is NOT the points
			// that are on the inside and outside! this is just something very
			// stupid i have to do to find that.
			temp = invertboolean(inorout === "in", innerrecord > outerrecord);
			// a boolean for if i should retain the indexes between instead of the
			// indexes outside.
			// - if the average between distance is greater than the average outside
			//   distance, then the groups don't represent in and out points
			//   respectively, but the opposites of those.
			if(temp) {
				path = path.slice(startindex, endindex + 1);
			}
			else {
				path = path.slice(endindex).concat(path.slice(0, startindex + 1));
			};
			return path;
		}
		modcoordinates(operations) {
		/*
		modcoordinates({
			multiply: ,
			add: ,
			math: "floor",
		})
		//*/
		// runs an applyoperations on the shape2d and also inverts directions
		// and shit properly.
			let i1 = 0;
			let i2 = 0;
			let arraylength = objarraylength(this);
			let olddiff = [];
			// stores the positivity/negativity of the coordinate differences
			// from point to point.
			// - point 0 stores whether point 1 is higher or lower, to the left
			//   or the right.
			// - then i'll do another loop after applyoperations is done, so i
			//   can check which distances have been inverted.
			// - i need to do all this convoluted bullshit for it to invert
			//   quarter/eighth curves properly.
			// if the x difference from the previous point has been inverted,
			// invert the previous elbow.
			for (i1 = 0; i1 < arraylength - 1; i1++) {
				olddiff[i1] = [
					Math.sign(this[i1 + 1].x - this[i1].x),
					Math.sign(this[i1 + 1].y - this[i1].y)
				];
			}
			if(this.closed) {
				olddiff[arraylength - 1] = [
					Math.sign(this[0].x - this[arraylength - 1].x),
					Math.sign(this[0].y - this[arraylength - 1].y)
				];
			}
			for (i1 = 0; i1 < arraylength; i1++) {
				this[i1].x = applyoperations(this[i1].x, operations, 0);
				this[i1].y = applyoperations(this[i1].y, operations, 1);
				if(this[i1].hasOwnProperty("elbow")) {
					if(this[i1].elbow.hasOwnProperty("x")) {
						this[i1].elbow.x = applyoperations(this[i1].elbow.x, operations, 0);
					};
					if(this[i1].elbow.hasOwnProperty("y")) {
						this[i1].elbow.y = applyoperations(this[i1].elbow.y, operations, 1);
					};
				};
			}
			let newdiff = [];
			// this is just one point, because i don't need anything more.
			let temp = "";
			function invertdirection(direction, axis) {
				let temp = [];
				function arraycycle(array, item, shiftby) {
				// might make this universal too.
				// - especially since it's super useful in arrays for circular
				//   things. it's always a pain in the ass to connect the last
				//   point to the first.
					if(array.includes(item)) {
						return array[ posmod(array.indexOf(item) + shiftby, array.length) ];
					}
					else {
						return item;
					};
				}
				temp = ["l", "r"];
				if(axis.includes("x") && temp.includes(direction)) {
					direction = arraycycle(temp, direction, 1);
				};
				temp = ["u", "d"];
				if(axis.includes("y") && temp.includes(direction)) {
					direction = arraycycle(temp, direction, 1);
				};
				temp = ["in", "out"];
				if(axis.includes("y") && temp.includes(direction)) {
					direction = arraycycle(temp, direction, 1);
				};
				return direction;
			};
			for (i1 = 0; i1 < arraylength + (this.closed ? 0 : -1); i1++) {
				if(this[i1].hasOwnProperty("elbow") && this[i1].elbow.hasOwnProperty("direction")) {
					if(i1 === arraylength - 1) {
						newdiff = [
							Math.sign(this[0].x - this[i1].x),
							Math.sign(this[0].y - this[i1].y)
						];
					}
					else {
						newdiff = [
							Math.sign(this[i1 + 1].x - this[i1].x),
							Math.sign(this[i1 + 1].y - this[i1].y)
						];
					};
					temp = "";
					if([-1, 1].includes(newdiff[0]) && newdiff[0] === -1*olddiff[i1][0]) {
						temp += "x";
					};
					if([-1, 1].includes(newdiff[1]) && newdiff[1] === -1*olddiff[i1][1]) {
						temp += "y";
					};
					this[i1].elbow.direction = invertdirection(this[i1].elbow.direction, temp);
				}
			}
		}
		newpoint(index) {
		// places a new point after the index specified.
		// - if the index is the last point index and it isn't a closed shape,
		//   this will be an extension, a duplicate of the connection between
		//   the last two points.
		// - if not, it'll be a subdivision of the connection between this point
		//   and the next.
			let i1 = 0;
			let i2 = 0;
			let arraylength = objarraylength(this);
			if(!index) {
				index = arraylength - 1;
			}
			if(!Number.isInteger(index) || index >= arraylength) {
				console.log("invalid index");
			};
			function objsplice(object, index, deletenumber, insert) {
			// object version of array.splice. this is gonna be balls and ass to
			// test, won't it
				let i1 = 0;
				let i2 = 0;
				let shiftby = -(deletenumber ?? 0) + (insert || insert === 0 ? 1 : 0);
				// now it means, "how many places to shift the indexes after by"
				let arraylength = objarraylength(object);
				if(shiftby > 0) {
					for (i1 = arraylength - 1; i1 >= index; i1++) {
						object[i1 + shiftby] = structuredClone(object[i1]);
					}
				}
				else if(shiftby < 0) {
					for (i1 = index; i1 < arraylength; i1++) {
						object[i1] = structuredClone(object[i1 - shiftby]);
					}
					for(i1 = arraylength; i1 - arraylength < -shiftby; i1++) {
						delete object[i1];
					}
				}
				if(insert || insert === 0) {
					object[index] = structuredClone(insert);
				};
			}
			objsplice(this, index + 1, 0, {});
			extend = index === arraylength - 1 && !this.closed;
			arraylength = objarraylength(this);
			if(arraylength === 2) {
				console.log("newpoint shouldn't be used if there's only one point so far.");
				this[index + 1] = {
					x: this[index].x + 10,
					y: this[index].y + 10,
				};
				if(this[index].hasOwnProperty("elbow")) {
					this[index + 1].elbow = structuredClone(this[index].elbow);
				}
				return;
			};
			let nextindex = (index + 2)%arraylength;
			if(extend) {
				this[index + 1].x = this[index].x + (this[index].x - this[index - 1].x);
				this[index + 1].y = this[index].y + (this[index].y - this[index - 1].y);
			}
			else {
				this[index + 1].x = (this[index].x + this[nextindex].x)/2;
				this[index + 1].y = (this[index].y + this[nextindex].y)/2;
			}
			if(this[index].hasOwnProperty("elbow")) {
				this[index + 1].elbow = structuredClone(this[index].elbow);
				if(this[index].elbow.hasOwnProperty("x") && this[index].elbow.hasOwnProperty("y")) {
					this[index + 1].elbow.x = this[index + 1].x + (this[index].elbow.x - this[index].x)/(extend ? 1 : 2);
					this[index + 1].elbow.y = this[index + 1].y + (this[index].elbow.y - this[index].y)/(extend ? 1 : 2);
				}
			}
		}
		//Shape2d.build(type, dimensions, fineness, points, offset, etc)
		static build(type, dimensions, fineness, points, offset, etc) {
		// an alternate constructor, similar to build3dshape. instead of using
		// coordinates, you specify a type of shape.
		// - type:
		//   - "circle": makes an ellipsoid using quarter-curves.
		//   - "rect":
		//   - "regular": makes a regular polygon, the number of sides matching
		//     the fineness number.
		//   - "star": makes a star with as many points as the fineness number.
		//     (or 5, by default.)
		//     - if etc contains a number property called "constant", it will
		//       use that to determine where the armpits are instead of where
		//       lines intersect. 0 is at the center, 1 is at the same distance
		//       as the points.
		// - dimensions: one number, or an array of a width and height.
		// - points: used for star and regular, determines how many points or
		//   sides, respectively
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			if(["ellipse", "ellipsoid", "circ"].includes(type)) {
				type = "circle";
			};
			if(["box", "square", "rectangle"].includes(type)) {
				type = "rect";
			};
			if(["polygon"].includes(type)) {
				type = "regular";
			};
			//if([""].includes(type)) {
			//	type = "";
			//};
			let w = 1;
			let h = 1;
			if(typeof dimensions === "number") {
				w = dimensions;
				h = dimensions;
			}
			else if(Array.isArray(dimensions) && dimensions.length >= 2) {
				w = dimensions[0];
				h = dimensions[1];
			}
			else {
				console.log("invalid dimensions.");
			};
			if(!points) {
				points = 5;
			};
			if(!Array.isArray(offset) || offset.length < 2) {
				offset = [0, 0];
			};
			let shape = [];
			switch (type) {
				case "circle":
					for (i1 = 0; i1 < 4; i1++) {
						shape[i1] = {
							x: [ w/2,    0, -w/2,    0][i1],
							y: [   0,  h/2,    0, -h/2][i1],
							elbow: {
								direction: ["in", "in", "out", "out"][i1],
							},
						};
					}
				break;
				case "rect":
					for (i1 = 0; i1 < 4; i1++) {
						shape[i1] = {
							x: [ w/2, -w/2, -w/2,  w/2][i1],
							y: [ h/2,  h/2, -h/2, -h/2][i1],
						};
					}
				break;
				case "regular":
					for (i1 = 0; i1 < points; i1++) {
						shape[i1] = {
							x: Math.cos(2*Math.PI*i1/points)*w/2,
							y: Math.sin(2*Math.PI*i1/points)*h/2,
						};
					}
				break;
				case "star":
					if(etc && etc.hasOwnProperty("constant") && typeof etc.constant === "number") {
						for (i1 = 0; i1 < points; i1++) {
							shape[2*i1] = {
								x: Math.cos(2*Math.PI*i1/points)*w/2,
								y: Math.sin(2*Math.PI*i1/points)*h/2,
							};
							shape[2*i1 + 1] = {
								x: Math.cos(2*Math.PI*(i1 + .5)/points)*etc.constant*w/2,
								y: Math.sin(2*Math.PI*(i1 + .5)/points)*etc.constant*h/2,
							};
						}
					}
					else {
						let pits = [];
						for (i1 = 0; i1 < points; i1++) {
							shape[i1] = {
								x: Math.cos(2*Math.PI*i1/points)*w/2,
								y: Math.sin(2*Math.PI*i1/points)*h/2,
							};
						}
						let places = [];
						places[0] = Math.ceil(points/2) - 1;
						places[1] = points + 1 - places[0];
						// this should work for 5, 6, 7, 8.
						for (i1 = 0; i1 < points; i1++) {
							pits[i1] = fourpointintersect(
								shape[i1].x,
								shape[i1].y,
								shape[(i1 + places[0])%points].x,
								shape[(i1 + places[0])%points].y,
								shape[(i1 + 1)%points].x,
								shape[(i1 + 1)%points].y,
								shape[(i1 + places[1])%points].x,
								shape[(i1 + places[1])%points].y,
							true);
							pits[i1] = {
								x: pits[i1][0],
								y: pits[i1][1],
							};
						}
						for (i1 = 0; i1 < points; i1++) {
							shape.splice(2*i1 + 1, 0, structuredClone(pits[i1]));
						};
					};
				break;
				default:
					console.log("invalid type.");
				break;
			};
			for (i1 = 0; i1 < shape.length; i1++) {
				shape[i1].x += offset[0];
				shape[i1].y += offset[1];
				if(shape[i1].hasOwnProperty("elbow") && shape[i1].elbow.hasOwnProperty("x") && shape[i1].elbow.hasOwnProperty("y")) {
					shape[i1].elbow.x += offset[0];
					shape[i1].elbow.y += offset[1];
				}
			}
			return new Shape2d(shape, true, fineness);
		}
	};
	function savectxsettings(ctx) {
	// returns an object with all the simple data of a ctx, so it can be
	// restored later.
	// - fillStyle, strokeStyle, font, etc.
		let i1 = "";
		let ctxsettings = {};
		for (i1 in ctx) {
			if (["string", "number", "boolean", "bigint"].includes(typeof ctx[i1]) || Array.isArray(ctx[i1])) {
				ctxsettings[i1] = structuredClone(ctx[i1]);
			}
		}
		return ctxsettings;
	}
	function restorectxsettings(ctx, ctxsettings) {
		let i1 = "";
		for (i1 in ctxsettings) {
			if (["string", "number", "boolean", "bigint"].includes(typeof ctxsettings[i1]) || Array.isArray(ctxsettings[i1])) {
				ctx[i1] = structuredClone(ctxsettings[i1]);
			}
		}
	}
	function easingplacement(value1, value2, time, easeinorout, easingtype, overshoot/*[distance, time, easeinorout, easingtype]*/) {
	// returns the coordinates the specified movement should produce.
	// - time: expressed as a fraction or decimal (for example, if a
	//   movement begins on frame 6 and ends on frame 8, on frame 7 you
	//   should enter 1/2)
	// - easing type:
	//   - "linear"
	//   - "circ"
	//     - or circular, or circle
	//   - "sine"
	//     - or sin
	// - in or out: ease "in", ease "out", ease "in/out", or ease "out/in"
	// - overshoot: an array with distance, time, easeinorout, and
	//   easingtype, in that order
	//   - this only applies to the retraction motion
	//   - overshoot distance (written as a fraction of the original
	//     distance) (this is multiplicative. if you want it to go an extra
	//     20%, write 1.2, not .2.)
	//   - at what point in the animation it should transition from the
	//     overshoot to the retraction (written as a fraction, like time)
	//   - the easeinorout to use
	//   - the easingtype to use
	// - defaults:
	//   - linear easing
	//   - ease in
	//   - overshoot
	//     - an inversion of the easeinorout (in if it was out, out if it
	//       was in. if there was nothing, it's out)
	//     - the same easingtype
	// - maybe i should just convert this into a "time to position"
	//   converter? it'd be more versatile that way... which makes it easier
	//   to do things like animate with a third axis.
	//   - eh, i should just limit it to one axis. the thing is, since this
	//     returns an array, and the coordinates are usually used as
	//     parameters for something else, i usually have to type
	//     "easingplacement(parameters)[0], easingplacement(parameters)[1]".
	//     that's super tedious. also redundant. (not that i'm at risk of
	//     running out of ram or whatever here, but still.)
	//   - point is, i already have to type it twice, so...
	//   - done.
	// - you can make the two values can be arrays, which makes it return an
	//   array between the two.
	//   - as in you can type 2d or 3d coordinates and it'll find whatever
	//     position between them, since it's tedious to copy this function twice
	//     or three times
		if(Array.isArray(value1) && Array.isArray(value2) && value1.length===value2.length) {
			ep_array = [];
			for(ep_i1 = 0; ep_i1 < value1.length; ep_i1++) {
				ep_array[ep_i1] = easingplacement(value1[ep_i1], value2[ep_i1], time, easeinorout, easingtype, overshoot);
			};
			return ep_array;
			// TODO not sure this is sompatible with overshoot considering that
			// modifies parameters
		};
		if(overshoot) {
			time /= overshoot[1];
			// modify the time so that the overshoot part of the animation
			// will be at 1 if the user inputs the overshoot time
			if(time > 1) {
			// if the overshoot is already done, modify the parameters to
			// work for the retraction
				time -= 1;
				time /= 1 - overshoot[1];
				// modify the time to be a fraction of the time remaining for retraction
				if(overshoot[2]) {
					easeinorout = overshoot[2];
				}
				else {
					if(easeinorout==="in") {
						easeinorout = "out";
					}
					else if(easeinorout==="out") {
						easeinorout = "in";
					}
					else {
						easeinorout = "out";
						// default to out for the retraction, to match how
						// it normally defaults to in
					};
					// reverse the in/out
				};
				if(overshoot[3]) {
					easingtype = overshoot[3];
				};
				// if they didn't specify an easing type for the retraction,
				// use the same thing again
				value1 += (value2 - value1)*overshoot[0];
				// make the coordinates of the overshoot the new starting
				// coordinates
			};
		};
		if(time <= 0) {
			return value1;
		}
		else if(time >= 1) {
			return value2;
		};
		if(easingtype==="circular" || easingtype==="circle") {
			easingtype = "circ";
		}
		else if(easingtype==="sin") {
			easingtype = "sine";
		}
		else if(!easingtype) {
			easingtype==="linear";
		};
		if(!easeinorout) {
			easeinorout==="in";
		};
		if(easingtype==="linear") {
			return value1 + time*(value2 - value1);
		};
		if(easeinorout==="in/out" || easeinorout==="out/in") {
			if(time===.5) {
				return (value1+value2)/2;
			}
			else if(time < .5) {
				value2 = (value1+value2)/2;
				if(easeinorout==="in/out") {
					easeinorout = "in";
				}
				else if(easeinorout==="out/in") {
					easeinorout = "out";
				}
				else {
					console.log("something went wrong");
					return;
				};
				time *= 2;
			}
			else if(time > .5) {
				value1 = (value1+value2)/2;
				if(easeinorout==="in/out") {
					easeinorout = "out";
				}
				else if(easeinorout==="out/in") {
					easeinorout = "in";
				}
				else {
					console.log("something went wrong");
					return;
				};
				time -= .5;
				time *= 2;
			}
			else {
				console.log("something went wrong");
				return;
			};
		};
		if(easingtype==="circ") {
			if(easeinorout==="in") {
				return value1 + (value2 - value1)*(1 - Math.cos(Math.asin(time)));
			}
			else if(easeinorout==="out") {
				return value1 + (value2 - value1)*Math.cos(Math.asin(time - 1));
			}
			else {
				console.log("something went wrong");
				return;
			};
		}
		else if(easingtype==="sine") {
			if(easeinorout==="in") {
				return value1 + (value2 - value1)*(1 + Math.sin((time - 1) * Math.PI/2));
			}
			else if(easeinorout==="out") {
				return value1 + (value2 - value1)*Math.sin(time * Math.PI/2);
			}
			else {
				console.log("something went wrong");
				return;
			};
		};
	}
	function easing(time, inorout, curve, overshoot/*[peak, time, inorout]*/, value1, value2) {
	// - curve: string for which kind of curve it is.
	//   - linear, sine, circ, square, cube, quart, quint
	//   - most of those have alternate names, look at the altnames constant in
	//     there
	// - overshoot
	//   - peak: the value it is when it peaks. (it goes from value1 to this to
	//     value2.) (value1 + 1.25*(value2 - value1) by default)
	//   - time: the time it peaks (that is, when it's value2) (.5 by default)
	//   - by default, inorout is the same as the original inorout, but
	//     inverted. (in becomes out, out becomes in. in/out and out/in are
	//     unchanged)
	//     - this is because generally, peak to value2 is in the opposite
	//       direction as value1 to value2.
		time = Math.min(Math.max(0, time), 1);
		inorout = ["in", "out", "in/out", "out/in"].includes(inorout) ? inorout : "in";
		if(typeof curve !== "number" && !["linear", "sine", "circ", "square", "cube", "quart", "quint"].includes(curve)) {
			const altnames = {
				circ: ["circular", "circle"],
				sine: ["sin"],
				square: ["^2", "**2"],
				cube: ["^3", "**3", "cubic", "cubed"],
				quart: ["^4", "**4"],
				quint: ["^5", "**5"],
			};
			let temp = false;
			let i1 = 0;
			for(i1 in altnames) {
				if(altnames.hasOwnProperty(i1) && altnames[i1].includes(curve)) {
					temp = true;
					curve = i1;
				};
			}
			if(!temp) {
				curve = "sine";
			};
		}
		value1 = typeof value1 === "number" ? value1 : 0;
		value2 = typeof value2 === "number" ? value2 : 1;
		if(overshoot) {
			if(!Array.isArray(overshoot)) {
				overshoot = [];
			};
			let os = {
				peak: overshoot[0] ?? (value1 + 1.25*(value2 - value1)),
				time: overshoot[1] ?? .5,
				inorout: overshoot[2] ?? {
					in: "out",
					out: "in",
					"out/in": "out/in",
					"in/out": "in/out",
				}[inorout],
			};
			if(os.peak !== value2 && os.time !== 1) {
			// those might cause divide by zero errors, and the result is the
			// same as if it wasn't there
				if(time <= os.time) {
					time /= os.time;
					value2 = os.peak;
				}
				else {
					time = (time - os.time)/(1 - os.time);
					return easing(time, os.inorout, curve, false, os.peak, value2);
				}
			}
		}
		inorout = ["in", "out", "in/out", "out/in"].includes(inorout) ? inorout : "in";
		if(["in/out", "out/in"].includes(inorout)) {
			inorout = inorout.split("/");
			if(time < .5) {
				inorout = inorout[0];
				value2 = (value1 + value2)/2;
			}
			else {
				time -= .5;
				inorout = inorout[1];
				value1 = (value1 + value2)/2;
			}
			time *= 2;
		};
		if(curve === "sine") {
			inorout = {in: "out", out: "in"}[inorout];
		};
		if(inorout === "out") {
			time = 1 - time;
		};
		let endvalue = null;
		if(typeof curve === "number") {
			endvalue = time**curve;
		}
		else if(curve === "linear") {
			endvalue = time;
		}
		else if(curve === "sine") {
			endvalue = Math.sin(time*Math.PI/2);
		}
		else if(curve === "circ") {
			// a**2 + b**2 = c**2
			// time**2 + (1 - end)**2 = r**2
			// (1 - end)**2 = 1 - time**2
			// (1 - end) = Math.sqrt(1 - time**2)
			// end = 1 - Math.sqrt(1 - time**2)
			endvalue = 1 - Math.sqrt(1 - time**2);
		}
		else if(["square", "cube", "quart", "quint"].includes(curve)) {
			endvalue = time**( ["square", "cube", "quart", "quint"].indexOf(curve) + 2 );
		};
		if(inorout === "out") {
			endvalue = 1 - endvalue;
		};
		return value1 + endvalue*(value2 - value1);
	}
	function wave(place, wavetype, equil, crest, invert) {
	// 0, .5, and 1 are equilibrium, .25 is crest, .75 is trough
	// - except sawtooth.
		place = posmod(place, 1);
		if(!["sine", "circ", "square", "tri", "saw"].includes(wavetype)) {
			const altnames = {
				sine: ["sin"],
				circ: ["circular", "circle"],
				square: ["sq"],
				tri: ["triangle"],
				saw: ["sawtooth"],
			}
			let temp = false;
			let i1 = 0;
			for(i1 in altnames) {
				if(altnames.hasOwnProperty(i1) && altnames[i1].includes(wavetype)) {
					temp = true;
					wavetype = i1;
				};
			}
			if(!temp) {
				wavetype = "sine";
			};
		}
		equil ??= 0;
		crest ??= 1;
		let amp = (crest - equil)*(invert ? -1 : 1);
		//*
		let endvalue = (
			wavetype === "sine" ? Math.sin(2*Math.PI*place) :
			wavetype === "circ" ? (
				place < .5
				?
				Math.sqrt(1 - (4*Math.abs(.25 - place))**2)
				:
				-Math.sqrt(1 - (4*Math.abs(.75 - place))**2)
			) :
			wavetype === "square" ? (place < .5 ? 1 : -1) :
			wavetype === "tri" ? (1 - Math.abs(4*((place + .25)%1) - 2)) :
			wavetype === "saw" ? 2*(place - .5) :
			0
		);
		//*/
		/*
		let endvalue = 0;
		if(wavetype === "sine") {
			endvalue = Math.sin(2*Math.PI*place);
		}
		else if(wavetype === "circ") {
			endvalue = (
				place < .5
				?
				Math.sqrt(1 - (4*Math.abs(.25 - place))**2)
				:
				-Math.sqrt(1 - (4*Math.abs(.75 - place))**2)
			);
		}
		else if(wavetype === "square") {
			endvalue = (place < .5 ? 1 : -1);
		}
		else if(wavetype === "triangle") {
			endvalue = (1 - Math.abs(4*((place + .25)%1) - 2));
		}
		else if(wavetype === "saw") {
			endvalue = 2*(place - .5);
		};
		//*/
		/*
		if(["sine", "circ", "triangle"].includes(wavetype)) {
			easing((time + .75)%1, "in/out", (wavetype === "triangle" ? "linear" : wavetype), [crest], trough, trough)
		}
		else if(wavetype === "square") {
			return
			easing((time + .75)%1, "in/out", "sine", [crest], trough, trough)
		}
		screw this, it'd be slower
		*/
		return equil + amp*endvalue;
	}
	let Physics = {
		shove: (time, init_speed, decel) => (
		// calculates the time-to-distance factor of an object whose only
		// propulsion is a sudden shove, with nothing pushing it after the fact.
		// - decel: to be specific, this is friction, wind resistance, something
		//   like that; it stops when the object stops. force/mass =
		//   acceleration, so change it accordingly for objects of different
		//   mass.
			time*decel >= init_speed
			?
			// enough time has passed to decelerate to a stop
			(init_speed**2)/(2*decel)
			//(init_speed/decel)*(init_speed/2)
			:
			(init_speed - decel*time/2)*time
		),
		addvectors: function(vector1, vector2) {
		// let vector = Physics.addvectors([magnitude1, angle1], [magnitude2, angle2]);
		// input two arrays of magnitude and angle, it'll add them together to
		// create the combined vector.
			let newvect = [
				Math.cos(vector1[1])*vector1[0] + Math.cos(vector2[1])*vector2[0],
				Math.sin(vector1[1])*vector1[0] + Math.sin(vector2[1])*vector2[0]
			];
			newvect = [
				Math.hypot(...newvect),
				get2dangle(...newvect, true)
			];
			console.log("addvectors: " + (newvect[1] === null ? [0, vector1[1]] : newvect));
			return (
				typeof newvect[1] === "string"
				?
				[0, vector1[1]]
				// it was [0, 0] or something before conversion.
				// - don't change the angle, since that's like the direction
				//   it's facing. it hasn't changed to vector2's direction until
				//   vector2 makes the magnitude more than zero.
				// - at least, that's how i think it should be. decelerating to
				//   a stop doesn't make you flip directions, right?
				:
				newvect
			);
		},
	}
	if(0===0) {
	// specific movement functions.
		function screwmovement(x1, y1, x2, y2, time, r, numofcycles, xy_angle, z_angle) {
		// - x1, y1, x2, y2, time: same as easingplacement
		// - r: radius of the circle
		// - numofcycles: number of circular motions it goes through before
		//   it ends
		// - xy_angle: the number of clockwise degrees to rotate the circle
		//   by (starting from the angle perpendicular to the line from the
		//   beginning to the end)

		};
		//ctx2.fillStyle = "#000000";
		//if(currframe%8 === 0 || currframe%8 >= 4) {
		//	circledraw(ctx2, easingplacement(8, 56, (4 - Math.abs(currframe%8 - 4))/4, "in/out", "sine"), easingplacement(8, 56, currframe/numofframes, "in", "sine"), 3);
		//};
		//easingplacement(8, 56, (4 - Math.abs(currframe%8 - 4))/4, "in/out", "sine"), easingplacement(8, 56, currframe/numofframes, "in", "sine")
		function _3dstar(x, y, z, r, fraction, rotation, starconstant, linearguments/*[context, antialiasing, viewer]*/) {
		// though this counts as a _3d function, this is only in a very
		// loose sense. if there's no valid z value, it'll just draw
		// normally.
		// - fraction: fraction of the star's perimeter to place the point
		//   at, going clockwise from the top.
		// - rotation: rotation offset for the star, works the same as
		//   fraction
		// - starconstant: this is the distance from a star's center to one
		//   of its armpits, divided by the radius. optional.
		// - linearguments: if there's something here, it will draw a star
		//   instead of giving coordinates. it's an array with:
		//   - context
		//   - antialiasing boolean
		//   - viewer
		// - TODO
		//   - make it so the number of points can be specified? (only odd
		//     numbers, probably)
		//   - add a setting that makes it draw/place a pentagram instead?
		//     - this would be pretty useful for fancy movement patterns
		//   - add a setting to use splines?
			if(!starconstant && starconstant!==0) {
				//console.log(Math.hypot(fourpointintersect(circlepoints(0, 0, 1, 0/5)[0], circlepoints(0, 0, 1, 0/5)[1], circlepoints(0, 0, 1, 2/5)[0], circlepoints(0, 0, 1, 2/5)[1], circlepoints(0, 0, 1, 4/5)[0], circlepoints(0, 0, 1, 4/5)[1], circlepoints(0, 0, 1, 1/5)[0], circlepoints(0, 0, 1, 1/5)[1])[0], fourpointintersect(circlepoints(0, 0, 1, 0/5)[0], circlepoints(0, 0, 1, 0/5)[1], circlepoints(0, 0, 1, 2/5)[0], circlepoints(0, 0, 1, 2/5)[1], circlepoints(0, 0, 1, 4/5)[0], circlepoints(0, 0, 1, 4/5)[1], circlepoints(0, 0, 1, 1/5)[0], circlepoints(0, 0, 1, 1/5)[1])[1]));
				starconstant = 0.3819660112501051;
				// . i think there's better ways
				// to calculate this but i don't give a shit
				// -
				// the reason i want it to be modular is it greatly
				// impacts how the star feels. if you look at like, i
				// dunno. stickers kindergarten teachers give out.
				// chances are this value is much higher.
			}
			let starpointx = [];
			let starpointy = [];
			let starpitx = [];
			let starpity = [];
			for(star_i1=0; star_i1 < 5; star_i1++){
				starpointx[star_i1] = circlepoints(x, y, r, star_i1/5 + (rotation ? rotation : 0))[0];
				starpointy[star_i1] = circlepoints(x, y, r, star_i1/5 + (rotation ? rotation : 0))[1];
				starpitx[star_i1] = circlepoints(x, y, r*starconstant, (star_i1 + .5)/5 + (rotation ? rotation : 0))[0];
				starpity[star_i1] = circlepoints(x, y, r*starconstant, (star_i1 + .5)/5 + (rotation ? rotation : 0))[1];
				//ctx2.fillText(star_i1, starpointx[star_i1], starpointy[star_i1]);
				//ctx2.fillText(star_i1, starpitx[star_i1], starpity[star_i1]);
				//circledraw(ctx2, starpointx[star_i1], starpointy[star_i1], 2, true);
				//circledraw(ctx2, starpitx[star_i1], starpity[star_i1], 2, true);
			}
			//linearguments[context, antialiasing, viewer]
			//nonaaline(context, x1, y1, x2, y2)
			//_3dline(viewer, context, x1, y1, z1, x2, y2, z2, antialiasing)
			if(linearguments) {
				if(z || z===0) {
					for(star_i1=0; star_i1 < 5; star_i1++){
						_3dline(linearguments[2], linearguments[0], starpointx[star_i1], starpointy[star_i1], z, starpitx[star_i1], starpity[star_i1], z, linearguments[1]);
						_3dline(linearguments[2], linearguments[0], starpitx[star_i1], starpity[star_i1], z, starpointx[(star_i1 + 1)%5], starpointy[(star_i1 + 1)%5], z, linearguments[1]);
					}
				}
				else {
					for(star_i1=0; star_i1 < 5; star_i1++){
						if(linearguments[1]) {
							linearguments[0].beginPath();
							linearguments[0].moveTo(starpointx[star_i1], starpointy[star_i1]);
							linearguments[0].lineTo(starpitx[star_i1], starpity[star_i1]);
							linearguments[0].lineTo(starpointx[(star_i1 + 1)%5], starpointy[(star_i1 + 1)%5]);
							linearguments[0].stroke();
							linearguments[0].closePath();
						}
						else {
							//nonaaline(context, x1, y1, x2, y2)
							nonaaline(linearguments[0], starpointx[star_i1], starpointy[star_i1], starpitx[star_i1], starpity[star_i1]);
							nonaaline(linearguments[0], starpitx[star_i1], starpity[star_i1], starpointx[(star_i1 + 1)%5], starpointy[(star_i1 + 1)%5]);
						};
					}
				};
			}
			else {
				fraction %= 1;
				fraction += 1;
				fraction %= 1;
				// just in case.
				let starx1 = (fraction%(1/5) < 1/10 ? starpointx[Math.floor(fraction/(1/5))] : starpitx[Math.floor(fraction/(1/5))]);
				let starx2 = (fraction%(1/5) < 1/10 ? starpitx[Math.floor(fraction/(1/5))] : starpointx[(Math.floor(fraction/(1/5)) + 1)%5]);
				// either going from the point to the pit or the pit to the next point
				let stary1 = (fraction%(1/5) < 1/10 ? starpointy[Math.floor(fraction/(1/5))] : starpity[Math.floor(fraction/(1/5))]);
				let stary2 = (fraction%(1/5) < 1/10 ? starpity[Math.floor(fraction/(1/5))] : starpointy[(Math.floor(fraction/(1/5)) + 1)%5]);
				fraction %= .1;
				fraction *= 10;
				return [starx1 + fraction*(starx2 - starx1), stary1 + fraction*(stary2 - stary1)];
			};
		}
	};
	var viewer = {
		x: 0,
		y: 0,
		z: 0,
		ratio: 1,
		offset: {
			x: 0,
			y: 0,
			z: 0,
			//x: (document.getElementById("xoffset").value ? document.getElementById("xoffset").value : 0),
			//y: (document.getElementById("yoffset").value ? document.getElementById("yoffset").value : 0),
			//z: (document.getElementById("zoffset").value ? document.getElementById("zoffset").value : 0),
		},
	};
	// - "ratio": ratio of pixels/degrees, how many pixels there should be
	//   per degree;
	// - offset: don't modify that directly, it's annoying to scroll back
	//   and forth and easy to forget.
	//   - do not make perspectiveconvert use this. this is for _3d
	//     functions to use. (the chain is _3d functions,
	//     perspectiveconvert, functions that actually draw stuff on the
	//     canvas. but if there's something like, say, the line you're
	//     drawing reaching behind the viewer, the _3d function has to know
	//     that, and it only can if the offsets are already applied by that
	//     point.)
	// NOTE: the z should be the most variable thing. that's the distance
	// it's zoomed out, the distance objects will be at 0 z position.
	function perspectiveconvert(viewer, x, y, z) {
	// converts coordinates from x/y/z space to screen coordinates
	// - notes
	//   - the size of an object is relative to what the angle is from our
	//     eyes to the edges of it.
	//   - so if i establish a "default distance" (when z === 0) in pixels,
	//     and a vanishing point where the angles are measured from, i could
	//     figure out where the edges should be. (for simplicity's sake, i'm
	//     probably just gonna assume the object is flat.)
	//   - or another way to put it is that i'm deciding the x, y, and z
	//     position of the camera.
	//     - nah, the viewer's eye. camera sounds so impersonal.
	// - surprise motherfucker, this DOES work (it was my line-drawing
	//   function that didn't. really.)
	// - TODO z needs an offset of some kind, because it's supposed to be
	//   that 0 z is where everything is onscreen, but that's not true at
	//   all.
	//   - well, i tried. it's in the junkpile file, because it didn't work.
		return viewer ? Viewer.fromobj(viewer).convert(x, y, z) : [x, y, z];
	}
	function screeninverse(viewer, x, y, z, plane) {
		return viewer ? Viewer.fromobj(viewer).inverse(x, y, z, plane) : plane.planepoint(x, y, "z");
	}
	function z_to_size(viewer, z) {
	// creates size scalers based on a z coordinate and a hypothetical sphere
	// that lines up with the vanishing point and has the z specified.
	// - ie it figures out what angles the left and right edge would have
	//   relative to the viewer, then converts the degrees to pixels with .ratio
		return Viewer.fromobj(viewer).z_size(z);
	};
	function central_z(viewer) {
	// returns the viewer.z to use for a sphere to be sized the same at
		return Viewer.fromobj(viewer).central_z;
	};
	function lightlevel(viewer, point, angle, alpha) {
	// returns an array of r, g, and b, calculating how much each lamp adds to
	// it.
	// - angle: the angle of the triangle the point is on, the direction it
	//   faces. use tridirection.
	// - alpha: a number from 0 to 1 for how opaque the surface is, so it can
	//   tell how much light can seep through if the lamp's light should fall on
	//   the other side of the triangle the point is on. (that is, if the
	//   Angle.compare between the angle and the angle from the point to the
	//   lamp is over 90) generally, you should use the alpha of the triangle's
	//   color.
	// - this should be multiplied by the point's color, then added to it. at
	//   least, that's how the default shader works.
	//   - red = red*(1 + lightlevel[0]);
		alpha ??= 1;
		let lightlevel = (typeof viewer.baselightlevel === "number" ? viewer.baselightlevel : 0);
		// the lightlevel should start at a negative number. when light is 0,
		// the color should be what it is in the texture, but the texture
		// assumes there's light.
		lightlevel = [
			lightlevel,
			lightlevel,
			lightlevel
		];
		// one for r, g, and b
		function addlight(lamp) {
		// adds to the lightlevel, taking into account one lamp's properties.
		// have to make this an inner function because otherwise i have to
		// violate DRY to make the stuff in the loop happen for singular lamps.
		// - lamp: a lamp object
			let addend = [
				lamp.x - point[0],
				lamp.y - point[1],
				lamp.z - point[2]
			];
			let dist = Math.hypot(...addend);
			if(dist === 0) {
			// if it's right at the lamp, the angle doesn't matter. (it'd be
			// invalid too.)
				addend = 1;
			}
			else {
				addend = Angle.get(...addend);
				addend = Math.abs(Math.cos(Angle.compare(angle, addend)));
				// it's 1 if angle and the angle to the lamp are parallel, 0 if
				// they're perpendicular.
				addend *= (addend >= Math.PI/2 ? 1 - alpha : 1);
				// the light is coming from the other side of the face, so
				// multiply by 1 - alpha
			};
			addend *= (typeof lamp.brightness === "number" ? lamp.brightness : 1)/(dist**2);
			// multiply by brightness, divide by surface area (since the number
			// of rays per whatever is directly tied to that.)
			// - technically surface area is 4*pi*dist**2, but there's no point
			//   dividing by a constant since the only point of this is
			//   accurately lowering/raising the brightness by distance
			if(lamp.hasOwnProperty("color")) {
				lightlevel[0] += addend*lamp.color[0]/255;
				lightlevel[1] += addend*lamp.color[1]/255;
				lightlevel[2] += addend*lamp.color[2]/255;
			}
			else {
				lightlevel[0] += addend;
				lightlevel[1] += addend;
				lightlevel[2] += addend;
			};
		}
		if(viewer.lamp.hasOwnProperty("single") && viewer.lamp.single) {
			addlight(lamp);
		}
		else {
			let i1 = 0;
			for (i1 in viewer.lamp) {
				if (viewer.lamp.hasOwnProperty(i1)) {
					addlight(lamp);
				};
			}
		};
		return lightlevel;
	};
	function _3dline(viewer, context, x1, y1, z1, x2, y2, z2, weight, antialiasing) {
	// draws a line in 3d space.
	// - weight does not have any effect if antialiasing is used.
	// - TODO
	//   - make it so weight changes based on the distance from the camera.
	//   - make it so this just does _3dlineexecute with circledraw
		if(viewer.offset.x) {
			x1 += viewer.offset.x;
			x2 += viewer.offset.x;
		};
		if(viewer.offset.y) {
			y1 += viewer.offset.y;
			y2 += viewer.offset.y;
		};
		if(viewer.offset.z) {
			z1 += viewer.offset.z;
			z2 += viewer.offset.z;
		};
		// apply offsets
		if(viewer.z - z1 < 0 && viewer.z - z2 < 0) {
		// if the line is behind the viewer, don't even draw it.
		}
		else {
			if(viewer.z - z1 >= 0 && viewer.z - z2 < 0) {
			// if it ends behind the viewer, cut it off.
				x2 = x1 + (x2 - x1)*(z1 - viewer.z)/(z2 - z1);
				y2 = y1 + (y2 - y1)*(z1 - viewer.z)/(z2 - z1);
				// the new z2 will be viewer.z, so you can find the x and y
				// coordinates by multiplying the x/y distance by the fraction
				// of the z distance that's still retained by this change.
				z2 = viewer.z;
			}
			else if(viewer.z - z1 < 0 && viewer.z - z2 >= 0) {
			// if it starts behind the viewer, cut it off.
				x1 = x1 + (x2 - x1)*(z1 - viewer.z)/(z2 - z1);
				y1 = y1 + (y2 - y1)*(z1 - viewer.z)/(z2 - z1);
				z1 = viewer.z;
			};
			// TODO both are untested.
			if(antialiasing) {
				context.beginPath();
				context.moveTo(perspectiveconvert(viewer, x1, y1, z1)[0], perspectiveconvert(viewer, x1, y1, z1)[1]);
				context.lineTo(perspectiveconvert(viewer, x2, y2, z2)[0], perspectiveconvert(viewer, x2, y2, z2)[1]);
				context.stroke();
				context.closePath();
			}
			else {
				nonaaline(context, perspectiveconvert(viewer, x1, y1, z1)[0], perspectiveconvert(viewer, x1, y1, z1)[1], perspectiveconvert(viewer, x2, y2, z2)[0], perspectiveconvert(viewer, x2, y2, z2)[1], weight);
			};
		};
	}
	function _3dcircle(viewer, context, x, y, z, r, fill) {
		if(viewer.hasOwnProperty("offset")) {
			if(viewer.offset.x) {
				x += viewer.offset.x;
			};
			if(viewer.offset.y) {
				y += viewer.offset.y;
			};
			if(viewer.offset.z) {
				z += viewer.offset.z;
			};
		}
		// apply offsets
		if(viewer.z - z < 0) {
		// if it's behind the viewer, don't bother
			return;
		};
		circledraw(context, perspectiveconvert(viewer, x, y, z)[0], perspectiveconvert(viewer, x, y, z)[1], r, fill);
	}
	function copy(ctx, x, y, w, h, background) {
	// getImageData and putImageData have the small gigantic flaw of fully
	// replacing what's there without factoring in transparency at all. this and
	// paste are an alternative that does.
	// - background: if this is a color, (whether a string or an array) any
	//   pixels of that color exactly will be saved with zero opacity.
		let i1 = 0;
		let i2 = 0;
		x = Math.floor(x);
		y = Math.floor(y);
		w = Math.floor(w);
		h = Math.floor(h);
		if(w === 0 || h === 0) {
			return {w: 0, h: 0};
		};
		if(w < 0) {
			x += w;
			w *= -1;
		};
		if(h < 0) {
			y += h;
			h *= -1;
		};
		if(x < 0) {
			w += x;
			x = 0;
		};
		if(y < 0) {
			h += y;
			y = 0;
		};
		let canvas_w = ctx.canvas.width;
		let canvas_h = ctx.canvas.height;
		if(x + w >= canvas_w) {
			w = canvas_w - x;
		};
		if(y + h >= canvas_h) {
			h = canvas_h - y;
		};
		if(typeof background === "string") {
			background = Color.rgb(ctx, background);
		};
		if(Array.isArray(background) && background.length === 3) {
			background[3] = 255;
		};
		background = (
			Array.isArray(background) && background.length === 4
			?
			new Uint8ClampedArray(background)
			:
			null
		);
		// it fails if i don't do this. if i had to guess, special
		// "unsigned" "clamped" numbers don't count as the same as their
		// normal counterparts.
		let copydata = {w, h};
		let imagedata = ctx.getImageData(x, y, w, h);
		for(i1 = 0; i1 < imagedata.data.length; i1 += 4) {
			let color = imagedata.data.slice(i1, i1 + 4);
			if(compareobject(color, background)) {
				color[3] = 0;
			};
			copydata[Math.round(i1/4)] = new Uint8ClampedArray(color);
			// using this class should save space or prevent invalids or
			// something. probably.
		}
		return copydata;
	};
	function paste(ctx, x, y, copydata) {
	// copydata: data returned by copy().
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		let styletemp = ctx.fillStyle;
		let imagedata = ctx.getImageData(x, y, copydata.w, copydata.h);
		for(i1 = 0; i1 < copydata.w; i1++) {
			for(i2 = 0; i2 < copydata.h; i2++) {
				let index = i2*copydata.w + i1;
				let color = new Uint8ClampedArray(copydata[index]);
				if(color[3] !== 0) {
					if(color[3] !== 255) {
						let under = imagedata.data.slice(index*4, (index + 1)*4);
						for(i3 = 0; i3 < 3; i3++) {
							const temp = under[i3] + Math.round((color[i3] - under[i3])*color[3]/255);
							console.log(under[i3] - temp);
							color[i3] = temp;
							//rgb = rgb1 + (rgb2 - rgb1)*alpha2;
						}
						color[3] = 255 - ((255 - under[3]) * (255 - color[3])/255);
						//alpha = 255 - ((255 - color1) * (255 - color2)/255);
					};
					ctx.fillStyle = "rgba(" + color.slice(0, 3) + "," + color[3]/255 + ")";
					ctx.clearRect(x + i1, y + i2, 1, 1);
					ctx.fillRect(x + i1, y + i2, 1, 1);
				};
			}
		}
		ctx.fillStyle = styletemp;
	}
	function _3dpoly(viewer, context, shape, offset, weight, invert, outline, etc) {
	// - shape: an object with this structure:
	//   - .points: array of coordinate arrays
	//   - .faces: array of objects
	//     - .faces[facenumber].indexes: point indexes to connect to form a
	//       face
	//     - .faces[facenumber].fill: fill color change
	//       - "default" refers to whatever the fill/stroke style was at the
	//         time of running _3dpoly.
	//     - .faces[facenumber].stroke: stroke color change
	//     - .faces[facenumber].center: changes to the point the faces
	//       face away from (an array of x/y/z coordinates, or a string
	//       saying "default" which sets it back to the average of all
	//       points)
	//     - .faces[facenumber].hide: an array of .faces[facenumber].indexes
	//       indexes indicating lines that shouldn't be drawn
	//   - .colors: array of colors for .fill and .stroke to use. (they can
	//     use the normal formats, but numbers will be converted to
	//     whatever's in here.)
	//   - the face is broken up into triangles by connecting the first
	//     point to all other points.
	// - offset: applied to all coordinates when drawing.
	// - weight: line weight passed to _3dline
	// - invert: if this is true, the side of each triangle that's one-sided
	//   will be inverted.
	//   - useful for drawing a room interior or something like that.
	//   - or you could run it uninverted and inverted to make all faces
	//     double-sided (useful for shapes that aren't closed)
	// - outline: an array with a color and a width. this is added to the
	//   outside of the 3d shape.
	//   - if there's no color, it'll use whatever the current strokeStyle
	//     is. (or you can use "stroke", but. why bother.)
	//   - if there's no number, it'll use a weight of 1.
	//   - if you use "default" as the color, it'll use whatever the
	//     strokeStyle was at the time of running _3dpoly. (as in, it will
	//     NOT be affected by .stroke properties in the faces that change
	//     it.)
	//   - this is not at all guaranteed to work with the below etc
	//     commands.
	// - etc: a series of special commands.
	//   - "wireframe": no fill will be done, and stroke will always be done
	//     regardless of which direction the triangle faces.
	//   - "tri": all triangles' strokes will be drawn.
	//   - "lineless": stroke will not be drawn.
	//   - "lock stroke color": this is mainly meant to be used internally.
	//     it prevents stroke color from being changed by the shape's
	//     .stroke properties.
	//   =
	//   - NOTE: if wireframe, tri, or lock stroke mode are removed for any reason,
	//     outline will not work.
	//   - you can use multiple of these by making them an array.
	// =
	// - NOTE: if something has gone wrong, there's a good chance of it
	//   being the shape, not _3dpoly. doublecheck both.
		// - TODO
		//   - finish
		//     - outline
		//   - test
		//     - lineless
		//     - tri
		//   - same cutoff things _3dline has
		//   - fix the issue with cube faces not being drawn right
		//   - lighting system
		//     - this is super duper important, because. it's kinda hard to
		//       make things look 3d when every face blends into each other.
		//     - figure out how to translate these elements into how much
		//       the surface should be lit
		//       - the angle the plane faces
		//       - the angle from the center of a triangle to the light
		//         source
		//     - add a "lamp" object, which works like viewer
		//     - add these parameters to _3dpoly
		//       - fill/stroke light color
		//       - fill/stroke dark color
		//       - some way of controlling how light *everything* is, and/or
		//         how much lighting varies
		//         - ideally this should be a parameter of shapes, too. so
		//           a face can be shinier?
		//         - eh, that's probably an oversimplification. i don't know
		//           a lot about lighting. but still.
		//       - a number for how many colors are actually displayed
		//     - make it so it can interpret arrays in .stroke or .fill as
		//       light/dark colors
		//       - if there's one color, that's displayed no matter what. if
		//         there's two, it's interpreted as the dark and normal
		//         color
		//   - outline does not interpret input that's just a color
		//     correctly.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		if(Array.isArray(offset) && offset.length >= 3) {
		// did you know that typeof doesn't work on arrays? i didn't.
			let logerror = false;
			let oldoffset = structuredClone(offset);
			for(i1 = 0; i1 < 3; i1++) {
				if(typeof offset[i1] !== "number" || isNaN(offset[i1])) {
				// if it's invalid, use 0
					logerror = true;
					offset[i1] = 0;
				};
			}
			if(logerror) {
				console.log("invalid coordinates: " + oldoffset);
			};
		}
		else {
			offset = [0, 0, 0];
		};
		let styletemp = [context.fillStyle, context.strokeStyle, context.strokeStyle];
		// [2] is for storing the stroke style when it switches to outline
		if(!etc) {
		// prevents undefined errors
			etc = "";
		};
		if(outline) {
			let outlinecolor = "stroke";
			let outlineweight = 1;
			if(Array.isArray(outline) && outline.length === 2 && typeof outline[0] === "string" && typeof outline[1] === "number") {
				outlinecolor = outline[0];
				outlineweight = outline[1];
			}
			else if(typeof outline === "string") {
				outlinecolor = outline;
			}
			else if(typeof outline === "number") {
				outlineweight = outline;
			};
			// the outline is partially covered up by the line weight
			// though, so...
			// - since the outline and normal lines are centered in the same
			//   place, it'd be (outline - weight)/2 = actual outline
			outlineweight *= 2;
			if(typeof weight === "number") {
				outlineweight += weight;
			}
			else if(Array.isArray(weight)) {
				outlineweight = [outlineweight + weight[0], outlineweight + weight[1]];
			}
			else {
				outlineweight += 1;
			};
			outlineweight -= 1;
			if(outlinecolor === "stroke") {
				context.strokeStyle = styletemp[1];
				_3dpoly(viewer, context, shape, offset, outlineweight, invert, false, ["wireframe", "tri"]);
			}
			else {
				if(outlinecolor === "default") {
					context.strokeStyle = styletemp[1];
				};
				_3dpoly(viewer, context, shape, offset, outlineweight, invert, false, ["wireframe", "tri", "lock stroke color"]);
			};
			// recurse this bitch. i'm a goddamn time wizard.
		};
		let points = structuredClone(shape.points);
		let center = [0, 0, 0];
		// the point that faces should face away from.
		for(i1 = 0; i1 < points.length; i1++){
			for(i2 = 0; i2 < 3; i2++){
				points[i1][i2] += offset[i2];
				center[i2] += points[i1][i2];
			}
		}
		for(i1 = 0; i1 < 3; i1++){
			center[i1] /= points.length;
		}
		let defaultcenter = structuredClone(center);
		// apply offset, define the default center
		let faces = structuredClone(shape.faces);
		for (b3s_i1 = 0; b3s_i1 < faces.length; b3s_i1++) {
			if(faces[b3s_i1].hasOwnProperty("center")) {
				faces[b3s_i1].center[0] += offset[0];
				faces[b3s_i1].center[1] += offset[1];
				faces[b3s_i1].center[2] += offset[2];
			}
		};
		// apply offset to centers described here, too
		let colors = structuredClone(shape.colors);
		let pointstemp = [];
		let currangle = [];
		let centerangle = [];
		let angletemp = [];
		if(!faces[0].center) {
			faces[0].center = "default";
		};
		if(!faces[0].fill && faces[0].fill !== 0) {
			faces[0].fill = "default";
		};
		if(!faces[0].stroke && faces[0].stroke !== 0) {
			faces[0].stroke = "default";
		};
		for(i1 = 1; i1 < faces.length; i1++){
		// runs for every face, applies changes to center and colors.
		// - it's sorta hard to explain, but the way changes used to be
		//   effected doesn't work if the faces get sorted first.
			if(!faces[i1].center) {
				faces[i1].center = structuredClone(faces[i1 - 1].center);
			};
			if(!faces[i1].fill && faces[0].fill !== 0) {
				faces[i1].fill = faces[i1 - 1].fill;
			};
			if(!faces[i1].stroke && faces[0].stroke !== 0) {
				faces[i1].stroke = faces[i1 - 1].stroke;
			};
		}
		function _3dpolysort(a, b) {
			let i1 = 0;
			let a_zaverage = 0;
			let b_zaverage = 0;
			for(i1 = 0; i1 < a.indexes.length; i1++){
				a_zaverage += points[a.indexes[i1]][2];
			}
			a_zaverage /= a.indexes.length;
			for(i1 = 0; i1 < b.indexes.length; i1++){
				b_zaverage += points[b.indexes[i1]][2];
			}
			b_zaverage /= b.indexes.length;
			return a_zaverage - b_zaverage;
		};
		faces.sort(_3dpolysort);
		// sorts it by whatever the average z position of their points is
		//console.log(currframe);
		//console.log(faces);
		for(i1 = 0; i1 < faces.length; i1++){
		// runs for every face
			if(!faces[i1].center) {
				console.log("face " + i1 + " has no defined center. _3dpoly is supposed to fill that automatically, something went wrong.");
			}
			else {
				if(faces[i1].center === "default") {
					center = structuredClone(defaultcenter);
				}
				else if(Array.isArray(faces[i1].center)) {
					center = structuredClone(faces[i1].center);
				};
			};
			if(!faces[i1].fill && faces[0].fill !== 0) {
				console.log("face " + i1 + " has no defined fill color. _3dpoly is supposed to fill that automatically, something went wrong.");
			}
			else {
				if(faces[i1].fill === "default") {
					context.fillStyle = styletemp[0];
				}
				else if(typeof faces[i1].fill === "number" && colors[faces[i1].fill]) {
				// .colors index
					context.fillStyle = colors[faces[i1].fill];
				}
				else if(typeof faces[i1].fill === "string") {
					context.fillStyle = faces[i1].fill;
				};
			};
			if(!faces[i1].stroke && faces[0].stroke !== 0) {
				console.log("face " + i1 + " has no defined stroke color. _3dpoly is supposed to fill that automatically, something went wrong.");
			}
			else {
				if(etc.includes("lock stroke color")) {
				}
				else if(faces[i1].stroke === "default") {
					context.strokeStyle = styletemp[1];
				}
				else if(typeof faces[i1].stroke === "number" && colors[faces[i1].stroke]) {
				// .colors index
					context.strokeStyle = colors[faces[i1].stroke];
				}
				else if(typeof faces[i1].stroke === "string") {
					context.strokeStyle = faces[i1].stroke;
				};
			};
			// trigger center/color changes
			for(i2 = 1; i2 < faces[i1].indexes.length - 1; i2++){
			// run for every index except the first and last. defines a
			// triangle, figures out the angle it faces, and draws the fill
			// part.
				pointstemp = [];
				pointstemp[0] = points[faces[i1].indexes[i2]];
				pointstemp[1] = points[faces[i1].indexes[i2 + 1]];
				pointstemp[2] = points[faces[i1].indexes[0]];
				// break the face up into triangles by connecting every side
				// to the first point
				currangle = Plane.frompoints(pointstemp).line().angle;
				currangle = Angle.correct(currangle);
				pointstemp[3] = [];
				pointstemp[3][0] = (pointstemp[0][0] + pointstemp[1][0] + pointstemp[2][0])/3;
				pointstemp[3][1] = (pointstemp[0][1] + pointstemp[1][1] + pointstemp[2][1])/3;
				pointstemp[3][2] = (pointstemp[0][2] + pointstemp[1][2] + pointstemp[2][2])/3;
				// average of all three points
				//_3dcircle(viewer, context, center[0], center[1], center[2], 5, true);
				centerangle = Angle.get(
					center[0] - pointstemp[3][0],
					center[1] - pointstemp[3][1],
					center[2] - pointstemp[3][2]
				);
				centerangle = Angle.correct(centerangle);
				// angle to the shape's center
				//if(i1 === 5 && ((currframe >= 1 && currframe <= 3) || (currframe >= 15 && currframe <= 21) || (currframe >= 69 && currframe <= 71))) {
				//	console.log("frame " + currframe + " before drawing");
				//	console.log(faces[i1].name + " face, tri " + i2);
				//	console.log("currangle:");
				//	console.log((360*currangle[0]/(2*Math.PI)) + ", " + 360*currangle[1]/(2*Math.PI));
				//	console.log("Angle.compare:");
				//	console.log(360*Angle.compare(currangle, centerangle)/(2*Math.PI));
				//};
				if(Angle.compare(currangle, centerangle) < Math.PI/2) {
				// if it's less than one hemisphere away, (ie the face angle
				// is facing toward the center) invert the face angle.
					currangle[0] += Math.PI;
					currangle[0] %= 2*Math.PI;
					currangle[1] *= -1;
					//if(i1 === 5 && ((currframe >= 1 && currframe <= 3) || (currframe >= 15 && currframe <= 21) || (currframe >= 69 && currframe <= 71))) {
					//	console.log("angle inverted");
					//};
				};
				/*
				_3dline(viewer, context,
					pointstemp[3][0],
					pointstemp[3][1],
					pointstemp[3][2],
					pointstemp[3][0] + framew*Angle.numbers(currangle)[0],
					pointstemp[3][1] + framew*Angle.numbers(currangle)[1],
					pointstemp[3][2] + framew*Angle.numbers(currangle)[2]
				);
				context.strokeStyle = "red";
				_3dline(viewer, context,
					pointstemp[3][0],
					pointstemp[3][1],
					pointstemp[3][2],
					pointstemp[3][0] + framew*Angle.numbers(centerangle)[0],
					pointstemp[3][1] + framew*Angle.numbers(centerangle)[1],
					pointstemp[3][2] + framew*Angle.numbers(centerangle)[2]
				);

				context.strokeStyle = "lime";
				_3dline(viewer, context,
					pointstemp[3][0],
					pointstemp[3][1],
					pointstemp[3][2],
					pointstemp[3][0] + (framew/2),
					pointstemp[3][1],
					pointstemp[3][2]
				);
				_3dline(viewer, context,
					pointstemp[3][0],
					pointstemp[3][1],
					pointstemp[3][2],
					pointstemp[3][0] + (framew/2)*Math.cos(Angle.compare(currangle, centerangle)),
					pointstemp[3][1] + (framew/2)*Math.sin(Angle.compare(currangle, centerangle)),
					pointstemp[3][2]
				);
				context.strokeStyle = "white";
				*/
				angletemp[i2] = structuredClone(currangle);
				/*
				_3dline(viewer, ctx2,
					pointstemp[3][0],
					pointstemp[3][1],
					pointstemp[3][2],
					pointstemp[3][0] + framew*Angle.numbers(currangle)[0],
					pointstemp[3][1] + framew*Angle.numbers(currangle)[1],
					pointstemp[3][2] + framew*Angle.numbers(currangle)[2]
				);
				*/
				if(currangle[1] === 0) {
				// if the z angle is 0, do not draw it if the angle between
				// the xy and the angle to the viewer x/y is obtuse.
					centerangle = get2dangle(viewer.x - (viewer.offset.x + pointstemp[3][0]), viewer.y - (viewer.offset.y + pointstemp[3][1]));
					if(
						(viewer.x - (viewer.offset.x + pointstemp[3][0]) === 0 && viewer.y - (viewer.offset.y + pointstemp[3][1]) === 0)
						||
						compare2dangle(currangle[0], centerangle) <= Math.PI/2
					) {
					// if it was right on top of the viewer (and therefore
					// there was no valid angle to begin with) or if the
					// is acute/right, draw it
					// - it bothers me to not catch the former sooner, but
					//   i'd rather not violate DRY
					}
					else {
						angletemp[i2][1] = "hide";
						// replaces the z angle with a string saying to hide
						// it. the line drawing logic can use this so it
						// doesn't have to figure this shit out again
					};
				};
				for(i3 = 0; i3 < 3; i3++) {
					pointstemp[i3] = perspectiveconvert(viewer, pointstemp[i3][0] + viewer.offset.x, pointstemp[i3][1] + viewer.offset.y, pointstemp[i3][2] + viewer.offset.z);
					// convert to x/y, add viewer offset since
					// _2dPoly.draw isn't a _3d function
				}
				pointstemp.splice(3, 1);
				// remove the center point
				if(
					!etc.includes("wireframe")
					&&
					(
						(!invert && currangle[1] >= 0 && currangle[1] !== "hide")
						||
						(invert && (currangle[1] < 0 || currangle[1] === "hide"))
					)
				) {
					_2dPoly.draw(context, pointstemp);
				};
				//if(i1 === 5 && ((currframe >= 1 && currframe <= 3) || (currframe >= 15 && currframe <= 21) || (currframe >= 69 && currframe <= 71))) {
				// troubleshooting thing
				//	console.log("frame " + currframe + " after drawing");
				//	console.log("pointstemp:");
				//	console.log(pointstemp);
				//	console.log("currangle:");
				//	console.log((360*currangle[0]/(2*Math.PI)) + ", " + 360*currangle[1]/(2*Math.PI));
				//};
				if(etc === "tri" || etc.includes("tri")) {
				// if it's tri mode, draw all triangles
					_2dPoly.draw(context, pointstemp, "stroke", weight);
				};
				// the big problem i hit my head against for so long was
				// that the center wasn't in the right place. i forgot to
				// apply offsets to it.
				// -
				// TODO there's still problems.
				// - problems with rendering cubes, mostly.
				// - if a cube is rotating in the xz axis like what i'm
				//   having it do, it should only display two faces at a
				//   time.
				// - and naturally, it should also display both triangles of
				//   those faces.
				// - instead, quite a lot of frames render it improperly.
				// - after fixing a few things and hiding the front face, i
				//   can see that the second-frontmost face and the face
				//   opposite of that are guaranteed to render properly, the
				//   frontmost face only sometimes renders properly, and
				//   everything else is guaranteed to not render properly.
				// - the front face draws improperly if it's at 15 to 21 /
				//   72 or 69 to 3 / 72.
				//   - in other words, 5 to 7 / 24 or 23 to 1 / 24...
				//   - except for 0, but that could be caused by some
				//     exception in logic. like compare2dangle or whatever.
				// - surprisingly, even though i turned back on the z angle
				//   === 0 logic, it isn't any less busted when i turn it
				//   off.
				// -
				// - i would love to just fuck off and do the rest of the
				//   body model shit now that spheroids work, but those are
				//   a little glitchy too when a face faces a certain angle.
				//   (only one face at a time, but still.)
				// - i ran it while forcing it to only show the top and
				//   bottom face, where i learned that which triangle is
				//   present changes when the center crosses the halfway
				//   point
				//   - in other words, the top triangle is always the one
				//     whose center is on the left side of the screen, and
				//     the bottom's center is always on the right.
				//   - after testing in different offsets, it seems bottom
				//     triangles will only display if their centers are
				//     below and to the right of the viewer, while top
				//     triangles only display if they're above and to the
				//     left
				//   - commenting out the === 0 fixes it. i thought that
				//     *didn't* make it more busted?
				//     - well, it should mostly affect the top and bottom
				//       since those are the only faces that always have a 0
				//       z angle... (i'm testing this with a cube that
				//       rotates in the xz axis)
				//   - considering these patterns and how the 0 z hiding
				//     logic revolves around the angle to the viewer... this
				//     is either a logic error or a flaw in get2dangle.
				//     - it's the latter. goddamn inverse tan. forgot to
				//       invert it if x is negative.
				//     - nope, it's both.
				// -
				// - it was a flaw in compare2dangle. you correct reflex angles
				//   by subtracting them from a circumference, not subtracting
				//   half a circumference from them. stoopid
				// - still not there yet though. the logic that inverts face
				//   angles is flawed.
				//   - part of the problem is that it doesn't effect .center
				//     changes correctly. using _3dcircle to show where it is
				//     shows it is not where it should be
				//   - that's not all though, there's problems with cubes too
			}
			angletemp[0] = angletemp[1];
			angletemp[angletemp.length] = structuredClone(angletemp[angletemp.length - 1]);
			// angletemp stores the angles of the faces each point's line
			// is part of.
			for(i2 = 0; i2 < faces[i1].indexes.length; i2++){
			// runs for every index, draws the lines of the face.
				if(
					(!faces[i1].hide || !faces[i1].hide.includes(i2))
					// if hide does not specify it should be hidden
					&&
					(
						(!invert && angletemp[i2][1] >= 0 && angletemp[i2][1] !== "hide")
						||
						(invert && (angletemp[i2][1] < 0 || angletemp[i2][1] === "hide"))
						||
						etc.includes("wireframe")
					)
					// and the z angle and invert or wireframe mode
					// indicates it should be drawn
					&&
					!etc.includes("lineless")
					// and it isn't lineless mode
				) {
				// if it hasn't been hidden and the triangle for it isn't
				// facing away from the camera, draw it
					_3dline(viewer, context,
						points[faces[i1].indexes[i2]][0],
						points[faces[i1].indexes[i2]][1],
						points[faces[i1].indexes[i2]][2],
						points[faces[i1].indexes[((i2 + 1)%faces[i1].indexes.length)]][0],
						points[faces[i1].indexes[((i2 + 1)%faces[i1].indexes.length)]][1],
						points[faces[i1].indexes[((i2 + 1)%faces[i1].indexes.length)]][2],
					weight);
				};
			}
		}
		context.fillStyle = styletemp[0];
		context.strokeStyle = styletemp[1];
		// what are all the steps to drawing a face.
		// - use structuredClone on .points and .faces
		// - for loop for every face
		//   - enact changes if .stroke, .fill, or .center is there
		//   - for loop for every index (or most indexes. the number of
		//     triangles is the number of points minus 2.)
		//     - find the angle using findplane
		//     - if the average of the three points plus the sin cosine
		//       whatever the hell of the 3d angle (the magic geometry math
		//       that says "this is how much x/y/z distance moving ___ pixels
		//       in this angle would have") is further from the center point
		//       than the average *minus* the sin cosine whatever the hell,
		//       invert the angle.
		//     - if the z angle is less than 0, don't draw it.
		//     - also save the angle for future reference. make it 1-indexed
		//       though. you'll see why later
		//   - for loop for every line
		//     - if it's in .hiddenlines, don't draw it.
		//     - but also don't draw it if there's no triangle with it that
		//       isn't hidden.
		//       - if it's line 0, check index 1. if it's line
		//         (.length - 1), check index (.length - 2).
	}
	function build3dshape(type, dimensions, fineness, offset) {
	// creates an array to be passed onto _3dpoly.
	// - type: a string specifying which kind of shape to build.
	//   - "sphere"
	//     - alternative names: spheroid, ball (none of these shapes are
	//       locked to a 1:1:1 ratio.)
	//     - it can probably be used to make an octahedron if fineness is 4.
	//       TODO
	//   - "cube"
	//     - alternative names: box
	//   - "cone"
	//     - alternative names: pyramid
	//   - "cylinder"
	//     - alternative names: prism
	//   - "disc" (makes circles or regular polygons, parallel to the xy
	//     plane)
	//     - alternative names: circle, polygon
	//   - "square" (makes squares, parallel to the xy plane)
	//     - alternative names: rectangle, rect
	//   - "stairs" (they face the camera. fineness is how many steps it's
	//     divided into)
	// - dimensions: a single value, or an array. if only one value is
	//   specified, it'll be used for all three. if two values are
	//   specified, d will be whichever is smaller.
	// - fineness: used for shapes like sphere and cone. adjusts how many
	//   sides a circle is made of.
	// - offset: by default, 0, 0, 0 will be the center of the shape.
	// - there are no parameters for rotating it. just use revolve.
	//   - TODO eh, maybe i should do this anyway
	// - remember, the structure of the shape object is:
	//   - .points: array of coordinate arrays
	//   - .faces: array of objects
	//     - .faces[facenumber].indexes: point indexes to connect to form a
	//       face
	//     - .faces[facenumber].fill: fill color change
	//       - "default" refers to whatever the fill/stroke style was at the
	//         time of running _3dpoly.
	//     - .faces[facenumber].stroke: stroke color change
	//     - .faces[facenumber].center: changes to the point the faces
	//       face away from (an array of x/y/z coordinates, or a string
	//       saying "default" which sets it back to the average of all
	//       points)
	//     - .faces[facenumber].hide: an array of .faces[facenumber].indexes
	//       indexes indicating lines that shouldn't be drawn
	//   - .colors: array of colors for .fill and .stroke to use. (they can
	//     use the normal formats, but numbers will be converted to
	//     whatever's in here.)
	//   - the face is broken up into triangles by connecting the first
	//     point to all other points.
		var shape = {};
		shape.points = [];
		shape.faces = [];
		shape.colors = [];
		var b3s_temp = 0;
		if(!Array.isArray(offset) || offset.length !== 3) {
			offset = [0, 0, 0];
		};
		if(typeof dimensions === "number") {
			var w = dimensions;
			var h = dimensions;
			var d = dimensions;
		}
		else if(Array.isArray(dimensions)) {
			var w = dimensions[0];
			if(dimensions.length >= 2) {
				var h = dimensions[1];
			};
			if(dimensions.length >= 3) {
				var d = dimensions[2];
			};
			if(!h && h !== 0) {
				var h = w;
			};
			if(!d && d !== 0) {
				var d = Math.min(w, h);
			};
		}
		else {
			console.log("build3dshape ran with invalid dimensions.");
			return [[offset[0], offset[1], offset[2]]];
		};
		if(type==="spheroid" || type==="ball") {
			type = "sphere";
		};
		if(type==="box") {
			type = "cube";
		};
		if(type==="pyramid") {
			type = "cone";
		};
		if(type==="prism") {
			type = "cylinder";
		};
		if(type==="circle" || type==="polygon") {
			type = "disc";
		};
		if(type==="rectangle" || type==="rect") {
			type = "square";
		};
		if(type==="sphere") {
			fineness = 4*Math.floor(fineness/4);
			if(fineness === 0) {
				fineness = 4;
			};
			shape.points = [];
			shape.points[0] = [0, -h/2, 0];
			b3s_temp = [];
			for (b3s_i1 = 1; b3s_i1 < fineness/2; b3s_i1++) {
			// each iteration is a new ring of points.
				b3s_temp[0] = shape.points.length;
				b3s_temp[1] = Math.cos(2*Math.PI*(.25 + b3s_i1/fineness))*w/2;
				// width modifier
				b3s_temp[2] = Math.cos(2*Math.PI*(.25 + b3s_i1/fineness))*d/2;
				// depth modifier
				b3s_temp[3] = -Math.sin(2*Math.PI*(.25 + b3s_i1/fineness))*h/2;
				// height of ring
				// [4] is like [0] but for faces
				for (b3s_i2 = 0; b3s_i2 < fineness; b3s_i2++) {
					shape.points[b3s_temp[0] + b3s_i2] = [Math.cos(2*Math.PI*b3s_i2/fineness)*b3s_temp[1], b3s_temp[3], Math.sin(2*Math.PI*b3s_i2/fineness)*b3s_temp[2]];
				}
				// define the points
				if(b3s_i1===1) {
				// make the top of the sphere, which is like a cone
					shape.faces[0] = {
						indexes: [0, 1, 2],
						center: [0, 0, 0],
						hide: [0, 1, 2],
					};
					for (b3s_i2 = 2; b3s_i2 <= fineness; b3s_i2++) {
						shape.faces[b3s_i2 - 1] = {
							indexes: [0, b3s_i2, (b3s_i2)%fineness + 1],
							hide: [0, 1, 2],
						};
					}
				}
				else {
					b3s_temp[4] = shape.faces.length;
					b3s_temp[5] = shape.points.length - (2*fineness);
					// the index of the first point of the second to last
					// ring
					for (b3s_i2 = 0; b3s_i2 < fineness; b3s_i2++) {
						if((Math.floor(8*(b3s_i1 + .5)/fineness)%2 === 0 && b3s_i1 <= fineness/4) || (Math.floor(8*(b3s_i1 + .5)/fineness)%2 === 1 && b3s_i1 > fineness/4)) {
						//               (circumference fraction)
						// (convert to whole number under 8   )
						// if it's an odd number 1/8 fraction and above the
						// equator or an even number fraction and below the
						// equator
							shape.faces[b3s_temp[4] + b3s_i2] = {
								indexes: [b3s_temp[5] + b3s_i2,  b3s_temp[5] + (b3s_i2 + 1)%fineness, b3s_temp[5] + (b3s_i2 + 1)%fineness + fineness, b3s_temp[5] + b3s_i2 + fineness],
								hide: [0, 1, 2, 3],
								// up cw, down cw, down ccw, up ccw
							};
							//console.log([b3s_i2, shape.faces[b3s_temp[4] + b3s_i2].indexes[1] - (fineness*(b3s_i1 - 2)), shape.faces[b3s_temp[4] + b3s_i2].indexes[2] - (fineness*(b3s_i1 - 1))])
						}
						else if((Math.floor(8*(b3s_i1 + .5)/fineness)%2 === 0 && b3s_i1 > fineness/4) || (Math.floor(8*(b3s_i1 + .5)/fineness)%2 === 1 && b3s_i1 <= fineness/4)) {
						// inverse of that
							shape.faces[b3s_temp[4] + b3s_i2] = {
								indexes: [b3s_temp[5] + b3s_i2 + fineness,  b3s_temp[5] + (b3s_i2 + 1)%fineness + fineness, b3s_temp[5] + (b3s_i2 + 1)%fineness, b3s_temp[5] + b3s_i2],
								hide: [0, 1, 2, 3],
								// down cw, up cw, up ccw, down ccw
							};
							//console.log([b3s_i2, shape.faces[b3s_temp[4] + b3s_i2].indexes[2] - (fineness*(b3s_i1 - 2)), shape.faces[b3s_temp[4] + b3s_i2].indexes[1] - (fineness*(b3s_i1 - 1))])
						}
						else {
							console.log("something went wrong with build3dshape sphere.");
						};
					}
					// the pattern of diagonals should be: ([] represents a
					// 1/4 mark)
					// [] [] [] [] []
					// /\\/\\/\\/\\/\
					// or
					// []  []  []  []  []
					// /\\//\\//\\//\\//\
					// the flow chart of which point to start with goes like
					// this:
					// - is the square within a odd number eighth of the
					//   circumference, or an even number? (if it's centered
					//   on a 1/8 mark due to being divisible by 4 but not
					//   8, round up. or down. whatever, as long as it's
					//   consistent)
					// - odd
					//   - start at the point that's earlier in the
					//     rotation, and outer
					//   - above the equator
					//     - up cw, down cw, down ccw, up ccw
					//   - below the equator
					//     - down cw, up cw, up ccw, down ccw
					// - even
					//   - start at the point that's earlier in the
					//     rotation, and inner
					//   - above the equator
					//     - down cw, up cw, up ccw, down ccw
					//   - below the equator
					//     - up cw, down cw, down ccw, up ccw
					if(b3s_i1===(fineness/2 - 1)) {
					// make the bottom, which is also like a cone
						b3s_temp[5] = shape.points.length - fineness;
						// the index of the first point of the last ring
						b3s_temp[4] = shape.faces.length;
						shape.points[shape.points.length] = [0, h/2, 0];
						for (b3s_i2 = 0; b3s_i2 < fineness; b3s_i2++) {
							shape.faces[b3s_temp[4] + b3s_i2] = {
								indexes: [shape.points.length - 1, b3s_temp[5] + b3s_i2, b3s_temp[5] + (b3s_i2 + 1)%fineness],
								hide: [0, 1, 2],
							};
						}
					};
				};
			}
			// TODO
			// - edit build3dshape and _3dpoly so that points and faces
			//   can be categorized.
			//   - like for this sphere here, i can put all the faces of one
			//     ring into a single array.
			//   - this actually wouldn't be too hard, i'd just have to
			//     rewrite build3dshape and have 3dpoly use .flat on the shape
			//     and face arrays.
			//   - wait no, .indexes doesn't support that kind of complexity.
			//     i'd have to make a format for that, and make it so _3dpoly
			//     can convert that into normal numbers...
			//   - it should also be an object instead of an array, since
			//     the whole point is to make it easier to keep track of all
			//     the points and stuff...
			//   - revolve needs to be able to process it too... shit.
			// - define each triangle of the ends as a separate face
		}
		else if(type==="cube") {
			shape.points = [
				[-w/2, -h/2, -d/2],
				// left top back
				[-w/2, -h/2, d/2],
				// left top front
				[-w/2, h/2, -d/2],
				// left bottom back
				[-w/2, h/2, d/2],
				// left bottom front
				[w/2, -h/2, -d/2],
				// right top back
				[w/2, -h/2, d/2],
				// right top front
				[w/2, h/2, -d/2],
				// right bottom back
				[w/2, h/2, d/2],
				// right bottom front
			];
			shape.faces[0] = {
				indexes: [0, 1, 3, 2],
				center: [0, 0, 0],
				name: "left",
			};
			// left
			shape.faces[1] = {
				indexes: [0, 1, 5, 4],
				name: "top",
			};
			// top
			shape.faces[2] = {
				indexes: [0, 2, 6, 4],
				name: "back",
			};
			// back
			shape.faces[3] = {
				indexes: [4, 5, 7, 6],
				name: "right",
			};
			// right
			shape.faces[4] = {
				indexes: [2, 3, 7, 6],
				name: "bottom",
			};
			// bottom
			shape.faces[5] = {
				indexes: [1, 3, 7, 5],
				name: "front",
			};
			// front
			// TODO remove names
		}
		else if(type==="cone") {
			shape.points = [];
			shape.points[0] = [0, -h/2, 0];
			for (b3s_i1 = 0; b3s_i1 < fineness; b3s_i1++) {
				shape.points[1 + b3s_i1] = [Math.cos(2*Math.PI*b3s_i1/fineness)*w/2, h/2, Math.sin(2*Math.PI*b3s_i1/fineness)*d/2];
			}
			shape.points[shape.points.length] = [0, h/2, 0];
			shape.faces = [];
			shape.faces[0] = {
				indexes: [],
				center: [0, 0, 0],
				hide: [0, fineness + 1],
			};
			for (b3s_i1 = 0; b3s_i1 <= fineness; b3s_i1++) {
				shape.faces[0].indexes[b3s_i1] = b3s_i1;
			}
			shape.faces[0].indexes[shape.faces[0].indexes.length] = 1;
			shape.faces[1] = structuredClone(shape.faces[0]);
			shape.faces[1].indexes[0] = shape.points.length - 1;
		}
		else if(type==="cylinder") {
			shape.points = [];
			shape.points[0] = [0, -h/2, 0];
			for (b3s_i1 = 0; b3s_i1 < fineness; b3s_i1++) {
				shape.points[1 + b3s_i1] = [Math.cos(2*Math.PI*b3s_i1/fineness)*w/2, -h/2, Math.sin(2*Math.PI*b3s_i1/fineness)*d/2];
				shape.points[1 + fineness + 1 + b3s_i1] = [Math.cos(2*Math.PI*b3s_i1/fineness)*w/2, h/2, Math.sin(2*Math.PI*b3s_i1/fineness)*d/2];
			}
			shape.points[fineness + 1] = [0, h/2, 0];
			shape.faces = [];
			shape.faces[0] = {
				indexes: [],
				center: [0, 0, 0],
				hide: [0, fineness + 1],
			};
			for (b3s_i1 = 0; b3s_i1 <= fineness; b3s_i1++) {
				shape.faces[0].indexes[b3s_i1] = b3s_i1;
			}
			shape.faces[0].indexes[shape.faces[0].indexes.length] = 1;
			// complete the circle
			for (b3s_i1 = 1; b3s_i1 <= fineness; b3s_i1++) {
				shape.faces[b3s_i1] = {
					indexes: [b3s_i1, b3s_i1 + fineness + 1, (b3s_i1%fineness) + 1 + fineness + 1, (b3s_i1%fineness) + 1],
					hide: [0, 2],
				};
			}
			b3s_temp = shape.faces.length;
			shape.faces[b3s_temp] = structuredClone(shape.faces[0]);
			delete shape.faces[b3s_temp].center;
			for (b3s_i1 = 0; b3s_i1 < shape.faces[b3s_temp].indexes.length; b3s_i1++) {
				shape.faces[b3s_temp].indexes[b3s_i1] += fineness + 1;
			}
		}
		else if(type==="disc") {
			shape.points = [];
			shape.points[0] = [0, 0, 0];
			for (b3s_i1 = 0; b3s_i1 < fineness; b3s_i1++) {
				shape.points[1 + b3s_i1] = [Math.cos(2*Math.PI*b3s_i1/fineness)*w/2, Math.sin(2*Math.PI*b3s_i1/fineness)*h/2, 0];
			}
			// no sense having duplicate points, so don't complete a full
			// circuit.
			shape.faces = [];
			shape.faces[0] = {
				indexes: [],
				center: [0, 0, -d/2],
				hide: [0, fineness + 1],
			};
			for (b3s_i1 = 0; b3s_i1 <= fineness; b3s_i1++) {
				shape.faces[0].indexes[b3s_i1] = b3s_i1;
			}
			shape.faces[0].indexes[shape.faces[0].indexes.length] = 1;
			// the above for loop goes from the center to all the outer
			// points, but it needs to return to the first outer point in
			// order to form a circle.
			shape.faces[1] = structuredClone(shape.faces[0]);
			shape.faces[1].center[2] *= -1;
			// draw it twice so it's double-sided
		}
		else if(type==="square") {
			shape.points = [
				[-w/2, -h/2, 0],
				// top left
				[w/2, -h/2, 0],
				// top right
				[w/2, h/2, 0],
				// bottom right
				[-w/2, h/2, 0]
				// bottom left
			];
			shape.faces = [];
			shape.faces[0] = {
				indexes: [0, 1, 2, 3],
				center: [0, 0, -d/2],
			};
			shape.faces[1] = structuredClone(shape.faces[0]);
			shape.faces[1].center[2] *= -1;
			// draw it twice so it's double-sided
		}
		else if(type==="stairs") {
			shape.points = [];
			shape.faces = [];
			for(b3s_i1=0; b3s_i1 <= fineness*2; b3s_i1++) {
				shape.points[b3s_i1*2] = [
					-w/2,
					h/2 - h*Math.floor((b3s_i1 + 1)/2)/fineness,
					d/2 - d*Math.floor(b3s_i1/2)/fineness
				];
				shape.points[b3s_i1*2 + 1] = structuredClone(shape.points[b3s_i1*2]);
				shape.points[b3s_i1*2 + 1][0] *= -1;
			};
			// lower points, then higher points
			for(b3s_i1=0; b3s_i1 < fineness*2; b3s_i1++) {
				shape.faces[b3s_i1] = {
					indexes: [b3s_i1*2 + 0, b3s_i1*2 + 1, b3s_i1*2 + 3, b3s_i1*2 + 2],
				};
			};
			shape.faces[0].center = [0, -h/2, d/2];
		};
		// - remember, the structure of the shape object is:
		//   - .points: array of coordinate arrays
		//   - .faces: array of objects
		//     - .faces[facenumber].indexes: point indexes to connect to form a
		//       face
		//     - .faces[facenumber].fill: fill color change
		//       - "default" refers to whatever the fill/stroke style was at the
		//         time of running _3dpoly.
		//     - .faces[facenumber].stroke: stroke color change
		//     - .faces[facenumber].center: changes to the point the faces
		//       face away from (an array of x/y/z coordinates, or a string
		//       saying "default" which sets it back to the average of all
		//       points)
		//     - .faces[facenumber].hide: an array of .faces[facenumber].indexes
		//       indexes indicating lines that shouldn't be drawn
		//   - .colors: array of colors for .fill and .stroke to use. (they can
		//     use the normal formats, but numbers will be converted to
		//     whatever's in here.)
		//   - the face is broken up into triangles by connecting the first
		//     point to all other points.
		for (b3s_i1 = 0; b3s_i1 < shape.points.length; b3s_i1++) {
			shape.points[b3s_i1][0] = Math.round(shape.points[b3s_i1][0]*(10**13))/(10**13) + offset[0];
			shape.points[b3s_i1][1] = Math.round(shape.points[b3s_i1][1]*(10**13))/(10**13) + offset[1];
			shape.points[b3s_i1][2] = Math.round(shape.points[b3s_i1][2]*(10**13))/(10**13) + offset[2];
			// because of the hell that is radians, operations like
			// Math.cos(2*Math.PI*3/4) run long stupid decimals when they
			// should really just give whole numbers. so. this rounds it to
			// the nearest .00000000000001 and also applies offset.
			// - seriously, how the hell are radians standard... this is
			//   like the one instance where i think the us customary system
			//   *isn't* the stupid one
			//   - i think maybe they use this because it makes more sense
			//     in scientific settings? like in physics equations, you
			//     gotta use shit like meters, meters per second, newtons,
			//     etc because all the measurement systems have to be
			//     compatible with each other. but this is still dumb 90% of
			//     the time
		};
		for (b3s_i1 = 0; b3s_i1 < shape.faces.length; b3s_i1++) {
			if(b3s_i1===0 && !shape.faces[b3s_i1].hasOwnProperty("center")) {
				shape.faces[b3s_i1].center = offset;
			}
			else if(shape.faces[b3s_i1].hasOwnProperty("center")) {
				shape.faces[b3s_i1].center[0] = Math.round(shape.faces[b3s_i1].center[0]*(10**13))/(10**13) + offset[0];
				shape.faces[b3s_i1].center[1] = Math.round(shape.faces[b3s_i1].center[1]*(10**13))/(10**13) + offset[1];
				shape.faces[b3s_i1].center[2] = Math.round(shape.faces[b3s_i1].center[2]*(10**13))/(10**13) + offset[2];
			}
		};
		// apply offset
		shape.colors = [];
		// TODO
		// - add modifying features
		//   - multiplying their distance from the edges of the box by a
		//     cosine or whatever (do it to a sphere, and it'll look like a
		//     rounded cube)
		//   - split into two parts using a plane
		return shape;
	}
	function polyjoin(shapes) {
	// returns a combination of all the 3d shapes provided.
	// - shapes should be an array.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		let sumshape = structuredClone(shapes[0]);
		if(!sumshape.hasOwnProperty("colors")) {
			sumshape.colors = [];
		};
		let tempshape = "";
		for(i1 = 1; i1 < shapes.length; i1++) {
			tempshape = structuredClone(shapes[i1]);
			if(tempshape.faces.length > 0) {
				if(!tempshape.faces[0].hasOwnProperty("center")) {
					// if the center isn't specified, it's supposed to be the average of
					// all points, but that won't be in the same place once it's
					// combined with the other shapes
					tempshape.faces[0].center = [0, 0, 0];
					for(i2 = 0; i2 < tempshape.points.length; i2++) {
						tempshape.faces[0].center[0] += tempshape.points[i2][0];
						tempshape.faces[0].center[1] += tempshape.points[i2][1];
						tempshape.faces[0].center[2] += tempshape.points[i2][2];
					}
					tempshape.faces[0].center[0] /= tempshape.points.length;
					tempshape.faces[0].center[1] /= tempshape.points.length;
					tempshape.faces[0].center[2] /= tempshape.points.length;
				};
				if(!tempshape.faces[0].hasOwnProperty("fill")) {
					// if fill isn't specified, it should be reset to the default color
					tempshape.faces[0].fill = "default";
				};
				if(!tempshape.faces[0].hasOwnProperty("stroke")) {
					// if fill isn't specified, it should be reset to the default color
					tempshape.faces[0].stroke = "default";
				};
			};
			for(i2 = 0; i2 < tempshape.faces.length; i2++) {
				for(i3 = 0; i3 < tempshape.faces[i2].indexes.length; i3++) {
					tempshape.faces[i2].indexes[i3] += sumshape.points.length;
				}
				// add the number of points sumshape has to every
				// .faces[x].indexes so it doesn't lead to the wrong points
				if(tempshape.faces[i2].hasOwnProperty("fill") && typeof tempshape.faces[i2].fill === "number") {
					tempshape.faces[i2].fill += sumshape.colors.length;
				};
				if(tempshape.faces[i2].hasOwnProperty("stroke") && typeof tempshape.faces[i2].stroke === "number") {
					tempshape.faces[i2].stroke += sumshape.colors.length;
				};
				// do the same thing for .colors indexes
			}
			sumshape.points = sumshape.points.concat(tempshape.points);
			sumshape.faces = sumshape.faces.concat(tempshape.faces);
			if(tempshape.hasOwnProperty("colors")) {
				sumshape.colors = sumshape.colors.concat(tempshape.colors);
			};
			// merge the points, faces, and colors arrays into sumshape
		}
		return sumshape;
	}
	function polysubdivide(shape, fineness) {
	// returns a version of the shape that has every face broken up into more
	// faces, so you can apply distortion and stuff like that.
	// - fineness: how many segments each edge is broken up into. the square of
	//   this is how many triangles each triangle becomes.
	// - notes for how this works:
	//   - it makes each triangle a separate face
	//   - it splices in duplicates of the faces, fineness^2 - 1 of them
	//   - fancy math time, change the points for each one so they're fragments
	//   - 'imma be real with you, it'll get to be kind of a clusterfuck. the
	//     however, any nonessential properties of a face will be shared by all
	//     the faces it's broken up into, so if you have a "name" property, it
	//     should point you to all the faces that face was made into.
	//     - also all the faces will have adjacent indexes. if the factor is 2,
	//       face 5 will be made into face 12 to 15.
	//       - that's assuming they're all triangles though. you're probably
	//         gonna have to do a little work to get the right index.
	//       - and points do not have the same luxury. new points are tacked
	//         onto the end of the array.
		var newshape = structuredClone(shape);
		var psd_temp = null;
		for(psd_i1=0; psd_i1 < newshape.faces.length; psd_i1++) {
		// runs for every face, breaks it up into triangles
			psd_temp = [];
			logtext = "";
			for(psd_i2=2; psd_i2 < newshape.faces[psd_i1].indexes.length - 1; psd_i2++) {
			// - skip the first triangle, that'll be done by the conditional at
			//   the end since all the others have to reference it
				psd_temp[psd_temp.length] = structuredClone(newshape.faces[psd_i1]);
				psd_temp[psd_temp.length - 1].indexes = [newshape.faces[psd_i1].indexes[0], newshape.faces[psd_i1].indexes[psd_i2], newshape.faces[psd_i1].indexes[psd_i2 + 1]];
				delete psd_temp[psd_temp.length - 1].fill;
				delete psd_temp[psd_temp.length - 1].stroke;
				delete psd_temp[psd_temp.length - 1].center;
				// redundant, the first side should enact all these changes
				if(newshape.faces[psd_i1].hasOwnProperty("hide") && newshape.faces[psd_i1].hide.includes(psd_i2)) {
					psd_temp[psd_temp.length - 1].hide = [0, 1, 2];
				}
				else {
					psd_temp[psd_temp.length - 1].hide = [0, 2];
				};
				// side 1 should be the outer side, so that's the only one that
				// could've been visible before.
				if(psd_i2===newshape.faces[psd_i1].indexes.length - 2) {
					newshape.faces[psd_i1].indexes = newshape.faces[psd_i1].indexes.slice(0, 3);
					// trim it down to the first three indexes
					if(newshape.faces[psd_i1].hasOwnProperty("hide")) {
						for(psd_i3=0; psd_i3 < newshape.faces[psd_i1].hide.length; psd_i3++) {
							if(newshape.faces[psd_i1].hide[psd_i3] >= 2) {
								// remove .hide items that are too high (2 is too high,
								// since that used to refer to an outside line)
								newshape.faces[psd_i1].hide.splice(psd_i3, 1);
								psd_i3--;
							};
						};
						newshape.faces[psd_i1].hide[newshape.faces[psd_i1].hide.length] = 2;
						// that's an inside line now, so get rid of it
					}
					else {
						newshape.faces[psd_i1].hide = [];
						newshape.faces[psd_i1].hide[0] = 2;
					};
				};
			}
			//for(psd_i2 = 0; psd_i2 < psd_temp.length; psd_i2++) {
			for(psd_i2 = psd_temp.length - 1; psd_i2 >= 0; psd_i2--) {
				newshape.faces.splice(psd_i1 + 1, 0, structuredClone(psd_temp[psd_i2]));
			}
			psd_i1 += psd_temp.length;
			// splice in psd_temp, add the length to psd_i1 so it skips them
			// - go backwards so it's in order
		}

		var subdivides = [];
		psd_temp = [];
		for(psd_i1=0; psd_i1 < newshape.faces.length; psd_i1++) {
		// runs for all of the new triangle faces
			// find all the right points, make them into new points and add
			// their indexes to an array
			// -
			subdivides = [];
			// structure is:
			// - steps from point 0 to point 1
			//   - steps from that point to the side between 1 and 2 (which also
			//     means the higher the "x", the few "y"s there are)
			subdivides[0] = [];
			subdivides[0][0] = newshape.faces[psd_i1].indexes[0];
			subdivides[0][fineness] = newshape.faces[psd_i1].indexes[2];
			subdivides[fineness] = [];
			subdivides[fineness][0] = newshape.faces[psd_i1].indexes[1];
			psd_temp = [];
			psd_temp[0] = structuredClone(newshape.points[ newshape.faces[psd_i1].indexes[0] ]);
			// the starting point for the creation of any new point.
			psd_temp[1] = structuredClone(newshape.points[ newshape.faces[psd_i1].indexes[1] ]);
			psd_temp[2] = structuredClone(newshape.points[ newshape.faces[psd_i1].indexes[2] ]);
			// arrays of the distances to move in order to move up one "x" or
			// "y". or they will be, anyway.
			for(psd_i2=0; psd_i2 < 3; psd_i2++) {
				psd_temp[1][psd_i2] -= psd_temp[0][psd_i2];
				psd_temp[1][psd_i2] /= fineness;
				psd_temp[2][psd_i2] -= psd_temp[0][psd_i2];
				psd_temp[2][psd_i2] /= fineness;
			};
			for(psd_i2=0; psd_i2 < fineness; psd_i2++) {
			// make one "x" row (skipping the last since that's only one point)
				if(psd_i2 !== 0) {
					subdivides[psd_i2] = [];
				};
				for(psd_i3=0; psd_i3 <= Math.min(fineness - psd_i2, fineness - 1); psd_i3++) {
				// make one "y" item
				// - don't go to full fineness since [0][fineness] is already
				//   filled
					if(psd_i2===0 && psd_i3===0) {
						psd_i3++;
					};
					psd_temp[3] = structuredClone(psd_temp[0]);
					// stores the coordinates for the new point
					for(psd_i4=0; psd_i4 < 3; psd_i4++) {
						psd_temp[3][psd_i4] += psd_i2*psd_temp[1][psd_i4];
						// move x-wise
						psd_temp[3][psd_i4] += psd_i3*psd_temp[2][psd_i4];
						// move y-wise
					}
					// - with each "x", move side 0/fineness, with every "y"
					//   move side 2/fineness
					newshape.points[newshape.points.length] = structuredClone(psd_temp[3]);
					subdivides[psd_i2][psd_i3] = newshape.points.length - 1;
					// create the point, record the index
				}
			}
			// subdivides array is now filled
			psd_temp = [];
			for(psd_i2=1; psd_i2 < fineness**2; psd_i2++) {
				psd_temp[0] = structuredClone(newshape.faces[psd_i1]);
				psd_temp[2] = psd_i2;
				for(psd_i3=0; psd_temp[2] >= 2*fineness - 1 - 2*psd_i3; psd_i3++) {
					psd_temp[2] -= 2*fineness - 1 - 2*psd_i3;
				}
				psd_temp[1] = psd_temp[2];
				psd_temp[2] = psd_i3;
				// this is the "x" and "y" coordinates of the subtriangle.
				// finding the right corners is another thing entirely though,
				// since some of them are inverted
				delete psd_temp[0].fill;
				delete psd_temp[0].stroke;
				delete psd_temp[0].center;
				psd_temp[0].indexes = [];
				psd_temp[0].indexes[0] = subdivides[ Math.round(psd_temp[1]/2) ][ psd_temp[2] ];
				psd_temp[0].hide = [];
				if(psd_temp[1]%2===1) {
				// if it's an inverted triangle
					psd_temp[0].indexes[1] = subdivides[ Math.round(psd_temp[1]/2) ][ psd_temp[2] + 1 ];
					psd_temp[0].indexes[2] = subdivides[ Math.round(psd_temp[1]/2) - 1 ][ psd_temp[2] + 1 ];
					psd_temp[0].hide = [0, 1, 2];
				}
				else {
					psd_temp[0].indexes[1] = subdivides[ Math.round(psd_temp[1]/2) + 1 ][ psd_temp[2] ];
					psd_temp[0].indexes[2] = subdivides[ Math.round(psd_temp[1]/2) ][ psd_temp[2] + 1 ];
					if(psd_temp[2] !== 0 || newshape.faces[psd_i1].hide.includes(0)) {
					// if it isn't part of what used to be the 0 side, or the first
					// triangle hides that side, hide it
						psd_temp[0].hide[ psd_temp[0].hide.length ] = 0;
					};
					if(psd_temp[1] !== 2*(fineness - 1 - psd_temp[2]) || newshape.faces[psd_i1].hide.includes(1)) {
						psd_temp[0].hide[ psd_temp[0].hide.length ] = 1;
					};
					if(psd_temp[1] !== 0 || newshape.faces[psd_i1].hide.includes(2)) {
						psd_temp[0].hide[ psd_temp[0].hide.length ] = 2;
					};
				};
				newshape.faces.splice(psd_i1 + psd_i2, 0, structuredClone(psd_temp[0]));
			}
			newshape.faces[psd_i1].indexes = [
				subdivides[0][0],
				subdivides[1][0],
				subdivides[0][1]
			];
			newshape.faces[psd_i1].hide[newshape.faces[psd_i1].hide.length] = 1;
			// this should be an inner side
			psd_i1 += fineness**2 - 1;
			// skip all the faces it just made
		}
		return newshape;
	}
	function polyrandomize(shape, range, condensefactor) {
	// randomizes the positions of every point to be moved in a random 3d angle
	// somewhere between 0 and the range provided.
	// - condensefactor: uses randexponent to make it more likely for it to move
	//   less, yet still have the range as a maximum
		let i1 = 0;
		let i2 = 0;
		let anglenum = [];
		let randnum = 0;
		if(!condensefactor) {
			condensefactor = 1;
		};
		for(i1 = 0; i1 < shape.points.length; i1++) {
			anglenum = [Math.random()*2*Math.PI, Math.random()*Math.PI - Math.PI/2];
			// random 3d angle
			anglenum = Angle.numbers(anglenum);
			// convert to 3d equivalent of cos/sin
			randnum = randexponent(condensefactor, true);
			for(i2 = 0; i2 < 3; i2++) {
				shape.points[i1][i2] += anglenum[i2]*randnum*range;
			}
		}
	}
	class Poly {
	// - (changes that can be set by .init or any faces)
	//   - .fill, .stroke
	//   - .center: the point that faces are assumed to face away from. (they
	//     are single-sided.) starts as an average of all points.
	//   - .invert_toggle: switches things so faces face towards the center, or
	//     switches back.
	//     - the reason it's a toggle is because the whole point is that what's
	//       visible becomes invisible and vice versa. wouldn't work well
	//       otherwise.
	//   - .outline
	//     - .color
	//     - .width
	//     =
	//     - starts as always being whatever the stroke currently is.
	//   - .reset (if this boolean is on, it resets everything back to how the
	//     main .init had it, just like exiting/entering a face group.)
	//   - .texture_name (changes which property of .texture to use for a
	//     texture)
	//   - .shader
	//     - .lightmod
	//     - .colormod
	//   =
	//   - enter "default" for any of these and it will reset to how it is
	//     *before* .init. for example, .fill and .stroke start as whatever the
	//     canvas styles were before running Poly.draw.
	//     - for things like shader, it will delete itself.
	// - .points: an array of coordinate arrays.
	// - .faces: an object of objects that store information for a single face.
	//   - .[integer] properties: these represent the individual points.
	//     - .index: which .points this is
	//     - .hide: whether to hide the line from this to the next point
	//     - .texture: texture 2d coordinates
	//   - (changes that can also be set by .init)
	//   - .circular
	//   - .double_sided: makes it so the face will be drawn regardless of which
	//     direction it faces.
	//   =
	//   - property names starting with an underscore are assumed to be
	//     categories. these will also reset any changes and go back to however
	//     things were as of the main .init property.
	//     - .init: these groups can have .inits of their own. they are applied
	//       in addition to the main .init, they do not replace it.
	//     =
	//     - you can nest these.
	//   - triangles are formed by connecting every consecutive pair to the
	//     first point.
	//     - if circular is on, it will also form a triangle with the first,
	//       last, and second. (this doesn't apply to the faces that come after,
	//       it's turned on per face. use it for circles, regular polygons,
	//       etc.)
	//   - don't create a property called "_settingsindex", or "_average".
	//     Poly.draw uses those.
	//     - Poly.draw doesn't modify the shape, and presumably you wouldn't be
	//       counting on it to react to your custom properties so it's not like
	//       it matters that it'll overwrite them.
	//     - so i'm not gonna say anything like "don't name anything this
	//       because it'll fuck up everything". i'm just too paranoid to not
	//       take note of a Forbidden Name for future properties
	// - .texture
	//   - for the sake of Poly.join and all that, this can be an object. or at
	//     least, it should be possible for it to be an object.
	//   - by default, it's assumed .texture is itself an ImageData and you
	//     should use that.
	// - .init
	//   - applies the changes faces can apply, but at the beginning. (for
	//     example, make .fill "orange" and the shape will be orange. you could
	//     do the same thing by editing the first face, but that can get messy)
	// - .staticsettings: static as in they're similar to the face/.init changes
	//   but can't be changed by those.
	//   - .orient: an angle for Poly.draw to use in revolve(), with [0, 0, 0]
	//     as the fulcrum. (this is done before offset is applied.)
	//     - read the comments at the beginning of revolve for information on
	//       what angles are allowed and how they work.
	//   - .offset: coordinates added to every point and center in Poly.draw.
	//   - .double_sided: does the same thing as making every face double-sided.
		constructor(makestructure) {
			if(makestructure) {
				this.points = [];
				this.faces = {};
				this.texture = null;
				this.init = {};
				this.staticsettings = {};
			};
		}
		static build(type, dimensions, fineness, offset, texture) {
		// the successor to build3dshape, which is so old i used var. ew.
		// - type:
		//   - "sphere"
		//     - this is like a latitude/longitude. horizontal rings of
		//       quadrangle faces.
		//   - "cube"
		//   - "cone"
		//     - the circular side is at the bottom, the point is at the top.
		//   - "cylinder"
		//     - the circular sides are at the top and bottom.
		//   - "disc" (circles or regular polygons, parallel to the xy plane)
		//     - alternative names: circle, polygon
		//   - "square" (makes squares, parallel to the xy plane)
		//     - alternative names: rectangle, rect
		//   - "stairs" (they face the camera. fineness is how many steps it's
		//     divided into.)
		//   =
		//   - despite names like "sphere" and "cube", none of these shapes are
		//     locked to a 1:1:1 ratio.
		//   - the "altnames" variable in this function shows other allowed
		//     names like "box" instead of cube.
		// - dimensions:
		//   - an array of width, height, depth
		//   - if it's only one number or an array of one number, it'll use that
		//     for every dimension
		//   - if it's two numbers, they'll be used as width and height, and
		//     depth will be whatever is smaller
		//   - by default, it's 1.
		//   - remember, for spheres and stuff you have to input diameter, not
		//     radius.
		// - fineness:
		//   - this is pretty much "how many sides a circle has".
		//   - ie, a cylinder with 5 fineness will be a pentagonal prism.
		//   - for spheres, it needs to be an even number. it will be ticked up
		//     if it isn't.
		// - offset: an array of three coordinates that it adds to each point at
		//   the end.
		//   - it does NOT use .staticsettings. i recommend using that instead
		//     because it's much easier to edit.
		// - texture: an object for specifying things about the texture
		//   coordinates.
		//   - texture coordinates are, roughly, scaled as what the dimensions
		//     of the shape should be.
		//   - .scalable: boolean for whether it should create it as if it's a
		//     1:1:1 shape. (the highest dimension is used.)
		//     - this is ideal for a shape whose dimensions might change, but
		//       the default is better for a more consistent pixel size.
		//   - .no_infinites: coordinates are not multiplied by pi or square
		//     roots or anything like that. instead it uses an approximate.
		//     - those are more accurate or whatever, but they also guarantee
		//       every coordinate is an infinite decimal and that can look weird
		//       and asymmetrical.
		//     - this does not avoid infinites caused by simple division,
		//       however. like, if you make a sphere with 6 fineness, every cell
		//       will be the diameter divided by 6, so there will be infinite
		//       decimals.
		//     - it will use 3 in place of pi.
		//   - note that Poly.build does not create a texture image, which means
		//     you don't have to worry about deleting texture coordinates if you
		//     don't want texturing.
		//     - Poly.draw only runs texturing if the points have texture
		//       coordinates and the texture isn't null.
		//     - but if you wanna omit it to make sure the object isn't bigger
		//       than it has to be, use an "omit" string.
		//   - .type: used in certain shapes. a string specifying a different
		//     way of assigning coordinates.
		//   - how the textures are mapped:
		//     - NOTE: generally, xz angle correlates to x position on the
		//       texture image, but this is inverted. angles close to 360 are on
		//       the left, angles close to 0 are on the right.
		//       - this is because 0 xz is the right, 90 xz is the front, 180 is
		//         left, 270 is the back... if you look at one face of a sphere,
		//         the left side is the one with *more* xz angle, not less.
		//     - NOTE: for circular features, it generally uses a fraction of a
		//       circumference rather than the actual side length.
		//     - sphere:
		//       - if .type === "square": a square grid where x is xz angle and
		//         y is which ring of faces it is. except for the top and
		//         bottom, which are isosceles triangles.
		//     - cylinder:
		//       - the top as a circle, the bottom right next to it, and the
		//         sides on the bottom.
		//       - if .type === "teeth": the top and bottom are two interlocked
		//         rows of triangles. (the leftmost tooth is part of the top.)
		//     - cube: a sideways T.
		//       - front, right, back, left, and top and bottom above and below
		//         the front side.
		//     - cone TODO
		//     - disc, square: these are just 2d versions of the shapes,
		//       positioned whatever way will guarantee the leftmost/upmost
		//       point at 0 x/y
		//     - stairs
		//   - .symmetry property
		//     - there's no rule against using the same part of a texture for
		//       multiple faces. it's actually pretty common since it means the
		//       texture can be smaller.
		//     - this property is an object that lets you specify which faces
		//       should be duplicates. it works differently for each shape
		//       though.
		//     =
		//     - multiple
		//       - radial: faces that are all part of the same circle share
		//         textures.
		//         - if this is a number, instead there will be multiple
		//           textures that it alternates between. (if it's 3 and this is
		//           used on a shape with 9 fineness, faces that are at position
		//           0, 3, and 6 will use the first texture, 1, 4, and 7 will
		//           use the second, etc)
		//         =
		//         - sphere
		//         - cone
		//         - cylinder
		//         - disc
		//     - sphere
		//       - vertical: there's only a single square texture for every
		//         column of faces. (the top and bottom will use the midpoint of
		//         the top/bottom edge of this square to form an isosceles
		//         triangle.)
		//         - like radial symmetry, you can specify how many faces to
		//           alternate between.
		//     - cube
		//       - x, y, z: the two sides of whatever specified axis match each
		//         other.
		//         - specifically, the coordinates are oriented so that every
		//           pixel directly matches the opposite side... but this also
		//           means that if you have an F on the top side, it'll be
		//           mirrored on the bottom side.
		//     - cone
		//     - cylinder
		//       - bases: same as cube's axis symmetries, but only for the top
		//         and bottom.
		//     - disc, square
		//       - other: the back side matches the front. NOTE this works
		//         differently than the others, it alters the actual shape. only
		//         one face is made, which is double-sided. (as opposed to
		//         duplicates that face opposite directions.)
		//     - stairs
		//       - sides
		//         - works like cube's symmetries.
		//       - tops: the tops of each step match. (you can specify how many
		//         rectangles to alternate between, like radial symmetry.)
		//       - fronts: same thing for the front of each step
		//       - topandfront: tops and fronts use the same set of rectangles
		// - log an example of the shape you're about to make if you want to
		//   know how the faces are structured.
		// - don't forget to add these, because this sure doesn't
		//   - .init
		//     - .fill, .stroke
		//     - if you're combining this with something
		//       - .reset
		//       - .center (it sets this as [0, 0, 0] or whatever offset is)
		//       - .texture_name
		//     - .shader (absent, which means )
		//       - .lightmod
		//       - .colormod
		//   - .staticsettings
		//     - .orient
		//     - .offset (the offset parameter is added to the points manually
		//       instead of using this, because that makes more sense when
		//       combining shapes)
		//     - .double_sided
		//   - .texture
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let altnames = {
				sphere: ["spheroid", "ball"],
				cube: ["box"],
				cone: ["pyramid"],
				cylinder: ["prism"],
				disc: ["circle", "polygon"],
				square: ["rectangle", "rect"],
				stairs: ["steps"],
			};
			if(typeof type !== "string") {
			// if they used false or something to skip it, use sphere
				type = "sphere";
			}
			else if(!altnames.hasOwnProperty(type)) {
			// if it's not one of the "correct" names, search the alternate
			// names, and use sphere if nothing matches
				let temp = false;
				for (i1 in altnames) {
					if (altnames.hasOwnProperty(i1) && altnames[i1].includes(type)) {
						type = i1;
						temp = true;
					}
				}
				if(!temp) {
					console.log("invalid shape type: " + type);
					type = "sphere";
				}
			};
			let w = null;
			let h = null;
			let d = null;
			if(typeof dimensions === "number") {
				w = dimensions;
				h = dimensions;
				d = dimensions;
			}
			if(typeof dimensions === "object") {
				let temp = [
					dimensions.hasOwnProperty(0) && typeof dimensions[0] === "number",
					dimensions.hasOwnProperty(1) && typeof dimensions[1] === "number",
					dimensions.hasOwnProperty(2) && typeof dimensions[2] === "number"
				];
				if(temp[0]) {
					if(!temp[1] && !temp[2]) {
					// one number
						w = dimensions[0];
						h = dimensions[0];
						d = dimensions[0];
					}
					else if(temp[1] && !temp[2]) {
					// two numbers
						w = dimensions[0];
						h = dimensions[1];
						d = Math.min(dimensions[0], dimensions[1]);
					}
					else if(temp[1] && temp[2]) {
					// three
						w = dimensions[0];
						h = dimensions[1];
						d = dimensions[2];
					};
				};
			}
			else if(typeof dimensions === "number") {
				w = dimensions;
				h = dimensions;
				d = dimensions;
			};
			w ??= 1;
			h ??= 1;
			d ??= 1;
			if(typeof fineness !== "number" || fineness <= 0) {
				fineness = 16;
			};
			if(type === "sphere") {
				fineness = 2*Math.ceil(fineness/2);
			}
			else {
				fineness = Math.floor(fineness);
			};
			if(!Array.isArray(offset)) {
				offset = [0, 0, 0];
			};
			let poly = new Poly(true);
			function convertfaces(facesobj) {
				function facefromindexes(array) {
				// takes an array of .points indexes and converts it into a proper
				// face.
					let i1 = 0;
					let obj = {};
					for (i1 = 0; i1 < array.length; i1++) {
						obj[i1] = {
							index: array[i1],
						};
					}
					return obj;
				}
				let i1 = 0;
				for (i1 in facesobj) {
					if (facesobj.hasOwnProperty(i1)) {
						if(i1.startsWith("_")) {
						// face category
							convertfaces(facesobj[i1]);
						}
						else if(i1 !== "init") {
						// face
							facesobj[i1] = facefromindexes(facesobj[i1]);
						};
					}
				}
			}
			function addring(pointsarray, position, radius, axis) {
			// adds a ring of points along the xy, xz, or yz axis.
			// - DRY and all that.
			// - position can be a three coordinate array or just a single
			//   number. if it's a single number, it's assumed to be on whatever
			//   axis the circle is perpendicular to.
				let i1 = 0;
				radius = typeof radius === "number" ? radius : 1;
				axis = ["xy", "xz", "yz"].includes(axis) ? axis : "xz";
				let axes = {
					pos: ["yz", "xz", "xy"].indexOf(axis),
					// axis to use the specified position for
				};
				axes.cos = "xyz".indexOf(axis.charAt(0));
				axes.sin = "xyz".indexOf(axis.charAt(1));
				if(!Array.isArray(position)) {
					let temp = position;
					position = [0, 0, 0];
					if(typeof temp === "number") {
						position[axes.pos] = temp;
					};
				};
				for (i1 = 0; i1 < fineness; i1++) {
					pointsarray[pointsarray.length] = structuredClone(position);
					pointsarray[pointsarray.length - 1][axes.cos] += radius*Math.cos(2*Math.PI*i1/fineness);
					pointsarray[pointsarray.length - 1][axes.sin] += radius*Math.sin(2*Math.PI*i1/fineness);
				}
			}
			function discindexes(center, ringstart) {
			// returns an array of indexes that can form a circle, the point of
			// a cone, the cap of a sphere, etc.
			// - it's an array so it won't screw up convertfaces.
			// - NOTE don't forget to add .circular after it's converted.
				let i1 = 0;
				let array = [center];
				for (i1 = 0; i1 < fineness; i1++) {
					array[array.length] = ringstart + i1;
				}
				return array;
			}
			// NOTE for the initial construction, point positions will stay
			// between -1 and 1. it's multiplied by the dimensions divided by 2,
			// later...
			// NOTE the pattern for creating rectangular faces is top-left,
			// top-right, bottom-right, bottom-left. for circular faces, it's in
			// order of angle
			// - actually, just look at the cube logic. basically, that's my
			//   order for the front side, and the other sides i just rotate the
			//   cube xz/yz in my head to make that side the front and do the
			//   same thing.
			if(type === "sphere") {
				// yyysphere
				let ring = {
					num: -1,
					// this starts at -1 because the first "ring" is the top of
					// the sphere, which can't create a ring of faces.
					y: null,
					r: null,
					start: 0,
					ref: null,
				};
				for (i1 = -1; i1 < fineness/2; i1++) {
				// makes a ring of points, then a ring of faces with the
				// previous ring.
					let angle = (-1/4 + (i1 + 1)/fineness)*2*Math.PI;
					ring.y = Math.sin(angle);
					ring.r = Math.abs(Math.cos(angle));
					ring.start = poly.points.length;
					// index this ring starts at
					ring.cap = false;
					if(i1 !== -1) {
						poly.faces["_" + i1] = {};
						ring.ref = poly.faces["_" + i1];
					};
					if([-1, fineness/2 - 1].includes(i1)) {
					// if the newest ring is the very top or the very bottom of
					// the sphere, only make one point
						poly.points[poly.points.length] = [0, Math.sign(angle), 0];
					}
					else {
						addring(poly.points, ring.y, ring.r, "xz");
					};
					// make the points
					if(i1 !== -1) {
						for (i2 = 0; i2 < fineness; i2++) {
						// connect the previous set of points to the new set of
						// points
						// - can't do this for the top, because there is no
						//   previous set of points.
							ring.ref[i2] = [
								ring.start + (i2 + 1)%fineness - fineness,
								ring.start + i2 - fineness,
								ring.start + i2,
								ring.start + (i2 + 1)%fineness
							];
							// needs to go in a c motion, so next meridian
							// to this meridian to this meridian to next
							// meridian. subtract fineness from the first
							// two to put them in the previous ring.
							if(i1 === 0) {
							// top of sphere
								ring.ref[i2].splice(0, 2, ring.start - 1);
							}
							else if(i1 === fineness/2 - 1) {
							// bottom of sphere
								ring.ref[i2].splice(2, 2, ring.start);
							}
						}
					}
					// make the faces
					ring.num++
				}
				// make the second cap/point
				convertfaces(poly.faces);
				for (i1 in poly.faces) {
					if (poly.faces.hasOwnProperty(i1)) {
					// run for every ring
						for (i2 in poly.faces[i1]) {
							if (poly.faces[i1].hasOwnProperty(i2)) {
							// run for every face
								for (i3 in poly.faces[i1][i2]) {
									if (poly.faces[i1][i2].hasOwnProperty(i3) && !isNaN(Number(i3))) {
									// run for every point
										poly.faces[i1][i2][i3].hide = true;
										// hide all edges.
									}
								}
							}
						}
					}
				}
				// i have no idea if this will work. it'll probably won't, at
				// first. this logic is hard.
			}
			else if(type === "cube") {
				for (i1 = 0; i1 < 8; i1++) {
					poly.points[i1] = [
						i1%8 < 4 ? -1 : 1,
						i1%4 < 2 ? -1 : 1,
						i1%2 < 1 ? -1 : 1
					];
				};
				// 0 000 left  top    back
				// 1 001 left  top    front
				// 2 010 left  bottom back
				// 3 011 left  bottom front
				// 4 100 right top    back
				// 5 101 right top    front
				// 6 110 right bottom back
				// 7 111 right bottom front
				poly.faces = {
					left	: [0, 1, 3, 2],
					right	: [5, 4, 6, 7],
					top		: [0, 4, 5, 1],
					bottom	: [3, 7, 6, 2],
					back	: [0, 4, 6, 2],
					front	: [1, 5, 7, 3],
				};
				convertfaces(poly.faces);
			}
			else if(type === "cone") {
				poly.points[poly.points.length] = [0, -1, 0];
				addring(poly.points, 1, 1, "xz");
				poly.points[poly.points.length] = [0, 1, 0];
				poly.faces.top = discindexes(0, 1);
				poly.faces.base = discindexes(1 + fineness, 1);
				convertfaces(poly.faces);
				poly.faces.top.circular = true;
				poly.faces.base.circular = true;
			}
			else if(type === "cylinder") {
				poly.points[poly.points.length] = [0, -1, 0];
				addring(poly.points, -1, 1, "xz");
				poly.points[poly.points.length] = [0, 1, 0];
				addring(poly.points, 1, 1, "xz");
				poly.faces.top = discindexes(0, 1);
				for (i1 = 0; i1 < fineness; i1++) {
					poly.faces[i1] = [
						1 + i1,
						1 + (i1 + 1)%fineness,
					];
					poly.faces[i1][2] = (1 + fineness) + poly.faces[i1][1];
					poly.faces[i1][3] = (1 + fineness) + poly.faces[i1][0];
				}
				poly.faces.bottom = discindexes(1 + fineness, 1 + fineness + 1);
				convertfaces(poly.faces);
				poly.faces.top.circular = true;
				poly.faces.bottom.circular = true;
				for (i1 = 0; i1 < fineness; i1++) {
					poly.faces[i1][1].hide = true;
					poly.faces[i1][3].hide = true;
				}
			}
			else if(["disc", "square"].includes(type)) {
				if(type === "disc") {
					poly.points[poly.points.length] = [0, 0, 0];
					addring(poly.points, 0, 1, "xy");
					poly.faces.front = discindexes(0, 1);
					poly.faces.back = discindexes(0, 1);
				}
				else if(type === "square") {
					for (i1 = 0; i1 < 4; i1++) {
						poly.points[i1] = [
							i1%4 < 2 ? -1 : 1,
							i1%2 < 1 ? -1 : 1,
							0
						];
					};
					// 0 00 left  top
					// 1 01 left  bottom
					// 2 10 right top
					// 3 11 right bottom
					poly.faces = {
						front: [0, 1, 3, 2],
						back: [0, 1, 3, 2],
					};
				}
				convertfaces(poly.faces);
				poly.faces.front.circular = true;
				poly.faces.back.circular = true;
				poly.faces.front.center = [0, 0, -1];
				poly.faces.back.center = [0, 0, 1];
			}
			else if(type === "stairs") {
				poly.points = [
					[-1, 1, -1],
					// bottom left back
					[1, 1, -1]
					// bottom right back
				];
				// bottom back corners
				poly.faces = {
					left: [0],
					right: [1],
					_tops: {},
					_fronts: {},
				}
				let temp1 = null;
				let temp2 = "";
				for (i1 = 0; i1 <= fineness; i1++) {
				// create four points for each step. (plus the two points on the
				// bottom. those aren't part of the top of any step.)
					temp1 = [
						-1,
						-1 + 2*i1/fineness,
						-1 + 2*i1/fineness
					];
					// the left back point of a stair's top
					poly.points[poly.points.length] = structuredClone(temp1);
					poly.points[poly.points.length] = structuredClone(temp1);
					poly.points[poly.points.length - 1][0] *= -1;
					// invert x to make right back point
					temp2 = poly.points.length - 1;
					poly.faces.left[poly.faces.left.length] = temp2 - 1;
					poly.faces.right[poly.faces.right.length] = temp2;
					// add to left/right sides
					if(i1 === 0) {
					// create back side
						poly.faces.back = [temp2 - 1, temp2, 0, 1];
						// top left back, top right back, bottom right back, bottom left back
					}
					else {
					// create the front face of a step using the front two
					// points from the last step.
						poly.faces._fronts[i1 - 1] = [temp2 - 3, temp2 - 2, temp2, temp2 - 1];
					};
					if(i1 === fineness) {
					// create bottom side
						poly.faces.bottom = [temp2 - 1, temp2, 1, 0];
						// bottom left front, bottom right front, bottom right back, bottom left back
					}
					else {
					// create the front two points.
						poly.points[poly.points.length] = structuredClone(temp1);
						poly.points[poly.points.length - 1][2] += 2*1/fineness;
						// add one step's worth of z
						poly.points[poly.points.length] = structuredClone(poly.points[poly.points.length - 1]);
						poly.points[poly.points.length - 1][0] *= -1;
						// copy and invert x
						temp2 = poly.points.length - 1;
						poly.faces.left[poly.faces.left.length] = temp2 - 1;
						poly.faces.right[poly.faces.right.length] = temp2;
						poly.faces._tops[i1] = [temp2 - 3, temp2 - 2, temp2, temp2 - 1];
						// add to left/right sides, create the top of a step
						// using all four points made this iteration.
					};
				}
				convertfaces(poly.faces);
			};
			// end of basic construction
			function finalcoordinates(point) {
				return [
					offset[0] + point[0]*w/2,
					offset[1] + point[1]*h/2,
					offset[2] + point[2]*d/2
					// halved because the initial construction places them between
					// -1 and 1 (ie they're 2 wide)
				];
			}
			for (i1 = 0; i1 < poly.points.length; i1++) {
				poly.points[i1] = finalcoordinates(poly.points[i1]);
			}
			let settings = Poly.allfaces(poly.faces, true);
			for (i1 = 0; i1 < settings.length; i1++) {
				if(settings[i1].hasOwnProperty("center")) {
					settings[i1].center = finalcoordinates(settings[i1].center);
				};
			}
			poly.init = {
				center: structuredClone(offset),
			};
			return poly;
		}
		static facetris(face) {
		// returns an array of all the triangles in a face.
		// - these are all arrays with three numbers, all of which are indexes
		//   for which point of the face they are. (that's not to be confused
		//   with indexes of .point.)
			let array = [];
			let facelength = objarraylength(face);
			let circular = !!face.circular && facelength > 3;
			let i1 = 0;
			for (i1 = 0; i1 < facelength; i1++) {
				if (i1 !== 0 && (circular || i1 !== facelength - 1)) {
					array[array.length] = [0, i1, (i1 + 1)%facelength];
				}
			}
			return array;
		}
		static tristroke(face, tri) {
		// returns an array of three booleans for which edges of a triangle
		// should be drawn.
		// - tri should be an array of three indexes, like what facetris
		//   returns.
			let numofpoints = objarraylength(face);
			let _return = [];
			let i1 = 0;
			for (i1 = 0; i1 < 3; i1++) {
				let pointA = tri[i1];
				let pointB = tri[(i1 + 1)%3];
				_return[i1] = false;
				if(!!face[pointA].hide) {
				// hide hides lines. end of story.
				}
				else if(pointA === numofpoints - 1) {
				// the normal flow is:
				// - tris: [0, 1, 2], [0, 2, 3]
				// - lines: 0 to 1 to 2 to 3 to 0
				// circular is like:
				// - tris: [0, 1, 2], [0, 2, 3], [0, 3, 1]
				// - lines: 1 to 2 to 3 to 1
					_return[i1] = pointB === (!!face.circular ? 1 : 0);
				}
				else {
					_return[i1] = (
						pointB - pointA === 1
						&&
						(
							!face.circular
							||
							pointA !== 0
						)
					);
				};
			}
			return _return;
		}
		// yyydraw
		draw(viewer, ctx, offset, orient, weight, etc) {
		// - offset: applied to all coordinates when drawing.
		// - orient: an angle to use with revolve(). [0, 0, 0] is the center of
		//   rotation. (this is done before offset is applied.)
		// - weight: line weight passed to _3dline
		// - etc: a series of special commands.
		//   - "wireframe": no fill will be done, and stroke will always be done
		//     regardless of which direction the triangle faces.
		//   - "tri": all triangles' strokes will be drawn.
		//   - "lineless": stroke will not be drawn.
		//   - "double-sided": faces will be drawn regardless of their
		//     direction.
		//   =
		//   - you can use multiple of these by making them an array.
		// =
		// - NOTE: if something has gone wrong, there's a good chance of it
		//   being the shape, not Poly.draw. doublecheck both.
			console.log(this);
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let _default = {
				fill: ctx.fillStyle,
				stroke: ctx.strokeStyle,
				center: [0, 0, 0],// this is changed to the average of all points, later
				invert: false,
				texture_name: null,
			};
			// - (changes that can be set by .init or any faces)
			//   - .fill, .stroke
			//   - .center
			//   - .invert_toggle
			//   - .outline
			//     - .color
			//     - .width
			//   - .reset
			//   - .texture_name
			//   - .shader
			//     - .lightmod
			//     - .colormod
			etc = (typeof etc === "string" || Array.isArray(etc) ? etc : []);
			// if it's nullish, it'll turn up errors
			let _this = structuredClone(this);
			let _offset = offset ? structuredClone(offset) : [];
			for (i1 = 0; i1 < 3; i1++) {
				_offset[i1] = typeof _offset[i1] === "number" && !isNaN(_offset[i1]) ? _offset[i1] : 0;
				if(!!_this.staticsettings && !!_this.staticsettings.offset) {
					_offset[i1] += _this.staticsettings.offset[i1];
				};
			}
			if(_this.staticsettings.orient) {
				_this.points = revolve(_this.staticsettings.orient, _this.points);
			};
			if(orient) {
				_this.points = revolve(orient, _this.points);
			};
			for (i1 = 0; i1 < _this.points.length; i1++) {
				_this.points[i1][0] += _offset[0];
				_this.points[i1][1] += _offset[1];
				_this.points[i1][2] += _offset[2];
				_default.center[0] += _this.points[i1][0];
				_default.center[1] += _this.points[i1][1];
				_default.center[2] += _this.points[i1][2];
			};
			_default.center[0] /= _this.points.length;
			_default.center[1] /= _this.points.length;
			_default.center[2] /= _this.points.length;
			let settings = structuredClone(_default);
			function reset() {
			// sets settings back to whatever it was right after the main .init.
				settings = structuredClone(_default);
				applychanges(_this.init);
			};
			let possiblechanges = [
				"reset",
				"fill",
				"stroke",
				"center",
				"invert_toggle",
				"outline",
				"texture_name",
				"shader"
			];
			function applychanges(object) {
			// applies the changes stored in a .init or face to settings.
			// - object: the .init or face
				let i1 = 0;
				let i2 = 0;
				let change = "";
				for (i1 = 0; i1 < possiblechanges.length; i1++) {
					change = possiblechanges[i1];
					if(object.hasOwnProperty(change)) {
						if(object[change] === "default") {
							if(_default.hasOwnProperty(change)) {
								settings[change] = structuredClone(_default[change]);
							}
							else {
								delete settings[change];
							}
						}
						else if(change === "reset") {
							reset();
						}
						else if(["fill", "stroke", "center", "texture_name"].includes(change)) {
							settings[change] = structuredClone(object[change]);
						}
						else if(change === "invert_toggle") {
							settings.invert = !settings.invert;
						}
						else if(change === "outline") {
							if(!settings.outline) {
								settings.outline = {
									color: settings.stroke,
									// this makes it use whatever the stroke currently
									// is.
									width: false,
								};
							};
							if(!!object.outline.color) {
								settings.outline.color = (
									object.outline.color === "default"
									?
									_default.stroke
									:
									object.outline.color
								);
							};
							if(object.outline.hasOwnProperty("width")) {
								settings.outline.width = object.outline.width;
							};
						}
						else if(change === "shader") {
							if(!settings.shader) {
								settings.shader = {
									lightmod: null,
									colormod: null,
								};
							};
							let temp = ["lightmod", "colormod"];
							for (i2 = 0; i2 < temp.length; i2++) {
								if(object.shader.hasOwnProperty(temp[i2])) {
									settings.shader[temp[i2]] = structuredClone(object.shader[temp[i2]]);
								};
							}
						};
					}
				}
			};
			applychanges(_this.init);
			let facesettings = [];
			// an array of the different settings different faces have. every time it
			// applies a change from .inits or faces, it will add a new object to this
			// array.
			facesettings[0] = structuredClone(settings);
			let faces = [];
			// this is an array of faces in a "workable" form. what that means is:
			// - all of the faces are in one linear array, instead of being in
			//   categories. (it has to be in one array for it to be sorted by z.)
			// - all data related to changes is gone.
			// - there's the ._settingsindex property, which tells it which facesettings
			//   to use, and the ._average property which stores the average coordinates
			//   of all points.
			function haschanges(object) {
				let i1 = 0;
				for (i1 = 0; i1 < possiblechanges.length; i1++) {
					if(object.hasOwnProperty(possiblechanges[i1])) {
						return true;
					}
				}
				return false;
			}
			function deletechanges(object) {
				let i1 = 0;
				for (i1 = 0; i1 < possiblechanges.length; i1++) {
					if(object.hasOwnProperty(possiblechanges[i1])) {
						delete object[possiblechanges[i1]];
					}
				}
			}
			// - _this: this should be "this", (the shape inputted into
			//   Poly.draw, which functions should not edit) not "_this" (the
			//   copy Poly.draw makes to get around not being allowed to edit
			//   this)
			//   - used in methods.
			function makeworkable(facesobj, keychain) {
			// converts faces to a workable form and adds them to the faces array. this
			// should be applied to a whole object of faces, because it recurses for
			// face groups.
			// - keychain: used in recursion
				let i1 = 0;
				let i2 = 0;
				if(keychain === undefined) {
					keychain = [];
				};
				for (i1 in facesobj) {
					if (facesobj.hasOwnProperty(i1)) {
						if(i1.startsWith("_")) {
						// face group
							let settingstemp = structuredClone(settings);
							reset();
							keychain[keychain.length] = i1;
							let categoryref = _this.faces;
							for (i2 = 0; i2 < keychain.length; i2++) {
								categoryref = categoryref[keychain[i2]];
								if(categoryref.hasOwnProperty("init")) {
									applychanges(categoryref.init);
								};
							}
							// apply the changes stored in the whole lineage of
							// categories
							facesettings[facesettings.length] = structuredClone(settings);
							makeworkable(facesobj[i1], keychain);
							settings = structuredClone(settingstemp);
							// go back to whatever it was back before this category, so
							// that the faces after it aren't affected by what i just
							// did.
							keychain = [];
							// the keychain won't apply to faces after this
							// category, so get rid of that too.
						}
						else if(i1 !== "init") {
						// face
							let booltemp = haschanges(facesobj[i1]);
							if(booltemp) {
							// has changes to apply and save
								applychanges(facesobj[i1]);
								facesettings[facesettings.length] = structuredClone(settings);
							};
							faces[faces.length] = structuredClone(facesobj[i1]);
							if(booltemp) {
								deletechanges(faces[faces.length - 1]);
							};
							faces[faces.length - 1]._settingsindex = facesettings.length - 1;
						};
					};
				}
			}
			makeworkable(_this.faces);
			// - make a settings array.
			// - run through every face
			// - every time there's a change, apply it to the temporary settings
			//   variable, and add a structured clone as a new index.
			// - save this index for each face.
			for (i1 = 0; i1 < facesettings.length; i1++) {
				if(facesettings[i1].hasOwnProperty("center")) {
				// apply offset to center changes
					if(_this.staticsettings.orient) {
						facesettings[i1].center = revolve(_this.staticsettings.orient, facesettings[i1].center);
					};
					if(orient) {
						facesettings[i1].center = revolve(orient, facesettings[i1].center);
					};
					facesettings[i1].center[0] += _offset[0];
					facesettings[i1].center[1] += _offset[1];
					facesettings[i1].center[2] += _offset[2];
				}
			}
			function facecoord(face, point) {
			// returns the coordinates of a specified face point.
				return structuredClone(_this.points[face[point].index]);
			};
			function tridirection(tri, center, invert) {
			// returns the angle for which direction the triangle faces.
			// - tri should be three coordinates.
			// - center must be specified, yes. technically it could maybe figure
			//   this out on its own but that'd be slower for where i'm using this
			//   function.
				let angle = Plane.frompoints(tri).line().angle;
				let anglenum = Angle.numbers(angle);
				let average = [
					(tri[0][0] + tri[1][0] + tri[2][0])/3,
					(tri[0][1] + tri[1][1] + tri[2][1])/3,
					(tri[0][2] + tri[1][2] + tri[2][2])/3,
				];
				let plusdist = Math.hypot(
					average[0] + anglenum[0] - center[0],
					average[1] + anglenum[1] - center[1],
					average[2] + anglenum[2] - center[2]
				);
				let minusdist = Math.hypot(
					average[0] - anglenum[0] - center[0],
					average[1] - anglenum[1] - center[1],
					average[2] - anglenum[2] - center[2]
				);
				return (invertboolean(plusdist < minusdist, invert) ? Angle.invert(angle) : angle);
				// invert the angle if it points towards the center instead of away.
				// (switch it around if invert is on.)
			};
			// functions i'll need for calculating position and direction
			for (i1 = 0; i1 < faces.length; i1++) {
			// calculate and add ._average
				faces[i1]._average = [0, 0, 0];
				let numofpoints = objarraylength(faces[i1]);
				//let highestz = null;
				for (i2 = 0; i2 < numofpoints; i2++) {
					//let temp = this.points[faces[i1][i2].index];
					let temp = facecoord(faces[i1], i2);
					faces[i1]._average[0] += temp[0];
					faces[i1]._average[1] += temp[1];
					faces[i1]._average[2] += temp[2];
					//if(temp[2] > highestz || highestz === null) {
						//highestz = temp[2];
					//}
				}
				faces[i1]._average[0] /= numofpoints;
				faces[i1]._average[1] /= numofpoints;
				faces[i1]._average[2] /= numofpoints;
				// i don't wanna do all of this in the sorting function because
				// then it'll be done on every comparison...
				//faces[i1]._highestz = highestz;
			}
			function zsort(a, b) {
				return a._average[2] - b._average[2];
				//return a._highestz - b._highestz;
			};
			faces.sort(zsort);
			// sorts it by whatever the average z position of their points is
			for (i1 = 0; i1 < faces.length; i1++) {
			// draw each face, finally
				let _settings = facesettings[ faces[i1]._settingsindex ];
				// underscored so it's distinct from the temporary settings object i
				// used to make facesettings.
				ctx.fillStyle = _settings.fill;
				ctx.strokeStyle = _settings.stroke;
				// apply color changes. these are the only _settings properties where
				// they have to be applied to a specific object rather than the code
				// referencing _settings...
				//console.log(_settings.center.toString());
				let f = faces[i1];
				// for easy reference
				let facetris = Poly.facetris(f);
				//
				// check for errors in facesettings
				// draw triangles
				// draw outline
				for (i2 = 0; i2 < facetris.length; i2++) {
				// each item of facetris is an array of the numbers for three points of
				// the face.
				// - it's best to leave the triangulation to a separate function, for
				//   the sake of DRY and to make it easier to change how it works...
					facetris[i2] = {
						0: facecoord(f, facetris[i2][0]),
						1: facecoord(f, facetris[i2][1]),
						2: facecoord(f, facetris[i2][2]),
						indexes: structuredClone(facetris[i2]),
					};
					let temp = [false, false, false];
					for (i3 = 0; i3 < this.points.length; i3++) {
						if(compareobject(this.points[i1], facetris[i2][0])) {
							temp[0] = true;
						}
						if(compareobject(this.points[i1], facetris[i2][1])) {
							temp[1] = true;
						}
						if(compareobject(this.points[i1], facetris[i2][2])) {
							temp[2] = true;
						}
					}
					facetris[i2]._average = [
						(facetris[i2][0][0] + facetris[i2][1][0] + facetris[i2][2][0])/3,
						(facetris[i2][0][1] + facetris[i2][1][1] + facetris[i2][2][1])/3,
						(facetris[i2][0][2] + facetris[i2][1][2] + facetris[i2][2][2])/3
					];
				};
				facetris.sort(zsort);
				for (i2 = 0; i2 < facetris.length; i2++) {
					let tri = facetris[i2];
					let strokes = etc.includes("tri") ? [true, true, true] : Poly.tristroke(f, tri.indexes);
					// an array of which sides of the triangles are drawn. (tri
					// mode makes it so all of them are)
					if(!!_settings.outline) {
					// draw the outline before the rest of the shape
					// - all legs are drawn
						ctx.strokeStyle = _settings.outline.color;
						for (i3 = 0; i3 < tri.length; i3++) {
							let temp = _settings.outline.weight;
							_3dline(viewer, ctx,
								tri[i3][0],
								tri[i3][1],
								tri[i3][2],
								tri[(i3 + 1)%3][0],
								tri[(i3 + 1)%3][1],
								tri[(i3 + 1)%3][2],
							temp);
						};
						ctx.strokeStyle = _settings.stroke;
						// restore the strokeStyle since i had to change it
					};
					//logspecial({face: i1, tri: i2, point0: tri[0], point1: tri[1], point2: tri[2], indexes: tri.indexes}, false, true);
					let angle = tridirection([tri[0], tri[1], tri[2]], _settings.center, _settings.invert);
					let hide = angle[1] < 0;
					// if it's facing away from the camera...
					if(angle[1] === 0) {
					// if it's perpendicular to the camera...
					// - do not draw it if the xy of the angle and the xy to the
					//   vanishing point are more than 90 degrees apart.
						let centerangle = get2dangle(
							viewer.x - (viewer.offset.x + tri._average[0]),
							viewer.y - (viewer.offset.y + tri._average[1]),
							true
						);
						hide = centerangle !== null && compare2dangle(angle[0], centerangle) > Math.PI/2;
						// if it's obtuse, hide it. don't hide it if it's right on top
						// of viewer
					};
					//hide = invertboolean(hide, _settings.invert);
					// if invert is on it should reverse whatever it was
					// - nope, this is redundant. tridirection already factors
					//   in invert.
					let double_sided = etc.includes("double-sided") || !!this.staticsettings.double_sided || !!f.double_sided;
					if(double_sided) {
						hide = false;
					};
					// double-sided draws it regardless of direction
					let tri2d = [];
					for(i3 = 0; i3 < 3; i3++) {
						tri2d[i3] = perspectiveconvert(
							viewer,
							tri[i3][0] + viewer.offset.x,
							tri[i3][1] + viewer.offset.y,
							tri[i3][2] + viewer.offset.z
						).slice(0, 2);
					}
					// convert to screen coordinates.
					// - add viewer offset since _2dPoly.draw isn't a _3d function
					// - also converts it to an array, which removes .indexes and
					//   ._average
					if(
						!etc.includes("wireframe")
						&&
						!hide
					) {
					// draw the fill
						let texture = typeof _settings.texture_name === "string" ? this.texture[ _settings.texture_name ] : this.texture;
						// this.texture can be an imagedata or a container of
						// other imagedatas, so
						if (
							!f[ tri.indexes[0] ].hasOwnProperty("texture")
							||
							!f[ tri.indexes[1] ].hasOwnProperty("texture")
							||
							!f[ tri.indexes[2] ].hasOwnProperty("texture")
						) {
						// and skip texturing if some of the points have no
						// coordinates.
							texture = null;
						};
						let shader = _settings.hasOwnProperty("shader") ? _settings.shader : null;
						let shaderangle = null;
						if(_settings.shader && double_sided && Angle.numbers(angle)[2] < 0) {
						// the shader needs whatever angle is facing the camera.
						// when it's single-sided you don't gotta worry about
						// that since hide will cover that, but if it's
						// double-sided, it might have to be inverted.
							shaderangle = Angle.invert(angle);
						}
						else {
							shaderangle = angle;
						};
						let lightmod = shader && shader.hasOwnProperty("lightmod") ? shader.lightmod : null;
						let colormodtype = null;
						if(!shader) {
						}
						else if(!shader.hasOwnProperty("colormod")) {
							colormodtype = "default";
						}
						else if(shader.colormod.hasOwnProperty("type")) {
							colormodtype = shader.colormod.type;
						}
						else {
							console.log("shader .colormods must have a specified type.");
							colormodtype = "default";
						};
						let defaultrgba = [
							parseInt(ctx.fillStyle.slice(1, 3), 16),
							parseInt(ctx.fillStyle.slice(3, 5), 16),
							parseInt(ctx.fillStyle.slice(5, 7), 16)
						];
						if(ctx.fillStyle.length === 9) {
						// alpha
							defaultrgba[3] = parseInt(ctx.fillStyle.slice(7, 9), 16);
						}
						else {
							defaultrgba[3] = 255;
						};
						if(texture || shader) {
						// run the pixel-by-pixel logic only if there's
						// texturing or pixel-by-pixel lighting.
							let planetemp = Plane.frompoints([tri[0], tri[1], tri[2]]);
							// used in screeninverse
							_2dPoly.execute(tri2d, true, function(x, y) {
								let coor = screeninverse(viewer, x, y, false, planetemp);
								// get the 3d coordinate this pixel represents
								let color = structuredClone(defaultrgba);
								if(texture) {
									color = tricoordinates(tri, coor);
									// convert to triangle coordinates
									color = tricoordinates([
										f[ tri.indexes[0] ].texture,
										f[ tri.indexes[1] ].texture,
										f[ tri.indexes[2] ].texture
									], color, true);
									// convert triangle coordinates to 2d
									// coordinates on the texture image
									color = 4*(texture.width*posmod(color[1], texture.height) + posmod(color[0], texture.width));
									// ImageData is an array of rgba values from the
									// left pixels to right, top to bottom. this is
									// the index to start from.
									color = texture.data.slice(coor, coor + 4);
								};
								if(shader) {
									let light = lightlevel(viewer, coor, angle, color[3]/255);
									// an array of modifiers for r, g, and b
									let i1 = 0;
									for (i1 = 0; i1 < 3; i1++) {
										if(lightmod) {
											light[i1] = applyoperations(light[i1], lightmod, i1);
										};
										if(colormodtype === "default") {
											color[i1] = color[i1]*(1 + light[i1]);
										}
										else if(colormodtype === "alt_palette") {
											//
										};
										color[i1] = Math.max(0, Math.min(Math.floor(color[i1]), 255));
										// apply flooring, minimum and maximum.
									}
								};
								ctx.fillStyle = "rgba(" + color.join(", ") + ")";
								ctx.fillRect(x, y, 1, 1);
							});
						}
						else {
							_2dPoly.draw(ctx, tri2d);
						};
					};
					if((!hide || etc.includes("wireframe")) && strokes.includes(true) && !etc.includes("lineless")) {
					// draw the stroke
					// - unless if this face is hidden
					// - or all strokes are hidden (by the points' .hides or by
					//   them not being an edge of the face)
					// - or it's lineless mode
					// - (invert is irrelevant because that was already applied
					//   to hide.)
						for (i3 = 0; i3 < tri2d.length; i3++) {
							if(strokes[i3]) {
								nonaaline(ctx,
									tri2d[i3][0],
									tri2d[i3][1],
									tri2d[(i3 + 1)%3][0],
									tri2d[(i3 + 1)%3][1],
								weight);
							};
						}
					};
				};// end of triangles loop
			};// end of faces loop
			ctx.fillStyle = _default.fill;
			ctx.strokeStyle = _default.stroke;
			// restore styles
		}
		static allfaces(facesobj, includeinits, array) {
		// returns an array of references to all faces in order, sifting through
		// all the categories and crap
		// - array: this is used in recursion (i dunno if Array.concat would
		//   retain references and i don't wanna risk it) but there's no harm in
		//   using it anyway. put in an array, and it'll add these references to
		//   the end.
		//   - if an array is given, it edits that. if not, it returns a new
		//     one.
		// - includeinits: what it sounds like. it'll add .inits if it sees
		//   them.
		//   - however, it can't check the init of the poly itself, so if you
		//     want that, input that as includeinits and it'll add that to the
		//     array.
			let i1 = 0;
			let i2 = 0;
			let arraygiven = typeof array === "object" && Array.isArray(array);
			if(!arraygiven) {
				array = [];
			}
			if(includeinits && typeof includeinits === "object") {
				array[array.length] = includeinits;
			};
			for (i1 in facesobj) {
				if (facesobj.hasOwnProperty(i1)) {
					if(i1.startsWith("_")) {
					// face group
						if(includeinits && facesobj.hasOwnProperty("init")) {
							array[array.length] = facesobj.init;
						};
						Poly.allfaces(facesobj[i1], false, array);
					}
					else if(i1 !== "init") {
					// face
						array[array.length] = facesobj[i1];
					};
				};
			}
			if(!arraygiven) {
				return array;
			}
		}
		static shrinkwrap(points) {
		// creates a Poly that resembles what _2dPoly.convexed would create.
		// - NOTE unfinished.
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let i4 = 0;
			if(points.length < 4) {
				let poly = new Poly(true);
				poly.points = structuredClone(points);
				poly.faces[0] = {};
				for(i1 = 0; i1 < points.length; i1++) {
					poly.faces[0][i1] = {index: i1};
				}
				return poly;
			}
			let center = [0, 0, 0];
			for(i1 = 0; i1 < points.length; i1++) {
				for(i2 = 0; i2 < 3; i2++) {
					center[i2] += points[i1][i2];
				}
			}
			for(i1 = 0; i1 < 3; i1++) {
				center[i1] /= points.length;
			};
			let distancefrom = (start, end) => Math.hypot(
				end[0] - start[0],
				end[1] - start[1],
				end[2] - start[2]
			);
			function distanceorder(start, highestfirst) {
			// returns an array of points indexes, sorted by distance from the
			// given point.
				let i1 = 0;
				let i2 = 0;
				let order = [];
				for(i1 = 0; i1 < points.length; i1++) {
					order[i1] = {index: i1, dist: distancefrom(start, Math.hypot(
						points[i1][0] - start[0],
						points[i1][1] - start[1],
						points[i1][2] - start[2]
					))};
				}
				order.sort(
					highestfirst
					?
					((a, b) => b.dist - a.dist)
					:
					((a, b) => a.dist - b.dist)
				);
				for(i1 = 0; i1 < order.length; i1++) {
					order[i1] = order[i1].index;
				}
				return order;
			}
			let order = distanceorder(center, true);
			// sort by highest distance first (triple round-robining is super
			// dangerous, i need to maximize the chances that the first faces it
			// tries are on the outside.)
			let tri = [];
			// array of three-index arrays representing triangle faces.
			let unclosed = {};
			// object storing data for edges that are only used by one tri, not
			// two. structure:
			// - [tri indexes, only present for tris that still have unclosed
			//   sides]
			//   - 0, 1, and 2 booleans (true means it's unclosed. side 0 is
			//     from 0 to 1, 1 is 1 to 2, etc)
			function addtri(newtri) {
				let i1 = 0;
				let i2 = 0;
				let _unclosed = {0: true, 1: true, 2: true};
				// it will add this to unclosed, for the new tri.
				let side = (index1, index2) => posmod(index1 + 1, 3) === index2 ? index1 : posmod(index2 + 1, 3) === index1 ? index2 : null;
				for(i1 in unclosed) {
					if(unclosed.hasOwnProperty(i1)) {
					// check for tris that share a side
						let same = [
							[0, tri[i1].indexOf(newtri[0])],
							[1, tri[i1].indexOf(newtri[1])],
							[2, tri[i1].indexOf(newtri[2])]
						];
						for(i2 = 0; i2 < same.length; i2++) {
							if(same[i2][1] === -1) {
								same.splice(i2, 1);
								i2--;
							};
						}
						// same is now an array of [newtri index, tri[i1] index]
						// matches
						if(same.length === 3) {
						// perfectly matches an existing tri, so it's
						// unnecessary. (this will only be caught if that tri
						// was unclosed, but i don't know how this would happen
						// anyway.)
							return;
						}
						else if(same.length === 2) {
							same = [
								side(same[0][0], same[1][0]),
								side(same[0][1], same[1][1])
							];
							// [newtri side index, tri[i1] side index]
							unclosed[i1][ same[1] ] = false;
							_unclosed[ same[0] ] = false;
							if(!unclosed[i1][0] && !unclosed[i1][1] && !unclosed[i1][2]) {
							// the tri isn't unclosed anymore
								delete unclosed[i1];
							};
							if(!_unclosed[0] && !_unclosed[1] && !_unclosed[2]) {
							// there's no more unclosed tris to find
								tri[tri.length] = structuredClone(newtri);
								return;
							};
						}
					}
				}
				tri[tri.length] = structuredClone(newtri);
				unclosed[ tri.length - 1 ] = structuredClone(_unclosed);
				// add to tri and unclosed
			}
			for(i1 = 0; i1 < order.length && !tri.length; i1++) {
			// find one tri on the outside.
				let _order = distanceorder(points[ order[i1] ]);
				// sort by closest first (otherwise it'll take way too long on
				// sphere-like shapes.)
				let order_slice = order.slice(0, i1);
				for(i2 = 0; i2 < _order.length && !tri.length; i2++) {
					if(!order_slice.includes(_order[i2])) {
					// if it went through this point in the i1 loop, that means
					// it tried every single combination with this one.
						for(i3 = i2 + 1; i3 < _order.length && !tri.length; i3++) {
							if(!order_slice.includes(_order[i3])) {
								let newtri = [
									order[i1],
									_order[i2],
									_order[i3]
								];
								let plane = Plane.frompoints([
									points[ newtri[0] ],
									points[ newtri[1] ],
									points[ newtri[2] ]
								]);
								let sign = null;
								for(i4 = 0; i4 < points.length; i4++) {
									let _sign = Math.sign(roundspecial(plane.pointtotal(points[i4])));
									if(_sign && !sign) {
									// set the first non-zero sign as the one to
									// expect
										sign = _sign;
									};
									if(_sign !== sign) {
										newtri = null;
										i4 += points.length;
									}
								};
								if(newtri) {
								// all other points are on the same side of this
								// tri, therefore it's on the outside.
									addtri(newtri);
								};
							}
						}
					}
				}
			}
			// - avoid invalid Plane.frompoints (all of them being on the same
			//   line)
			// - iterate through unclosed, find an outside tri for every
			//   unclosed side and quit when unclosed is empty.
			//   - do it how i found the first tri?
			//   - or do it how _2dPoly.convexed does? (get the plane of the
			//     tri, picture it rotating around the unclosed side, find the
			//     point that'd collide with it first.)
			//     - this is probably better, but how do i rotate a plane, and
			//       in which direction...
			// - create Poly from it and return that.
		}
		// TODO
		// - finish tricoordinates
		// - Poly.draw
		//   - calculate the outline weight to use based on the stroke weight and
		//     whether a stroke will be drawn for this leg
		//   - make a strokeweight property
		//   - write alternate shader.colormod modes
		//     - alt_palette
		//     - others
		// - method rewrites
		//   - build
		//     - write texturing logic
		//     - fix problems associated with disc/square and cones, rewrite
		//       construction logic accordingly
		//     - test and fix sphere
		//   - join
		//   - subdivide
		//     - make sure it creates a face category for each divided face.
		//       (unless the factor is 1 and it started as a triangle.)
		//     - make it possible to use on a single face
		//   - randomize
	}
	function _3dlineexecute(viewer, context, x1, y1, z1, x2, y2, z2, weight, increment, code, codeis3d) {
	/*
	function _2d_3le_code(context, x, y, weight)
	function _3d_3le_code(viewer, context, x, y, z, weight)
	*/
	// executes a function at regularly spaced positions along a line in 3d
	// space.
	// - code is a function with the parameters context, x, y, weight.
	//   - or, if codeis3d is true, viewer, context, x, y, z, weight.
	//   - "weight" is misleading. what it means is pretty much "a number
	//     that's bigger the closer it is to the camera, can be adjusted in
	//     the given function, and may change over the course of the line."
	//     - it doesn't change with z in a perfect way though. it checks
	//       what the perspectiveconvert-ed x position of x + weight/2, y, z
	//       minus the perspectiveconvert-ed x position x - weight/2, y, z
	//       would be.
	//     - that's equivalent to checking the width of a flat disc that's
	//       facing the camera, rather than the radius of a sphere. TODO.
	// - just like _3dline, weight can be an array of two numbers, representing
	//   the value at the beginning and end
	// - codeis3d: boolean. if this is used, the code will be expected to have a
	//   viewer parameter before all the others.
	// - increment: what the 3d distance between executions should be. by
	//   default it is 1.
	// - remember, don't be afraid to write a small function that does whatever
	//   you want it to. the same is true for every function that runs code, in
	//   my opinion.
	// - TODO. this might not work yet.
	// - TODO add a parameter that makes it break lines up to properly show
	//   perspective?
	//   - like if you filmed a cube with a fisheye lens, the edges are straight
	//     but they'd look curved.
	//   - this just connects two 3d-to-screen coordinates with one line, so it
	//     doesn't show that.
	//   - i guess make a Line with the two points, and find intersections with
	//     xy, xz, and yz planes
	//     - like check where it meets the "y === 0" plane, then the "y === 2"
	//       plane, and so on
		if(!codeis3d) {
			if(viewer.offset.x) {
				x1 += viewer.offset.x;
				x2 += viewer.offset.x;
			};
			if(viewer.offset.y) {
				y1 += viewer.offset.y;
				y2 += viewer.offset.y;
			};
			if(viewer.offset.z) {
				z1 += viewer.offset.z;
				z2 += viewer.offset.z;
			};
		};
		// TODO apply cutoff
		let angle = Angle.get(x2 - x1, y2 - y1, z2 - z1);
		let xinc = Angle.numbers(angle);
		let yinc = xinc[1];
		let zinc = xinc[2];
		xinc = xinc[0];
		let fulldist = Math.hypot(x2 - x1, y2 - y1, z2 - z1);
		// - code is a function with the parameters context, x, y, weight.
		//   - or, if codeis3d is true, viewer, context, x, y, z, weight.
		let distcovered = 0;
		let weighttemp = 0;
		let x = x1;
		let y = y1;
		let z = z1;
		if(Array.isArray(weight) && weight.length >= 2) {
		}
		else if(typeof weight === "number") {
			weighttemp = "x";
		}
		else {
			weighttemp = "x";
			weight = 0;
		};
		// if there's no array, always use weight proper
		if(!x && x !== 0) {
			return;
		};
		if(!y && y !== 0) {
			return;
		};
		if(!z && z !== 0) {
			return;
		};
		for(; distcovered <= fulldist ;) {
			if(Array.isArray(weight) && weight.length >= 2) {
				weighttemp = weight[0] + (weight[1] - weight[0])*distcovered/fulldist;
			}
			else {
				weighttemp = Math.abs(perspectiveconvert(viewer, x + weight/2, y, z)[0] - perspectiveconvert(viewer, x - weight/2, y, z)[0]);
			};
			if(codeis3d) {
				code(viewer, context, x, y, z, weighttemp);
			}
			else {
				code(context, perspectiveconvert(viewer, x, y, z)[0], perspectiveconvert(viewer, x, y, z)[1], weighttemp);
			};
			x += xinc;
			y += yinc;
			z += zinc;
			distcovered += increment;
		}
	}
	CanvasRenderingContext2D.prototype.lineexecute = function(x1, y1, x2, y2, weight, code, omitstart) {
	/*
	ctx.lineexecute(x1, y1, x2, y2, weight, function(ctx, x, y, weight) {
		//
	}, omitstart);
	*/
	// executes a function at every pixel in the line between the two points.
	// - code is a function with the parameters context, x, y, weight.
	//   - "weight" is misleading. what it means is pretty much "a number
	//     that's bigger the closer it is to the camera, can be adjusted in
	//     the given function, and may change over the course of the line."
	// - weight can be an array of two numbers, representing the value at the
	//   beginning and end
	// - omitstart: boolean. if true, the code will not execute for the starting
	//   pixel. (this is a fairly specific need, but it's useful for chaining
	//   multiple line executes together seamlessly.)
	//   - note that it will not omit it if the end and beginning happen to be
	//     at the same place.
	// - TODO: make an increment parameter that makes it execute at even
	//   positions instead of pixels (that way there isn't a difference in
	//   density between cardinal and diagonal)
	//   - make sure the coordinates are still floored
		let i1 = 0;
		omitstart = !!omitstart;
		if(weight) {
			x1 = .5*Math.round(x1/.5);
			y1 = .5*Math.round(y1/.5);
			x2 = .5*Math.round(x2/.5);
			y2 = .5*Math.round(y2/.5);
			if(Array.isArray(weight)) {
			// makes sure they're centered on the center or top left corner of
			// the pixel coordinates given
				if((.5*Math.round(weight[0]/.5))%2===1) {
					x1 += .5;
					y1 += .5;
				};
				if((.5*Math.round(weight[1]/.5))%2===1) {
					x2 += .5;
					y2 += .5;
				};
			}
			else if(weight%2===1) {
				x1 += .5;
				y1 += .5;
				x2 += .5;
				y2 += .5;
			};
		}
		else {
			x1 = Math.round(x1);
			y1 = Math.round(y1);
			x2 = Math.round(x2);
			y2 = Math.round(y2);
			weight = 1;
		};
		if(!Number.isInteger(2*x1) || !Number.isInteger(2*y1) || !Number.isInteger(2*x2) || !Number.isInteger(2*y2)) {
			console.log("invalid coordinates. (" + [x1, y1, x2, y2].join() + ")");
			return;
		};
		let getwt = (value) => (Array.isArray(weight) ? Math.round(weight[0] + value*(weight[1] - weight[0])) : weight);
		const start = [x1, y1];
		const end = [x2, y2];
		let coor = [(end[0] - start[0]), (end[1] - start[1])];
		const axis1 = Number(Math.abs(coor[1]) > Math.abs(coor[0]));
		// the wider axis is the one it iterates across.
		const axis2 = (axis1 + 1)%2;
		const sign1 = Math.sign(coor[axis1]);
		const diff1 = Math.abs(coor[axis1]);
		const sign2 = Math.sign(coor[axis2]);
		const diff2 = Math.abs(coor[axis2]);
		coor = [start[0], start[1]];
		// coordinate of the pixel to run code on. loops change it, iteration by
		// iteration
		if(x1 === x2 && y1 === y2) {
			code(this, x1, y1, (
				weight
				?
				(Array.isArray(weight) ? Math.max(...weight) : weight)
				:
				1
			));
		}
		else if(x1 === x2 || y1 === y2) {
		// unsloped line, or both coordinates are the same. to avoid divide by
		// zero errors.
			for(i1 = Number(omitstart); i1 <= diff1; i1++) {
				coor[axis1] = start[axis1] + sign1*i1;
				code(this, ...coor, getwt(i1/diff1));
			}
		}
		else {
			let line = get2dline(x1, y1, x2, y2, true);
			// it fills the first pixel whose line[0]*x + line[1]*y + offset is
			// between 0 and 1.
			function getcoor(knowncoor) {
			// axis1 is the known axis, the one the coordinate comes from. axis2
			// is the unknown axis.
				// 0 = x*line.x + ?*line.y + offset
				// 0 = knowncoor*line[axis1] + ?*line[axis2] + line[2]
				// ? = -(knowncoor*line[axis1] + line[2])/line[axis2]
				let num = -((knowncoor + .5)*line[axis1] + line[2])/line[axis2];
				//let num = (.5 - (knowncoor + .5)*line[axis1] - line[2])/line[axis2];
				//return num;
				//return Math.round(num - .5);
				return Math.floor(num);
				//return Math[ ["floor", "round", "ceil"][-sign2 + 1] ](num - .5);
			}
			if(line[0] === 0 || line[1] === 0) {
				console.log("this shouldn't happen");
				return;
			}
			if(sign2 === 0) {
				console.log("this shouldn't happen");
				/*
				console.log("Math.sign(end[axis2] - start[axis2])");
				console.log("Math.sign(end[" + axis2 + "] - start[" + axis2 + "])");
				console.log("Math.sign(" + end[axis2] + " - " + start[axis2] + ")");
				console.log("Math.sign(" + (end[axis2] - start[axis2]) + ")");
				//*/
				//console.log("xy"[axis1] + "xy"[axis2] + ": " + [x1, x2, y1, y2].join());
				return;
			}
			for (i1 = Number(omitstart); i1 <= diff1; i1++) {
				coor[axis1] = start[axis1] + i1*sign1;
				coor[axis2] = getcoor(coor[axis1]);
				code(this, ...coor, getwt(i1/diff1));
			}
		};
	}
	function nonaaline(context, x1, y1, x2, y2, weight) {
	// draws a line that isn't antialiased.
	// - uses strokeStyle
	// - weight can be a single value or an array with the starting weight and
	//   ending weight
	//   - NOTE it does not just pass the array onto circledraw, so if you're
	//     trying to make a line with an elliptical particle, it won't work.
	//     it'll do this instead.
	// - TODO add a gradient line thing?
	//   - make it possible to specify color, and if it's an array, same deal as
	//     weight
	//   - it draws a dot in the first color, then a dot in the second color
	//     over it, with the opacity depending on where in the line it is
	// - TODO keep it from making misshapen ends
	//   - probably caused by an x coordinate that's closer to a .5 number, and
	//     a y coordinate that's closer to a .0 number. see circledraw for
	//     details.
		let styletemp = context.fillStyle;
		context.fillStyle = context.strokeStyle;
		function naal_circ(context, x, y, weight) {
			circledraw(context, Math.floor(x) + .5, Math.floor(y) + .5, weight/2, true);
		}
		context.lineexecute(x1, y1, x2, y2, weight, naal_circ);
		context.fillStyle = styletemp;
	}
	function linespecial(code, x1, y1, x2, y2, center) {
	/*
	linespecial(ctx, x1, y1, x2, y2, center)
	linespecial(function(x, y, progress) {
		//
	}, x1, y1, x2, y2, center)
	//*/
	// draws a line or runs a function on a line. it's like nonaaline, except it
	// doesn't suck as bad. it tries to make it as symmetrical as possible.
	// - code: function you want to run for each coordinate. the only arguments
	//   should be x, y, and progress. (ie if the point is at the beginning or
	//   end of the line. a 0 to 1 number.)
	//   - if this is a canvas context, instead it'll draw a line one pixel
	//     wide, using the strokeStyle.
	//   - if this is null, it'll just return the points array.
	// - center: a coordinate array. if it has to choose between two pixels,
	//   it'll choose the one further from this.
		let i1 = 0;
		let i2 = 0;
		center ??= [0, 0];
		center[0] = Math.floor(center[0]);
		center[1] = Math.floor(center[1]);
		const SER = SL.start_end_rounding(x1, y1, x2, y2, center);
		x1 = SER[0];
		y1 = SER[1];
		x2 = SER[2];
		y2 = SER[3];
		let points = [];
		// list of coordinates to iterate over in order to draw a line or whatever you're doing
		if(x1 === x2 && y1 === y2) {
			points[0] = [x1, y1];
		}
		else if(x1 === x2) {
			const sign = Math.sign(y2 - y1);
			for(i1 = y1; Math.sign(y2 - i1) === sign || i1 === y2; i1 += sign) {
				points[points.length] = [x1, i1];
			}
		}
		else if(y1 === y2) {
			const sign = Math.sign(x2 - x1);
			for(i1 = x1; Math.sign(x2 - i1) === sign || i1 === x2; i1 += sign) {
				points[points.length] = [i1, y1];
			}
		}
		else {
			let temp = [
				Math.abs(x1 - x2) + 1,
				Math.abs(y1 - y2) + 1
			];
			const axisA = Number(temp[1] > temp[0]);
			// longer axis (0 means x, 1 means y)
			const axisB = Number(!axisA);
			// shorter axis
			const dim = {
				0: temp[0],
				1: temp[1],
				get a() {
					return this[axisA];
				},
				get b() {
					return this[axisB];
				},
			};
			let linenum = [];
			// an array of segment lengths to create the line. (for example, an
			// 8 w 3 y line would be [3, 2, 3]) used to create the points.
			if(dim.a%dim.b === 0) {
			// avoids divide by zero errors, saves time
				let segment = Math.round(dim.a/dim.b);
				for(i1 = 0; i1 < dim.b; i1++) {
					linenum[i1] = segment;
				};
			}
			else {
				function bleah(dimA, dimB) {
				// tries to make linenum arrays like [4, 3, 4, 3, 4] or [2, 2,
				// 1, 2, 2].
					let i1 = 0;
					let i2 = 0;
					if(
						dimA <= 0
						||
						!Number.isInteger(dimA)
						||
						dimB <= 0
						||
						!Number.isInteger(dimB)
					) {
						console.log("invalid input.");
						return;
					};
					if(dimB > dimA) {
						const temp = numA;
						numA = numB;
						numB = temp;
					}
					let num1 = dimA%dimB;
					let num2 = dimB - num1;
					let value1 = Math.floor(dimA/dimB) + 1;
					let value2 = value1 - 1;
					if(num1 === num2) {
						let array = [];
						for(i1 = 0; i1 < num1; i1++) {
							array[array.length] = value1;
							array[array.length] = value2;
						};
						return array;
					}
					else if(num2 > num1) {
						let temp = num1;
						num1 = num2;
						num2 = temp;
						temp = value1;
						value1 = value2;
						value2 = temp;
					};
					// there's two lengths, 1 and 2. 1 is whichever there will
					// be more of. num1 and value1 are how many there will be of
					// length 1 and how long it is, num2 and value2 are the same
					// for length 2.
					let quotient = Math.floor(num1/(num2 + 1));
					// how many num1s there should be between num2s.
					let remainder = num1%(num2 + 1);
					// how many times there should be one more num1.
					let array = [];
					for(i1 = 0; i1 <= num2; i1++) {
						for(i2 = 0; i2 < quotient + !!remainder; i2++) {
							array[array.length] = value1;
						}
						if(remainder) {
							remainder--;
						};
						if(i1 !== num2) {
							array[array.length] = value2;
						}
					}
					return array;
				};
				const gcf = mathgcf([dim.a, dim.b], true);
				if(gcf !== 1) {
					let temp = bleah(dim.a/gcf, dim.b/gcf);
					for(i1 = 0; i1 < gcf; i1++) {
						linenum = linenum.concat(temp);
					};
				}
				else {
					linenum = bleah(dim.a, dim.b);
				}
			}
			//console.log("(" + dim[0] + ", " + dim[1] + ") linenum: " + linenum);
			temp = 0;
			for(i1 = 0; i1 < linenum.length; i1++) {
				temp += linenum[i1];
			}
			if(temp !== dim.a) {
				console.log("this shouldn't happen");
			};
			// linenum is complete, time to make the points.
			let coor = [x1, y1];
			let sign = {
				0: Math.sign(x2 - x1),
				1: Math.sign(y2 - y1),
				get a() {
					return this[axisA];
				},
				get b() {
					return this[axisB];
				},
			};
			for(i1 = 0; i1 < linenum.length; i1++) {
				for(i2 = 0; i2 < linenum[i1]; i2++) {
					points[points.length] = structuredClone(coor);
					coor[axisA] += sign.a;
				}
				coor[axisB] += sign.b;
			}
			coor[axisA] -= sign.a;
			coor[axisB] -= sign.b;
			const diff = [
				Math.abs(coor[0] - x2),
				Math.abs(coor[1] - y2)
			];
			if(diff[0] || diff[1]) {
				console.log("difference: " + Math.hypot(...diff));
			};
			function inverse(x, y) {
				const midpoint = [
					(x1 + x2)/2,
					(y1 + y2)/2
				];
				return [
					Math.round(-1*(x - midpoint[0]) + midpoint[0]),
					Math.round(-1*(y - midpoint[1]) + midpoint[1])
				];
			};
			let _points = [];
			for(i1 = points.length - 1; i1 >= 0; i1--) {
				_points[_points.length] = inverse(...points[i1]);
			};
			// this should be the same thing but flipped 180.
			for(i1 = 0; i1 < points.length; i1++) {
			// compare each point's coordinate b to the inverse version's
			// coordinate b, and redefine the coordinate b accordingly.
			// - if the midpoint is an integer, use that.
			// - otherwise, choose whichever is further from the center.
			// - and if both distances are equal, choose whichever is lower.
				if(points[i1][axisA] !== _points[i1][axisA]) {
					console.log("this shouldn't happen: " + (points[i1][axisA] - _points[i1][axisA]));
				};
				let b = [
					points[i1][axisB],
					_points[i1][axisB]
				];
				let diff = Math.abs(b[0] - b[1]);
				if(diff === 0) {
				}
				else if(diff%2 === 0) {
					//console.log("benign error. (" + dim.a + " x " + dim.b + ")");
					points[i1][axisB] = Math.round((b[0] + b[1])/2);
				}
				else {
					if(diff >= 2) {
						//console.log("benign error. (" + dim.a + " x " + dim.b + ")");
						b = [
							Math.floor((b[0] + b[1])/2),
							Math.ceil((b[0] + b[1])/2)
						];
					};
					let dists = [
						Math.abs(center[axisB] - b[0]),
						Math.abs(center[axisB] - b[1])
					];
					points[i1][axisB] = (
						dists[0] > dists[1]
						?
						b[0]
						:
						(
							dists[1] > dists[0]
							?
							b[1]
							:
							Math.min(...b)
						)
					);
				}
			};
		}
		// points array is done.
		if(code instanceof CanvasRenderingContext2D) {
			let styletemp = code.fillStyle;
			code.fillStyle = code.strokeStyle;
			for(i1 = 0; i1 < points.length; i1++) {
				code.fillRect(...points[i1], 1, 1);
			}
			code.fillStyle = styletemp;
		}
		else if(code === null) {
			return points;
		}
		else {
			for(i1 = 0; i1 < points.length; i1++) {
				code(...points[i1], i1/(points.length - 1));
			}
		}
	};
	let SL = {
	// "special line". pseudoclass for an endless lines that use linespecial's
	// algorithm.
	// =
	// structure:
	// - x, y, w, h: the boundaries of the linespecial. w and h are always
	//   positive, and x and y are always the up-left corner.
	// - values: numbers used to check where a point is relative to the line.
	//   - indexes are axisA - line[axisA] (longer dimension)
	//   - values are axisB - line[axisB] (shorter dimension)
	//   - subtract line x/y from a point, remainder by w/h
	//   - if the point's axisB matches values[axisA], it's on the line.
	// - points are checked through this process:
	//   - subtract line.x and line.y
	//   - create a grid of sorts with the w and h
	//     - divide by them to see if it's even on a sector the line passes
	//       through
	//     - if it is, posmod by w and h and compare point[axisB] to
	//       line.values[ point[axisA] ].
		start_end_rounding: function(x1, y1, x2, y2, center) {
		// used in linespecial. it's here to avoid DRY.
			x1 = Math.round(x1*2)/2;
			y1 = Math.round(y1*2)/2;
			x2 = Math.round(x2*2)/2;
			y2 = Math.round(y2*2)/2;
			// round to the nearest .5
			for(i1 = 0; i1 < 4; i1++) {
			// for .5s, round to whatever integer is closer to the other end of the
			// line. (this way, where the pixel is will depend on the direction of
			// the line, but it'll always use the corner you indicated.)
			// - or if they line up, move further from the center.
			//   - this code used to be only four lines before i accounted for that.
				let num = [x1, y1, x2, y2][i1];
				if(!Number.isInteger(num)) {
				// putting this in a conditional saves just a little bit of trouble.
					let temp = Math.sign([x2, y2, x1, y1][i1] - num);
					temp = temp ? temp : Math.sign(num - center[i1%2]);
					// sign that brings it closer to the other end, or further from the
					// center.
					num = Math[temp === 1 ? "ceil" : "floor"](num);
					if(i1 === 0) {
						x1 = num;
					}
					else if(i1 === 1) {
						y1 = num;
					}
					else if(i1 === 2) {
						x2 = num;
					}
					else if(i1 === 3) {
						y2 = num;
					};
				}
			}
			return [x1, y1, x2, y2];
		},
		new: function(x1, y1, x2, y2, center) {
			let i1 = 0;
			let line = {};
			let array = [];
			linespecial(function(x, y, progress) { array[array.length] = [x, y] }, x1, y1, x2, y2, center);
			let temp = [
				array[0],
				array[array.length - 1]
			];
			line.x = Math.min(temp[0][0], temp[1][0]);
			line.y = Math.min(temp[0][1], temp[1][1]);
			line.w = Math.max(temp[0][0], temp[1][0]) - line.x;
			line.h = Math.max(temp[0][1], temp[1][1]) - line.y;
			// guarantee positive dimensions
			const axisA = Number(line.h > line.w);
			const axisB = (axisA + 1)%2;
			const dimA = line["wh"[axisA]];
			const coorA = line["xy"[axisA]];
			const coorB = line["xy"[axisB]];
			line.values = [];
			for(i1 = 0; i1 < dimA; i1++) {
				line.values[i1] = null;
			}
			for(i1 = 0; i1 < array.length; i1++) {
				let temp = array[i1][axisA] - coorA;
				line.values[temp] = array[i1][axisB] - coorB;
			}
			// subtract coorA/B so it starts at zero
			return line;
		},
		A_to_B: function(_this, coorA) {
		// input an coorA, and you get a value, which is axisB. coorB minus this
		// is the sign.
			const axisA = Number(_this.h > _this.w);
			const axisB = (axisA + 1)%2;
			const dimA = _this["wh"[axisA]];
			coorA -= _this["xy"[axisA]];
			// relative to x/y
			let value = _this["xy"[axisB]] + _this.values[ posmod(coorA, dimA) ];
			let temp = _this.values[ _this.values.length - 1 ] - _this.values[0];
			// dimB, except made the right positivity/negativity
			temp *= Math.floor(coorA/dimA);
			// where it is on the "grid", how many dimBs to add
			value += temp;
			return value;
		},
		check: function(_this, ref_x, ref_y, x, y, w, h) {
		// returns:
		// - 0 if x/y is on the line
		// - 1 if x/y is on the same side as ref_x/ref_y
		// - -1 if it's on the opposite
		// - returns null if ref_x/ref_y is on the line or the line's w and h are 0.
		// - w, h: optional. this will make it modify an entire rectangle of
		//   values and return that.
		//   - specifically an array of 0/1/-1s. w is how long one row is. x and y
		//     are the coordinates the top-left corner represents.
			let i1 = 0;
			let i2 = 0;
			const no_data = !w || !h;
			w ??= 1;
			h ??= 1;
			let data = [];
			for(i1 = 0; i1 < w*h; i1++) {
				data[i1] = null;
			};
			const _x = x;
			const _y = y;
			// top left corner (so that x and y's values can change)
			let ref_side = null;
			if(!_this.w || !_this.h) {
				// single point, or vertical/horizontal line
				if(_this.w || _this.h) {
					ref_side = Math.sign(
						_this.h
						?
						ref_x - _this.x
						:
						ref_y - _this.y
					);
				}
				if((!_this.w && !_this.h) || ref_side === 0) {
					// single point, or ref_x/ref_y is on the line
					return null;
				};
				for(i1 = 0; i1 < data.length; i1++) {
					x = _x + i1%w;
					y = _y + Math.floor(i1/w);
					data[i1] = ref_side*Math.sign(
						_this.h
						?
						x - _this.x
						// vertical
						:
						y - _this.y
						// horizontal
					);
				}
			}
			else {
				const axisA = Number(_this.h > _this.w);
				const axisB = (axisA + 1)%2;
				const rectA = axisA ? h : w;
				// longer axis, (or x) shorter axis
				ref_side = Math.sign((axisB ? ref_y : ref_x) - SL.A_to_B(_this, axisA ? ref_y : ref_x));
				if(ref_side === 0) {
					return null;
				}
				let values = [];
				for(i1 = 0; i1 < rectA; i1++) {
					values[i1] = SL.A_to_B(_this, (axisA ? _y : _x) + i1);
					// the conditional thing adds the rectangle's x/y
				};
				for(i1 = 0; i1 < data.length; i1++) {
					let coor = [
						i1%w,
						Math.floor(i1/w)
					];
					data[i1] = ref_side*Math.sign([_x, _y][axisB] + coor[axisB] - values[ coor[axisA] ]);
				}
			}
			return (
				no_data
				?
				data[0]
				:
				data
			);
		},
	};
	function circlepoints(x, y, r, fraction) {
	// runs the coordinates of the point you specify, measured in entire
	// circles and starting clockwise from the top.
	// - so if fraction is 0, it'll return the point one radius directly above
	//   the circle's center.
	// - if that format sounds dumb it probably is, but it's because this is
	//   going to be used the most for placing several objects in a circle. for
	//   example, drawing a star.
		return [x + r*Math.cos(2*Math.PI*-(fraction-.25)), y - r*Math.sin(2*Math.PI*-(fraction-.25))];
	}
	function limitlessrand(chance, modifier, multiply, initialvalue) {
	// moved to reusables
	// =
	// - if multiply is true, it'll multiply the initial value by modifier. if
	//   not, it'll add modifier.
	// - if modifier is an array of two numbers, it'll pick a random number
	//   between them. if the third item of the array is "int", it'll only pick
	//   integers.
		let i1 = 0;
		let i2 = 0;
		let lr_return = typeof initialvalue === "number" && !isNaN(initialvalue) ? initialvalue : (multiply ? 1 : 0);
		modifier = typeof modifier === "number" && !isNaN(modifier) ? modifier : (multiply ? 2 : 1);
		let lr_mod = 0;
		for (i1 = Math.random(); i1 < chance; i1 = Math.random()) {
			if(Array.isArray(modifier) && modifier.length===2) {
				lr_mod = modifier[0] + Math.random()*(modifier[1] - modifier[0]);
			}
			else if(Array.isArray(modifier) && modifier.length===3 && modifier[2]==="int") {
				lr_mod = modifier[0] + Math.floor(Math.random()*(1 + modifier[1] - modifier[0]));
			}
			else if((!isNaN(Number(modifier)) && Number(modifier) !== 0) || modifier === 0) {
			// if it's a valid number
				lr_mod = modifier;
			}
			else {
				console.log("invalid modifier.");
				return;
			};
			if(multiply) {
				lr_return *= lr_mod;
			}
			else {
				lr_return += lr_mod;
			};
		}
		return lr_return;
	}
	function get3rddist(d1, d2, dtotal) {
	// moved to reusables
		//d1**2 + d2**2 + d3**2 = dtotal**2
		if(dtotal**2 - (d1**2 + d2**2) < 0) {
			console.log("invalid get3rddist operation: d1 (" + d1 + ") and d2 (" + d2 + ") are bigger than what dtotal (" + dtotal + ") can allow for.")
			return 0;
		}
		else {
			return Math.sqrt(dtotal**2 - (d1**2 + d2**2));
		};
	}
	function revolve(angle, points, center, format) {
	// returns a new version of the points where they are revolved by the angle
	// specified, around the center specified.
	// - you can use an array of points, or just one. it will return it in the
	//   same format.
	// - you can use these angle formats:
	//   - 3d (two numbers)
	//     - xy/z
	//     - xz/y
	//   - 2d
	//     - xy
	//     - xz
	//     - yz
	// - i modified this so that you can use objects.
	//   - if points is an object, it'll use the integer properties to make an
	//     array.
	//   - if the points are objects, it'll look for .x, .y, and .z. however, it
	//     will return an array instead of keeping it as is.
	// - if you use a 3d angle for the format, it'll use the center and that
	//   angle to make a Line that points will be revolved around. this is
	//   called "roll". (use a 2d angle for the angle parameter.)
		let i1 = 0;
		if(!center || !(Array.isArray(center) && center.length >= 3)) {
			center = [0, 0, 0];
		};
		let dist = 0;
		let r_points = [];
		// should be a separate, structured clone. since arrays are objects,
		// modifying the points array directly would modify whatever array was
		// used as points input, and this is supposed to just return points.
		let one_point = typeof points[0] === "number" && typeof points[1] === "number" && typeof points[2] === "number";
		let cos = (angle) => [1, 0, -1, 0][angle/(Math.PI/2)] ?? Math.cos(angle);
		let sin = (angle) => [0, 1, 0, -1][angle/(Math.PI/2)] ?? Math.sin(angle);
		if(one_point) {
		// if there's only one point, make it part of an array so the for loop
		// will accept it
			r_points[0] = structuredClone(points);
		}
		else if(typeof points !== "object") {
			console.log("invalid input.");
			return;
		}
		else if(!Array.isArray(points)) {
			r_points = structuredClone(objecttoarray(points));
		}
		else {
			r_points = structuredClone(points);
		};
		let angletype = Array.isArray(angle) && angle.length >= 2 && typeof angle[0] === "number" && typeof angle[1] === "number";
		//angletype = angletype || angle instanceof Angle;
		if(angletype || isrevolutions(angle)) {
			angletype = "3d";
		}
		else if(typeof angle === "number") {
			angletype = "2d";
		}
		else {
			angletype = null;
			console.log("invalid angle: " + angle);
		};
		let formattype = null;
		if(["xy", "xz", "yz"].includes(format)) {
			formattype = "2d";
		}
		else if(["neo", "old", "xz/y"].includes(format)) {
			formattype = "3d";
		}
		else if(!format) {
			formattype = "3d";
			format = "neo";
		}
		else if(Array.isArray(format) && format.length >= 2 && typeof format[0] === "number" && typeof format[1] === "number") {
			formattype = "roll";
		}
		else {
			console.log("invalid angle format: " + format);
			format = "neo";
			formattype = "3d";
		};
		if((angletype === "3d") !== (formattype === "3d")) {
			console.log("you used a " + angletype + " angle with a " + formattype + " format.");
		};
		// format is now known, it's xy/z if 3d and xy, xz, or yz if 2d
		let axis1 = 0;
		let axis2 = 0;
		if(["xy", "xz", "yz"].includes(format)) {
			axis1 = "xyz".indexOf(format.charAt(0));
			//axis2 = (axis1 + 1)%3;
			axis2 = "xyz".indexOf(format.charAt(1));
			// easier to work with, this way
		};
		let coortemp = [];
		let angletemp = 0;
		let matrix = null;
		// used in neo and roll
		let oldmatrix = null;
		// used only in roll
		if(format === "neo") {
			matrix = [
				[1, 0, 0],
				[0, 1, 0],
				[0, 0, 1]
			];
			if(isrevolutions(angle)) {
			// revolutions object
				let format = "";
				for (i1 in angle) {
					if (angle.hasOwnProperty(i1)) {
						format = (i1.includes("_") ? i1.slice(0, i1.indexOf("_")) : i1);
						matrix = revolve(angle[i1], matrix, false, format);
					}
				}
			}
			else {
				//let lr = getlinerevolve(angle);
				//matrix = revolve(lr.magnitude, matrix, [lr.axis.x, lr.axis.y, lr.axis.z], lr.axis.angle);
				//logspecial(matrix, "before", true);
				//logspecial({xy_: lr.axis.angle[0]*180/Math.PI, _z: lr.axis.angle[1]*180/Math.PI, magnitude: lr.magnitude*180/Math.PI,}, "lr", true);
				//matrix = lr.axis.linerevolve(lr.magnitude, matrix);
				//logspecial(matrix, "after", true);
				let glr = GLR.new(angle);
				matrix = revolve(glr.magnitude, matrix, null, GLR.axis(glr));
			};
			let hypot = [];
			for (i1 = 0; i1 < 3; i1++) {
				hypot[i1] = Math.hypot(
					matrix[i1][0] - matrix[(i1 + 1)%3][0],
					matrix[i1][1] - matrix[(i1 + 1)%3][1],
					matrix[i1][2] - matrix[(i1 + 1)%3][2]
				);
				if(Math.abs(Math.SQRT2 - hypot[i1]) > .00001) {
					console.log("bad angle: " + [angle[0]*180/Math.PI, angle[1]*180/Math.PI]);
					i1 += 3;
				};
			};
			matrix = {
				x: new Line(0, 0, 0, Angle.get(...matrix[0])),
				y: new Line(0, 0, 0, Angle.get(...matrix[1])),
				z: new Line(0, 0, 0, Angle.get(...matrix[2])),
			};
			// convert these points into Lines.
		}
		else if(formattype === "roll") {
			if(typeof format[2] === "number") {
				angle = posmod(angle + format[2], 2*Math.PI);
			};
			oldmatrix = [
				structuredClone([format[0], format[1], 0]),
				rolldirection([format[0], format[1], 0]),
				rolldirection([format[0], format[1], Math.PI/2])
			];
			// if you make these angles into Lines, they should all be
			// perpendicular to each other.
			matrix = [
				structuredClone([format[0], format[1], 0]),
				rolldirection([format[0], format[1], angle]),
				rolldirection([format[0], format[1], posmod(angle + Math.PI/2, 2*Math.PI)])
			];
			// same thing, except they're rotated by whatever 2d angle was
			// specified
			/*
			logspecial([
				format[0]*180/Math.PI,
				format[1]*180/Math.PI,
				angle*180/Math.PI
			], "angle", true);
			logspecial([
				Angle.numbers(oldmatrix[0]),
				Angle.numbers(oldmatrix[1]),
				Angle.numbers(oldmatrix[2])
			], "oldmatrix", true);
			logspecial([
				Angle.numbers(matrix[0]),
				Angle.numbers(matrix[1]),
				Angle.numbers(matrix[2])
			], "matrix", true);
			//*/
			let compare = [];
			for (i1 = 0; i1 < 3; i1++) {
				compare[0] = Angle.compare(oldmatrix[i1], oldmatrix[(i1 + 1)%3]);
				compare[1] = Angle.compare(matrix[i1], matrix[(i1 + 1)%3]);
				if(Math.abs(compare[0] - Math.PI/2) > .00001 || Math.abs(compare[1] - Math.PI/2) > .00001) {
					console.log("bad angle: " + [format[0]*180/Math.PI, format[1]*180/Math.PI, angle*180/Math.PI]);
					i1 += 3;
				};
			}
			for (i1 = 0; i1 < 3; i1++) {
				oldmatrix[i1] = new Line(0, 0, 0, oldmatrix[i1]);
				matrix[i1] = new Line(0, 0, 0, matrix[i1]);
			}
			// this works just like the other revolve, checking where each point
			// is on the old axes and translating that to the new axes
			// -
			// the matrix axes are numbers instead of letters because they're
			// placed around the revolve line's angle rather than space
		}
		for (i1 = 0; i1 < r_points.length; i1++) {
			if(!Array.isArray(r_points[i1])) {
				r_points[i1] = [r_points[i1].x, r_points[i1].y, r_points[i1].z];
			};
			coortemp = Points.subtract(r_points[i1], center);
			// coordinates relative to the center
			if(formattype === "2d" && (coortemp[axis1] || coortemp[axis2])) {
				let temp = Point2.rotate([coortemp[axis1], coortemp[axis2]], angle);
				r_points[i1][axis1] = center[axis1] + temp[0];
				r_points[i1][axis2] = center[axis2] + temp[1];
			}
			else if(["3d", "roll"].includes(formattype) && (coortemp[0] || coortemp[1] || coortemp[2])) {
			// if all coordinates are zero, rotating it won't move it.
				if(format === "neo") {
					r_points[i1] = [
						matrix.x.findposition(coortemp[0]),
						matrix.y.findposition(coortemp[1]),
						matrix.z.findposition(coortemp[2]),
					];
					// translate its distances across the old axes into what x/y/z
					// those distances mean on the new axes.
					r_points[i1] = [
						center[0] + r_points[i1][0][0] + r_points[i1][1][0] + r_points[i1][2][0],
						center[1] + r_points[i1][0][1] + r_points[i1][1][1] + r_points[i1][2][1],
						center[2] + r_points[i1][0][2] + r_points[i1][1][2] + r_points[i1][2][2],
					];
					// but findposition returns three-coordinates arrays, so you
					// gotta sum them up. add the center back while you're at it.
				}
				else if(format === "old") {
					// if both are zero, it's right on the center, meaning
					// there's no point revolving (and Angle.get will turn up
					// errors)
					dist = Math.hypot(coortemp[0], coortemp[1], coortemp[2]);
					angletemp = Angle.get(coortemp[0], coortemp[1], coortemp[2]);
					// original angle
					angletemp[0] += angle[0];
					angletemp[1] += angle[1];
					// modified angle
					angletemp = Angle.correct(angletemp);
					// make sure it isn't out of bounds
					angletemp = Angle.numbers(angletemp);
					r_points[i1][0] = center[0] + angletemp[0]*dist;
					r_points[i1][1] = center[1] + angletemp[1]*dist;
					r_points[i1][2] = center[2] + angletemp[2]*dist;
				}
				else if(formattype === "roll") {
					r_points[i1] = [
						oldmatrix[0].findplace(coortemp),
						oldmatrix[1].findplace(coortemp),
						oldmatrix[2].findplace(coortemp)
					];
					// find its place in the coordinate system formed around the
					// oldmatrix
					r_points[i1] = [
						matrix[0].findposition(r_points[i1][0]),
						matrix[1].findposition(r_points[i1][1]),
						matrix[2].findposition(r_points[i1][2])
					];
					// translate that into the new matrix
					r_points[i1] = [
						center[0] + r_points[i1][0][0] + r_points[i1][1][0] + r_points[i1][2][0],
						center[1] + r_points[i1][0][1] + r_points[i1][1][1] + r_points[i1][2][1],
						center[2] + r_points[i1][0][2] + r_points[i1][1][2] + r_points[i1][2][2],
					];
					// findposition returns arrays, so sum them up
				};
			}
		}
		//
		if(one_point) {
			r_points = r_points[0];
		};
		return r_points;
	}
	function raysegmentintersect(x1, y1, angle, x2a, y2a, x2b, y2b) {
	// - x1, y1, angle: parameters for the ray (a ray is a line that
	//   only travels one direction, if you didn't remember inane math
	//   trivia from fourth grade)
	// - x2a, y2a, x3a, y3a: parameters for the line segment
	// - returns either coordinates for the intersection, or a false
	//   boolean
		let adist = Math.hypot(x2a - x1, y2a - y1);
		let bdist = Math.hypot(x2a - x1, y2a - y1);
		if((x1===x2a && y1===y2a) && (x1===x2b && y1===y2b)) {
			return [x1, y1];
		}
		if(
			(
				angle >= Math.min(Math.acos((x2a - x1)/adist), Math.acos((x2b - x1)/bdist))
				&&
				angle <= Math.max(Math.acos((x2a - x1)/adist), Math.acos((x2b - x1)/bdist))
			)
			||
			(
				angle >= Math.min(Math.asin((y2a - y1)/adist), Math.asin((y2b - y1)/bdist))
				&&
				angle <= Math.max(Math.asin((y2a - y1)/adist), Math.asin((y2b - y1)/bdist))
			)
		) {
		// if angle is between the angle to point 2a and the angle to
		// point 2b,
			let segangle = 0;
			for(rsi_i1 = 0; rsi_i1 < 4; rsi_i1++) {
				if((rsi_i1%2)===0) {
					segangle = Math.hypot(x2b - x2a, y2b - y2a);
					if(rsi_i1 < 2) {
						segangle = Math.acos((x2b - x2a)/segangle);
					}
					else {
						segangle = Math.asin((y2b - y2a)/segangle);
					};
					for(; segangle < 0 ;) {
						segangle += 2*Math.PI;
					}
					for(; segangle >= 2*Math.PI ;) {
						segangle -= 2*Math.PI;
					}
				};
				if((rsi_i1%2)===1) {
					segangle += Math.PI;
					segangle %= 2*Math.PI;
				}
				if(segangle === angle) {
					if(adist <= bdist) {
						return [x2a, y2a];
					}
					else if(bdist <= adist) {
						return [x2b, y2b];
					};
				};
			}
			return fourpointintersect(x1, y1, x1 + Math.cos(angle), y1 + Math.sin(angle), x2a, y2a, x2b, y2b);
		}
		else {
			return false;
		};
	}
	function get2dangle(x, y, shush) {
		if(x === 0) {
			if(y > 0) {
				return Math.PI/2;
			}
			else if(y < 0) {
				return 3*Math.PI/2;
			}
			else if(y === 0) {
				if(shush) {
					return null;
				}
				else {
					console.log("invalid get2dangle input: " + [x, y]);
					return 0;
				};
			}
			else {
				if(shush) {
					return null;
				}
				else {
					console.log("something went wrong with get2dangle.");
					return 0;
				};
			};
		}
		else {
			let returnangle = Math.atan(y/x);
			if(x < 0) {
				returnangle += Math.PI;
			};
			// double negatives make inverse tan screw up, etc
			return posmod(returnangle, 2*Math.PI);
		};
	}
	function compare2dangle(angle1, angle2) {
		let returnangle = posmod(
			posmod(Math.max(angle1, angle2), 2*Math.PI) - posmod(Math.min(angle1, angle2), 2*Math.PI),
		2*Math.PI);
		if(returnangle > Math.PI) {
			returnangle = 2*Math.PI - returnangle;
		};
		return returnangle;
	}
	class Operations {
	// this really only exists to make it easy to verify that something's an
	// operations object. (otherwise, you'd have to check every property and
	// make sure the name starts with one of the allowed words.)
		constructor(value) {
			if(noargumentscheck([value])) {
			// create an empty object that another object's contents can be
			// pasted into
				return;
			}
			let i1 = 0;
			for (i1 in value) {
				if (value.hasOwnProperty(i1)) {
					this[i1] = structuredClone(value[i1]);
				}
			}
		}
		useless(isangle) {
		// returns a boolean for whether the operations is just composed of
		// arithmetic that barely changes the number at all because it just
		// multiplies it by 1.000000000000000000001 or something
		// - isangle: also declares 2 pi minus .0000000000000001 or w/e useless
			let i1 = "";
			let op = "";
			for (i1 in this) {
				if (this.hasOwnProperty(i1)) {
					op = (i1.includes("_") ? i1.slice(0, i1.indexOf("_")) : i1);
					if(
						["add", "subtract"].includes(op)
						&&
						(
							Math.abs(this[i1]) < .0000000001
							||
							(
								isangle
								&&
								Math.abs(this[i1] - 2*Math.PI) < .0000000001
							)
						)
					) {
					// if it's adding/subtracting 0 or a number infinitesimally close to 0
					}
					else if(["multiply", "divide"].includes(op) && Math.abs(1 - this[i1]) < .0000000001) {
					// if it's multiplying/dividing 1 or a number infinitesimally close to 1
					}
					else {
						return false;
					};
				}
			}
			return true;
		}
	}
	function applyoperations(number, operations, place) {
	// applies the operations in the operations object to the given number and
	// returns the new version.
	// - add, subtract, multiply, divide, remainder, exponent, math.
	// - the first five are pretty obvious. they are either arrays of multiple
	//   numbers, or one number applied regardless of the place value entered.
	//   - place is the index to use if it's an array. for example, if you
	//     wanted to add a 5 x and -10 y offset to coordinates, you would have
	//     an add: [5, -10] property, and use 0 as the place number when using
	//     this on an x coordinate.
	// - math is different. math is a string representing a function of the
	//   Math object. usually floor, ceil, round.
	// - this was created so i could easily adjust coordinates to be
	//   absolute, apply a multiplier, and floor it.
	// - add an underscore after a property name to add a number or whatever
	//   while still recognizing the operation (for example, you can't have
	//   multiply, add, multiply because that'd mean two properties are the
	//   same. but if it was multiply_1, add, multiply_2, it'd be fine.)
		let i1 = "";
		let temp = "";
		let operand = 0;
		for (i1 in operations) {
			if (operations.hasOwnProperty(i1)) {
				if(i1.includes("_")) {
					temp = i1.slice(0, i1.indexOf("_"));
				}
				else {
					temp = i1;
				};
				if(Array.isArray(operations[i1]) && operations[i1].length > place) {
					if(
						typeof operations[i1][place] === "number"
						||
						(
							typeof operations[i1][place] === "string"
							&&
							(
								temp === "add"
								||
								temp === "math"
							)
						)
					) {
						operand = operations[i1][place];
					}
					else {
						operand = NaN;
					}
				}
				else if(
					typeof operations[i1] === "number"
					||
					(
						typeof operations[i1] === "string"
						&&
						(
							temp === "add"
							||
							temp === "math"
						)
					)
				) {
					operand = operations[i1];
				}
				else {
					operand = NaN;
				}
				switch (temp) {
					case "set":
					number = operand;
					break;
					case "add":
					number += operand;
					break;
					case "subtract":
					number -= operand;
					break;
					case "multiply":
					number *= operand;
					break;
					case "divide":
					number /= operand;
					break;
					case "remainder":
					number %= operand;
					break;
					case "exponent":
					number = number**operand;
					break;
					case "math":
					if(Math.hasOwnProperty(operand) && typeof Math[operand] === "function") {
						number = Math[operand](number);
					}
					else {
						number = NaN;
					}
					break;
					default:
					console.log("invalid operation.");
					break;
				}
			};
		}
		return number;
	}
	function newoperationname(operations, newoperation) {
	// for use with a applyoperations input. checks every
	// "[operation name]_[number]" property so that the new property will be one
	// that isn't used yet and is higher than whatever the highest number is,
	// then it returns that property name
		let i1 = 0;
		let currentuses = [];
		for (i1 in operations) {
			if (operations.hasOwnProperty(i1) && i1.slice(0, i1.indexOf("_")) === newoperation) {
				currentuses[currentuses.length] = i1;
			};
		}
		if(currentuses.length === 0) {
			return newoperation;
		}
		else {
			let highestnum = 1;
			let temp = "";
			for(i1 = 0; i1 < currentuses.length; i1++) {
				temp = currentuses[i1].slice(newoperation.length + 1);
				if(temp && !isNaN(Number(temp)) && Number(temp) > highestnum) {
					highestnum = Math.ceil(Number(temp));
					// the ceil is in case i use decimal points or something...
					// can't just add 1 to that, that'll make it confusing
				};
			}
			return newoperation + "_" + (highestnum + 1);
		}
	}
	function inverseoperations(input) {
	// returns a version of the given operations object where it's in reverse
	// order and all operations are inverses of what they were.
	// - applying these should reverse the changes of the original and revert a
	//   number to what it was before.
	// - there are limits, however.
	//   - a lot of Math operations cannot be reversed.
	//   - *, /, or ** by 0 cannot be reversed
	//   - even-number exponents for negative numbers will make them positive,
	//     so running an inverse operation on it will not return it to what it
	//     was.
		let i1 = 0;
		let i2 = 0;
		let inverse = {};
		let keys = Object.keys(input);
		let types = ["set", "add", "subtract", "multiply", "divide", "remainder", "exponent", "math"];
		let op = "";
		let temp = "";
		for (i1 = 0; i1 < keys.length; i1++) {
			op = "";
			for (i2 = 0; i2 < types.length; i2++) {
				if(keys[i1].slice(0, types[i2].length) === types[i2]) {
					op = types[i2];
					i2 += types.length;
				};
			}
			if(!op) {
				console.log("invalid operation.");
				return;
			};
			if(op === "math") {
				temp = ["cos", "sin", "tan", "cosh", "sinh", "tanh"];
				// the other math methods with only one argument are:
				// - reversible
				//   - cbrt
				//   - sqrt
				// - irreversible
				//   - abs
				//   - ceil
				//   - floor
				//   - round
				//   - sign
				//   - trunc
				//   - clz32
				//   - fround
				// - probably reversible but i'd have to make special arguments
				//   and i'm not doing that
				//   - exp
				//   - expm1
				// - don't feel like figuring this shit out right now
				//   - log
				//   - log10
				//   - log1p
				//   - log2
				// 2 arguments:
				//   - atan2
				//   - hypot
				//   - max
				//   - min
				//   - pow (exponent does the same thing though)
				// - i do not give a shit about whatever this is,
				//   - imul
				// =
				// - oh who gives a shit. the math property string already takes
				//   the place of the operand.
				op = input[keys[i1]];
				if(temp.includes(op)) {
					inverse[keys[i1]] = "a" + op;
					// cos to acos
				}
				else if(op === "sqrt") {
					inverse[newoperationname(input, "exponent")] = 2;
				}
				else if(op === "cbrt") {
					inverse[newoperationname(input, "exponent")] = 3;
				}
				else if(op.charAt(0) === "a" && temp.includes(op.slice(1))) {
					inverse[keys[i1]] = op.slice(1);
					// acos to cos
				}
				else if(["floor", "ceil", "round", "fround", "trunc", "abs", "sign", "clz32", "fround"].includes(op)) {
					console.log("Math." + op + " operations are irreversible.");
				}
				else if(["exp", "expm1", "log", "log10", "log1p", "log2"].includes(op)) {
					console.log("Math." + op + " operations are probably reversible maybe, but i don't really feel like figuring it out right now.");
				}
				else if(!Math[i1] || typeof Math[i1] !== "function" || Math[i1].length !== 1) {
					console.log("this Math function either doesn't exist, isn't a function, or has more than one argument. you aren't supposed to use those to begin with.");
				}
				else {
					console.log("this shouldn't happen");
				};
			}
			else if(["set", "remainder"].includes(op)) {
				console.log(op + " operations are irreversible.");
			}
			else {
				if(["add", "subtract"].includes(op)) {
					temp = "negative";
				}
				else if(["multiply", "divide", "exponent"].includes(op)) {
					temp = "reciprocate";
				}
				else {
					console.log("this shouldn't happen");
				};
				let inputvalue = 0;
				// temp
				for (i2 = 0; i2 < (Array.isArray(input[keys[i1]]) ? input[keys[i1]].length : 1); i2++) {
					if(Array.isArray(input[keys[i1]])) {
						if(i2 === 0) {
							inverse[keys[i1]] = [];
						}
						inputvalue = input[keys[i1]][i2];
					}
					else {
						inputvalue = input[keys[i1]];
					};
					if(typeof inputvalue === "number") {
						switch (temp) {
							case "negative":
								if(Array.isArray(input[keys[i1]])) {
									inverse[keys[i1]][i2] = -1*inputvalue;
								}
								else {
									inverse[keys[i1]] = -1*inputvalue;
								};
							break;
							case "reciprocate":
								if(inputvalue === 0) {
									console.log(op + " operations with 0 are irreversible.");
								}
								else {
									if(Array.isArray(input[keys[i1]])) {
										inverse[keys[i1]][i2] = 1/inputvalue;
									}
									else {
										inverse[keys[i1]] = 1/inputvalue;
									};
								};
							break;
							default:
								console.log("this shouldn't happen");
							break;
						};
					}
					else if(typeof inputvalue === "string") {
						console.log("string concatenation is technically reversible but only kind of and also it's a pain in the ass");
					}
					else {
						console.log("this shouldn't happen");
					};
				}
			}
		}
		return inverse;
	}
	function isoperations(object) {
		let i1 = 0;
		let op = "";
		if(typeof object !== "object" || Object.keys(object).length <= 0) {
			return false;
		};
		for (i1 in object) {
			if (object.hasOwnProperty(i1)) {
				op = i1.includes("_") ? i1.slice(0, i1.indexOf("_")) : i1;
				if(!["set", "add", "subtract", "multiply", "divide", "remainder", "exponent", "math"].includes(op)) {
					return false;
				}
			}
		}
		return true;
	}
	function isrevolutions(object) {
		let i1 = 0;
		let op = "";
		if(typeof object !== "object" || Object.keys(object).length <= 0) {
			return false;
		};
		for (i1 in object) {
			if (object.hasOwnProperty(i1)) {
				op = i1.includes("_") ? i1.slice(0, i1.indexOf("_")) : i1;
				if(!["xy", "xz", "yz"].includes(op)) {
					return false;
				}
			}
		}
		return true;
	}
	let Rel = {
	// means "relative angle", as in the difference between one 3d angle and
	// another.
	// - relative angles consist of a line revolve, and a roll change.
	// - how it works is:
	//   - get getlinerevolve and roll of angle1
	//   - apply an inverse of that getlinerevolve to angle2, and subtract the
	//     roll
	//   - get the getlinerevolve of this new angle, but trim it down to the
	//     axis angle and magnitude
	//   - include the difference between angle1 and angle2's roll
	// - they're applied by taking the angle numbers, revolving them with the
	//   magnitude and axis direction the relative angle specifies, converting
	//   it back to an angle, and adding the roll change.
		get: function(angle1, angle2) {
		// creates a relative angle, angle2 minus angle1.
			//let lr = getlinerevolve(angle1);
			let lr = GLR.new(angle);
			let num = Angle.numbers(angle2, true);
			// short for "angle numbers and satellite". Angle.numbers and
			// satellite of angle2
			num = revolve(posmod(-lr.magnitude, 2*Math.PI), num, false, GLR.axis(lr));
			// revert to what would make angle1 [0, 0]
			let rel = Angle.get(...num[0]);
			rel = GLR.new(rel);
			// line revolve of that
			num = revolve(rel.magnitude, Angle.numbers([0, 0], true), false, GLR.axis(rel));
			num = revolve(lr.magnitude, num, false, GLR.axis(lr));
			// what Rel.apply does, with unnecessary bits cut out
			let roll = Angle.getwithroll(num)[2];
			rel = {
				xy: GLR.axis(rel)[0],
				z: GLR.axis(rel)[1],
				magnitude: rel.magnitude,
				rollchange: posmod(
					//(angle2[2] ?? 0) - (angle1[2] ?? 0),
					(angle2[2] ?? 0) - roll,
					2*Math.PI
				),
			};
			return rel;
		},
		apply: function(absangle, relangle) {
		// applies the relative angle to the absolute angle, returning a new
		// absolute angle
		// - how it works is that it saves the revolution and roll that would
		//   bring [1, 0, 0] and [1, 1, 0] to what the absangle starts as,
		//   applies the relative angle to [1, 0, 0] and [1, 1, 0], then adds
		//   back that line revolve and roll
			//let lr = getlinerevolve(absangle);
			let lr = GLR.new(absangle);
			// axis, magnitude
			//
			let num = Angle.numbers([0, 0, 0], true);
			// convert angle to numbers, do an inverse line revolve back to
			// angle [0, 0, 0]. the actual math for that is a waste of time but
			// that's the principle.
			num = revolve(relangle.magnitude, num, false, [relangle.xy, relangle.z]);
			if(relangle.rollchange) {
				num = Angle.getwithroll(num);
				num[2] = posmod(num[2] + relangle.rollchange, 2*Math.PI);
				num = Angle.numbers(num, true);
			};
			num = revolve(lr.magnitude, num, false, GLR.axis(lr));
			return Angle.getwithroll(num);
		},
		invert: function(relangle) {
			let _return = structuredClone(relangle);
			_return.magnitude = posmod(-_return.magnitude, 2*Math.PI);
			_return.rollchange = posmod(-_return.rollchange, 2*Math.PI);
			return _return;
		},
		orient: function(absangle, relangle, points, center) {
		// - to get a relative angle that can be used as a 3d orientation thing:
		//   - create a [0, 0, 0] angle. (or any angle, really. as long as you
		//     can get the same thing later.)
		//   - when applying revolutions to the shape in question, also apply
		//     revolutions to this angle, using Angle.numbers(angle, true) and
		//     Angle.getwithroll
		//   - use Rel.get on the angle you started with and this new angle
		// - to use it, just put it into this function.
		// - absangle: the angle you start with, like the [0, 0, 0] i used as an
		//   example.
			let _points = revolve(relangle.magnitude, structuredClone(points), center, [relangle.xy, relangle.z]);
			let newangle = Rel.apply(absangle, relangle);
			return (
				relangle.rollchange
				?
				revolve(relangle.rollchange, _points, center, newangle)
				// apply roll
				:
				_points
			);
		},
		useless: function(relangle) {
			function uselessnum(input) {
				return Math.min(Math.abs(input), Math.abs(input - 2*Math.PI))/(2*Math.PI) < .0000000001;
			}
			return uselessnum(relangle.magnitude) && uselessnum(relangle.rollchange);
		},
		rand: (includeroll) => Rel.get(Angle.rand(includeroll), Angle.rand(includeroll)),
	};
	function calcroll(angle, revolutions) {
	// this will return an array of three numbers. they represent the new xy/z
	// angle and the roll.
	// - angle: this is the absolute angle you start with. if you do specify a
	//   third number for roll, it is assumed it starts at zero.
	// - revolutions: it's kinda like Operations, create an object with properties
	//   named after rotations formats. (xy, xz, yz, xy/z. like operations, you
	//   can write an underscore after the format and it'll use everything before
	//   that as the angle format.) it will apply these revolutions and calculate
	//   the roll.
		let i1 = 0;
		let point = [];
		let returnvalue = [];
		returnvalue[2] = (angle.length >= 3 ? angle[2] : 0);
		point[0] = Angle.numbers(angle);
		point[1] = revolve(angle, [1, 1, 0]);
		/*
		let inverseangle = [
			posmod(2*Math.PI - angle[0], 2*Math.PI),
			-angle[1]
		];
		point[0] = revolve(inverseangle, point[0]);
		// revolve back to [1, 0, 0], aka xy/z 0, 0
		let point[1] = [1, 1, 0];
		// add satellite we can measure roll from
		point[0] = revolve(angle, point[0]);
		point[1] = revolve(angle, point[1]);
		// revolve back to where it was
		// -
		//*/
		// i never actually intended to use this code. it's just a clearer way
		// of showing what i'm doing. point[1] should be in the same place it
		// would be if point[0] started out at an xy/z of 0, 0 and was revolved
		// by angle to get where it is.
		let format = "";
		for (i1 in revolutions) {
			if (revolutions.hasOwnProperty(i1)) {
				if(i1.includes("_")) {
					format = i1.slice(0, i1.indexOf("_"));
				}
				else {
					format = i1;
				};
				point = revolve(revolutions[i1], point, false, format);
			}
		}
		returnvalue[0] = Angle.get(point[0][0], point[0][1], point[0][2]);
		// absolute angle after revolutions
		returnvalue[1] = returnvalue[0][1];
		returnvalue[0] = returnvalue[0][0];
		let inverseangle = [
			posmod(2*Math.PI - returnvalue[0], 2*Math.PI),
			-returnvalue[1]
		];
		point = revolve(inverseangle, point);
		// revolve to [1, 0, 0]
		if(Math.abs(point[1][0] - point[0][0]) > .0000000001) {
		// they *should* have the same x.
			console.log("this shouldn't happen");
		};
		returnvalue[2] += get2dangle(point[1][1] - point[0][1], point[1][2] - point[0][2], true);
		// the point[1]'s relation to point[0] should be a yz angle, so turn
		// that into a 0 to 2 pi number. that's roll.
		// - this used to start as [1, 0, 1] and make the 2d angle with z before
		//   y, but this is better. x (is 1 at 0 angle) and y = normal 2d angle
		//   system, y (1 at 0 angle) and z = roll angle
		return returnvalue;
	}
	let GLR = {
	// pseudoclass. stores orientation, sort of. an object storing the data for
	// a revolution from [1, 0, 0] to the specified angle. (which can include
	// roll.)
	// - the theory this all revolves around is finding the circle that the
	//   angle numbers and [1, 0, 0] rest on.
	// - structure:
	//   - axis_xy_is_0, axis_z, axis getter: the axis used for the revolve. xy
	//     is always 90 unless axis_xy_is_0 is on. axis_z varies. axis is a
	//     getter that simplifies this into a real angle.
	//   - magnitude: a 2d angle for how much to revolve
	//   - roll: the roll of the original angle. if roll is involved, do a yz
	//     revolve with this angle before the line revolve.
		new: function(angle) {
			angle ??= [0, 0, 0];
			let axis_z = 0;
			let axis_xy_is_0 = false;
			let magnitude = null;
			if(angle[1] === 0) {
				// axis is perpendicular to the xy plane
				axis_xy_is_0 = true;
				axis_z = Math.PI/2;
				magnitude = angle[0];
				if(magnitude < Math.PI) {
					magnitude = posmod(-magnitude, 2*Math.PI);
					axis_z *= -1;
				};
			}
			else if(Math.abs(angle[1]) === Math.PI/2) {
				axis_z = 0;
				magnitude = posmod(-angle[1], 2*Math.PI);
			}
			else if([0, Math.PI].includes(angle[0]) && !angle[1]) {
				// axis is vertical
				axis_z = Math.PI/2;
				magnitude = posmod(angle[1] + angle[0], 2*Math.PI);
			}
			else {
				// the theory behind this process is: the angle numbers of [0, 0] and the
				// target angle fall on the same circle, so this is trying to find the
				// correct axis and magnitude.
				// - that axis is always along the yz plane.
				let anglenum = Angle.numbers(angle);
				//
				magnitude = Math.acos(anglenum[0]);
				// the angle for where it is on the circle.
				//
				axis_z = Angle.get(0, -anglenum[2], anglenum[1]);
				// flatten it into a yz angle, rotate it 90 degrees so it's
				// perpendicular
				let axis_xy = axis_z[0];
				axis_z = axis_z[1];
				axis_xy = Math.round(axis_xy / (Math.PI/2));
				// convert to 0-4 number (it should be infinitesimally close to a
				// 0/90/180/270 angle)
				if(axis_xy >= 2) {
					// if it's 270, flip it
					axis_xy = 4 - axis_xy;
					axis_z *= -1;
					magnitude = posmod(-magnitude, 2*Math.PI);
				};
				axis_xy_is_0 = !axis_xy;
			};
			return {
				axis_xy_is_0,
				axis_z,
				magnitude,
				roll: angle[2] ?? 0,
			};
		},
		axis: (_this) => [
			!_this.axis_xy_is_0 * Math.PI/2,
			_this.axis_z
		],
		apply: function(_this, point) {
			let _point = structuredClone(point);
			if(_this.roll) {
				_point = revolve(_this.roll, _point, null, "yz");
			};
			if(_this.magnitude) {
				_point = revolve(_this.magnitude, _point, null, GLR.axis(_this));
			};
			return _point;
		},
		to_points: function(_this, include_z) {
			let array = [
				GLR.apply(_this, [1, 0, 0]),
				GLR.apply(_this, [0, 1, 0])
			];
			if(include_z) {
				array[2] = GLR.apply(_this, [0, 0, 1]);
			};
			return array;
		},
		// converts it to the Angle.numbers for an x pole and a y pole.
		from_points: function(points) {
			let glr = GLR.new(Angle.get(...points[0]));
			// GLR that brings [1, 0, 0] to points[0]
			let temp = structuredClone(glr);
			temp.magnitude = posmod(2*Math.PI - temp.magnitude, 2*Math.PI);
			temp = GLR.apply(temp, structuredClone(points[1]));
			// inverse that revolution so it can discern roll
			glr.roll = get2dangle(temp[1], temp[2]);
			return glr;
		},
		// converts it back
		revolve: function(_this, format, angle, center) {
			let temp = revolve(angle, GLR.to_points(_this), center, format);
			return GLR.from_points(temp);
		},
		// applies a revolution
	};
	function rolldirection(angle) {
	// returns an xy/z for what direction roll points in.
	// - the way revolve works is that it revolves the points around whatever
	//   line and magnitude would bring a [1, 0, 0] point to the angle
	//   specified.
	// - so the way roll works is that 0 will always be whatever direction a
	//   [0, 1, 0] point would be in if it was dragged along.
	//   - 90 would be a [0, 0, 1] point.
		let i1 = 0;
		let xy_ = angle[0];
		let _z = angle[1];
		let roll = angle[2] ?? 0;
		let satel = [0, Math.cos(roll), -Math.sin(roll)];
		// or [0, 1, 0] if roll is 0, [0, 0, -1] if roll is 90
		let anglenum = Angle.numbers(angle);
		let doublecheck = null;
		let revolvetype = null;
		// for logging errors
		if(_z === 0) {
			satel = revolve(xy_, satel, null, "xy");
			doublecheck = revolve(xy_, [1, 0, 0], null, "xy");
			revolvetype = "_z === 0";
		}
		else if(Math.abs(_z) === Math.PI/2) {
			let temp = posmod(_z, 2*Math.PI);
			satel = revolve(temp, satel, null, "xz");
			doublecheck = revolve(temp, [1, 0, 0], null, "xz");
			revolvetype = "Math.abs(_z) === Math.PI/2";
		}
		else if([0, Math.PI].includes(xy_)) {
			let temp = posmod(_z + xy_, 2*Math.PI);
			satel = revolve(temp, satel, null, "xz");
			doublecheck = revolve(temp, [1, 0, 0], null, "xz");
			revolvetype = "[0, Math.PI].includes(xy_)";
		}
		else {
			revolvetype = "main";
			function linerevolve(point) {
			// something's wrong with how this works because running it on [1,
			// 0, 0] doesn't make it close to the anglenum.
			// - run through the process:
			//   - use getlinerevolve to get the axis, magnitude, and circ_hw
			//     - nothing's wrong with this, i tested it with a ProcAnim
			//   - get the findplace
			//   - move it to the revolve plane
			//   - make y a number from -1 to 1 by dividing it by circ_hw
			//   - xy revolve
			//   - multiply it by circ_hw again, move it to the revolve plane
			//     again
			//   - reverse the move to the revolve plane
				let satel = structuredClone(point);
				let lr = GLR.new(angle);
				let line = new Line(0, 0, 0, GLR.axis(lr));
				let circ_hw = Angle.numbers(angle);
				circ_hw = Math.abs(Math.sin(get2dangle(circ_hw[2], circ_hw[1])));
				if(angle[0] < Math.PI) {
					lr.magnitude = posmod(-lr.magnitude, 2*Math.PI);
				}
				// lr.axis, lr.magnitude, lr.circ_hw
				// this is how much to rotate by.
				// -
				// that's the axis and magnitude that takes [1, 0, 0] to anglenum, so
				// now we figure out what doing the same thing does to [1, 1, 0]
				// - (n/a here) get coordinates relative to fulcrum
				let axisplace = line.findplace(satel);
				// need this number for later
				satel = line.plane().movetoplane(satel);
				// to move it to the revolution plane, make it into a line parallel to
				// the axis and find where that intersects with the plane
				satel[1] /= circ_hw;
				satel = revolve(lr.magnitude, satel, false, "xy");
				satel[1] *= circ_hw;
				satel = line.plane().planepoint(satel[0], satel[1], "z");
				// - revolve
				// - reverse the lr.circ_hw division
				// - put it on the revolution plane (z is made unreliable by the 2d
				//   revolution, so you need planepoint to get the right z)
				//*
				satel = new Line(...satel, GLR.axis(lr));
				satel = satel.findposition(axisplace);
				//*/
				// - reverse the move to plane
				return satel;
			}
			// all of this code would be much easier if i could use line revolve
			// the normal way, but i can't because line revolve uses this.
			// - thankfully it's doable because the line revolve axis is always
			//   on the yz plane
			satel = linerevolve(satel);
			doublecheck = linerevolve([1, 0, 0]);
		};
		doublecheck = Math.hypot(
			anglenum[0] - doublecheck[0],
			anglenum[1] - doublecheck[1],
			anglenum[2] - doublecheck[2]
		);
		if(doublecheck >= .00001) {
			console.log(
				revolvetype + " rolldirection error: " + doublecheck + " units away." + String.fromCharCode(10) +
				"angle: " + Angle.convert(angle)
			);
		};
		return Angle.get(
			satel[0] - anglenum[0],
			satel[1] - anglenum[1],
			satel[2] - anglenum[2]
		);
	}
	function rollinverse(angle, rollangle) {
	// does the opposite of roll direction, taking a direction perpendicular to
	// the angle and figuring out which roll would produce that.
		let temp = Math.abs(Angle.compare(angle, rollangle) - Math.PI/2);
		if(temp > .0000000001) {
			console.log("rollinverse: rollangle is not perpendicular. " + temp);
			return;
		};
		let points = Angle.numbers(angle);
		points = [
			structuredClone(points),
			structuredClone(points)
			// satellite
		];
		temp = Angle.numbers(rollangle);
		points[1][0] += temp[0];
		points[1][1] += temp[1];
		points[1][2] += temp[2];
		// 0: angle numbers, 1: satellite
		//let lr = getlinerevolve(angle);
		let lr = GLR.new(angle);
		lr.magnitude = posmod(-lr.magnitude, 2*Math.PI);
		//points = lr.axis.linerevolve(lr.magnitude, points);
		points = revolve(lr.magnitude, points, null, GLR.axis(lr));
		// this should revolve it back to [1, 0, 0]
		temp = [];
		temp[0] = Math.hypot(
			points[0][0] - 1,
			points[0][1],
			points[0][2],
		);
		temp[1] = Math.abs(points[1][0] - 1);
		temp[2] = Math.abs(Math.hypot(points[1][1], points[1][2]) - 1);
		if(temp[0] > .0000000001) {
			console.log("rollinverse: point is " + temp[0] + " away from [1, 0, 0]");
		};
		if(temp[1] > .0000000001 || temp[2] > .0000000001) {
			console.log("rollinverse: satellite x is " + temp[0] + " away from 1 and satellite y/z hypotenuse is " + temp[2] + " away from 1.");
		};
		return get2dangle(
			points[1][1] - points[0][1],
			points[1][2] - points[0][2]
		);
	}
	function tricoordinates(tri, point, inverse) {
	// converts 2d or 3d coordinates to coordinates defined by the triangle.
	// - inverse: the opposite process, converting triangle coordinates to
	//   2d/3d.
	// - the way it works is this:
	//   - point 0 of the triangle is [0, 0]
	//   - point 1 is [1, 0]
	//   - point 2 is [0, 1].
	//   - the coordinates are a measure of how far along each side of the
	//     triangle the point is.
	//   - it uses the line from 0 to 1 and the line from 0 to 2 as axes. in
	//     other words, to find "x" it finds which 0-to-2-parallel line the
	//     point is on, and where it intersects with the 0 to 1 line. (0
	//     being at point 0, 1 being point 1, and possibly more or less than
	//     that, but that would make it outside the triangle.) "y" is the
	//     opposite.
	//     =
	//         1y--2
	//            / \
	//      .5y--*---*
	//          /   / \
	//     0y--0---*---1
	//        /   /   /
	//       0x .5x  1x
	//   - points are outside the triangle if x and y adds up to more than
	//     1, or if either is negative.
	// - anyway, i use this for 3d texturing.
	//   - get perspectived triangle points
	//   - run _2dpoly.execute
	//     - run screeninverse to figure out what 3d point this pixel
	//       represents
	//     - use tricoordinates to convert it to triangle coordinates
	//     - use inverse tricoordinates with the 2d triangle assigned to that 3d
	//       triangle to figure out which pixel of the texture image to
	//       reference for the color
		let i1 = 0;
		let mode = null;
		let _point = null;
		if(tri[0].length === 2 && tri[1].length === 2 && tri[2].length === 2 && (inverse || point.length === 2)) {
			mode = "2d";
			_point = point;
		}
		else if(tri[0].length === 3 && tri[1].length === 3 && tri[2].length === 3 && (inverse || point.length === 3)) {
			mode = "3d";
			_point = Plane.frompoints(tri).movetoplane(point);
		}
		else {
			console.log("inconsistent coordinate array lengths. (or maybe it was nullish or something.)");
			return;
		};
		if(inverse) {
			let newpoint = structuredClone(tri[0]);
			for (i1 = 0; i1 < (mode === "2d" ? 2 : 3); i1++) {
				newpoint[i1] += point[0]*(tri[1][i1] - tri[0][i1]);
				newpoint[i1] += point[1]*(tri[2][i1] - tri[0][i1]);
			};
			return newpoint;
		}
		else {
			let xunit = [];
			let yunit = [];
			// (by x and y i mean how they work in triangle coordinates. these
			// are variables for how 1 x/y of triangle coordinates converts to
			// 3d space.)
			let alldist = [];
			let sum = {
				x: 0,
				y: 0,
				all: 0,
			};
			for (i1 = 0; i1 < (mode === "2d" ? 2 : 3); i1++) {
				xunit[i1] = tri[1][i1] - tri[0][i1];
				yunit[i1] = tri[2][i1] - tri[0][i1];
				alldist[i1] = _point[i1] - tri[0][i1];
				sum.x += xunit[i1];
				sum.y += yunit[i1];
				sum.all += alldist[i1];
			};
			// as in the change in position that comes from moving 1 in this
			// triangle axis, and the total distances from point 0 to the main
			// point. n1 number of xunits plus n2 number of yunits = alldist.
			// that's the math we gotta do.
			// -
			// n1 * xdist[0] + n2 * ydist[0] = alldist[0],
			// n1 * xdist[1] + n2 * ydist[1] = alldist[1],
			// and n1 * xdist[2] + n2 * ydist[2] = alldist[2], so:
			// -
			// n1 * sum.x + n2 * sum.y = sum.all
			if(mode === "2d") {
				let axis = {
					x: new Line(...tri[0], 0, Angle.get(...xunit, 0)),
					y: new Line(...tri[0], 0, Angle.get(...yunit, 0)),
				};
				return [
					axis.x.findplace(_point)/Math.hypot(...xunit),
					axis.y.findplace(_point)/Math.hypot(...yunit)
				];
			}
			else if(mode === "3d") {
				let axis = {
					x: new Line(...tri[0], Angle.get(...xunit)),
					y: new Line(...tri[0], Angle.get(...yunit)),
				};
				return [
					axis.x.findplace(_point)/Math.hypot(...xunit),
					axis.y.findplace(_point)/Math.hypot(...yunit)
				];
			};
		}
	}
	function mathtester(func, condition, sortby, iterations, func_arg, graph) {
	/*
	document.getElementById("mt_area").hidden = false;
	mathtester(function() {
		//
	},
	false, false, false, false, {
		ctx: document.getElementById("mt_canvas").getContext("2d"),
		func: function(ctx, x, result) {
			ctx.fillRect(x, ctx.canvas.height, 1, -ctx.canvas.height*result.???/???);
			ctx.fillRect(x, ctx.canvas.height*(1 - result.error/???), 1, 1);
		}
		log: false,
	});
	//*/
	// - func: this should be a function that creates and returns an
	//   object created through randomness and the math functions you're
	//   testing.
	//   - for example, if i wanted to test a function that revolves
	//     points, i'd plot a random point, use a math function that
	//     *should* bring a control (or maybe another random point) to
	//     that position, then use Math.hypot to calculate how close it
	//     is. it'd return something like:
	//     - .destination (coordinate array)
	//     - .accuracy (Math.hypot result)
	// - condition: boolean function for putting something in the
	//   success array instead of the failure array. (func's output will
	//   be used as the sole parameter.) by default it is (result) =>
	//   result[sortby] < .0000000001.
	// - sortby: a string for the property they're going to be sorted
	//   by. by default, it is "error".
	// - iterations: number of trials. 1000 by default
	// - func_arg: specify arguments for func, in the form of an array.
	// - graph: an object for graphing
	//   - .ctx
	//   - .func: function for graphing
	//     - arguments
	//       - ctx
	//       - x: the row to use for your fillRects and what not
	//       - result: the object that holds all the data for this
	//         success/failure
	//     - fillStyle and strokeStyle will be start as green or orange
	//       depending on whether it was success or failure.
	//   - log: boolean for whether to bother logging the success/failure arrays
		let i1 = 0;
		let success = [];
		let failure = [];
		condition	= typeof condition	=== "function"	? condition		: (result) => result[sortby] < .0000000001;
		sortby		= typeof sortby		=== "string"	? sortby		: "error";
		iterations	= typeof iterations	=== "number"	? iterations	: 1000;
		let total_failure = null;
		for(i1 = 0; i1 < iterations; i1++) {
			let result = (Array.isArray(func_arg) ? func(...func_arg) : func());
			if(condition(result)) {
				success[success.length] = structuredClone(result);
			}
			else {
				failure[failure.length] = structuredClone(result);
				if(result.hasOwnProperty("error")) {
					total_failure += result.error;
				};
			}
		}
		function mt_sort(a, b) {
			return a[sortby] - b[sortby];
		};
		success.sort(mt_sort);
		failure.sort(mt_sort);
		if(!graph || graph.hasOwnProperty("log") && graph.log) {
			console.log("success:");
			console.log(success);
			console.log("failure:" + (total_failure === null ? "" : " (average: " + total_failure/failure.length + ")"));
			console.log(failure);
		};
		if(graph) {
			let ctx = graph.ctx;
			ctx.canvas.width = success.length + failure.length;
			ctx.fillStyle = "white";
			ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			for (i1 = 0; i1 < success.length; i1++) {
				ctx.fillStyle = "green";
				ctx.strokeStyle = "green";
				graph.func(ctx, i1, success[i1]);
			}
			for (i1 = 0; i1 < failure.length; i1++) {
				ctx.fillStyle = "orange";
				ctx.strokeStyle = "orange";
				graph.func(ctx, success.length + i1, failure[i1]);
			}
		}
	}
	function functiontimer(func, args) {
	// executes the function and returns the number of seconds it took to
	// execute.
		let starttime = new Date();
		func(...args);
		let endtime = new Date();
		return ((endtime.valueOf() - starttime.valueOf())/1000);
	}
	function forinspecial(code, object, runforparents, fis_i) {
	/*
	forinspecial(function(property, keychain, parent) {
		let propstring = keychain[keychain.length - 1];
	}, object, runforparents);
	//*/
	// if this works as intended, it will allow the function specified
	// to run for every property and property's property and property's
	// property's property, and so on. this is possible thanks to it
	// calling itself.
	// - the code should be a function with these arguments:
	//   - property (not the name/string, but the value stored in that
	//     property.)
	//   - keychain (an array of the strings of the property, the property's
	//     property, etc chain that this property is part of. .length can be
	//     used to know how deep in it is too.)
	//   - parent: the object the property is a property of (you could get this
	//     by using fis_i but that's annoying)
	// - runforparents: a boolean. if true, code will run for properties
	//   that are objects themselves. if not, it'll skip those.
	// - fis_i: don't type anything for this. this is just a variable,
	//   the only reason it's a parameter is so it can be passed into
	//   into the next iteration.
	// =
	// moved to reusables
		if(fis_i === undefined) {
			fis_i = [];
		};
		if(fis_i.length > 1000) {
			return;
		};
		let fis_level = fis_i.length;
		// represents how many levels in it is. 0 is a property of the
		// object. 1 is a property's property. etc.
		for (fis_i[fis_level] in object) {
			if (object.hasOwnProperty(fis_i[fis_level])) {
			// check every property
				if(typeof object[fis_i[fis_level]] === "object" && !Array.isArray(object[fis_i[fis_level]]) && object[fis_i[fis_level]]) {
				// if this property is an object of its own, (and not an array or
				// null) run the function on it. (retain fis_i so you can keep track
				// of the keys)
				// - long story short, Object.keys().length CANNOT be
				//   used to check if something's an object. if it's a
				//   string, for whatever goddamn reason
				//   Object.keys(stringvariable) will be an array of as
				//   number strings as there are characters in the
				//   string.
				// - gotta use typeof, and also check its truthy/falsy
				//   status because object is used for anything that it
				//   can't categorize. also null. null is an object. i
				//   don't care what smart ass reasons they have for
				//   that. that's fuckin stupid
				//   - eh i guess it's pretty bad faith to assume it's
				//     because something something "well technically,
				//     technically that's the closest thing null can be
				//     defined as,". these are programmers. they
				//     probably have practical reasons. (but they better
				//     be damned good ones.)
					if(runforparents) {
						code(object[fis_i[fis_level]], fis_i, object);
					};
					forinspecial(code, object[fis_i[fis_level]], runforparents, fis_i);
					fis_i.splice(fis_i.length - 1, 1);
					// make sure those properties aren't retained in
					// fis_i
				}
				else {
				// if not, run the code
					code(object[fis_i[fis_level]], fis_i, object);
				};
			};
		}
	}
	/*
	function hasproperty(object, property) {
		return (isobject(object) && Object.keys(object).includes(property));
	}
	function getproperty(object, propertyname) {
		if(object.hasproperty(propertyname)) {
			return object[propertyname];
		}
		else {
			return false;
		};
	}
	//*/
	function arraytoobject(array) {
		let i1 = 0;
		if(!Array.isArray(array)) {
			if(typeof array === "object") {
				return array;
			}
			else {
				console.log("invalid input.");
				return;
			};
		};
		object = {};
		for (i1 = 0; i1 < array.length; i1++) {
			object[i1] = structuredClone(array[i1]);
		};
		return object;
	};
	function objecttoarray(object) {
		let i1 = 0;
		if(Array.isArray(object) || typeof object !== "object") {
			console.log("invalid input.");
			return;
		};
		array = [];
		for (i1 in object) {
			if (object.hasOwnProperty(i1) && Number.isInteger(Number(i1)) && (i1 || i1 === 0)) {
				array[Number(i1)] = structuredClone(object[i1]);
			};
		}
		return array;
	};
	function objarraylength(object) {
	// returns a number equivalent to the .length of an array. one more than the
	// highest integer property.
	// =
	// moved to reusables
		let i1 = "";
		let highest = null;
		for (i1 in object) {
			if (
				object.hasOwnProperty(i1) && Number.isInteger(Number(i1)) && (i1 || i1 === 0)
				&&
				(highest === null || Number(i1) > highest)
			) {
				highest = Number(i1);
			};
		}
		if(highest === null) {
			return 0;
		}
		else {
			return highest + 1;
		};
	}
	function logspecial(variables, preface, stringify) {
	// lets you log several variables at once in a very concise and clear way.
	// - variables: an object. just take a bunch of variables separated by
	//   commas, and add curly braces.
	// - preface: if present, it will log this string first. useful for letting
	//   you know where it is in the code.
	// - stringify: if true, objects will be logged as text instead of being
	//   logged separately.
	//   - if stringify === "get", it'll return the text instead of logging it.
	//     (this is useful for ProcAnims. drawing text on the canvas that says
	//     the state of a variable.)
		let i1 = 0;
		if(preface) {
			console.log(preface);
		};
		let text = "";
		let maxlength = 0;
		for (i1 in variables) {
			if (variables.hasOwnProperty(i1) && i1.length > maxlength) {
				maxlength = i1.length;
			}
		}
		for (i1 in variables) {
			if (variables.hasOwnProperty(i1) && (typeof variables[i1] !== "object" || stringify)) {
				text += (text ? String.fromCharCode(10) : "") + i1 + " ".repeat(maxlength - i1.length) + ": ";
				if(typeof variables[i1] === "object" && !Array.isArray(variables[i1])) {
					text += JSON.stringify(variables[i1]);
				}
				else {
					text += variables[i1];
				}
			}
		}
		if(text) {
			if(stringify === "get") {
				return text;
			}
			else {
				console.log(text);
			};
		};
		if(!stringify) {
			for (i1 in variables) {
				if (variables.hasOwnProperty(i1) && typeof variables[i1] === "object" && variables[i1]) {
					console.log(i1 + " ".repeat(maxlength - i1.length) + ": ");
					console.log(variables[i1]);
				}
			}
		}
	}
	function removewhitespace(input, join) {
	// used it on a bracketindent-ed JSON.stringify to convert it back to
	// JSON.parse-able text. (actually i don't know if JSON.parse is bothered by
	// whitespace but whatever. consistency. reversibility.)
	// - join: the character to use when .join-ing it back at the end. if it
	//   isn't a string, it'll return an unjoined array instead
	//   - NOTE: sets of quotes count as a single word.
		let i1 = 0;
		let i2 = 0;
		input = input.trim();
		let output = [];
		// an index for each word
		output[0] = "";
		let quotes = null;
		// stores null, or a character code for the kind of quotes it's in.
		let whitespacenum = 0;
		// a temp for the number of consecutive whitespaces
		for (i1 = 0; i1 < input.length; i1++) {
			let bool = false;
			// boolean for whether it entered quotes during this character. (to
			// keep quote enter conditions from also being quote exit
			// conditions)
			if(quotes === null && [34, 39, 96].includes(input.charCodeAt(i1))) {
			// enter quotes mode and save what kind of quote it is
				quotes = input.charCodeAt(i1);
				bool = true;
			};
			if(quotes !== null || input[i1].trim()) {
			// if it's in quotes, it shouldn't delete spaces and stuff like
			// that.
				output[output.length - 1] += input[i1];
				whitespacenum = 0;
			}
			else {
			// whitespace
				if(whitespacenum === 0) {
				// if onespace is on and this isn't a consecutive space, add a
				// new word
					output[output.length] = "";
				};
				whitespacenum++;
			};
			if(!bool && quotes !== null && input.charCodeAt(i1) === quotes) {
			// matches the beginning quotes, so exit quote mode
				quotes = null;
			};
		}
		if(typeof join === "string") {
			return output.join(join);
		}
		else {
			return output;
		};
	}
	function objlength(obj) {
	// returns the number of properties an object has.
		let i1 = 0;
		let num = 0;
		for (i1 in obj) {
			if (obj.hasOwnProperty(i1)) {
				num++;
			}
		}
		return num;
	};
	function newpropertyname(object, string) {
	// returns a version of the string you entered that, by adding numbers, is
	// not the name of a property the object already has.
	// - string: the name you want to give this property.
		let i1 = 0;
		let name = string;
		if(object.hasOwnProperty(string)) {
			let temp = (string ? "_" : "") + i1;
			// only add the underscore if string is truthy
			for (i1 = 1; object.hasOwnProperty(string + temp); i1++) {
			}
			name += temp;
			// increase i1 until it reaches a number that won't share a name with
			// another track.
		}
		return name;
	}
	function mapstructure(object, types) {
	// creates an array of arrays with property names. use it with compareobject
	// to check if the structure of two objects matches.
	// - types: if true, this will make it record the typeof instead of the
	//   property name.
	//   - obviously, only use this in combination with the normal mode, because
	//     otherwise changes to property names will slip through unnoticed.
		let i1 = 0;
		let array = [];
		for (i1 in object) {
			if (object.hasOwnProperty(i1)) {
				array[array.length] = (types ? typeofobject[i1] : i1);
				if(typeof object[i1] === "object") {
					array[array.length] = mapobjectstructure(object[i1]);
				};
			};
		}
		return array;
	}
	function noargumentscheck(args) {
	// returns a boolean for whether the function was run with no arguments.
	// - i use it for constructors because this is an easy way to be sure it's
	//   the kind of running where you're just running it so you can have an
	//   object with that class that you can insert the contents of another
	//   object into.
	// - anyway args should be an array or an object.
		let i1 = 0;
		for (i1 in args) {
			if (args.hasOwnProperty(i1) && typeof args[i1] !== "undefined") {
				return false;
			}
		}
		return true;
	}
	function getspheroidradius(angles, w, h, d) {
		return Math.hypot(
			(w/2)*Math.cos(angles[1])*Math.cos(angles[0])
			(h/2)*Math.cos(angles[1])*Math.sin(angles[0]),
			(d/2)*Math.sin(angles[1]),
		);
		// fucking really!!!??
		// - the me from a few whatevers ago sure was a bitch
	}
	function withinrect(x, y, rect) {
	// checks if the coordinates are within the rectangle object provided.
	// (which should be an object with .x, .y, .w, .h)
		return (
			x >= rect.x
			&&
			x < rect.x + rect.w
			&&
			y >= rect.y
			&&
			y < rect.y + rect.h
		);
	}
	function onrect(x, y, rect, leeway) {
		leeway ??= 0;
		if(leeway) {
			x = Math.floor(x/leeway)*leeway;
			y = Math.floor(y/leeway)*leeway;
		};
		return (
			(
				(Math.abs(x - rect.x) <= leeway || Math.abs(x - (rect.x + rect.w)) <= leeway)
				&&
				rect.y <= y && y <= (rect.y + rect.h)
			)
			//[rect.x, rect.x + rect.w].includes(x))
			// on an x line
			||
			(
				(Math.abs(y - rect.y) <= leeway || Math.abs(y - (rect.y + rect.h)) <= leeway)
				&&
				rect.x <= x && x <= (rect.x + rect.w)
			)
			//[rect.y, rect.y + rect.h].includes(y)
			// on a y line
		);
	}
	function reversearray(array) {
		let _array = [];
		let i1 = 0;
		for(i1 = array.length - 1; i1 >= 0; i1--) {
			_array[_array.length] = structuredClone(array[i1]);
		};
		return _array;
	};
	function randomarrayitem(array, number) {
	// use Infinity to return a shuffled array.
		if(array.length === 0) {
			return null;
		}
		else if(typeof number === "number" && number > 1) {
			let _array = structuredClone(array);
			let choices = [];
			let i1 = 0;
			for(i1 = 0; i1 < number && _array.length > 0; i1++) {
				let temp = Math.floor(Math.random()*_array.length);
				choices[i1] = structuredClone(_array[temp]);
				_array.splice(temp, 1);
			}
			return choices;
		}
		else {
			return structuredClone(array[ Math.floor(Math.random()*array.length) ]);
		};
	};
	function multirandom(obj) {
	// use a "_multi" property to specify properties that should have more than one item selected.
		let _obj = structuredClone(obj);
		let multi = {};
		if(_obj.hasOwnProperty("_multi")) {
			multi = structuredClone(_obj._multi);
			delete _obj._multi;
		}
		let i1 = 0;
		for(i1 in _obj) {
			if(_obj.hasOwnProperty(i1) && Array.isArray(_obj[i1])) {
				let num = multi.hasOwnProperty(i1) ? multi[i1] : 1;
				// number of array items to pick
				_obj[i1] = randomarrayitem(_obj[i1], num);
			}
		}
		return _obj;
	}
	function weightedselection(choices, odds) {
		let _choices = [];
		let i1 = 0;
		let i2 = 0;
		for(i1 = 0; i1 < odds.length; i1++) {
			if(typeof odds[i1] === "number" && !isNaN(odds[i1])) {
				for(i2 = 0; i2 < odds[i1]; i2++) {
					_choices[_choices.length] = choices[i1];
				}
			}
		}
		return randomarrayitem(_choices);
	}
	class ProcAnim {
	// a thing for making procedural animations.
	// - i have nowhere else to put this so, here's some semi-universal
	//   variables.
	//   - v.pos: position. an array for where the animation is played.
	//   - v.rhythm: this one, i've just invented. it's for mickey mousing.
	//     - this should be a string of letters and spaces.
	//     - each character is a frame.
	//     - if the character for the current frame is a letter, it's assumed a
	//       note plays in the accompanying music on this frame, and the
	//       animation will probably have something happen accordingly.
	//       - sometimes it will react differently depending on which note is
	//         used, but not always.
	//     - if the character is a space, there is no note on this frame.
	//     - if it's a dash, a note is being held. most of the time this is the
	//       same as a frame with no note, but not always.
	//     - any other characters will be ignored, so you can use |s to divide
	//       measures and .s to divide beats or whatever.
	//     - if the frame is past the end of the rhythm string, it loops
	//     - use rhythmat(v.rhythm, frame) to return the character for that frame.
		constructor() {
		// the functions will be overwritten by whatever you write, but these
		// are the templates your functions should be based on. under penalty
		// of:
		// - having variables disappear between frames
		// - having fillStyle and shit like that be an inconsistent mess
			this.v = {};
			// do not define anything here. do that in initB, because initA
			// clears this.
			this.initB = function() {
			// initialize variables, ctxsettings, and animations
				let v = this.v;
				let u = v.u;
				let ctx = v.ctxsettings.new;
				v.pos ??= [u.w/2, u.h/2];
				//ctx.fillStyle = "black";
				//v.variablename ??= 0;
				// - use ??= so that you don't overwrite the parent ProcAnim
				//   having set this already in initA
				//this.childanimationname = suite.childanimationname;
				//this.childanimationname.initA(u, duration, etc);
				v.initialized = true;
			};
			this.func = function(frame) {
				let i1 = 0;
				let i2 = 0;
				let i3 = 0;
				// this isn't related to ProcAnim, but forgetting i numbers can
				// cause a lot of trouble.
				let v = this.v;
				let u = v.u;
				let ctx = u.ctx;
				// for easy reference
				let exit = this.framestart(frame);
				if(exit) {
					return;
				};
				//
				// animate something.
				// - always define variables as a property of v, unless you're
				//   okay with them vanishing between frames.
				// - u stands for "universal object", it's an object that's a
				//   variable of the .run function. it contains things like the
				//   context, the frame width and height, (u.w and u.h
				//   respectively. you could also use ctx.canvas but whatever)
				//   the viewer, etc.
				// - don't worry about changing ctx properties. provided it
				//   isn't an object or function, it will be kept consistent
				//   from one frame to the next and will not interfere with the
				//   parent ProcAnim's ctx properties.
				//
				this.frameend(frame);
			};
		}
		initA(u, duration, etc) {
		// clears/creates .v, applies any variable definings specified
		// in etc, creates v.ctxsettings and v.initialized, runs initB.
		// - initB should contain initial variable definings, and running .initA
		//   for all the child ProcAnims it uses
			let i1 = 0;
			if(this.hasOwnProperty("v")) {
				for (i1 in this.v) {
					if(this.v.hasOwnProperty(i1)) {
						delete this.v[i1];
					};
				}
			}
			else {
				this.v = {};
			};
			// this may seem silly, but it's a way of making sure i can do fancy
			// object reference tricks. if an object is defined, object
			// reference disappears. so if i make it a reference to something
			// before i run initA, i can only retain that reference if that else
			// doesn't run.
			let v = this.v;
			v.u = u;
			v.duration = duration;
			if(etc) {
				for (i1 in etc) {
					if (etc.hasOwnProperty(i1)) {
						v[i1] = structuredClone(etc[i1]);
					}
				}
			}
			// for stuff like position, scale, etc. things that would clutter up
			// the arguments, but *would* be nice to specify
			if(!v.hasOwnProperty("ctxsettings") || !v.ctxsettings.hasOwnProperty("old") || !v.ctxsettings.hasOwnProperty("new")) {
				v.ctxsettings = {
					new: {},
					old: {},
				};
			}
			if(this.initB) {
				v.initialized = false;
				this.initB();
			}
			else {
				v.initialized = true;
			};
		}
		framestart(frame) {
		// plays at the beginning of every frame. returns a boolean for whether
		// it should return, also sets ctxsettings
			let v = this.v;
			let u = v.u;
			if(frame < 0 || frame >= v.duration) {
				return true;
				// tells it to return
			}
			if(!v.hasOwnProperty("initialized") || !v.initialized) {
				console.log("animation is not initialized. either initA was never run, or initB does not set .initialized as true.");
				return true;
			}
			v.ctxsettings.old = savectxsettings(u.ctx);
			// the settings of the outer ProcAnim at the time it played this one
			restorectxsettings(u.ctx, v.ctxsettings.new);
			// the settings within this ProcAnim, so that it can retain changes
			// from frame to frame
			return false;
		}
		frameend() {
		// sets ctxsettings
			let v = this.v;
			let u = v.u;
			v.ctxsettings.new = savectxsettings(u.ctx);
			restorectxsettings(u.ctx, v.ctxsettings.old);
		}
		render(ctx, u, duration, initarguments, funcarguments, sheet) {
		// runs through the ProcAnim and returns an object of imagedatas and
		// imageurls.
		// - there is no bgcolor argument because you can just do it yourself
		//   before running this. no sense making it so you have to create a new
		//   procanim just to start with an unorthodox static background
		// - u: specify extra properties for u, variables that you want all
		//   animations to be able to access. (for example, a viewer for 3d
		//   stuff)
		// - funcarguments: an array of arguments. basically, just write
		//   whatever you would write in a function parentheses, (except for
		//   frame) but put brackets around it.
		//   - thanks for spread syntax, whoever invented spread syntax. or put
		//     it in here. probably mozilla
		//   - without it i'd have to resort to an ugly-ass anonymous function
		// - sheet: an object with settings for turning it into a spritesheet.
		//   (it'll use the color of the 0, 0 pixel as the border color.)
		//   - ctx: required
		//   - columns: number of columns
		//   - borderwidth
			if(!u) {
				u = {};
			}
			else {
				if(u.hasOwnProperty("w")) {
					ctx.canvas.width = u.w;
				};
				if(u.hasOwnProperty("h")) {
					ctx.canvas.height = u.h;
				};
			};
			u.ctx = ctx;
			u.w = u.ctx.canvas.width;
			u.h = u.ctx.canvas.height;
			u.bg = u.ctx.getImageData(0, 0, u.w, u.h);
			// whatever image was there before
			u.imagedata = [];
			u.imageurl = [];
			u.mainanim = this;
			let frame = 0;
			// used as the iterator of the main procanim
			if(!funcarguments) {
				funcarguments = [];
			}
			funcarguments.splice(0, 0, frame);
			this.initA(u, duration, initarguments);
			for (frame = 0; frame < duration; frame++) {
				funcarguments[0] = frame;
				this.func(...funcarguments);
				u.imagedata[frame] = u.ctx.getImageData(0, 0, u.w, u.h);
				u.imageurl[frame] = u.ctx.canvas.toDataURL();
				u.ctx.putImageData(u.bg, 0, 0);
			}
			if(sheet && sheet.hasOwnProperty("ctx")) {
				sheet.columns ??= 4;
				sheet.borderwidth ??= 0;
				sheet.ctx.canvas.width = sheet.columns * (u.w + sheet.borderwidth) - sheet.borderwidth;
				sheet.ctx.canvas.height = Math.ceil(duration/sheet.columns) * (u.h + sheet.borderwidth) - sheet.borderwidth;
				sheet.ctx.fillStyle = getcolor(sheet.ctx, 0, 0);
				sheet.ctx.fillRect(0, 0, sheet.ctx.canvas.width, sheet.ctx.canvas.height);
				for (frame = 0; frame < duration; frame++) {
					sheet.ctx.putImageData(u.imagedata[frame], (frame%sheet.columns)*(u.w + sheet.borderwidth), Math.floor(frame/sheet.columns)*(u.h + sheet.borderwidth));
				};
			};
			return {imagedata: u.imagedata, imageurl: u.imageurl};
		}
		animtree(indent) {
		// returns a string visualizing all the procanims in this procanim, and
		// all the procanims in *those* procanims
		// - indent: used in recursion, ignore it
			let i1 = "";
			let output = [];
			indent ??= 0;
			for (i1 in this) {
				if (this.hasOwnProperty(i1) && this[i1] instanceof ProcAnim) {
					output[output.length] = "&#160;".repeat(indent + 1) + i1;
					// non-breaking space
					output[output.length] = this[i1].animtree(indent + 1);
				}
			}
			for (i1 = 0; i1 < output.length; i1++) {
				if(typeof output[i1] === "string") {
				}
				else if(Array.isArray(output[i1])) {
					output[i1] = output[i1].join(String.fromCharCode(10));
					output[i1] = "&#160;".repeat(indent) + output[i1];
				}
				else {
					console.log("this shouldn't happen");
				}
			}
			if(indent === 0) {
				return output;
			}
			else {
				return output.join(String.fromCharCode(10));
			}
		}
	}
	function rhythmat(rhythm, frame) {
		let i1 = 0;
		for(i1 = 0; i1 < rhythm.length; i1++) {
			if(rhythm.charAt(i1).toLowerCase() === rhythm.charAt(i1).toUpperCase() && ![" ", "-"].includes(rhythm.charAt(i1))) {
			// if it's not a letter, space, or dash, splice it out.
				rhythm = rhythm.slice(0, i1) + rhythm.slice(i1 + 1);
				i1--;
			}
		}
		return rhythm.charAt(frame%rhythm.length);
	}
	let suite = new ProcAnim();
	let slite = {};
	// this is for storing animations so minor that they can be functions. (ie
	// they don't need to save variables between frames, or preserve ctx
	// settings before running, or save changes to ctx settings within)
	// - it stands for "suite lite". i don't want the name to be too long, it
	//   sounds kinda funny, it's the same as suite except for one changed
	//   letter, which amuses me
	suite.dsrainbow2 = new ProcAnim();
	suite.dsrainbow2.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		v.ds_data ??= diamondsquare(false, 0, 0, 256, (input, level) => input + 64*randexponent(1, true)*( ( 2**(-1) )**(Math.log2(64) - level) ));
		v.initialized = true;
	};
	suite.dsrainbow2.func = function(frame, colorsatonce, flatten) {
	// - colorsatonce: there will be this many colors at the 1/6
	//   marks, and this many +1 between.
	//   - so if it's 1, it'll be orange until the 1/6 mark, then lime
	//     until the 2/6, etc, with the new color coming in for the
	//     lower value pixels first until the whole screen has become
	//     lime
	//   - but if it's 2, everything will be lime or mint by the 1/12
	//     mark. the first 1/6 will be orange, lime, and mint, the
	//     second will be lime, mint, and azure, etc. the idea of the
	//     1/6 marks being orange, lime, mint, etc only describes the
	//     highest value pixels
	// - flatten: the value of each pixel will only be relevant to
	//   determining which hue it is. the value when actually
	//   drawing it will bring it up to 255 so everything's just as
	//   dark/light.
	//   - recommended, since otherwise the boundary between lime
	//     and mint is too weak.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		// animate something.
		colorsatonce ??= 1;
		let ds_temp = 0;
		let colorsector = 0;
		let colortemp = "";
		// i've been trying to make every variable a property of one
		// variables object, since that's probably what a true ProcAnim
		// class will entail. ...but i might as well take the opportunity to
		// distinguish temps like these that change every frame from
		// everything else. these don't need to be stored between frames.
		for (i1 = 0; i1 < v.ds_data.length; i1++) {
			for (i2 = 0; i2 < v.ds_data[i1].length; i2++) {
				ds_temp = Math.floor(v.ds_data[i1][i2])%256;
				colorsector = 6*frame/v.duration;
				colorsector += colorsatonce*ds_temp/256;
				colorsector = Math.floor(colorsector)%6;
				/*
				colorsector = frame/v.duration + (ds_temp/256)*(v.duration/6);
				colorsector = Math.floor(6*colorsector)%6;
				//v.duration = 36
				// equivalent to colorsatonce: 36, flatten: false
				ora o -
				lim - o
				min   o -
				azu   - o
				pur -   o
				vio o   -
				//*/
				if(flatten) {
					ds_temp = 255;
				};
				ds_temp /= 4;
				colortemp = "rgb(";
				if((colorsector + 1)%6 < 2) {
					colortemp += Math.floor(4 * ds_temp);
				}
				else if(colorsector%3 === 1) {
					colortemp += Math.floor(3 * ds_temp);
				}
				else {
					colortemp += Math.floor(2 * ds_temp);
				};
				colortemp += ", ";
				if((colorsector + 5)%6 < 2) {
					colortemp += Math.floor(4 * ds_temp);
				}
				else if(colorsector%3 === 0) {
					colortemp += Math.floor(3 * ds_temp);
				}
				else {
					colortemp += Math.floor(2 * ds_temp);
				};
				colortemp += ", ";
				if((colorsector + 3)%6 < 2) {
					colortemp += Math.floor(4 * ds_temp);
				}
				else if(colorsector%3 === 2) {
					colortemp += Math.floor(3 * ds_temp);
				}
				else {
					colortemp += Math.floor(2 * ds_temp);
				};
				colortemp += ")";
				ctx.fillStyle = colortemp;
				ctx.fillRect(i1, i2, 1, 1);
			}
		}
		//
		this.frameend(frame);
	};
	suite.startrace = new ProcAnim();
	suite.startrace.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		v.pos ??= [u.w/2, u.h/2, 0];
		v.initialized = true;
	};
	suite.startrace.func = function(frame, xyrev, _3drev, starradius, dotradius, afterimages, dottedtrail, color) {
		let i0 = 0;
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		logspecial({frame, xyrev, _3drev, starradius, dotradius, afterimages, dottedtrail, color}, "= startrace =");
		let progress = 0;
		let currdotr = 0;
		let dotcoord = [];
		let prevcoord = [];
		let starplace = 0;
		for(i1 = 0; i1 < 5; i1++){
			prevcoord[i1] = [];
		}
		for(i0 = afterimages; i0 >= 0; i0--){
		// draw a bunch of afterimages first
			frame -= i0;
			if(frame >= 0 && frame < v.duration) {
				progress = frame/v.duration;
				// progress through the current star, expressed as a fraction
				if(!dottedtrail) {
					ctx.strokeStyle = color;
				};
				ctx.fillStyle = (dottedtrail && i0 !== 0 ? color : "white");
				/*
				if(v.mode === 1) {
					currdotr = easingplacement(0, dotradius, progress, "in/out", "sine");
					if(progress < .5) {
						starplace = easingplacement(0, .1, progress/2, "in/out", "sine");
					}
					else {
						starplace = easingplacement(.1, .2, (progress - .5)/2, "in/out", "sine");
					};
				}
				else {
				};
				//*/
				if(progress < .5) {
					currdotr = easingplacement(0, dotradius, progress*2, "out", "circ");
				}
				else {
					currdotr = easingplacement(dotradius, 0, (progress - .5)*2, "in", "circ");
				};
				starplace = easingplacement(0, .2, progress, "in/out", "circ") - .1;
				let startemp = Shape2d.build("star", 2*starradius, false, false, v.pos);
				for(i1 = 0; i1 < 5; i1++){
				// draw each dot and its trail
					//dotcoord = _3dstar(v.pos[0], v.pos[1], v.pos[2], starradius, (v.mode === 1 ? .1 : 0) + i1*.2 + starplace, xyrev);
					//dotcoord = _3dstar(v.pos[0], v.pos[1], v.pos[2], starradius, i1*.2 + starplace, xyrev);
					dotcoord = startemp.pathfraction(i1*.2 + starplace);
					dotcoord[2] = v.pos[2];
					dotcoord = revolve(xyrev, dotcoord, v.pos);
					dotcoord = revolve(_3drev, dotcoord, v.pos);
					// apply x scaling
					if(dottedtrail) {
						_3dcircle(viewer, ctx, dotcoord[0], dotcoord[1], dotcoord[2], currdotr, true);
					}
					else {
					// draw a smooth trail using _3dline
						if(i0 !== afterimages) {
						// if it's the first afterimage, there won't be
						// starting coordinates to use.
							_3dline(viewer, ctx, prevcoord[i1][0], prevcoord[i1][1], prevcoord[i1][2], dotcoord[0], dotcoord[1], v.pos[2], [2*prevcoord[i1][3], 2*currdotr]);
							// double the weight, since it's a radius being
							// turned into a diameter
							if(i0 === 0) {
							// make the end white
								_3dcircle(viewer, ctx, dotcoord[0], dotcoord[1], dotcoord[2], currdotr, true);
							};
						};
						prevcoord[i1] = [dotcoord[0], dotcoord[1], v.pos[2], currdotr];
						// save the coordinates and radius for use by the
						// next afterimage
					};
				}
			};
			frame += i0;
		}
		//
		this.frameend(frame);
	};
	suite.blast = new ProcAnim();
	suite.blast.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		v.pos ??= [u.w/2, u.h/2];
		v._lineexecute_code ??= function(context, x, y, weight) {
			circledraw(context, x, y, weight/2*(Math.random()/2 + .75), true);
		};
		v.initialized = true;
	};
	suite.blast.func = function(frame, angles, radius, starradius, starrev, length, color) {
	// - angles: this should be a 3d angle
	// - length: refers to the blast's length, in pixels. distance from the base
	//   to the end.
		let i0 = 0;
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		logspecial({angles, radius, starradius, starrev, length, color});
		// angles
		let blastcoord = [];
		let endcoord = [];
		let blastradius = 0;
		let prevcoord = [[], []];
		let starpoints = [];
		let anglenum = Angle.numbers(angles);
		for (i0 = 0; i0 < 2; i0++) {
			// the main part of the blast, then the white center
			progress = frame/v.duration;
			// progress through this blast
			// same meanings as before. the star, and the progress
			ctx.strokeStyle = (i0 ? "white" : color);
			blastradius = radius*easingplacement(1, 0, progress/2, "in", "sine");
			blastcoord = structuredClone(v.pos);
			// coordinates of the base of the blast
			for(i1=0; i1 < 3; i1++) {
				blastcoord[i1] += Math.random()*4*easingplacement(4, 1, progress, "out", "sine") - 2;
				// random offset that's wilder at the beginning
				blastcoord[i1] += anglenum[i1]*(blastradius + starradius)/8;
				// recoil with easing similar to the radius
			}
			blastradius += Math.random()*4 - 2;
			// and narrow a little as it fires (but add a little
			// randomness to that width so it looks erratic instead of
			// uniform)
			starpoints = [];
			// array of points to draw the star
			starpoints[10] = Math.random();
			// the angle for the star
			for (i1 = 0; i1 < 10; i1++) {
				starpoints[i1] = _3dstar(blastcoord[0], blastcoord[1], blastcoord[2], blastradius + (2*starradius - blastradius)/2, i1/10, starpoints[10]);
				starpoints[i1][2] = v.pos[2];
			}
			starpoints.splice(10, 1);
			starpoints = revolve(starrev, starpoints, v.pos);
			for (i1 = 0; i1 < 10; i1++) {
				nonaaline(ctx, starpoints[i1][0], starpoints[i1][1], starpoints[(i1+1)%10][0], starpoints[(i1+1)%10][1]);
			}
			//_3dstar(blastcoord[0], blastcoord[1], blastcoord[2], blastradius, "", Math.random(), "", [ctx, false, viewer]);
			if(i0 === 1) {
				// make the white center narrower
				blastradius *= Math.random();
			};
			endcoord = [];
			for (i1 = 0; i1 < 3; i1++) {
				endcoord[i1] = blastcoord[i1];
				// whole line jolts randomly
				//endcoord[i1] = v.pos[i1];
				// ending point remains stable
				//endcoord[i1] = blastcoord[i1];
				//blastcoord[i1] = v.pos[i1];
				// starting point remains stable
				endcoord[i1] += length*anglenum[i1];
			}
			_3dline(viewer, ctx, blastcoord[0], blastcoord[1], blastcoord[2], endcoord[0], endcoord[1], endcoord[2], blastradius);
			// this looks like one a' 'em homestucks,
			//blastcoord = revolve(angles, blastcoord, v.pos);
			//endcoord = revolve(angles, endcoord, v.pos);
			//_3dlineexecute(viewer, ctx, blastcoord[0], blastcoord[1], blastcoord[2], endcoord[0], endcoord[1], endcoord[2], blastradius, blastradius/2, v._lineexecute_code);
			// new version
			if(frame !== 0) {
			// draw an afterimage, if one exists
				_3dline(viewer, ctx, prevcoord[i0][0], prevcoord[i0][1], prevcoord[i0][2], prevcoord[i0][3], prevcoord[i0][4], prevcoord[i0][5], prevcoord[i0][6]);
				//_3dlineexecute(viewer, ctx, prevcoord[i0][0], prevcoord[i0][1], prevcoord[i0][2], prevcoord[i0][3], prevcoord[i0][4], prevcoord[i0][5], prevcoord[i0][6], prevcoord[i0][6]/2, v._lineexecute_code);
			};
			prevcoord[i0] = [blastcoord[0], blastcoord[1], blastcoord[2], endcoord[0], endcoord[1], endcoord[2], blastradius];
			// stores afterimage data, like before. just one frame of
			// afterimage.
		}
		//
		this.frameend(frame);
	};
	suite.starblast = new ProcAnim();
	suite.starblast.initB = function() {
	// initialize variables, ctxsettings, and animations
		let i1 = 0;
		let v = this.v;
		let u = v.u;
		u.viewer.offset.z = -24;
		v.pos ??= [u.w/2, u.h/2, 0];
		// coordinates of its center
		//v.mode ??= 0;
		// 1: weird easing thing i stumbled on
		suite.starblast.startrace = suite.startrace;
		suite.starblast.blast = suite.blast;
		v.startrace_v = [];
		v.blast_v = [];
		for (i1 = 0; i1 < 3; i1++) {
			v.startrace_v[i1] = {};
			this.startrace.v = v.startrace_v[i1];
			this.startrace.initA(u, null, {pos: v.pos});
			v.blast_v[i1] = {};
			this.blast.v = v.blast_v[i1];
			this.blast.initA(u, null, {pos: v.pos});
		}
		// thanks to object reference, position should change with the parent
		// ProcAnim's position. duration, i'll just set before every func
		// running.
		v.initialized = true;
	};
	suite.starblast.func = function(frame, framesperstar, starpause, pause, color, starradius, dotradius, xscaling, rotationperstar, afterimages, dottedtrail) {
	// - things this is missing compared to the original:
	//   - mode: i don't remember this super well and it'd have to be passed
	//     through arguments and shit...
	//   - the blast animation used to retain an afterimage from the previous
	//     blast.
	// - framesperstar: used as the duration for startrace
	// - starpause: frames between the beginnings and endings of starpause
	//   runnings
	// - pause: pause between  starradius, dottedtrail
	// - color: an array of three colors, used for the stars and blasts
	// - starradius: the radius of the stars in startrace (each one is smaller
	//   than the last, this is the radius of the largest. the blasts start
	//   twice as wide.)
	// - dotradius: the radius of the dots that trace the stars
	// - xscaling: the ratio of w/h for the star. this is used to determine the
	//   angle they have.
	// - rotationperstar: difference in orientation between stars (measured in
	//   circumferences, not radians)
	// - afterimages: number of frames to trace backward to create a trail.
	// - dottedtrail: by default, each afterimage connects to the last to make a
	//   smooth trail. this opts out of that.
	// - TODO
	//   - troubleshoot
	//     - the stuff that causes errors is that in suite.blast, the revolve
	//       returns undefined or something
	//     - since the blast is pretty versatile, i should probably have the
	//       stars in the background be in starblast's script instead..?
	//       - i'll add a parameter for running an anonymous function using the
	//         coordinates of the base of the blast as arguments. that way, i
	//         can keep the random offset.
		let i0 = 0;
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		if(!framesperstar && framesperstar !== 0) {
			framesperstar = 12;
		}
		if(!starpause && starpause !== 0) {
			starpause = 3;
		}
		if(!rotationperstar && rotationperstar !== 0) {
			rotationperstar = 1/45;
		}
		// measured in circumferences
		if(!color) {
			color = ["#3f3fbf", "#bf00bf", "#3fbf3f"];
		}
		if(!dotradius && dotradius !== 0) {
			dotradius = 4;
		}
		if(!xscaling && xscaling !== 0) {
			xscaling = Math.sqrt(2)/2;
		}
		// a scale factor like this makes it look more like it exists in
		// 3d space, thanks to the perspective tools.
		if(!afterimages && afterimages !== 0) {
			//afterimages = (v.mode === 1 ? Math.floor(.5*framesperstar) : Math.floor(.25*framesperstar));
			afterimages = Math.floor(.25*framesperstar);
		}
		if(!pause && pause !== 0) {
			pause = 2*afterimages;
		};
		// frames between the stars and the blasts
		if(!starradius && starradius !== 0) {
			starradius = u.h/4;
		}
		let starangle = [Math.cos(xscaling), 0];
		let blastangle = Math.cos(xscaling) - Math.PI/2;
		blastangle = [posmod(blastangle, 2*Math.PI), 0];
		// these are xz angles. the first is the angle the stars are
		// tilted at to compress them x-ways, the second is the
		// perpendicular angle the beam should fire at
		// temps
		//logspecial({frame, framesperstar, starpause, pause, color, starradius, dotradius, xscaling, rotationperstar, afterimages, dottedtrail});
		for (i1 = 0; i1 < 3; i1++) {
			v.startrace_v[i1].duration = framesperstar;
			v.startrace_v[i1].pos = v.pos;
			this.startrace.v = v.startrace_v[i1];
			suite.startrace.func(
				frame - i1*(framesperstar + starpause),
				(1 + i1)*rotationperstar*2*Math.PI,
				// xyrev: rotate a little with each star
				starangle,
				easingplacement(starradius, 0, (1 + i1)/4, "in", "sine"),
				// starradius: shrink a little with each star
				dotradius,
				afterimages,
				dottedtrail,
				color[i1]
				// color: use a new color in the array each time
			);
			v.blast_v[i1].duration = framesperstar;
			v.blast_v[i1].pos = v.pos;
			this.blast.v = v.blast_v[i1];
			suite.blast.func(
				-3*framesperstar - 2*starpause + frame - pause - i1*framesperstar,
				blastangle,
				// angles
				easingplacement(2*starradius, 0, i1/4, "out", "sine"),
				// radius: decrease with each blast
				starradius,
				starangle,
				2*u.w,
				// length
				color[i1]
			);
		}
		// TODO
		// - needs more breathing room between stars
		// - while the placement easing should definitely be slow at the
		//   points, the dot radius easing should be at it's maximum there
		// -
		// - make _3dline adjust weight using the z positions
		// - blast looks a little too erratic
		//   - make sure the randomness for the inner and outer are the same
		//     numbers?
		//   - decrease the randomness of the inner to make it more stable?
		//   - make it so the inner's radius is derivative of the outer's
		//     radius?
		//   - make it so the inner is .5 to 1 times as big?
		//   - add one frame of afterimage?
		// - add a parameter to _3dline for random weight, and use that?
		//   - eh, i dunno. that's not a job for _3dline because it'd be
		//     applied per pixel instead of per 3d distance.
		// -
		// - make the blasts cut off sharply, decreasing to 0 radius in the
		//   last few frames
		// - make it so the first star is tilted too
		// - increase the weight of the stars at the base of the blasts
		//78 frames
		//
		// add v., u.w, u.h
		// v.pos
		// currframe to frame
		// ctx2 to ctx
		// smoothtrail to dottedtrail
		//
		// at a bit of an impasse here.
		// - the goal of the ProcAnim class is to be able to subdivide and combine
		//   animations to create something interesting.
		// - this animation is kind of already there. to convert it, i should break
		//   it up into "dots tracing a star" and "homestuck blast"
		// - however. i don't feel like doing that
		//   - not right now, anyway
		// - but also. the more accumulation you have, the more parameters you need.
		//   presently there are 9 goddamn arguments.
		// - i think i'm gonna solve that with spread syntax. have arguments named
		//   after the subanimations.
		// - another problem: arguments are very limited, to the point that i'm
		//   considering making it the default to specify everything through the
		//   initA running
		//   - here's the thing: arguments entered through the etc parameter of
		//     initA become part of .v. that means they can be accessed very easily
		//     by the parent ProcAnim. parameters of .func cannot.
		//   - what that means for this animation is, the duration has to match the
		//     framesperstar, when framesperstar is a .func parameter that could
		//     change every frame for all i know.
		// - ANOTHER problem: how do i run multiple runnings of the same child
		//   animation over each other.
		//   - they'll all be using the same .v, so they'll overwrite each other's
		//     variables.
		//   - i can't just structuredClone them. structuredClone does not work on
		//     functions.
		//   - possible solutions
		//     - use toString(), .replace, and the function constructor
		//       - by far the wonkiest solution.
		//   - i think i have something.
		//   - create an array in the parent ProcAnim, that stores multiple .vs of
		//     the subanimation. when you're running the first iteration of the
		//     subanimation, set the subanimation's .v as [0]. for the second
		//     iteration, use [1].
		//   - this did require making a small change in initA though.
		//   - so in summary, to make an animation run multiple times...
		//     - in initB, create an array for it, make an empty object in as many
		//       indexes as there are runnings of it.
		//     - before the first initA, write "this.subanimationname.v =
		//       v.subanimationname[0]". do the same with [1] for the second, etc
		//     - and do the same every time you run a .func in your script.
		//
		this.frameend(frame);
	};
	suite.ds_bwcycle = new ProcAnim();
	suite.ds_bwcycle.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		v.ds_data ??= diamondsquare(false, 0, 0, 256, (input, level) => input + 64*randexponent(1, true)*( ( 2**(-1) )**(Math.log2(64) - level) ));
		v.increment ??= 128;
		v.initialized = true;
	};
	suite.ds_bwcycle.func = function(frame) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		//let temp = 0;
		for (i1 = 0; i1 < v.ds_data.length; i1++) {
			for (i2 = 0; i2 < v.ds_data[i1].length; i2++) {
				//temp = Math.floor(v.ds_data[i1][i2] + 256*currframe/numofframes)%256;
				if(Math.floor(v.ds_data[i1][i2] + frame)%v.increment < v.increment/2) {
					ctx.fillStyle = "white";
				}
				else {
					ctx.fillStyle = "black";
				};
				ctx.fillRect(i1, i2, 1, 1);
			}
		}
		//
		this.frameend(frame);
	};
	suite.revolvingrings = new ProcAnim();
	suite.revolvingrings.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		v.pos ??= [u.w/2, u.h/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		//this.childanimationname.initA(u, duration, etc);
		//
		v.initialized = true;
	};
	suite.revolvingrings.func = function(frame, shape2d, scale, numperring, accelfunc, ringspacing, ringinterval, donthidecenter) {
	// - shape2d: the shape it draws and rotates. it will be unaltered for
	//   shapes at the right side of the ring, and flipped in the y axis if the
	//   speed of the current ring is negative.
	// - scale: the number all shape2d dimensions are multiplied by
	// - numperring: number of shape duplicates the ring has
	// - accelfunc: either a number or a function.
	//   - every ring is faster than the last, ie the amount it revolves per
	//     frame is higher.
	//   - if it's a number, this should by how much of a difference there is
	//     between rings, measured in revolutions-per-frame. this will also be
	//     the revolution speed of the first ring.
	//   - if it's a function, it should have one parameter, "ringnum", and
	//     return the number of revolutions per frame it should have given that
	//     parameter.
	//     - so you could enter "(ringnum) => 1/3 + ringnum/12" for it to start
	//       at 1/3 and increase to 5/12, 6/12, 7/12, etc
	// - ringspacing: number of pixels between rings
	// - ringinterval: number of frames between the appearance of new rings
	// - donthidecenter: by default, the innermost ring is hidden since
	//   otherwise it blinks obnoxiously.
	// - TODO
	//   - use an easing thing by default, making the speed increase the same
	//     every time is underwhelming
	//   - add a boolean parameter that makes the rings stop appearing so that
	//     the last one leaves the screen before the animation ends.
	//     - use pos, u.w/u.h, and Math.hypot to figure out how long it takes to
	//       leave the screen
	//     - you'd also need to add the lowest x value of the path. what a pain.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		if(!shape2d) {
			shape2d = new Shape2d([
				{
					x: 0,
					y: 0,
				},
				{
					x: 1,
					y: 0,
				},
				{
					x: 1/3,
					y: 1/3,
				},
				{
					x: 1/3,
					y: 0,
				},
			]),
			scale = 12;
		}
		scale ??= 1;
		numperring ??= 21;
		// numperring
		if(!["function", "number"].includes(typeof accelfunc)) {
			accelfunc = 1/32;
		};
		ringspacing ??= 16;
		if(!ringinterval) {
			ringinterval = 4;
		};
		//
		let path = structuredClone(shape2d.path);
		for(i1 = 0; i1 < path.length; i1++) {
			path[i1][0] *= scale;
			path[i1][1] *= scale;
		};
		let negpath = structuredClone(path);
		for(i1 = 0; i1 < negpath.length; i1++) {
			negpath[i1][1] *= -1;
		};
		// flipped version
		let drawring = function(ctx, pos, r, shape2d, path, num, rev) {
			let i1 = 0;
			let i2 = 0;
			let _path = null;
			let revtemp = 0;
			for(i1 = 0; i1 < num; i1++) {
				revtemp = (rev + i1/num)*2*Math.PI;
				_path = structuredClone(path);
				for (i2 = 0; i2 < _path.length; i2++) {
					_path[i2][2] = 0;
				}
				_path = structuredClone(revolve(revtemp, _path, false, "xy"));
				for (i2 = 0; i2 < _path.length; i2++) {
					_path[i2].splice(2, 1);
					_path[i2][0] += r*Math.cos(revtemp);
					_path[i2][1] += r*Math.sin(revtemp);
				}
				shape2d.draw(ctx, pos[0], pos[1], false, shape2d.closed, _path);
			}
		};
		let numofrings = Math.ceil(frame/ringinterval);
		let r = 0;
		let frameselapsed = 0;
		// for this ring, that is
		let revoffset = 0;
		let ringspeed = 0;
		for(i1 = 0; i1 < numofrings + (donthidecenter ? 0 : -1); i1++) {
			//ctx.strokeStyle = ["#fb0", "#ff0", "#bf0", "#0fb", "#0ff", "#0bf", "#b0f", "#f0f", "#f0b"][i1%9];
			frameselapsed = frame - i1*ringinterval;
			r = frameselapsed*ringspacing/ringinterval;
			ringspeed = 0;
			if(typeof accelfunc === "function") {
				ringspeed = accelfunc(i1)*(i1%2 === 1 ? -1 : 1);
			}
			else if(typeof accelfunc === "number") {
				ringspeed = accelfunc*(i1 + 1)*(i1%2 === 1 ? -1 : 1);
			}
			else {
				console.log("this shouldn't happen");
			};
			revoffset = 2*Math.PI*((ringspeed*frameselapsed)%1);
			drawring(ctx, v.pos, r, shape2d, (ringspeed < 0 ? negpath : path), numperring, revoffset);
		}
		//circledraw(ctx, v.pos[0], v.pos[1], 32, true);
		//
		this.frameend(frame);
	};
	suite.shimmershape = new ProcAnim();
	suite.shimmershape.initB = function() {
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		//ctx.fillStyle = "black";
		//v.variablename ??= 0;
		v.initialized = true;
	};
	suite.shimmershape.func = function(frame, shape2d, numofpoints, cyclelength) {
	// connects many path fractions to draw a rough version of the shape, and
	// changes the offset for all of them every frame. the result is a distorted
	// version that's weird and warbly at the curves and corners.
	// - shape: shape2d
	// - numofpoints: if this is 16, it'll connect the points at the 1/16, 2/16,
	//   etc. you get the idea
	// - cyclelength: number of frames it takes for it to repeat. lower numbers
	//   are faster, etc. negative numbers make it go backwards.
	// - i think this might be what "shaky" line art like omori uses?
	//   - or maybe it's just slightly randomizing the coordinates.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		if(!numofpoints) {
			numofpoints = Math.ceil(shape2d.length/8);
			// in other words, the length of the path between path fractions is
			// 8 pixels or less.
		};
		let reverse = cyclelength < 0;
		if(typeof cyclelength !== "number") {
			cyclelength = 8;
		};
		cyclelength = Math.abs(cyclelength);
		let newshape = [];
		let offset = null;
		if(cyclelength === 0) {
			offset = 0;
		}
		else if(reverse) {
			offset = 1 - (frame%cyclelength)/cyclelength;
		}
		else {
			offset = (frame%cyclelength)/cyclelength;
		}
		offset /= numofpoints;
		for (i1 = 0; i1 < numofpoints - (shape2d.closed ? 0 : 1); i1++) {
			newshape[i1] = shape2d.pathfraction(offset + i1/numofpoints);
		}
		if(!shape2d.closed) {
		// if it isn't closed, make sure there's always a point at the beginning
		// and end.
			if(reverse || frame%cyclelength !== 0) {
				newshape.splice(0, 0, shape2d.pathfraction(0));
			};
			if(!reverse || frame%cyclelength !== 0) {
				newshape[newshape.length] = shape2d.pathfraction(1);
			};
		};
		shape2d.draw(ctx, v.pos[0], v.pos[1], false, shape2d.closed, newshape);
		//
		this.frameend(frame);
	};
	suite.polaris = new ProcAnim();
	suite.polaris.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		v.easing ??= {};
		v.easing.inorout ??= "in/out";
		v.easing.type ??= "sine";
		v.easing.overshoot ??= false;
		ctx.fillStyle = "white";
		v.initialized = true;
	};
	suite.polaris.func = function(frame, easefactor, revspeed, offcenter, starratio, radius) {
	// an animation of a sky of stars rotating.
	// - easefactor: fraction of the speed to ease.
	//   - for example, a value of 1/8 eith a revspeed of 1/32 will have the
	//     amount it moves per frame be (1/32)*(1 - 1/8) + (1/32 with easing
	//     applied)*1/8
	//   - easing is applied per revolution, ie it moves slower at the
	//     beginning/end of each revolution and faster in the middle
	//   - it uses sine in/out easing, but it's stored in v. variables, so that
	//     can be changed if you want.
	// - revspeed: revolutions per frame
	// - offcenter: the distance between the center of revolution and the point
	//   the stars are placed around. (having some difference adds some weight
	//   to it.)
	// - starratio: number of stars it places per pixel of circumference for the
	//   current ring
	// - radius: a number or function for the radius of the stars.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		revspeed ??= 1/32;
		easefactor ??= 1/8;
		offcenter ??= 16;
		starratio ??= 1/128;
		radius ??= () => Math.floor(1 + randexponent(2)*2);
		if(!v.hasOwnProperty("stars")) {
		// create the stars if there are none.
		// - i would put this in initB, but then the most important parameters
		//   would have to be crammed into the etc parameter. lame.
			let center = Math.random()*2*Math.PI;
			center = [v.pos[0] + offcenter*Math.cos(center), v.pos[1] + offcenter*Math.sin(center)];
			// a random point [offcenter] pixels away from v.pos
			let maxr = Math.max(
				Math.hypot(center[0], center[1]),
				// distance from top left
				Math.hypot(u.w - center[0], center[1]),
				// distance from top right
				Math.hypot(center[0], u.h - center[1]),
				// distance from bottom left
				Math.hypot(u.w - center[0], u.h - center[1]),
				// distance from bottom right
			);
			v.stars = [];
			let temp = 0;
			for (i1 = 0; i1 < maxr; i1++) {
				for (i2 = 0; i2 < Math.round(starratio*i1*2*Math.PI); i2++) {
					temp = Math.random()*2*Math.PI;
					v.stars[v.stars.length] = [center[0] + i1*Math.cos(temp), center[1] + i1*Math.sin(temp)];
				}
			}
		};
		let r = typeof radius === "function" ? 0 : radius;
		let temp = [];
		temp = 1/revspeed;
		// frames per revolution
		let angletemp = (frame%temp)/temp;
		// place within the rotation
		angletemp = temp*(1 - easefactor)*angletemp + easingplacement(0, temp*easefactor, angletemp, v.easing.inorout, v.easing.type, v.easing.overshoot);
		//let angletemp = temp*Math.floor(frame/temp) + temp*(1 - easefactor)*(frame%temp)/temp + easingplacement(0, temp*easefactor, (frame%temp)/temp, v.easing.inorout, v.easing.type, v.easing.overshoot);
		// substitute for frame number, adjusted to add easing
		/*
		if(v.hasOwnProperty("angletemp")) {
			console.log("frame " + frame + ": " + ((angletemp < v.angletemp ? temp : 0) + angletemp - v.angletemp));
		}
		v.angletemp = angletemp;
		//*/
		angletemp *= revspeed*2*Math.PI;
		for (i1 = 0; i1 < v.stars.length; i1++) {
			if(typeof radius === "function") {
				r = radius();
			};
			temp = revolve(angletemp, [v.stars[i1][0], v.stars[i1][1], 0], [v.pos[0], v.pos[1], 0], "xy");
			circledraw(ctx, temp[0], temp[1], r, true);
		}
		//
		this.frameend(frame);
	};
	suite.rhythmicshine = new ProcAnim();
	suite.rhythmicshine.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		//v.pos ??= [u.w/2, u.h/2];
		v.lines ??= [];
		v.initialized = true;
	};
	suite.rhythmicshine.func = function(frame, rhythm, shinelength, rotamount) {
	// - rhythm: rhythm string (see the comments at the top of the ProcAnim class
	//   for details)
	// - shinelength: frames per shine
	// - rotamount: amount of rotations each line does before it ends
	// - TODO
	//   - better defaults
	//   - figure out a rhythm that works well with it
	//   - maybe make shinelength an array of colors
	//   - maybe make shines hourglass-like
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		rhythm ??= "o".repeat(v.duration);
		shinelength ??= 4;
		rotamount ??= 1/2;
		if(rhythmat(rhythm, frame).toUpperCase() !== rhythmat(rhythm, frame).toLowerCase()) {
			v.lines[v.lines.length] = {
				x: Math.floor(Math.random()*u.w),
				y: Math.floor(Math.random()*u.h),
				angle: Math.random()*2*Math.PI,
				frame,
			};
		}
		let temp = null;
		for (i1 = 0; i1 < v.lines.length; i1++) {
			if((frame - v.lines[i1].frame) <= shinelength) {
				temp = {
					x: v.lines[i1].x,
					y: v.lines[i1].y,
					angle: v.lines[i1].angle + (frame - v.lines[i1].frame)*2*Math.PI*(rotamount/shinelength),
				};
				temp.x1 = temp.x - Math.hypot(u.w, u.h)*Math.cos(temp.angle);
				temp.y1 = temp.y - Math.hypot(u.w, u.h)*Math.sin(temp.angle);
				temp.x2 = temp.x + Math.hypot(u.w, u.h)*Math.cos(temp.angle);
				temp.y2 = temp.y + Math.hypot(u.w, u.h)*Math.sin(temp.angle);
				nonaaline(ctx, temp.x1, temp.y1, temp.x2, temp.y2);
			}
			else {
				v.lines.splice(i1, 1);
				i1--;
			};
		}
		//
		this.frameend(frame);
	};
	suite.linerevolvetest = new ProcAnim();
	suite.linerevolvetest.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		ctx.font = "16px 'fomp2'";
		ctx.textBaseline = "top";
		v.initialized = true;
	};
	suite.linerevolvetest.func = function(frame, a_color, b_color, timetable, xymode, zmode, rollmode) {
	// - timetable: decides how long each action takes.
	//   - roll
	//   - pause1
	//   - xyz
	//   - pause2
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		a_color = a_color ? a_color : "#ff007f";
		b_color = b_color ? b_color : "#007fff";
		let center = [u.w/2, u.h/2, -u.w/2];
		// for easy reference.
		let sphere_r = Math.min(u.w, u.h)/4;
		ctx.strokeStyle = "#3f3f3f";
		ctx.fillStyle = "#3f3f3f";
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		sphere_r, false);
		let point_r = 2.5;
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		point_r, true);
		if(!v.hasOwnProperty("angle")) {
		// random angle, with roll
			v.angle = [];
			//
			if(typeof xymode === "number") {
				v.angle[0] = xymode*Math.PI/180;
			}
			else {
				v.angle[0] = Math.random()*2*Math.PI;
			};
			//
			if(typeof zmode === "number") {
				v.angle[1] = zmode*Math.PI/180;
			}
			else if(zmode === "+") {
				v.angle[1] = Math.random()*Math.PI/2;
			}
			else if(zmode === "-") {
				v.angle[1] = -Math.random()*Math.PI/2;
			}
			else {
				v.angle[1] = (2*Math.random() - 1)*Math.PI/2;
			};
			//
			if(typeof rollmode === "number") {
				v.angle[2] = rollmode*Math.PI/180;
			}
			else {
				v.angle[2] = Math.random()*2*Math.PI;
			};
		};
		if(typeof timetable !== "object") {
			timetable = {};
		};
		/*
		timetable.xyz ??= v.duration/2;
		timetable.pause1 ??= 0;
		timetable.roll ??= v.duration/2;
		timetable.pause2 ??= 0;
		//*/
		timetable.xyz ??= v.duration/4;
		timetable.pause1 ??= v.duration/4;
		timetable.roll ??= v.duration/4;
		timetable.pause2 ??= v.duration/4;
		let starts = {};
		starts.xyz_a = 0;
		starts.pause1_a = starts.xyz_a + timetable.xyz;
		starts.roll_a = starts.pause1_a + timetable.pause1;
		starts.roll_b = 0;
		starts.pause1_b = starts.roll_b + timetable.roll;
		starts.xyz_b = starts.pause1_b + timetable.pause1;
		starts.pause2 = timetable.xyz + timetable.pause1 + timetable.roll;
		starts.end = starts.pause2 + timetable.pause2;
		function inphase(phase) {
			let nextphase = {
				xyz_a: "pause1_a",
				pause1_a: "roll_a",
				roll_a: "pause2",
				roll_b: "pause1_b",
				pause1_b: "xyz_b",
				xyz_b: "pause2",
				pause2: "end",
			};
			//console.log("starts[" + phase + "] = " + starts[phase]
			//+ String.fromCharCode(10) + "starts[" + nextphase[phase] + "] = " + starts[nextphase[phase]]);
			return frame >= starts[phase] && frame < starts[nextphase[phase]];
		}
		// all this, just to be able to quickly check what phase it's in...
		// maybe i could streamline this with a ProcAnim static method or
		// something but i sure as hell won't do it today
		let points = {
			a: [
				[1, 0, 0],
				[1, 1, 0]
			],
			b: [
				[1, 0, 0],
				[1, 1, 0]
			],
		};
		points.a = [];
		points.b = [];
		//let distances = [];
		for (i1 = 0; i1 <= 8; i1++) {
			for (i2 = 0; i2 <= 8; i2++) {
				points.a[points.a.length] = [
					i1/8,
					i2/8,
					0
				];
				points.b[points.b.length] = [
					i1/8,
					i2/8,
					0
				];
				/*
				distances[distances.length] = Math.hypot(
					i1/8,
					i2/8,
					0
				);
				//*/
			}
		}
		// yes, the most efficient way is to have this start over every frame.
		function xyz_phase(points, angle, frametemp) {
			let angletemp = [];
			angletemp[0] = (
				angle[0] < Math.PI
				?
				frametemp*angle[0]
				:
				2*Math.PI + frametemp*(angle[0] - 2*Math.PI)
			);
			// multiply its distance from 0/360 by frametemp
			angletemp[1] = frametemp*angle[1];
			//logspecial({angletemp, points});
			return revolve(angletemp, points);
		}
		function roll_phase(points, angle, frametemp, set) {
			if(set === "a") {
				let angletemp = (v.angle[2] < Math.PI ? v.angle[2]*frametemp : 2*Math.PI + (v.angle[2] - 2*Math.PI)*frametemp);
				// same as xy
				if(inphase("roll_a")) {
					let anglenum = Angle.numbers(v.angle.slice(0, 2));
					ctx.strokeStyle = "white";
					_3dline(u.viewer, ctx,
						center[0] - sphere_r*anglenum[0],
						center[1] - sphere_r*anglenum[1],
						center[2] - sphere_r*anglenum[2],
						center[0] + sphere_r*anglenum[0],
						center[1] + sphere_r*anglenum[1],
						center[2] + sphere_r*anglenum[2]
					);
				}
				return revolve(angletemp, points, false, v.angle.slice(0, 2));
			}
			else if(set === "b") {
				let angletemp = (v.angle[2] < Math.PI ? v.angle[2]*frametemp : 2*Math.PI + (v.angle[2] - 2*Math.PI)*frametemp);
				// same as xy
				if(inphase("roll_b")) {
					ctx.strokeStyle = "white";
					_3dline(u.viewer, ctx,
						center[0] - sphere_r,
						center[1],
						center[2],
						center[0] + sphere_r,
						center[1],
						center[2]
					);
				}
				return revolve(angletemp, points, false, [0, 0]);
			}
			else {
				console.log("include the set.");
				return;
			};
		}
		if(inphase("xyz_a")) {
		// set a: xyz before the roll
			frametemp = (frame - starts.xyz_a)/timetable.xyz;
			// 0 = beginning of revolution, 1 = end
			points.a = xyz_phase(points.a, v.angle, frametemp);
			// xy/z revolution
			let anglenum = Angle.numbers(v.angle.slice(0, 2));
			ctx.strokeStyle = "green";
			_3dcircle(u.viewer, ctx,
				center[0] + sphere_r*anglenum[0],
				center[1] + sphere_r*anglenum[1],
				center[2] + sphere_r*anglenum[2],
				point_r,
				false
			);
		}
		else if(inphase("pause1_a")) {
			points.a = xyz_phase(points.a, v.angle, 1);
			let anglenum = Angle.numbers(v.angle.slice(0, 2));
			ctx.strokeStyle = "green";
			_3dcircle(u.viewer, ctx,
				center[0] + sphere_r*anglenum[0],
				center[1] + sphere_r*anglenum[1],
				center[2] + sphere_r*anglenum[2],
				point_r,
				false
			);
		}
		else if(inphase("roll_a")) {
			points.a = xyz_phase(points.a, v.angle, 1);
			// apply the first phase's revolution
			frametemp = (frame - starts.roll_a)/timetable.roll;
			points.a = roll_phase(points.a, v.angle, frametemp, "a");
		};
		if(inphase("roll_b")) {
		// set b: roll before xyz (aka what a is trying to recreate)
			frametemp = (frame - starts.roll_b)/timetable.roll;
			points.b = roll_phase(points.b, v.angle, frametemp, "b");
			// roll
		}
		else if(inphase("pause1_b")) {
			points.b = roll_phase(points.b, v.angle, 1, "b");
		}
		else if(inphase("xyz_b")) {
			points.b = roll_phase(points.b, v.angle, 1, "b");
			frametemp = (frame - starts.xyz_b)/timetable.xyz;
			points.b = xyz_phase(points.b, v.angle, frametemp);
		};
		if(inphase("pause2")) {
		// make sure all revolutions are done
			points.a = xyz_phase(points.a, v.angle, 1);
			points.a = roll_phase(points.a, v.angle, 1, "a");
			points.b = roll_phase(points.b, v.angle, 1, "b");
			points.b = xyz_phase(points.b, v.angle, 1);
		};
		for (i1 in {b: true, a: true}) {
			if (points.hasOwnProperty(i1)) {
				if(i1 === "a") {
					ctx.strokeStyle = a_color;
					ctx.fillStyle = a_color;
				}
				else if(i1 === "b") {
					ctx.strokeStyle = b_color;
					ctx.fillStyle = b_color;
				};
				// points[set][point or satellite][coordinate]
				_3dline(u.viewer, ctx,
					center[0],
					center[1],
					center[2],
					center[0] + sphere_r*points[i1][0][0],
					center[1] + sphere_r*points[i1][0][1],
					center[2] + sphere_r*points[i1][0][2]
				);
				_3dline(u.viewer, ctx,
					center[0] + sphere_r*points[i1][0][0],
					center[1] + sphere_r*points[i1][0][1],
					center[2] + sphere_r*points[i1][0][2],
					center[0] + sphere_r*points[i1][1][0],
					center[1] + sphere_r*points[i1][1][1],
					center[2] + sphere_r*points[i1][1][2]
				);
				for (i2 = 0; i2 < points[i1].length; i2++) {
					_3dcircle(u.viewer, ctx,
						center[0] + sphere_r*points[i1][i2][0],
						center[1] + sphere_r*points[i1][i2][1],
						center[2] + sphere_r*points[i1][i2][2],
					point_r, i2 === 0);
					// filled circle for the point, hollow circles for
					// satellites
					/*
					let r = Math.hypot(points[i1][i2][0], points[i1][i2][1], points[i1][i2][2]);
					if(Math.abs(r - distances[i2]) > .0000000001) {
						console.log("point[" + i1 + "][" + i2 + "] dist = " + r);
					};
					//*/
				}
			}
		}
		// draw the points
		ctx.fillStyle = "white";
		let text = numalign([Math.trunc(v.angle[0]*180/Math.PI), Math.trunc(v.angle[1]*180/Math.PI), Math.trunc(v.angle[2]*180/Math.PI)]);
		text[0] = "xy  : " + text[0];
		text[1] = "z   : " + text[1];
		text[2] = "roll: " + text[2];
		let lineheight = 12;
		for (i1 = 0; i1 < text.length; i1++) {
			ctx.fillText(text[i1], 4, i1*lineheight);
		}
		let currphase = [];
		for (i1 in starts) {
			if (starts.hasOwnProperty(i1) && inphase(i1)) {
				currphase[currphase.length] = i1;
			}
		}
		for (i1 = 0; i1 < currphase.length; i1++) {
			if(currphase[i1].endsWith("_a")) {
				ctx.fillStyle = a_color;
				ctx.fillText(currphase[i1].slice(0, currphase[i1].lastIndexOf("_a")), 4, u.h - (2 + i1)*lineheight);
			}
			else if(currphase[i1].endsWith("_b")) {
				ctx.fillStyle = b_color;
				ctx.fillText(currphase[i1].slice(0, currphase[i1].lastIndexOf("_b")), 4, u.h - (2 + i1)*lineheight);
			}
			else {
				ctx.fillText(currphase[i1], 4, u.h - (2 + i1)*lineheight);
			}
		}
		if(inphase("pause2")) {
			let diff = Math.hypot(
				points.a[1][0] - points.b[1][0],
				points.a[1][1] - points.b[1][1],
				points.a[1][2] - points.b[1][2]
			);
			ctx.fillStyle = (diff <= .00001 ? "green" : "orange");
			ctx.fillText(diff, 4, text.length*lineheight);
		};
		// write the angle and diff
		//
		this.frameend(frame);
	};
	suite.glrtest = new ProcAnim();
	suite.glrtest.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		v.x = randexponent(1, true);
		ctx.font = "16px 'fomp2'";
		ctx.textBaseline = "top";
		v.initialized = true;
	};
	suite.glrtest.func = function(frame) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		let center = [u.w/2, u.h/2, -u.w/2];
		// for easy reference.
		let sphere_r = Math.min(u.w, u.h)/4;
		ctx.strokeStyle = "#3f3f3f";
		ctx.fillStyle = "#3f3f3f";
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		sphere_r, false);
		let point_r = 2.5;
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		point_r, true);
		//
		let angle = 2*Math.PI*frame/v.duration;
		//*
		angle = [0, Math.sin(angle), Math.cos(angle)];
		angle[0] = v.x;
		angle[1] *= Math.sin(Math.acos(v.x));
		angle[2] *= Math.sin(Math.acos(v.x));
		angle = Angle.get(...angle);
		//*/
		ctx.fillStyle = "white";
		ctx.strokeStyle = "white";
		let anglenum = Angle.numbers(angle);
		_3dcircle(u.viewer, ctx,
			center[0] + sphere_r*anglenum[0],
			center[1] + sphere_r*anglenum[1],
			center[2] + sphere_r*anglenum[2],
		point_r, true);
		//let lr = getlinerevolve(angle);
		//anglenum = Angle.numbers(lr.axis.angle);
		let lr = GLR.new(angle);
		anglenum = Angle.numbers(GLR.axis(lr));
		let circ_hw = Angle.numbers(angle);
		circ_hw = Math.abs(Math.sin(get2dangle(circ_hw[2], circ_hw[1])));
		_3dline(u.viewer, ctx,
			center[0] - sphere_r*anglenum[0],
			center[1] - sphere_r*anglenum[1],
			center[2] - sphere_r*anglenum[2],
			center[0] + sphere_r*anglenum[0],
			center[1] + sphere_r*anglenum[1],
			center[2] + sphere_r*anglenum[2]
		);
		let pc = {
			center: perspectiveconvert(u.viewer, center[0], center[1], center[2]),
			right: perspectiveconvert(u.viewer, center[0] + sphere_r, center[1], center[2]),
			bottom: perspectiveconvert(u.viewer, center[0], center[1] + sphere_r*circ_hw, center[2]),
		};
		pc.radius = [
			pc.right[0] - pc.center[0],
			pc.bottom[1] - pc.center[1],
		];
		circledraw(ctx, pc.center[0], pc.center[1], pc.radius);
		_3dcircle(u.viewer, ctx,
			center[0] + sphere_r*Math.cos(lr.magnitude),
			center[1] + sphere_r*Math.sin(lr.magnitude)*circ_hw,
			center[2],// + sphere_r*Math.cos(Math.asin(circ_hw)),
		point_r, true);
		// show the magnitude
		let text = logspecial({
			xy: numalign([angle[0]*180/Math.PI, 360])[0],
			z: numalign([angle[1]*180/Math.PI, -90])[0],
			frame_angle: numalign([360*frame/v.duration, 360])[0],
			axis_angle: numalign([get2dangle(anglenum[1], anglenum[2])*180/Math.PI, 360])[0],
			circ_hw,
			//anglenum_y: Angle.numbers(angle)[1],
			magnitude: lr.magnitude*180/Math.PI,
		}, false, "get").split(String.fromCharCode(10));
		let lineheight = 12;
		for (i1 = 0; i1 < text.length; i1++) {
			ctx.fillText(text[i1], 4, i1*lineheight);
		}
		v.circgraph ??= [];
		v.circgraph[frame] = circ_hw;
		let temp = (u.w/v.duration);
		for (i1 = 0; i1 < v.circgraph.length; i1++) {
			ctx.fillStyle = i1 === frame ? "white" : "#3f3f3f";
			ctx.fillRect(temp*i1, u.h, temp, -v.circgraph[i1]*u.h/4);
		}
		//
		this.frameend(frame);
	};
	suite.rolldirtest = new ProcAnim();
	suite.rolldirtest.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		v.angle ??= Angle.rand();
		//v.angle[1] = 0;
		//v.angle[1] = .0000000001;
		let anglenum = Angle.numbers(v.angle);
		v.circle = [];
		let i1 = 0;
		for (i1 = 0; i1 < v.duration; i1++) {
		// does the math for every frame
		// - this is done at initialization because i want to be able to draw
		//   the whole circle.
			v.circle[i1] = {
				roll: 2*Math.PI*i1/v.duration,
				// this is the roll angle
			};
			let ref = v.circle[i1];
			let temp = rolldirection([v.angle[0], v.angle[1], ref.roll]);
			// roll direction
			ref.inaccuracy = Angle.compare(v.angle, temp);
			// 2d angle between them
			ref.inaccuracy = Math.abs(Math.PI/2 - ref.inaccuracy)/(Math.PI/2);
			// how far it is from 90, measured in 90 degree arcs (0 means it's
			// perpendicular)
			ref.inaccuracy = Math.trunc(ref.inaccuracy*(10**10))/(10**10);
			ctx.strokeStyle = "rgb(255" + (", " + (255*ref.accuracy)).repeat(2) + ")";
			ref.point = Angle.numbers(temp);
			ref.point[0] += anglenum[0];
			ref.point[1] += anglenum[1];
			ref.point[2] += anglenum[2];
		}
		ctx.font = "16px 'fomp2'";
		ctx.textBaseline = "top";
		v.initialized = true;
	};
	suite.rolldirtest.func = function(frame) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		let center = [u.w/2, u.h/2, -u.w/2];
		// for easy reference.
		let sphere_r = Math.min(u.w, u.h)/4;
		ctx.strokeStyle = "#3f3f3f";
		ctx.fillStyle = "#3f3f3f";
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		sphere_r, false);
		let point_r = 2.5;
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		point_r, true);
		//
		let point = Angle.numbers(v.angle);
		let satel = v.circle[frame].point;
		let temp = u.w/v.duration;
		for (i1 = 0; i1 < v.duration; i1++) {
		// i could optimize this by figuring all of this out at initB instead of
		// every frame but, i don't care
			let ref1 = v.circle[i1];
			let ref2 = v.circle[(i1 + 1)%v.duration];
			ctx.strokeStyle = "rgb(255" + (", " + (255*(1 - Math.min(ref1.inaccuracy, 1)))).repeat(2) + ")";
			_3dline(u.viewer, ctx,
				center[0] + sphere_r*ref1.point[0],
				center[1] + sphere_r*ref1.point[1],
				center[2] + sphere_r*ref1.point[2],
				center[0] + sphere_r*ref2.point[0],
				center[1] + sphere_r*ref2.point[1],
				center[2] + sphere_r*ref2.point[2]
			);
			ctx.fillStyle = (i1 === frame ? "white" : ctx.strokeStyle);
			ctx.fillRect(i1*temp, u.h, temp, -ref1.inaccuracy*u.h/4);
		}
		// draw the circle
		//let lr = getlinerevolve(v.angle);
		//let lr_num = Angle.numbers(lr.axis.angle);
		let lr = GLR.new(v.angle);
		let circ_hw = Angle.numbers(v.angle);
		circ_hw = Math.abs(Math.sin(get2dangle(circ_hw[2], circ_hw[1])));
		let lr_num = Angle.numbers(GLR.axis(lr));
		ctx.strokeStyle = "green";
		let pc = {
			center: perspectiveconvert(u.viewer, center[0], center[1], center[2]),
			right: perspectiveconvert(u.viewer, center[0] + sphere_r, center[1], center[2]),
			bottom: perspectiveconvert(u.viewer, center[0], center[1] + sphere_r*circ_hw, center[2]),
		};
		pc.radius = [
			pc.right[0] - pc.center[0],
			pc.bottom[1] - pc.center[1],
		];
		circledraw(ctx, pc.center[0], pc.center[1], pc.radius);
		_3dline(u.viewer, ctx,
			center[0] - sphere_r*lr_num[0],
			center[1] - sphere_r*lr_num[1],
			center[2] - sphere_r*lr_num[2],
			center[0] + sphere_r*lr_num[0],
			center[1] + sphere_r*lr_num[1],
			center[2] + sphere_r*lr_num[2]
		);
		ctx.fillStyle = "white";
		ctx.strokeStyle = "white";
		_3dline(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
			center[0] + sphere_r*point[0],
			center[1] + sphere_r*point[1],
			center[2] + sphere_r*point[2]
		);
		_3dcircle(u.viewer, ctx,
			center[0] + sphere_r*point[0],
			center[1] + sphere_r*point[1],
			center[2] + sphere_r*point[2],
		point_r, true);
		_3dline(u.viewer, ctx,
			center[0] + sphere_r*point[0],
			center[1] + sphere_r*point[1],
			center[2] + sphere_r*point[2],
			center[0] + sphere_r*satel[0],
			center[1] + sphere_r*satel[1],
			center[2] + sphere_r*satel[2]
		);
		_3dcircle(u.viewer, ctx,
			center[0] + sphere_r*satel[0],
			center[1] + sphere_r*satel[1],
			center[2] + sphere_r*satel[2],
		point_r, true);
		let text = logspecial({
			inaccuracy: v.circle[frame].inaccuracy,
			xy: numalign([Math.round(v.angle[0]*180/Math.PI), 360])[0],
			z: numalign([Math.round(v.angle[1]*180/Math.PI), -90])[0],
			roll: numalign([Math.round(v.circle[frame].roll*180/Math.PI), 360])[0],
		}, false, "get").split(String.fromCharCode(10));
		let lineheight = 12;
		for (i1 = 0; i1 < text.length; i1++) {
			ctx.fillText(text[i1], 4, i1*lineheight);
		}
		//
		this.frameend(frame);
	};
	suite.linefindtest = new ProcAnim();
	suite.linefindtest.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		ctx.font = "16px 'fomp2'";
		ctx.textBaseline = "top";
		v.initialized = true;
	};
	suite.linefindtest.func = function(frame, mode, mod, increment) {
	// tests both Line.findposition and Line.findplace
	// - mode
	//   - "place": it gets coordinates using .findplace, and draws circles
	//     there
	//   - "position": it gets coordinates using angle numbers, and draws the
	//     .findplace it gets at those coordinates.
	// - mod: if true for place mode, it uses findposition on the random place
	//   then findplace on it. if true for position mode, it uses findplace then
	//   findposition. either way, it *should* barely change it.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		increment = typeof increment === "number" ? increment : 1/8;
		mode = ["place", "position"].includes(mode) ? mode : "position";
		mod = true;
		//
		let center = [u.w/2, u.h/2, -u.w/2];
		// for easy reference.
		let sphere_r = Math.min(u.w, u.h)/4;
		ctx.strokeStyle = "#3f3f3f";
		ctx.fillStyle = "#3f3f3f";
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		sphere_r, false);
		let point_r = 2.5;
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		point_r, true);
		//
		function getstyle(value) {
			if(value < 0) {
			// redder the lower it is, peaking at -1
				return "rgb(255" + (", " + ((1 - Math.abs(i1))*255)).repeat(2) + ")";
			}
			else if(value > 0) {
			// more cyan the higher it is, peaking at 1
				return "rgb(" + ((1 - Math.abs(i1))*255) + ", 255, 255)";
			}
			else {
				return "white";
			};
			// looks like one of those three-flavor popsicles.
		}
		let line = new Line(0, 0, 0, Angle.rand());
		let anglenum = Angle.numbers(line.angle);
		let prevpos = null;
		let prevneg = null;
		ctx.strokeStyle = "white";
		for (i1 = 0; i1 <= 1; i1 += increment) {
			for (i2 = -1; i2 <= Math.sign(i1); i2 += 2) {
				ctx.fillStyle = getstyle(i2*i1);
				if(mode === "place") {
					let point = line.findposition(i2*i1);
					if(mod) {
						point = line.findposition(line.findplace(point));
					}
					//*
					if(Math.sign(i2*i1) === 1) {
						_3dline(u.viewer, ctx,
							center[0] + sphere_r*prevpos[0],
							center[1] + sphere_r*prevpos[1],
							center[2] + sphere_r*prevpos[2],
							center[0] + sphere_r*point[0],
							center[1] + sphere_r*point[1],
							center[2] + sphere_r*point[2]
						);
						prevpos = structuredClone(point);
					}
					else if(Math.sign(i2*i1) === -1) {
						_3dline(u.viewer, ctx,
							center[0] + sphere_r*prevneg[0],
							center[1] + sphere_r*prevneg[1],
							center[2] + sphere_r*prevneg[2],
							center[0] + sphere_r*point[0],
							center[1] + sphere_r*point[1],
							center[2] + sphere_r*point[2]
						);
						prevneg = structuredClone(point);
					}
					else {
						prevpos = structuredClone(point);
						prevneg = structuredClone(point);
					};
					//*/
					_3dcircle(u.viewer, ctx,
						center[0] + sphere_r*point[0],
						center[1] + sphere_r*point[1],
						center[2] + sphere_r*point[2],
					point_r, true);
				}
				else if(mode === "position") {
					let point = [
						i2*i1*anglenum[0],
						i2*i1*anglenum[1],
						i2*i1*anglenum[2]
					];
					if(mod) {
						point = line.findposition(line.findplace(point));
					};
					let place = line.findplace(point);
					let pc = perspectiveconvert(u.viewer,
						center[0] + sphere_r*point[0],
						center[1] + sphere_r*point[1],
						center[2] + sphere_r*point[2]
					);
					ctx.fillText(Math.round(place/increment), pc[0], pc[1]);
				};
			}
		}
		ctx.strokeStyle = "green";
		_3dline(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
			center[0] + sphere_r*anglenum[0],
			center[1] + sphere_r*anglenum[1],
			center[2] + sphere_r*anglenum[2]
		);
		ctx.fillStyle = "yellow";
		let text = logspecial({
			xy: numalign([Math.round(line.angle[0]*180/Math.PI), 360])[0],
			z: numalign([Math.round(line.angle[1]*180/Math.PI), -90])[0],
		}, false, "get").split(String.fromCharCode(10));
		let lineheight = 12;
		for (i1 = 0; i1 < text.length; i1++) {
			ctx.fillText(text[i1], 4, i1*lineheight);
		}
		//
		this.frameend(frame);
	};
	suite.skill_up = new ProcAnim();
	suite.skill_up.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2, -u.w/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		v.stretch ??= u.h/2;
		// how many pixels long the stretch is
		v.stretchtime = 12;
		v.weight ??= 4;
		v.endpause ??= 8;
		if((v.particles ?? null) === null) {
			v.particles = [];
			let i1 = 0;
			for (i1 = 0; i1 < 48; i1++) {
				v.particles[i1] = {
					pos: [
						Math.floor(Math.random()*u.w),
						u.h + Math.floor(Math.random()*u.h),
						-Math.floor(Math.random()*u.w),
					],
					stretchstart: Math.floor(Math.random()*(v.duration - (v.stretchtime + v.endpause))),
				};
			}
		}
		v.color ??= "#003fff";
		//
		v.initialized = true;
	};
	suite.skill_up.func = function(frame) {
	// needs much more polish.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		viewer = u.viewer;
		ctx.strokeStyle = v.color;
		for (i1 = 0; i1 < v.particles.length; i1++) {
			let time = (frame - v.particles[i1].stretchstart)/v.stretchtime;
			// negative if it hasn't happened yet, over 1 if it has
			let ymod = -2*u.h*frame/(v.duration - (v.stretchtime + v.endpause));
			// how much to increase the y by, not factoring in the earthworming
			if(time < 0) {
				_3dcircle(
					viewer,
					ctx,
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod,
					v.particles[i1].pos[2],
					v.weight/2,
					true
				);
			}
			else if(time >= 0 && time < .5) {
				time = easingplacement(0, 1, time*2, "in/out", "sine");
				_3dline(
					viewer,
					ctx,
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod,
					v.particles[i1].pos[2],
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod - time*v.stretch,
					v.particles[i1].pos[2],
					v.weight
				);
			}
			else if(time >= .5 && time < 1) {
				time = easingplacement(0, 1, (time - .5)*2, "in/out", "sine");
				_3dline(
					viewer,
					ctx,
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod - time*v.stretch,
					v.particles[i1].pos[2],
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod - v.stretch,
					v.particles[i1].pos[2],
					v.weight
				);
			}
			else if(time >= 1) {
				_3dcircle(
					viewer,
					ctx,
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod - v.stretch,
					v.particles[i1].pos[2],
					v.weight/2,
					true
				);
			}
			else {
				console.log("this shouldn't happen");
			};
		}
		//
		this.frameend(frame);
	};
	suite.fireplaceybg = new ProcAnim();
	suite.fireplaceybg.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2, -u.w/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		v.color1 ??= "#7fff00";
		v.color2 ??= "#000000";
		// these must be hexadecimal codes.
		v.waveinterval = 4;
		v.waveinterval = Math.floor(v.duration/v.waveinterval)/v.duration;
		// converts it to an even divisor of v.duration. i think.
		v.bumpiness = 4;
		// number of pixels each column can vary from the previous
		v.speedvariation = .25;
		// each column moves 1 - speedvariation to 1 + speedvariation times
		// faster than the previous
		v.waveduration = 8;
		// number of frames it takes a wave column with .pos 0 to go from the
		// bottom of the screen to the top
		// - the initial speed is u.h/v.waveduration
		if((v.waves ?? null) === null) {
			v.waves = [];
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			for (i1 = 0; i1 < v.duration/v.waveinterval; i1++) {
				v.waves[i1] = {};
				v.waves[i1].cols = [];
				let ref = v.waves[i1].cols;
				for (i2 = 0; i2 < u.w; i2++) {
					for (i3 = 0; i3 < 2; i3++) {
						let index = [Math.floor(u.w/2 - i2), Math.ceil(u.w/2 + i2)][i3];
						//ref[i2] = 1 + Math.random();
						ref[index] = (1 + Math.random()*v.speedvariation);
						if(Math.random() < .5) {
							ref[index] = 1/ref[index];
						};
						if(i2 !== 0) {
							ref[index] *= ref[index + [1, -1][i3]];
						};
					}
				}
				let temp = Math.floor(Math.random()*u.w);
			}
		}
		//
		v.initialized = true;
	};
	suite.fireplaceybg.func = function(frame) {
	// TODO
	// - render after images for each wave? both the current frame and the
	//   afterimages are partial opacity and the same color, so it looks blurry
	// - render last indexes on the first frames
	// - improve the random speed
	//   - the way i want it is that every column's speed is derivative of the
	//     adjacent columns, and peaks and valleys form
	//   - but the problem is that column 0 always has the least range.
	//   - also i think something's wrong with how i apply random
	//     multiplication/division, even though it looks sound to me. things
	//     always get high at the ends, never low
	// - i am too bored of this to improve it, though,
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		let newest = Math.floor(v.waves.length*frame/v.duration);
		// the wave that began most recently.
		function renderwave(index) {
			let wave = v.waves[index];
			let wavestart = v.waveinterval*index;
			if(frame >= wavestart && frame < wavestart + v.waveduration) {
				ctx.fillStyle = colorgradient(v.color1, v.color2, posmod(frame - wavestart, v.waveduration)/v.waveduration);
				let i1 = 0;
				let i2 = 0;
				for (i1 = 0; i1 < wave.cols.length; i1++) {
					let speed1 = wave.cols[i1]*u.h/v.waveduration;
					let speed2 = u.h/v.waveduration;
					ctx.fillRect(i1, u.h, 1, Math.round(-(speed1 + speed2)/2)*(frame - wavestart));
				}
			}
			else {
				ctx.fillStyle = v.color2;
				ctx.fillRect(0, 0, u.w, u.h);
			};
		}
		for (i1 = newest + 1; i1 < v.waves.length; i1++) {
			renderwave(i1);
		}
		for (i1 = 0; i1 <= newest; i1++) {
			renderwave(i1);
		}
		// render every wave, starting from the oldest to the newest. since this
		// loops, you should start with the wave that begins after, and cycle
		// around.
		//
		this.frameend(frame);
	};
	suite.twitchyshape = new ProcAnim();
	suite.twitchyshape.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2, -u.w/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		//
		v.initialized = true;
	};
	suite.twitchyshape.func = function(frame, shape2d, x, y, scale, randrange, randfactor) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		if(!(shape2d instanceof Shape2d)) {
			shape2d = Shape2d.build("star", 128);
		}
		x = typeof x === "number" ? x : u.w/2;
		y = typeof y === "number" ? y : u.h/2;
		scale = typeof scale === "number" ? scale : 1;
		randrange = typeof randrange === "number" ? randrange : 8;
		randfactor = typeof randfactor === "number" ? randfactor : 2;
		let polygon = shape2d.path;
		for (i1 = 0; i1 < polygon.length; i1++) {
			polygon[i1] = [
				scale*polygon[i1][0] + x + Math.trunc(randrange*randexponent(randfactor, true)),
				scale*polygon[i1][1] + y + Math.trunc(randrange*randexponent(randfactor, true)),
			];
		}
		_2dPoly.draw(ctx, polygon, "both");
		//
		this.frameend(frame);
	};
	slite.drawtile = function(ctx, x, y, type, size, params) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		if(!params) {
			params = {};
		};
		if(type === "grass") {
		// params structure:
		// - rows (as in the number of them)
		// - blade_h (maximum height of a blade of grass, measured as a fraction of size)
		// - colors (array of colors for it to cycle through)
		// value is the number of silhouettes
			params.rows ??= 4;
			params.blade_h ??= 3/8;
			if((params.colors ?? null) === null) {
				params.colors = [
					"rgb(0,223,79)",
					"rgb(0,239,95)",
					"rgb(0,255,127)"
				];
				params.colors = [
					params.colors[0],
					params.colors[1]
				];
				// used to be dark to medium to light to medium, but it's
				// better if it's only two colors. it only needs just barely
				// enough for silhouettes to be possible, if the color
				// pattern is too distinct it'll easier to notice the
				// grid...
			}
			let colors = params.colors;
			let colorindex = Math.floor(Math.random()*colors.length);
			ctx.fillStyle = colors[colorindex];
			ctx.fillRect(x, y, size, size);
			let overflow = [];
			// structure:
			// - x
			// - h
			// - color
			for (i1 = 0; i1 < params.rows; i1++) {
				colorindex++;
				colorindex %= colors.length;
				let row_y = Math.floor(size*((i1 + 1)/params.rows));
				for (i2 = 0; i2 < size; i2++) {
					let temp = Math.floor(randexponent(1)*params.blade_h*size);
					// height of the blade
					if(temp > row_y) {
						overflow[overflow.length] = {
							x: i2,
							h: temp - row_y,
							color: colorindex,
						};
						temp = row_y;
					};
					ctx.fillStyle = colors[colorindex];
					ctx.fillRect(x + i2, y + row_y, 1, -temp);
					ctx.fillRect(x + i2, y + row_y, 1, size - row_y);
				};
			}
			for (i1 = 0; i1 < overflow.length; i1++) {
				ctx.fillStyle = colors[overflow[i1].color];
				ctx.fillRect(x + overflow[i1].x, y + size, 1, -overflow[i1].h);
			}
		}
		else if(type === "brick") {
		// params:
		// - rows: number of rows
		// - columns: number of columns
		// - desiccation: pixels will only be drawn if a Math.random() is
		//   below this.
		// - thickness: pixel width of the lines between bricks
		// - linecolor
		// - valuefunc, colorfunc: function for generating a random number,
		//   and a function for returning a brick color using that number.
			params.rows ??= 4;
			params.columns ??= 4;
			params.desiccation ??= .875;
			params.thickness ??= 1;
			params.linecolor ??= hsvtorgb(30, 25, 94.75, true);
			//params.valuefunc ??= () => (1 - randexponent(3)) < .75 ? .5 : 1;
			params.valuefunc ??= (centerfactor) => Math.floor( randexponent(4*centerfactor) *3)/3;
			//params.colorfunc ??= (value) => "hsl(" + [0, /*Math.floor(75*value) +*/ "100%", "87.5%"].join(",") + ")";
			params.colorfunc ??= (value) => hsvtorgb(
				(1 - value)*0 + value*30,
				(1 - value)*75 + value*25,
				(1 - value)*87.5 + value*94.75,
			true);
			let edgecloseness = (rect, x, y) => Math.min(
				Math.abs(rect.x - x),
				// the point to the left on the rectangle, at the same y
				Math.abs(rect.x + rect.w - x),
				// the point to the right
				Math.abs(rect.y - y),
				// up
				Math.abs(rect.y + rect.h - y)
				// down
			);
			let block = {
				w: size/params.columns,
				h: size/params.rows,
			};
			for (i1 = 0; i1 < size; i1++) {
			// x
				for (i2 = 0; i2 < size; i2++) {
				// y
					let rect = [
						Math.floor(i1/block.w),
						Math.floor(i2/block.h)
					];
					let temp = rect[0]%2 === rect[1]%2;
					rect = {
						x: (rect[0] - (temp ? 0 : 1))*block.w,
						y: rect[1]*block.h,
						w: block.w*2,
						h: block.h,
					};
					let edgedist = edgecloseness(rect, i1, i2);
					let centerfactor = Math.min(block.w*2/2, block.h/2);
					// maximum edgedist
					centerfactor = edgedist/centerfactor;
					ctx.fillStyle = (
						edgedist < params.thickness && Math.random() < params.desiccation
						?
						params.linecolor
						:
						params.colorfunc(params.valuefunc(centerfactor))
					);
					ctx.fillRect(x + i1, y + i2, 1, 1);
				}
			}
		}
		else if(type === "road") {
		// params:
		// - roadcolor
		// - gapfill (color used to draw over all areas it sprays, before
		//   they're sprayed)
		// - path
		//   - "ul_corner", "ur_corner", etc
		//   - "vert"
		//   - "hori"
		//   - "u_end", "r_end", etc
		//   - "center"
		//   - "u_cross", "r_cross", etc
		//   - "cross"
		// - spray
		//   - r
		//   - density (measured in pixels per spray area)
		// - spraysperpixel
			params.roadcolor ??= ["#efbf8f", "#efcfaf"];
			params.gapfill ??= "";
			//params.roadcolor ??= ["#2f2f5f", "#575f93", "#7f8fc7"];
			//params.gapfill ??= "black";
			params.path ??= "center";
			params.spray ??= {};
			params.spray.r ??= 1/4;
			params.spray.density ??= 1/4;
			params.spraysperpixel ??= 1/8;
			//
			let spray_r = params.spray.r*size;
			let spray_density = Math.floor(params.spray.density*Math.PI*spray_r**2);
			let data = [];
			for (i1 = 0; i1 < size; i1++) {
				data[i1] = [];
				for (i2 = 0; i2 < size; i2++) {
					data[i1][i2] = 0;
				}
			}
			function spray(x, y) {
				let i1 = 0;
				for (i1 = 0; i1 < spray_density; i1++) {
					let temp = [
						spray_r*randexponent(2),
						Math.random()*2*Math.PI
					];
					temp = [
						Math.floor(x + Math.cos(temp[1])*temp[0]),
						Math.floor(y + Math.sin(temp[1])*temp[0])
					];
					if(temp[0] >= 0 && temp[0] < size && temp[1] >= 0 && temp[1] < size) {
						data[ temp[0] ][ temp[1] ]++;
					};
				}
			}
			function spraythisrect(rect) {
				if(params.gapfill) {
					let temp = ctx.fillStyle;
					ctx.fillStyle = params.gapfill;
					ctx.fillRect(x + rect.x, y + rect.y, rect.w, rect.h);
					ctx.fillStyle = temp;
				};
				let numofsprays = rect.w*rect.h*params.spraysperpixel;
				for (i1 = 0; i1 < numofsprays; i1++) {
					spray(rect.x + Math.random()*rect.w, rect.y + Math.random()*rect.h);
				}
			}
			let road_w = size - (2*spray_r);
			let rect = {
				x: spray_r,
				y: spray_r,
				w: road_w,
				h: road_w,
			};
			spraythisrect(rect);
			let ends = [false, false, false, false];
			// r, d, l, u
			let temp = "";
			if(["ul", "ur", "dr", "dl"].includes(params.path.slice(0, 2)) && params.path.slice(2) === "_corner") {
				temp = params.path.slice(0, 2);
			}
			if(["r", "d", "l", "u"].includes(params.path[0]) && ["_end", "_cross"].includes(params.path.slice(1))) {
				temp = params.path[0];
			};
			if(temp.includes("l")) {
				ends[0] = true;
			};
			if(temp.includes("u")) {
				ends[1] = true;
			};
			if(temp.includes("r")) {
				ends[2] = true;
			};
			if(temp.includes("d")) {
				ends[3] = true;
			};
			if(["r", "d", "l", "u"].includes(params.path[0]) && params.path.slice(1) === "_cross") {
				ends = [true, true, true, true];
				ends[ ["r", "d", "l", "u"].indexOf(params.path[0]) ] = false;
			};
			if(params.path === "cross") {
				ends = [true, true, true, true];
			};
			if(params.path === "vert") {
				ends = [false, true, false, true];
			};
			if(params.path === "hori") {
				ends = [true, false, true, false];
			};
			if(ends[0]) {
			// right
				rect = {
					x: size - spray_r,
					y: spray_r,
					w: spray_r,
					h: road_w,
				};
				spraythisrect(rect);
			};
			if(ends[1]) {
			// down
				rect = {
					x: spray_r,
					y: size - spray_r,
					w: road_w,
					h: spray_r,
				};
				spraythisrect(rect);
			};
			if(ends[2]) {
			// left
				rect = {
					x: 0,
					y: spray_r,
					w: spray_r,
					h: road_w,
				};
				spraythisrect(rect);
			};
			if(ends[3]) {
			// up
				rect = {
					x: spray_r,
					y: 0,
					w: road_w,
					h: spray_r,
				};
				spraythisrect(rect);
			};
			if(!Array.isArray(params.roadcolor)) {
				ctx.fillStyle = params.roadcolor;
			}
			for(i1 = 0; i1 < data.length; i1++) {
				for(i2 = 0; i2 < data[i1].length; i2++) {
					if(Array.isArray(params.roadcolor)) {
						if(data[i1][i2] > 0) {
							ctx.fillStyle = params.roadcolor[ Math.min(data[i1][i2], params.roadcolor.length) - 1 ];
							ctx.fillRect(x + i1, y + i2, 1, 1);
						}
					}
					else {
						for(i3 = 0; i3 < data[i1][i2]; i3++) {
							ctx.fillRect(x + i1, y + i2, 1, 1);
						}
					}
				}
			}
		}
	};
	slite.jankynumbers = function(ctx, x, y, number, string, spacing, intensity, scaleintensity) {
	// - number: the number it's drawing
	// - string: strings to write next to the number. if it's only one string,
	//   it'll come after. if it's an array of two strings, it'll be the one
	//   that comes before and the one that comes after.
	// - spacing: spacing between characters.
	//   - i don't know a better way to get the x position of each character and
	//     i only use monospace fonts anyway.
	// - intensity: the number it should multiply random offsets by
	// - scaleintensity: if this is truthy, it'll also multiply the offset by
	//   the value of the number. if it's a number, it'll add this to the number
	//   before multiplying (for example, if you want it to have zero intensity
	//   at 100, make this -100.)
		let i1 = 0;
		if(!string) {
			string = number.toString();
		}
		else if(typeof string === "string") {
			string = number + string;
		}
		else if(Array.isArray(string) && string.length === 2 && typeof string[0] === "string" && typeof string[1] === "string") {
			string = string[0] + number + string[1];
		}
		else {
			console.log("invalid string parameter.");
			return;
		};
		if(!spacing && spacing !== 0) {
			let temp = Number(ctx.font.slice(0, ctx.font.indexOf("px")))/2;
			spacing = (temp ? temp : 8);
		};
		if(!intensity) {
			intensity = spacing/2;
		};
		if(typeof scaleintensity === "number") {
			number += scaleintensity;
		};
		scaleintensity = scaleintensity || typeof scaleintensity === "number";
		// it's only used as a boolean after this point
		for (i1 = 0; i1 < string.length; i1++) {
			let shake = [
				Math.random()*2*Math.PI,
				randexponent(2)
			];
			// angle, intensity
			shake = [
				intensity*shake[1]*Math.cos(shake[0]),
				intensity*shake[1]*Math.sin(shake[1]),
			];
			if(scaleintensity) {
				shake[0] *= number;
				shake[1] *= number;
			};
			shake = [
				Math.trunc(shake[0]),
				Math.trunc(shake[1])
			];
			ctx.fillText(string[i1], x + i1*spacing + shake[0], y + shake[1]);
		}
	};
	slite.gleam = {
		create: function(size, hw_ratio) {
			// creates an object slite.gleam.draw can draw
			let i1 = 0;
			let w = size;
			let h = size*hw_ratio;
			let angle = randexponent(2, true)*2*Math.PI/8;
			let shape = Shape2d.build("ellipse", [w, h]);
			let length = objarraylength(shape);
			for(i1 = 0; shape.hasOwnProperty(i1); i1++) {
				shape[i1].elbow.direction = {in: "out", out: "in"}[ shape[i1].elbow.direction ];
			};
			return {shape, w, h, angle};
		},
		draw: function(time, gleam, ctx, x, y) {
			let i1 = 0;
			let path = new Shape2d();
			let overshoot_time = 1/2;
			for(i1 in gleam.shape) {
				if(gleam.shape.hasOwnProperty(i1)) {
					path[i1] = structuredClone(gleam.shape[i1]);
					if(!isNaN(Number(i1))) {
						let temp = easing(2*time, "out", "circ", [2, overshoot_time, "out"]);
						path[i1].y *= temp;
					}
				}
			}
			path = structuredClone(path.path);
			_2dPoly.draw(ctx, path, "fill", false, [x, y]);
			let flare_duration = 1/2;
			let flare_turn = 1/8;
			if(overshoot_time <= 2*time && 2*time <= overshoot_time + flare_duration) {
			// hashtag-shaped lens flare
				let r = null;
				for(i1 = 0; i1 < path.length; i1++) {
					let temp = Math.hypot(path[i1][0], path[i1][1]);
					if(r === null || temp < r) {
						r = temp;
					};
				}
				let nums = [gleam.w*1/16, 4*gleam.h];
				// width/height of the bars
				let flare = [
					Shape2d.build("rect", [nums[0], nums[1]], false, false, [-(r/2 + nums[0]/2), 0]),
					Shape2d.build("rect", [nums[0], nums[1]], false, false, [ (r/2 + nums[0]/2), 0]),
					Shape2d.build("rect", [nums[1], nums[0]], false, false, [0, -(r/2 + nums[1]/2)]),
					Shape2d.build("rect", [nums[1], nums[0]], false, false, [0,  (r/2 + nums[1]/2)])
				];
				let angle = (2*time - overshoot_time)/flare_duration;
				angle = easing(angle, "out", "square")*flare_turn*2*Math.PI;
				angle += gleam.angle;
				for(i1 = 0; i1 < flare.length; i1++) {
					flare[i1].rotate.angle = angle;
					flare[i1] = structuredClone(flare[i1].path);
				}
				// hashtag-shaped lens flare
				//
				for(i1 = 0; i1 < flare.length; i1++) {
					_2dPoly.draw(ctx, flare[i1], "fill", false, [x, y]);
				};
			}
		},
	};
	suite.gleams = new ProcAnim();
	suite.gleams.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2, -u.w/2];
		v.numofgleams ??= 1;
		if((v.gleam ?? null) === null) {
			v.gleam = [];
			v.offsets = [];
			let i1 = 0;
			for(i1 = 0; i1 < v.numofgleams; i1++) {
				v.gleam[i1] = slite.gleam.make((1 + randexponent(2, true)/2)*u.w/2, 5/4);
				v.offsets[i1] = [
					Math.floor(v.pos[0] + randexponent(2, true)*u.w/2),
					Math.floor(v.pos[1] + randexponent(2, true)*u.h/2)
				];
			};
		}
		//
		v.initialized = true;
	};
	suite.gleams.func = function(frame, gleamspacing, gleamlength) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		ctx.fillStyle = "black";
		ctx.fillRect(0, 0, u.w, u.h);
		ctx.fillStyle = "white";
		ctx.strokeStyle = "white";
		gleamspacing ??= 4;
		gleamlength ??= 8;
		for(i1 = 0; i1 < v.gleam.length; i1++) {
			let temp = (frame - i1*gleamspacing);
			if(0 <= temp && temp < gleamlength) {
				slite.gleam.draw(temp/gleamlength, v.gleam[i1], ctx, ...v.offsets[i1]);
			};
		}
		//
		this.frameend(frame);
	};
	slite.ditherparallax = function(frame, ctx, input, direction) {
	/*
	slite.ditherparallax(frame, ctx, [
		{
			dither: "",
			cutoff: ,
			direction: ,
			speed: ,
			color: ,
		}
	], direction);
	//*/
	// - input: array of objects.
	//   - dither (name string)
	//   - invert: if present and true, it'll only draw if the dither returns
	//     false instead of true
	//   - cutoff, direction: cutoff is a coordinate, direction is a single
	//     letter. (u/d/l/r) "l" means it'll only draw dither on pixels with a
	//     lower x than cutoff, "u" means it draws on pixels with lower y, etc.
	//   - speed: number of pixels to scroll per frame
	//   - color
	// - direction: direction to use if it's absent from an input.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		direction = ["u", "d", "l", "r"].includes(direction) ? direction : "d";
		let dim = [ctx.canvas.width, ctx.canvas.height];
		const dithersobj = dithers;
		// right now they're stored in a screwy place...
		for(i1 = 0; i1 < input.length; i1++) {
			let dir = input[i1].hasOwnProperty("direction") ? input[i1].direction : direction;
			if(!input[i1].hasOwnProperty("cutoff")) {
				let temp = dim[ Math.sign("ud".includes(dir)) ];
				if(i1 === 0) {
					input[i1].cutoff = temp/2;
				}
				else if("dr".includes(dir)) {
					input[i1].cutoff = (temp + input[i1 - 1].cutoff)/2;
				}
				else {
					input[i1].cutoff = input[i1 - 1].cutoff/2;
				}
			}
			if(!input[i1].hasOwnProperty("speed")) {
				input[i1].speed = (i1 === 0 ? 0 : input[i1 - 1].speed + 1);
			}
			let bounds = [0, ctx.canvas.width, 0, ctx.canvas.height];
			// searches pixels with x between [0] and [1], y between etc etc
			bounds["rldu".indexOf(dir)] = input[i1].cutoff;
			let scroll = "lrud".indexOf(dir);
			scroll = [
				[0, 0, -1, 1][scroll] * frame * input[i1].speed,
				[-1, 1, 0, 0][scroll] * frame * input[i1].speed
			];
			if(input[i1].hasOwnProperty("color")) {
				ctx.fillStyle = input[i1].color;
			}
			else {
				ctx.fillStyle = "rgb(" + [255, Math.floor(255*i1/input.length), 0].join() + ")";
			}
			for(i2 = bounds[0]; i2 < bounds[1]; i2++) {
				for(i3 = bounds[2]; i3 < bounds[3]; i3++) {
					let coor = [i2 + scroll[0], i3 + scroll[1]];
					if(dither_interpreter(input[i1].dither, coor[0], coor[1], input[i1].hasOwnProperty("invert") && input[i1].invert)) {
						ctx.fillRect(i2, i3, 1, 1);
					};
				}
			}
		}
	}
	slite._2dpoly = {};
	// functions that are related to _2dPoly but not enough to be _2dPoly
	// functions directly.
	slite._2dpoly.random = function(r, numofpoints, condensefactor, angleoffset) {
	// returns a random _2dPoly that doesn't have hourglass intersections or
	// anything.
		let i1 = 0;
		condensefactor ??= 1;
		angleoffset = typeof angleoffset === "number" ? angleoffset : Math.random();
		let shape = [];
		for(i1 = 0; i1 < numofpoints; i1++) {
			let anglenum = 2*Math.PI*(i1/numofpoints) + angleoffset;
			anglenum = [
				Math.cos(anglenum),
				Math.sin(anglenum)
			];
			amplitude = r*(randexponent(condensefactor, true) + 1)/2;
			shape[i1] = [
				amplitude*anglenum[0],
				amplitude*anglenum[1]
			];
		};
		return shape;
	};
	slite._2dpoly.colorbydistance = function(_this, ctx, colorfunc, divideby) {
		colorfunc ??= (value) => "rgb(" + [255, Math.floor(value*255), 0].join(",") + ")";
		divideby ??= 1;
		_2dPoly.execute(_this, true, function(x, y) {
			let temp = _2dPoly.distfromedge(_this, x, y)/divideby;
			ctx.fillStyle = colorfunc(temp);
			ctx.fillRect(x, y, 1, 1);
		});
	};
	slite.walkers = {};
	// a "walker" is when you have it start at a random coordinate, add to a
	// value for that coordinate, have it move one pixel in a random direction,
	// and repeat. this can be used to create heightmaps and stuff like
	// diamondsquare. or fire, apparently.
	// - it's a lot more scraggly than diamond square though, and probably more
	//   intensive.
	slite.walkers.start = {
	// an object of functions for use in slite.walkers.create. they return
	// random starting positions, usually on the outline or inside of a
	// specified shape.
		circle: function(x, y, r, etc) {
		// - etc
		//   - "inside": it'll choose a point inside the circle. (points closer
		//     to the center are more likely, since it chooses a random angle
		//     and magnitude.)
		//   - "lopsided": it'll use randexponent to make it start near angle 0
		//     more often.
			etc ??= [];
			let angle = posmod(randexponent(etc.includes("lopsided") ? 1.5 : 1, true)*Math.PI, 2*Math.PI);
			// randexponent so that most of the landmass is on one side
			let magn = etc.includes("inside") ? Math.random() : 1;
			return [
				x + r*Math.cos(angle)*magn,
				y + r*Math.sin(angle)*magn
			];
			// start at a random place on the circle
		},
		rect: function(x, y, w, h) {
			x ??= 0;
			y ??= 0;
			return [
				x + Math.random()*w,
				y + Math.random()*h
			];
		},
		point: (x, y) => [x, y],
	};
	slite.walkers.create = function(w, h, start_func, start_args, numofwalkers, walkerlength, etc) {
	// - start_func: a string for the slite.walkers.start you want to use, or a
	//   function.
	// - start_args: an array of arguments to use in that.
	// - etc:
	//   - "eightdir": makes it so the walker moves in eight directions, just
	//     moving up/down 1 x/y instead of using the sin/cos of a random angle
	//   - "direct": if this is followed by a number, it'll use that as an
	//     angle, rerolling the random angle once if it wasn't within Math.PI/2
	//     of this. (ex if you set it as 3/2 pi, it'll reroll it once if the
	//     angle wasn't in the upper half.)
		let i1 = 0;
		let i2 = 0;
		if(typeof start_func !== "function" && (typeof start_func !== "string" || !slite.walkers.start.hasOwnProperty(start_func))) {
			return;
		};
		start_args ??= [];
		numofwalkers ??= 2**8;
		walkerlength ??= 2**7;
		etc ??= [];
		let data = [];
		for(i1 = 0; i1 < w; i1++) {
			data[i1] = [];
			for(i2 = 0; i2 < h; i2++) {
				data[i1][i2] = 0;
			}
		}
		for(i1 = 0; i1 < numofwalkers; i1++) {
			let coor = (
				typeof start_func === "string"
				?
				slite.walkers.start[start_func](...start_args)
				:
				start_func(...start_args)
			);
			coor[0] += .5;
			coor[1] += .5;
			// start in the center of the pixel
			for(i2 = 0; i2 < walkerlength; i2++) {
				let _coor = [Math.floor(coor[0]), Math.floor(coor[1])];
				if(withinrect(..._coor, {x: 0, y: 0, w: data.length, h: data[0].length})) {
				// if the walker is still on the screen, add a point to
				// their position's value in data
					data[ _coor[0] ][ _coor[1] ]++;
				};
				if(etc.includes("eightdir")) {
					let dir = Math.floor(Math.random()*8);
					// 567
					// 4 0
					// 321
					if([5, 6, 7].includes(dir)) {
						coor[1]--;
					}
					else if([3, 2, 1].includes(dir)) {
						coor[1]++;
					};
					if([5, 4, 3].includes(dir)) {
						coor[0]--;
					}
					else if([7, 0, 1].includes(dir)) {
						coor[0]++;
					};
				}
				else if(etc.includes("knight")) {
					let angle = Math.floor(Math.random()*8);
					let temp = angle%4;
					temp = temp === 1 || temp === 2;
					let x = temp ? 2 : 1;
					let y = temp ? 1 : 2;
					if(angle%8 < 4) {
						x *= -1;
					};
					if((angle + 6)%8 < 4) {
						y *= -1;
					};
					coor[0] += x;
					coor[1] += y;
				}
				else {
					let dir = Math.random()*2*Math.PI;
					//let dir = Math.random()*2*Math.PI;
					if(etc.includes("direct")) {
						let angle = etc[ (etc.indexOf("direct") + 1) ];
						if(typeof angle === "number") {
							let dist = Math.abs(angle - dir);
							if(dist >= Math.PI) {
								dist = 2*Math.PI - dist;
							};
							// make sure it's circular and all that, 359 and 0
							// are next to each other
							if(dist >= Math.PI/2) {
								dir = Math.random()*2*Math.PI;
							};
						}
					}
					coor[0] += Math.cos(dir);
					coor[1] += Math.sin(dir);
				};
			}
		}
		return data;
	};
	slite.walkers.draw = function(ctx, data, colorfunc) {
		let i1 = 0;
		let i2 = 0;
		colorfunc ??= (num) => "rgb(" + [255, 16*num, 0].join() + ")";
		for(i1 = 0; i1 < data.length; i1++) {
			for(i2 = 0; i2 < data[i1].length; i2++) {
				let num = data[i1][i2];
				if(num > 0) {
					ctx.fillStyle = colorfunc(num);
					ctx.fillRect(i1, i2, 1, 1);
				}
			}
		}
	};
	slite.walkers.shift = function(data, x, y) {
		let _data = structuredClone(data);
		x = posmod(x, _data.length);
		y = posmod(y, _data[0].length);
		if(x) {
			_data = _data.slice(-x).concat( _data.slice(0, -x) );
		};
		if(y) {
			let i1 = 0;
			for(i1 = 0; i1 < _data.length; i1++) {
				_data[i1] = _data[i1].slice(-y).concat( _data[i1].slice(0, -y) );
			}
		};
		return _data;
	};
	slite.walkers.add = function(data, create_args, subtract) {
	// creates a new walker data and adds that to the one you have.
	// - create_args: arguments for .create. skip w and h.
	// - subtract: boolean that will make it subtract the new amounts instead of adding them
		let i1 = 0;
		let i2 = 0;
		let _data = slite.walkers.create(data.length, data[0].length, ...create_args);
		for(i1 = 0; i1 < _data.length; i1++) {
			for(i2 = 0; i2 < _data[i1].length; i2++) {
				_data[i1][i2] = Math.max(0, (data[i1][i2] + (subtract ? -1 : 1)*_data[i1][i2]));
			}
		}
		return _data;
	};
	slite.walkers.flame = function(data, angle, magnitude, create_args) {
	/*
	slite.walkers.flame(data, angle, magnitude, [
		start_func,
		start_args,
		numofwalkers,
		walkerlength,
		etc
	])
	*/
	// animates it to resemble flames.
	// - angle, magnitude: used to get the x and y it uses in .shift.
	// - create_args: array of arguments for .add and .create. (if it's falsy,
	//   it'll skip this part.)
	//   - skip data, w, and h, since those are already inputted.
	// - it decays the current values by square rooting them if they're above 1,
	//   and subtracting them if they're 1.
	// - so far, i think it looks alright for a sun or something, but not for
	//   fire. bluh.
	//   - looks like fire you'd see in one of those crappy gba games that's
	//     like "check it out we can do 3d!!! kind of!"
		let i1 = 0;
		let i2 = 0;
		magnitude ??= 4;
		angle ??= 3*Math.PI/2;
		// straight up
		let x = Math.trunc(magnitude*Math.cos(angle));
		let y = Math.trunc(magnitude*Math.sin(angle));
		let _data = slite.walkers.shift(data, x, y);
		for(i1 = 0; i1 < _data.length; i1++) {
			for(i2 = 0; i2 < _data[i1].length; i2++) {
				//_data[i1][i2] = Math.max(0, _data[i1][i2] - decay);
				if(_data[i1][i2] === 1) {
					_data[i1][i2]--;
				}
				else {
					_data[i1][i2] = Math.floor(Math.sqrt(_data[i1][i2]));
				}
			}
		}
		if(create_args) {
			_data = slite.walkers.add(_data, create_args);
		}
		return _data;
	};
	slite.spiro = function(frame, r, rev) {
	/*
	slite.spiro(frame/8, [2, 1], [1, 1/2])
	// cardioid
	*/
	// returns the 2d coordinates of a point that revolves in a circle that
	// itself revolves.
	// - r: an array of the radii of each revolution.
	// - rev: an array of the lengths of each revolution, measured in how many
	//   frames one revolution takes.
	//   - negative numbers will be interpreted as counterclockwise
		let i1 = 0;
		let i2 = 0;
		if(r.length !== rev.length) {
			console.log("r array length doesn't match rev array.");
			return;
		}
		let coor = [0, 0];
		for(i1 = 0; i1 < r.length; i1++) {
			let negative = Math.sign(rev[i1]) === -1;
			let temp = Math.abs(rev[i1]);
			temp = 2*Math.PI*(frame%temp)/temp;
			if(negative) {
				temp = 2*Math.PI - temp;
			};
			temp = [
				r[i1]*Math.cos(temp),
				r[i1]*Math.sin(temp)
			];
			coor[0] += temp[0];
			coor[1] += temp[1];
		}
		return coor;
	}
	slite.harmonysprawl = function(ctx, x, y, rules, names, colors, node_r, start_r, circle_gap, onebranch, sector_gap, skiprings) {
	// this is procedural drawing, not animation... and it's an infographic too.
	// whatever
	// - rules: an array of arrays, for which chords each chord can go to. write
	//   all chords as numbers.
	//   - NOTE start at one, not zero.
	// - names: an array of strings to write for each chord
	// - colors: an array of colors for the nodes.
	// - start_r: the radius of the circle the first ring sits on.
	// - circle_gap: the radius difference between circles
	// - node_r: node radius
	// - onebranch: if you only want to graph one chord's branch, give that
	//   chord's index.
	//   - again, start at one.
	// - sector_gap: determines how much spacing there is between different
	//   branches' dedicated sectors.
		let i1 = 0;
		let i2 = 0;
		rules ??= [
			[1, 2, 3, 4, 5, 6, 7],
			[1, 5, 7],
			[1, 4, 6],
			[1, 2, 5, 7],
			[1, 6],
			[1, 2, 3, 4, 5],
			[1]
		];
		for(i1 = 0; i1 < rules.length; i1++) {
			for(i2 = 0; i2 < rules[i1].length; i2++) {
				rules[i1][i2]--;
			};
		};
		names ??= ["I", "ii", "iii", "IV", "V", "vi", "vii" + String.fromCharCode(176)];
		if(!Array.isArray(colors)) {
			colors = [
				"rgb(119, 187, 255)",
				"rgb(255, 68, 51)",
				"rgb(119, 0, 255)"
			];
			colors = [
				colors[0],
				colors[1],
				colors[1],
				colors[0],
				colors[0],
				colors[1],
				colors[2]
			];
		};
		node_r ??= 8;
		circle_gap ??= node_r * 4;
		start_r ??= 1*circle_gap;
		sector_gap ??= 1/4;
		let centerchord = null;
		for(i1 = 0; i1 < rules.length; i1++) {
		// checks for chords that can lead to every chord. if this exists, it'll
		// be the center of the concentric circles.
			let bool = true;
			for(i2 = 0; i2 < rules.length; i2++) {
				if(!rules[i1].includes(i2)) {
					bool = false;
					i2 += rules.length;
				};
			}
			if(bool) {
				centerchord = i1;
				i1 += rules.length;
			};
		}
		if(
			typeof onebranch === "number"
			&&
			1 <= onebranch && onebranch < rules.length + 1
			&&
			(centerchord === null || centerchord !== onebranch - 1)
		) {
			onebranch--;
		}
		else {
			onebranch = null;
		};
		ctx.font = "16px 'fomp2'";
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		let tree = {};
		// an object of trees. it iterates to extend them over and over until it
		// can't extend anymore. the structure is a chain of objects. it has a
		// property for each chord it's allowed to continue into, which in turn
		// is an object of chords that chord can continue into.
		// - nulls are used to say, "this chord hasn't been extended as its own
		//   tree yet.", the tree extendy thing searches for them...
		function createbranch(property, keychain) {
			let ref = rules[ Number(keychain[keychain.length - 1]) ];
			// array of possible continuations
			for(let i1 = 0; i1 < ref.length; i1++) {
				if(!keychain.includes(ref[i1].toString())) {
					// avoid any continuations that have already been used
					let _keychain = structuredClone(keychain);
					_keychain[_keychain.length] = ref[i1].toString();
					property[ ref[i1] ] = {};
					createbranch(property[ ref[i1] ], _keychain);
				};
			}
		}
		if(centerchord !== null) {
			tree[centerchord] = {};
			createbranch(tree[centerchord], [centerchord.toString()]);
		}
		else {
			for(i1 = 0; i1 < rules.length; i1++) {
				tree[i1] = {};
				createbranch(tree[i1], [i1.toString()]);
			}
		};
		// create the tree
		function stringify(tree, propertyname) {
			let i1 = 0;
			let i2 = 0;
			let text = [];
			if(propertyname === null) {
				for(i1 in tree) {
					text[text.length] = stringify(tree[i1], i1);
				}
			}
			else {
				text[0] = names[ Number(propertyname) ];
				for(i1 in tree) {
					let temp = stringify(tree[i1], i1).split(String.fromCharCode(10));
					for(i2 = 0; i2 < temp.length; i2++) {
						temp[i2] = String.fromCharCode(9) + temp[i2];
					}
					text[text.length] = temp.join(String.fromCharCode(10));
				}
			}
			text = text.join(String.fromCharCode(10));
			return text;
		};
		//let text = stringify(tree, null);
		//console.log(text);
		let nodes = [];
		// array sorted by which ring they're on.
		// - node data is a bunch of objects with data for connecting them.
		//   - chord: the index of the chord this node represents
		//   - parent: the index its parent has in the nodes array for this
		//     ring.
		//   - ancestor: the chord of the ring 1/0 level it descends from.
		//   - x, y: coordinates for drawing
		// - NOTE index 0 is the center of the circles, which is empty unless
		//   centerchord exists.
		let sectors = [];
		// sorted by ring, then by ancestor. each index is an array of the
		// lowest and highest node indexes with that ancestor.
		function createnodes(tree, propertyname, parent, level) {
		// create .chord, .parent, .ancestor
			let i1 = 0;
			let i2 = 0;
			nodes[level] ??= [];
			let index = nodes[level].length;
			nodes[level][index] = {
				chord: Number(propertyname),
				parent,
			};
			let ancestor = null;
			if(level < 1) {
				// it can stay null
			}
			else if(level === 1) {
				ancestor = nodes[level][index].chord;
			}
			else if(level > 1) {
				ancestor = nodes[level - 1][parent].ancestor;
			}
			else {
				console.log("this shouldn't happen");
			};
			nodes[level][index].ancestor = ancestor;
			if(ancestor !== null) {
				sectors[level] ??= [];
				sectors[level][ancestor] ??= [null, null];
				let ref = sectors[level][ancestor];
				if(ref[0] === null || index < ref[0]) {
					ref[0] = index;
				};
				if(ref[1] === null || index > ref[1]) {
					ref[1] = index;
				};
			};
			for(i1 in tree) {
				createnodes(tree[i1], i1, index, level + 1);
			};
		};
		if(centerchord === null) {
			nodes[0] = [];
			nodes[0][0] = {chord: null, parent: null};
			// if a node's chord is null, no circled name will be made. if the
			// parent is null, no connection will be made. i'd still like a
			// central node, even if it's empty.
			for(i1 in tree) {
				createnodes(tree[i1], i1.toString(), 0, 1);
			}
		}
		else {
			createnodes(tree[centerchord], centerchord.toString(), null, 0);
		};
		let styletemp = [ctx.fillStyle, ctx.strokeStyle];
		ctx.strokeStyle = "silver";
		let drawcondition = (node_ancestor) => onebranch === null || [null, onebranch].includes(node_ancestor);
		function getangle(level, ancestor, index) {
			let i1 = 0;
			let circdivisor = rules.length - (centerchord !== null);
			//console.log("circdivisor: " + circdivisor);
			let angle = (sectors[level][ancestor][1] - sectors[level][ancestor][0]);
			angle = (
				angle === 0
				// highest and lowest are the same, only one index
				?
				.5
				:
				(index - sectors[level][ancestor][0])/angle
			);
			angle = sector_gap/2 + angle*(1 - sector_gap);
			//console.log("place: " + angle);
			angle /= circdivisor;
			angle += (ancestor - (centerchord === null || ancestor >= centerchord))/circdivisor;
			console.log("ancestor: " + ancestor);
			console.log("sector: " + [(ancestor - (centerchord === 0 ? 1 : 0)), circdivisor].join("/"));
			angle = posmod(angle - 1/(2*circdivisor), 1);
			angle *= 2*Math.PI;
			return angle;
		}
		if(!skiprings) {
			for(i1 = 1; i1 < nodes.length; i1++) {
				circledraw(ctx, x, y, start_r + (i1 - 1)*circle_gap, false);
			};
		};
		for(i1 = 0; i1 < nodes.length; i1++) {
			for(i2 = 0; i2 < nodes[i1].length; i2++) {
			// create x and y, and draw lines connecting to parents
				let node = nodes[i1][i2];
				node.x = x;
				node.y = y;
				if(i1 > 0) {
					let r = start_r + (i1 - 1)*circle_gap;
					//let angle = getangle(i1, node.ancestor, i2);
					//*
					let angle = 2*Math.PI*i2/nodes[i1].length;
					if(i1 > 1) {
					// there's complicated reasons for this but basically, each
					// branch should be centered over where it started from.
						angle = posmod(angle - 2*Math.PI*1/(2*rules.length), 2*Math.PI);
					}
					//*/
					node.x += r*Math.cos(angle);
					node.y += r*Math.sin(angle);
				};
				if(
					drawcondition(node.ancestor)
					&&
					node.parent !== null && i1 > 0
				) {
				// connect it to the parent, in the parent's color
					let parent = nodes[i1 - 1][node.parent];
					ctx.strokeStyle = colors[parent.chord];
					//ctx.strokeStyle = "black";
					nonaaline(ctx, parent.x + 1, parent.y, node.x + 1, node.y);
					nonaaline(ctx, parent.x - 1, parent.y, node.x - 1, node.y);
					nonaaline(ctx, parent.x, parent.y + 1, node.x, node.y + 1);
					nonaaline(ctx, parent.x, parent.y - 1, node.x, node.y - 1);
					//ctx.strokeStyle = colors[parent.chord];
					ctx.strokeStyle = "white";
					nonaaline(ctx, parent.x, parent.y, node.x, node.y);
				}
			}
		}
		function drawnode(x, y, chord) {
			ctx.fillStyle = colors[chord];
			circledraw(ctx, x, y, node_r, true);
			ctx.strokeStyle = styletemp[1];
			circledraw(ctx, x, y, node_r, false);
			ctx.fillStyle = ctx.strokeStyle;
			ctx.fillText(names[chord], Math.floor(x) - 1, Math.floor(y));
			ctx.fillText(names[chord], Math.floor(x) + 1, Math.floor(y));
			ctx.fillText(names[chord], Math.floor(x), Math.floor(y) + 1);
			ctx.fillText(names[chord], Math.floor(x), Math.floor(y) - 1);
			ctx.fillText(names[chord], Math.floor(x) - 1, Math.floor(y) + 1);
			ctx.fillStyle = "white";
			ctx.fillText(names[chord], Math.floor(x), Math.floor(y));
		};
		for(i1 = 0; i1 < nodes.length; i1++) {
			for(i2 = 0; i2 < nodes[i1].length; i2++) {
			// create x and y, and draw lines connecting to parents
				let node = nodes[i1][i2];
				if(drawcondition(node.ancestor) && node.chord !== null) {
					drawnode(node.x, node.y, node.chord);
				};
			}
		}
		ctx.fillStyle = styletemp[0];
		ctx.strokeStyle = styletemp[1];
	}
	suite.waveattack = new ProcAnim();
	suite.waveattack.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/4, u.h/2, -u.w/2];
		v.nodes ??= [];
		//
		v.initialized = true;
	};
	suite.waveattack.func = function(frame, sizes, colors, arc_speed, wave_speed, startangle, breakdown, breaklength, shove_speed, shove_decel) {
	// an animation of a thing circling, and a wave being created from that.
	// it's complicated.
	// - sizes: object of different dimensions
	//   - r: radius of the arc
	//   - circler: radius of the circling thing itself
	//   - wave: weight of the wave
	// - colors: object of colors
	//   - circler
	//   - wave
	//   - waveedge
	// - arc_speed: angle the circling thing moves per frame
	// - wave_speed: pixels the nodes of the wave move per frame
	// - startangle, breakdown, breaklength: the place on the circle it starts,
	//   the place it freezes, and how long.
	// - shove_speed, shove_decel: used in Physics.shove for a speed boost at
	//   the end.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		sizes ??= {};
		sizes.r ??= u.w/8;
		sizes.circler ??= sizes.r/4;
		sizes.wave ??= false;
		colors ??= {};
		colors.circler ??= "white";
		colors.wave ??= "orange";
		colors.waveedge ??= "#3f3fff";
		arc_speed ??= -(2*Math.PI/7);
		wave_speed ??= sizes.r*4/3;
		startangle ??= 2*Math.PI*1/4;
		breakdown ??= 2*Math.PI*3/4;
		breaklength ??= 7;
		shove_speed ??= wave_speed;
		shove_decel ??= shove_speed/7;
		let breakframe = (breakdown - startangle)/arc_speed;
		if(breakframe < 0) {
			breakframe += 2*Math.PI/arc_speed;
		};
		let framechange = 0;
		let breakfuncframe = null;
		if(frame >= breakframe) {
			breakfuncframe = frame - breakframe;
			// used in the slite or whatever the breakdown animation is
			if(breakfuncframe > breaklength) {
			// change frame so it draws like the freeze never happened
				framechange = -breaklength;
				frame += framechange;
			}
			else {
			// change frame so it draws the last frame before the freeze
				framechange = breakframe - frame;
				frame = breakframe;
			};
		};
		let wave_angle = (startangle + 2*Math.PI*3/4)%(2*Math.PI);
		// always perpendicular so that startangle is the trough of the wave
		wave_speed = [
			wave_speed*Math.cos(wave_angle),
			wave_speed*Math.sin(wave_angle)
		];
		// numbers to add to each node
		if(breakfuncframe > breaklength) {
			let temp = Physics.shove(frame - breakframe, shove_speed, shove_decel);
			temp -= Physics.shove((frame - 1) - breakframe, shove_speed, shove_decel);
			wave_speed[0] += temp*Math.cos(wave_angle);
			wave_speed[1] += temp*Math.sin(wave_angle);
		};
		// add the shove
		for(i1 = 0; i1 < v.nodes.length; i1++) {
			v.nodes[i1][0] += wave_speed[0];
			v.nodes[i1][1] += wave_speed[1];
		};
		// move that nodes that are already there
		let temp = Math.max(
			(arc_speed < 0 ? -2*Math.PI : 0),
			Math.min( frame*arc_speed,
			(arc_speed < 0 ? 0 : 2*Math.PI) )
		);
		console.log(frame + ": " + Angle.convert(temp));
		let circler = posmod(startangle + temp, 2*Math.PI);
		// angle of circler;
		circler = [
			v.pos[0] + sizes.r*Math.cos(circler),
			v.pos[1] + sizes.r*Math.sin(circler)
		];
		v.nodes[v.nodes.length] = structuredClone(circler);
		// make new node
		let intersect = [
			v.pos[0] + sizes.r*Math.cos(startangle),
			v.pos[1] + sizes.r*Math.sin(startangle),
			null,
			null,
			circler[0],
			circler[1],
			null,
			null
		];
		intersect[2] = intersect[0] + Math.cos(wave_angle);
		intersect[3] = intersect[1] + Math.sin(wave_angle);
		intersect[6] = intersect[4] + Math.cos(startangle);
		intersect[7] = intersect[5] + Math.sin(startangle);
		intersect = fourpointintersect(...intersect, true);
		if(typeof intersect !== "string") {
			v.nodes[v.nodes.length] = structuredClone(intersect);
		};
		ctx.fillStyle = colors.wave;
		_2dPoly.draw(ctx, v.nodes, "fill");
		if(typeof intersect !== "string") {
			v.nodes.splice(v.nodes.length - 1, 1);
		}
		ctx.strokeStyle = colors.waveedge;
		_2dPoly.draw(ctx, v.nodes, "stroke", sizes.wave, null, "skiplaststroke");
		ctx.fillStyle = colors.circler;
		circledraw(ctx, ...circler, sizes.circler, true);
		if(breakfuncframe !== null) {
			//
			// run code here, probably a slite.
			//
		};
		frame -= framechange;
		// frameend doesn't use frame, but just in case it does someday
		//
		this.frameend(frame);
	};
	slite.linkage = class {
		constructor(type) {
		// structure:
		// - nodes
		//   - [node names]
		//     - x, y
		// - location: array of arrays. each one is a location constraint; a
		//   list of nodes that have to remain the same distance from each
		//   other.
		// - base: duplicate of what nodes is like at the beginning, to prevent
		//   the length numbers from decaying.
			this.nodes = {};
			this.location = [];
			if(type === "klann") {
				this.nodes = {
					motor: {
						x: -8,
						y: 0,
					},
					legstart: {
						x: -8,
						y: -5,
					},
					leglimiter: {
						x: -12,
						y: -6,
					},
					//
					rotatorA: {
						x: -8,
						y: 4,
					},
					limit1A: {
						x: -12,
						y: -2,
					},
					kneeA: {
						x: -6.5,
						y: -13,
					},
					limit2A: {
						x: -17,
						y: -9,
					},
					toeA: {
						x: -23.5,
						y: 16,
					},
					// A is the one that starts lower
				};
				this.location = [
					["motor", "rotatorA", "rotatorB"],
					//
					["rotatorA", "limit1A", "limit2A"],
					["rotatorB", "limit1B", "limit2B"],
					//
					["leglimiter", "limit1A"],
					["leglimiter", "limit1B"],
					//
					["legstart", "kneeA"],
					["kneeA", "limit2A", "toeA"],
					["legstart", "kneeB"],
					["kneeB", "limit2B", "toeB"],
				];
				let temp = structuredClone(this.nodes);
				this.rotate("motor", "rotatorA", Math.PI);
				for(let i1 in this.nodes) {
					if(i1.endsWith("A")) {
						this.nodes[i1.slice(0, -1) + "B"] = structuredClone(temp[i1]);
					};
				}
			}
			this.base = structuredClone(this.nodes);
		}
		constraints(nodename) {
			let obj = {};
			// lengths, indexed by node name
			for(let i1 = 0; i1 < this.location.length; i1++) {
				let ref = this.location[i1];
				if(ref.includes(nodename)) {
					for(let i2 = 0; i2 < ref.length; i2++) {
						if(ref[i2] !== nodename && this.nodes.includes(ref[i2])) {
							let temp = this.base ?? this.nodes;
							obj[ref[i2]] = Math.hypot(
								temp[nodename].x - temp[ref[i2]].x,
								temp[nodename].y - temp[ref[i2]].y
							);
						}
					}
				}
			}
			return obj;
		}
		move(nodename, x, y, covered) {
			covered ??= [];
			covered[covered.length] = nodename;
			let node = this.nodes[nodename];
			let change = [
				x - node.x,
				y - node.y
			];
			node.x = x;
			node.y = y;
			let constraints = this.constraints(nodename);
			for(let i1 in constraints) {
				if(constraints.hasOwnProperty(i1) && !covered.includes(i1)) {
				// if there's a constraint for how far they have to be from each
				// other, apply that by recursing.
				// - avoid infinite loops by skipping parts that were already
				// moved.
					let _node = this.nodes[i1];
					let angle = get2dangle(
						_node.x - node.x,
						_node.y - node.y,
						true
					) ?? 0;
					this.move(
						i1,
						node.x + constraints[i1]*Math.cos(angle),
						node.y + constraints[i1]*Math.sin(angle),
						covered
					);
				}
			}
		}
		rotate(fulcrum, nodename, angle, fineness) {
			fulcrum = this.nodes[fulcrum];
			let node = this.nodes[nodename];
			let startangle = [
				node.x - fulcrum.x,
				node.y - fulcrum.y
			]
			let length = Math.hypot(...startangle);
			if(!length) {
				return;
			};
			startangle = get2dangle(...startangle, true) ?? 0;
			fineness ??= 16;
			movements = Math.ceil(fineness*Math.abs(angle)/(2*Math.PI));
			for(let i1 = 1; i1 <= movements; i1++) {
				let _angle = startangle + angle*i1/movements;
				this.move(
					nodename,
					length*Math.cos(_angle),
					length*Math.sin(_angle)
				);
			}
		}
	}
	slite.cardioidblob = function(ctx, time, x, y, r, angle) {
		//let _r = -Math.abs(2*time - 1) + 1;
		//_r *= r*Math.PI;
		// between 0 and half circumference
		angle ??= 3*Math.PI/2;
		let _angle = posmod(angle + 2*Math.PI*time, 2*Math.PI);
		let coor = [
			x + Math.cos(_angle)*r,
			y + Math.sin(_angle)*r,
		];
		let _r = Math.hypot(
			x + r*Math.cos(angle) - coor[0],
			y + r*Math.sin(angle) - coor[1]
		);
		if(ctx === "getdata") {
			return [coor[0], coor[1], _r];
		}
		else {
			circledraw(ctx, ...coor, _r);
		};
	};
	suite.hypnosis_partial = new ProcAnim();
	suite.hypnosis_partial.initB = function() {
	//this.hypnosis_partial = suite.hypnosis_partial;
	//this.hypnosis_partial.initA(u, v.duration, {pos: [u.w/2, u.h/2], r: u.w/8, direction: 3*Math.PI/2});
	//this.hypnosis_partial.func(frame, color0, color1, bloblength)
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		let i1 = 0;
		let i2 = 0;
		v.r ??= u.w/8;
		v.angle ??= 3*Math.PI/2;
		v.pos[0] -= v.r*Math.cos(v.angle);
		v.pos[1] -= v.r*Math.sin(v.angle);
		v.blob = [];
		for(i1 = 0; i1 < v.duration; i1++) {
			let temp = easing(i1/v.duration, "in/out", "cube");
			temp = (temp * 1/2) + ((i1/v.duration) * 1/2);
			v.blob[i1] = slite.cardioidblob("getdata", temp, v.pos[0], v.pos[1], v.r, v.angle);
			v.blob[i1][ v.blob[i1].length ] = i1;
		};
		ctx.fillStyle = "black";
		//
		v.initialized = true;
	};
	suite.hypnosis_partial.func = function(frame, color0, color1, bloblength) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		color0 ??= "#bf7fff";
		color1 ??= "magenta";
		bloblength ??= 4;
		let data = v.blob.slice(frame - bloblength, frame);
		data.sort((a, b) => (-Math.abs(b[3] - v.duration/2)) - (-Math.abs(a[3] - v.duration/2)) );
		for(i1 = 0; i1 < data.length; i1++) {
			ctx.strokeStyle = colormath(ctx, color0, color1, i1/(data.length - 1));
			circledraw(ctx, ...data[i1].slice(0, 3), true);
			circledraw(ctx, ...data[i1].slice(0, 3), false);
		}
		// TODO
		// - make this a separate ProcAnim named hypnosis or something
		// - make it play four times, rotating each time but keeping the zero
		//   radius point in the same spot
		//   - make them overlap a little in timing
		//   - have them reverse direction at the right places to make it sort
		//     of draw a clover?
		//   - wait, i can do this with a nested procanim. why don't i do that
		//     more often, timing is always a pain in the ass
		//
		this.frameend(frame);
	};
	suite.hypnosis = new ProcAnim();
	suite.hypnosis.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		let i1 = 0;
		let i2 = 0;
		this.hypnosis_partial = suite.hypnosis_partial;
		v.spacing = 14;
		v.durations = 16;
		v.startangle = 3*Math.PI/2;
		v.anglechange = -Math.PI/2;
		v.numofpartials = 4;
		v.lastinit = null;
		// you need to run initA when you switch from one partial to the next,
		// and in a lot of cases you'll need to run multiple on one frame. this
		// helps it know where to rerun initA
		v.v_backups = [];
		// and you gotta save and restore this
		// - why did i make a system where you can do everything BUT run the
		//   same animation multiple times? am i that dumb?
		v.createbackup = function(v) {
			let i1 = 0;
			let backup = {};
			for (i1 in v) {
				if (v.hasOwnProperty(i1) && typeof v[i1] !== "function" && !["u", "ctx"].includes(i1)) {
					backup[i1] = structuredClone(v[i1]);
				}
			}
			return backup;
		};
		v.restorebackup = function(v, backup) {
			let i1 = 0;
			for (i1 in backup) {
				if (backup.hasOwnProperty(i1)) {
					v[i1] = structuredClone(backup[i1]);
				}
			}
		}
		//
		v.initialized = true;
	};
	suite.hypnosis.func = function(frame, color0, color1, bloblength) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		for(i1 = 0; i1 < v.numofpartials; i1++) {
			let start = i1*v.spacing;
			if(start <= frame && frame < start + v.durations) {
				if(v.lastinit !== i1) {
					this.hypnosis_partial.initA(u, v.durations, {
						pos: structuredClone(v.pos),
						r: u.w/8,
						angle: posmod(v.startangle + i1*v.anglechange, 2*Math.PI),
					});
					v.lastinit = i1;
					if(!!v.v_backups[i1]) {
						v.restorebackup(this.hypnosis_partial.v, v.v_backups[i1]);
					};
				};
				this.hypnosis_partial.func(frame - start, color0, color1, bloblength);
				v.v_backups[i1] = v.createbackup(this.hypnosis_partial.v);
			};
		}
		// TODO
		// - it doesn't overlap properly and there's an awkward change partway
		//   through every partial.
		// - make this a more general ProcAnim for this exact kind of multiple
		//   runnings.
		//
		this.frameend(frame);
	};
	slite.star = {
	// v.star = slite.star.create(x, y, r, points, angle);
	// let points = slite.star.points(v.star, r*frame/duration, 2*Math.PI*frame/duration);
		create: function(x, y, r, points, angle) {
			x ??= 0;
			y ??= 0;
			r ??= 1;
			points = typeof points === "number" && points >= 4 ? points : 5;
			angle ??= 0;
			return {
				x,
				y,
				r,
				points,
				angle,
				progress: 0,
			};
		},
		points: function(_this, progress, angle) {
		// - _this: star created by the create function.
		// - progress: how many pixels outward each side should be moved.
		// - angle: adds to the angle the star already has.
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			progress ??= 0;
			angle ??= 0;
			progress += _this.progress;
			angle += _this.angle;
			let tips = [];
			for(i1 = 0; i1 < _this.points; i1++) {
				let _angle = 2*Math.PI*i1/_this.points + angle;
				_angle = posmod(_angle, 2*Math.PI);
				tips[i1] = [
					_this.x + _this.r*Math.cos(_angle),
					_this.y + _this.r*Math.sin(_angle)
				];
			}
			let interval = _this.points%2 ? Math.floor(_this.points/2) : _this.points/2 - 1;
			let data = [];
			// what it returns.
			function pitdata(point, otherside) {
				let i1 = 0;
				let i2 = 0;
				let temp = [
					0,
					-interval
				];
				let cutoff = [
					-1,
					-1 + interval
				];
				// how many places up or down from the relevant tip each point
				// is. (that is, the four points used in the fourpointintersect)
				for(i1 = 0; i1 < 2; i1++) {
					if(otherside) {
						temp[i1] *= -1;
						cutoff[i1] *= -1;
					};
					temp[i1] = posmod(point + temp[i1], _this.points);
					cutoff[i1] = posmod(point + cutoff[i1], _this.points);
				};
				let coor = fourpointintersect(
					...tips[ temp[0]   ],
					...tips[ temp[1]   ],
					...tips[ cutoff[0] ],
					...tips[ cutoff[1] ],
					true
				);
				// coordinates of the armpit.
				//console.log(point + (otherside ? "B" : "A") + ":" + coor);
				const tip_angle = get2dangle(
					tips[point][0] - coor[0],
					tips[point][1] - coor[1]
				);
				cutoff = [...tips[cutoff[0]], ...tips[cutoff[1]]];
				// structured as a line fourpointintersect can use
				let out_angle = get2dangle(
					cutoff[0] - cutoff[2],
					cutoff[1] - cutoff[3],
				);
				// move parallel to the cutoff line
				let line = [
					coor[0] + progress*Math.cos(out_angle),
					coor[1] + progress*Math.sin(out_angle),
					tips[point][0] + progress*Math.cos(out_angle),
					tips[point][1] + progress*Math.sin(out_angle)
				];
				return {
					x: coor[0],
					y: coor[1],
					tip_angle,
					out_angle,
					cutoff,
					line,
				};
			};
			for(i1 = 0; i1 < _this.points; i1++) {
			// - find the armpits
			// - find the angle that makes it move outward
			// - find the lines that define the star, the ones relevant to
			//   said armpit (you draw a 5-point star by going from 0 to 2,
			//   4, 1, 3, right? those lines.)
			// - create a line using the pit and the angle
			// - find the intersection between that and the defining line
			// - find the intersection between that and the counterpart
				let pitA = pitdata(i1, false);
				let pitB = pitdata(i1, true);
				// in the form of two points, moved [progress] pixels in the
				// out_angle.
				//console.log(pitA);
				//console.log(pitB);
				//console.log([Angle.convert(pitA.tip_angle), Angle.convert(pitB.tip_angle)]);
				data[i1] = [
					pitA.line,
					pitB.line
				];
			}
			return data;
		},
	};
	slite.bean = function(fineness, scaling, h_squish, d_scaler) {
	// BEAN
		let i1 = 0;
		let i2 = 0;
		fineness ??= 32;
		scaling ??= 64;
		h_squish ??= 3/4;
		d_scaler ??= 5/8;
		function bean(core, roller, buffer, fineness, squish) {
		// - core, roller: radii
		//   - look up cardioids and epicycloids. it's a shape made by
		//     tracing the edge of a circle as it rotates around another
		//     circle.
		//   - this function cheats a little bit though. normally, radii
		//     differences affect how many dips it has, but this will force
		//     1 dip no matter what. which doesn't quite make sense for
		//     "rolling".
		// - buffer: and epitrochoids are the same thing, except the point
		//   it traces is on the inside on the roller instead of the edge.
		//   makes it softer, and a little bigger.
		//   - roller + buffer = how far from the roller center the traced
		//     point is.
		// - fineness: how many points it makes.
		// - squish: number for scaling the points in the direction of the
		//   dip. (ex: 1 will look mostly like a cardioid, .75 will be
		//   squished 25% to look more like a bean.)
			let i1 = 0;
			core ??= 1;
			roller ??= 1/2;
			buffer ??= 0;
			fineness ??= 32;
			squish ??= 3/4;
			let points = [];
			for(let i1 = 0; i1 < fineness; i1++) {
				let core_angle = 2*Math.PI*i1/fineness;
				// angle from the core to the contact point
				let roller_angle = (core_angle*2)%(2*Math.PI);
				// angle from the roller to the contact point
				let coor = [
					(core*squish + roller)*Math.cos(core_angle),
					(core + roller)*Math.sin(core_angle)
				];
				// the *core gets it from the core to the contact point, the
				// roller gets it from there to the roller center
				coor[0] += (roller + buffer)*Math.cos(roller_angle);
				coor[1] += (roller + buffer)*Math.sin(roller_angle);
				//coor[0] *= squish;
				points[points.length] = structuredClone(coor);
			}
			return points;
		}
		let final = [];
		for(i1 = 0; i1 < fineness/4; i1++) {
			let angle = (Math.PI/2)*i1/(fineness/4);
			angle = [
				Math.cos(angle),
				Math.sin(angle)
			];
			let z = angle[1]*scaling*d_scaler;
			let points = [angle[0]*1, angle[0]*1/2, angle[1]*(-1/4)];
			points = bean(...points, fineness, h_squish);
			for(i2 = 0; i2 < points.length; i2++) {
				final[final.length] = [
					scaling*points[i2][0],
					scaling*points[i2][1],
					z
				];
				if(z) {
					final[final.length] = structuredClone(final[final.length - 1]);
					final[final.length - 1][2] *= -1;
				};
			}
		}
		return revolve(Math.PI/2, final, null, "xy");
	};
	slite.eye = class {
		constructor() {
			let ref = slite.eye.template;
			for(let i1 in ref) {
				if(ref.hasOwnProperty(i1)) {
					this[i1] = structuredClone(ref[i1]);
				};
			}
		}
		static template = {
			r: 1,
			corner: {
				l: [-1, 0],
				r: [1, 0],
			},
			top: [
				[-.5, -.5],
				[.5, -.5],
			],
			bottom: [
				[-.5, .5],
				[.5, .5],
			],
			closed: [],
			openness: [1, 1],
			// the way all of these work is:
			// - all points are cast onto a sphere with 1 radius, then
			//   multiplied by .radius.
			//   - if the hypotenuse of any point is above 1, it'll be made
			//     shorter.
			// - corner.l, top, and corner.r form the line the upper lid rests
			//   at
			// - same for bottom
			// - and corner.l, closed, and corner.r form the line the lids rest
			//   at when closed.
			// - openness[0] and openness[1] are numbers for how open the lids
			//   are.
			//   - if it's 1, they're where they are in top/bottom.
			//   - if it's 0, they're at closed.
			//   - if it's -1, they're at the opposite top/bottom.
			//   - anything above 1 or below -1... they just continue in that
			//     direction.
			//   - in other words, higher numbers open it wider, lower closes
			//     them.
			sclera: "white",
			iris: {
				type: "dome",
				r: 2,
			},
			pupil: {
				type: "circle",
				r: 1,
			},
		}
		static spherecast(x, y) {
		// converts x/y coordinates to a 3d angle for where that'd be projected
		// onto a sphere with 1 radius.
			let hypot = Math.hypot(x, y);
			let point = (
				hypot >= 1
				?
				[
					x/hypot,
					y/hypot,
					0
				]
				:
				[
					x,
					y,
					Math.sqrt(1 - x**2 - y**2)
				]
			);
			return Angle.get(...point);
		}
		get shape() {
		// returns the eye shape as a series of xy/z angles representing a
		// closed shape on the surface of the sphere.
		// - you only need to run this when corner, top, bottom, closed, or
		//   openness changes.
			let i1 = 0;
			let i2 = 0;
			let angle = {
				corner: {
					l: slite.eye.spherecast(...this.corner.l),
					r: slite.eye.spherecast(...this.corner.r),
				},
				top: [],
				bottom: [],
				closed: [],
			};
			let place = {
				top: [],
				bottom: [],
				closed: [],
			};
			let temp = ["top", "bottom", "closed"];
			for(i1 = 0; i1 < temp.length; i1++) {
				let _i1 = temp[i1];
				let ref = angles[_i1];
				for(i2 = 0; i2 < this[_i1].length; i2++) {
					ref[i2] = slite.eye.spherecast(...this[_i1][i2]);
					place[_i1][i2] = Angle.compare(ref[i2], i2 ? ref[i2 - 1] : angle.corner.l);
					// radians from this to the previous point
				}
				for(i2 = 1; i2 <= place[_i1].length; i2++) {
					place[_i1][i2] += place[_i1][i2 - 1];
					// radians from the first point to this
				}
				if(place[_i1].length) {
					let total = place[_i1][ place[_i1].length - 1 ] + Angle.compare(ref[ref.length - 1], angle.corner.r);
					// radians from the first point to the last
					for(i2 = 0; i2 <= place[_i1].length; i2++) {
						place[_i1][i2] /= total;
						// 0-1 numbers for where it is from the first point to
						// the last
					}
				}
			}
			function findalongpath(name, num) {
			// findalongpath("top", .5) = "find the halfway point of the top
			// lid's line." (as an angle.)
				for(let i1 = 0; i1 <= place[name].length; i1++) {
					let prev = i1 ? place[name][i1 - 1] : 0;
					let prev_angle = i1 ? angle[name][i1 - 1] : angle.corner.l;
					let next = i1 < place[name].length ? place[name][i1] : 1;
					let next_angle = i1 < place[name].length ? angle[name][i1] : angle.corner.r;
					if(num === prev) {
						return angle[name][i1 - 1];
					}
					else if(num === next) {
						return angle[name][i1];
					}
					else if(num > prev && num < next) {
						return Angle.between(prev_angle, next_angle, (num - prev)/(next - prev));
					};
				}
				console.log("this shouldn't happen");
				return null;
			}
			let shape = [];
			for(i0 = 0; i0 < 2; i0++) {
			// take into account all three lines and the openness numbers to
			// form the shape.
				let array = [];
				let open = this.openness[i0];
				if(open === 0) {
					array = structuredClone(angle.closed);
				}
				else {
					let lid = invertboolean(i0, open < 0) ? "bottom" : "top";
					open = Math.abs(open);
					// run for the top lid, then the bottom lid. if open is
					// negative, draw it as the opposite lid and invert open to
					// match.
					for(i1 = 0; i1 < angle[lid].length; i1++) {
						array[array.length] = Angle.between(findalongpath("closed", place[lid][i1]), angle[lid][i1], open);
					}
				}
				shape[shape.length] = angle.corner["lr"[i0]];
				if(i0) {
					for(i1 = array.length - 1; i1 >= 0; i1--) {
						shape[shape.length] = array[i1];
					}
				}
				else {
					shape = shape.concat(array);
				}
			}
			return shape;
		}
		render() {
			let i1 = 0;
			let i2 = 0;
			let shape = this.shape;
			let points = [];
			for(i1 = 0; i1 < shape.length; i1++) {
				points[i1] = Angle.numbers(shape[i1]);
				points[i1][0] *= this.r;
				points[i1][1] *= this.r;
				points[i1][2] *= this.r;
			}
			let raster = [];
			let w = 2*this.r + 1;
			for(i1 = 0; i1 < w**2; i1++) {
				raster[i1] = 0;
			}
			// make an empty image
			raster = Raster.ellipse(raster, w, 0, 0, 2*this.r, 2*this.r);
			// start with a full circle
			for(i1 = 0; i1 < shape.length; i1++) {
			// find the 2d version of the ellipse, and exclude pixels if they're
			// not inside it.
				let angle1 = shape[i1];
				let angle2 = shape[(i1 + 1)%shape.length];
				let axis = null;
				if(angle1[1] >= 0 || angle2[1] >= 0) {
				// if both points are on the back side, skip it. if only one is,
				// bring it to 0 z.
					axis = Quat.arc(angle1, angle2);
				}
				if(axis) {
				// don't do anything if they're both the same angle
					let magnitude = axis.magnitude;
					axis = axis.axis;
					// arc between them. the ellipse they're both on would be the
					let xy = Angle.numbers(axis).slice(0, 2);
					let minor = Math.hypot(...xy);
					// the radius of the narrowest dimension
					xy = get2dangle(...xy, true) ?? 0;
					// xy angle of that narrowest dimension (null means it's
					// perpendicular to the screen)
					for(i2 = 0; i2 < raster.length; i2++) {
						if(raster[i2]) {
							let x = i2%w - this.r;
							let y = Math.floor(i2/w) - this.r;
							// - minor*this.r = ellipse w
							// - this.r = ellipse h
							// - xy = how much it's rotated
							let temp = [
								Math.cos(-angle),
								Math.sin(-angle)
							];
							x = x*temp[0] - y*temp[1];
							y = x*temp[1] + y*temp[0];
							// "complex number" rotation
							// - (x, y), angle
							// - (x + y*i)*(cos(angle) + sin(angle)*i)
							// - (x*cos - y*sin) + (x*sin + y*cos)*i
							// - x = x*cos - y*sin, y = x*sin + y*cos
							// - somehow.
							// =
							// - you can tell if it's inside by rotating it by
							//   negative xy, and seeing if it's inside the
							//   unrotated version of the ellipse
							x /= minor;
							if(Math.hypot(x, y) > 1) {
								raster[i2] = 0;
							};
							// which can be done more simply by dividing x by minor
							// and checking if the hypotenuse is within this.r.
						}
					}
				};
			}
			// convert from angles to coordinates, multiply by radius
		}
	};
	slite.face = class {
		constructor() {
			let ref = slite.face.template;
			for(let i1 in ref) {
				if(ref.hasOwnProperty(i1)) {
					this[i1] = structuredClone(ref[i1]);
				};
			}
		}
		static template = {
			cranium: {
				w: 32,
				h: 28,
				d: 28,
				xz: 2*Math.PI*11/12,
				// how much to rotate it in the xz plane.
				// - when viewing the head from the left, positive is clockwise,
				//   negative is counterclockwise.
				// - the w/h/d numbers apply *after* rotation. the box the
				//   spheroid fits in will have the same dimensions no matter
				//   what this angle is.
				fineness: 16,
				// 32 would better fit the resolution, and it wouldn't break the
				// bank either... but i think a flatter and sharper spheroid is
				// closer to a real head than a rounder one.
			},
			mouth: {
				column: {
				// data for the rigid, skeletal parts of the mouth area.
				// - the properties define the position and dimensions of
				//   several half-ellipses.
				// - properties are cumulative. if an area's y is 4, that means
				//   that half-ellipse is 4 below the previous half-ellipse.
				// - if a property is missing, it uses 0.
				// - i recommend giving toptop more w and d than start. that
				//   emulates the maxilla better.
					start: {
					// where the cranium ends and the gums begin.
						y: 10,
						z: -1,
						// NOTE: these are relative to the center of the
						// cranium.
						w: 16,
						d: 16,
					},
					toptop: {
						y: 4,
						w: 2,
						d: 1,
					},
					topbottom: {
						y: 4,
					},
					// the top and bottom of the top row of teeth.
					bottomtop: {
						y: 4,
					},
					bottombottom: {
						y: 4,
					},
					// the bottom row of teeth
					end: {
						y: 4,
						w: -2,
						d: -1,
					},
					// chin
				},
				column_fineness: 16,
				// number of sides those half-ellipses have
				fineness: 16,
				// number of sides the mouth curve has (or one half of it
				// anyway. remember that it folds onto itself when closed.)
				fulcrum: {
					y: 0,
					z: 0,
				},
				// where the fulcrum of the jaw is, relative to the center of
				// the cranium.
			},
			convex: [],
			// points that are added to the main head shape. concave features
			// won't show. (put cheekbones and stuff in here.)
			concave: {
			// shapes that are drawn as part of the head, but in a way that
			// allows for concave features. (for example, if you put the nose
			// and ear shapes in .convex... it'll just look like they're wearing
			// a skintight bag over their head.)
				nose: {
					points: [],
				},
				ear: {
					points: [],
				},
			},
		}
		render() {
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let ref = this.cranium;
			let temp = Quat.new("xy", Math.PI/2);
			if(ref.xz) {
				temp = Quat.rotate(temp, "xz", ref.xz);
			};
			let shape = addspheroids([[0, 0, 0, ref.w, ref.h, ref.d, temp]], ref.fineness ?? 16);
			if(ref.xz) {
				temp = {
					h: Math.hypot(
						ref.d*Math.cos(-ref.xz + Math.PI/2),
						ref.h*Math.sin(-ref.xz + Math.PI/2)
					),
					d: Math.hypot(
						ref.d*Math.cos(-ref.xz),
						ref.h*Math.sin(-ref.xz)
					),
				};
				// this should be the new h and d after rotation, so divide all
				// y/z coordinates by these.
				for(i1 = 0; i1 < shape.length; i1++) {
					shape[i1][1] /= temp.h;
					shape[i1][2] /= temp.d;
				}
			}
			shape = shape.concat(shape.convex);
			// add cheekbones and stuff
			let jaw = [];
			// array of points that get rotated with the jaw
			ref = this.mouth.column;
			let column = {};
			temp = [
				"start",
				"toptop",
				"topbottom",
				"bottomtop",
				"bottombottom",
				"end"
			];
			if(
				(ref.start ?? null) === null
				||
				(ref.start.w ?? null) === null
				||
				(ref.start.d ?? null) === null
			) {
			// this is probably an accident, since it would mean a curve with
			// zero w or d
				console.log(".column.start is incomplete.");
				return;
			}
			for(i1 = 0; i1 < temp.length; i1++) {
				let _i1 = temp[i1];
				if(i1 === 0) {
					column[_i1] = structuredClone(ref[_i1]);
					column[_i1].y ??= 0;
					column[_i1].z ??= 0;
				}
				else {
					column[_i1] = structuredClone(column[temp[i1 - 1]]);
					// clone the previous level
					for(i2 = 0; i2 < 4; i2++) {
						column[_i1]["yzwd"[i2]] += ref[_i1]["yzwd"[i2]] ?? 0;
					}
				};
				for(i2 = 0; i2 <= this.mouth.column_fineness; i2++) {
				// get the points of the half-ellipse
					let angle = Math.PI*i2/this.mouth.column_fineness;
					let point = [
						Math.cos(angle)*column[_i1].w/2,
						column[_i1].y,
						column[_i1].z + Math.sin(angle)*column[_i1].d
					];
					if(i1 >= temp.length/2) {
						jaw[jaw.length] = structuredClone(point);
					}
					else {
						shape[shape.length] = structuredClone(point);
					}
				}
			}
			// now column is a copy of this.column, except complete
		}
	}
	slite.expression = class {
		constructor() {

		}
		static template = {
			jaw: {
				yz: 0,
				xz: 0,
			},
			// how much the jaw is opened, measured in radians
			mimetics: {
			// i don't know anything about mimetic muscles except that the word
			// is fun to say and basing variables off of those muscles would be
			// complicated and unintuitive. instead, how this works is that for
			// every push and pullable feature, there's an array of "drag this
			// point here" actions.
				mouth: [],
			},
		}
	};
	suite.test = new ProcAnim();
	suite.test.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2, -u.w/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		let i1 = 0;
		let i2 = 0;
		this.revolvingrings = suite.revolvingrings;
		this.revolvingrings.initA(u, v.duration);
		this.shimmershape = suite.shimmershape;
		this.shimmershape.initA(u, v.duration);
		v.shape2d = new Shape2d([
			{
				x: -1,
				y: .5,
				elbow: {
					direction: "l",
				},
			},
			{
				x: -.5,
				y: -.5,
			},
			{
				x: 1,
				y: -.5,
				elbow: {
					direction: "in",
				},
			},
			{
				x: 0,
				y: .5,
				elbow: {
					x: -.5,
					y: 1.5,
				},
			},
		], true);
		v.shape2d.modcoordinates({multiply: [u.w/4, u.h/4]});
		this.polaris = suite.polaris;
		this.polaris.initA(u, v.duration);
		this.starblast = suite.starblast;
		this.starblast.initA(u, v.duration);
		ctx.strokeStyle = "white";
		this.rhythmicshine = suite.rhythmicshine;
		this.rhythmicshine.initA(u, v.duration);
		if((v.shape ?? null) === null) {
			v.shape = build3dshape("cube", Math.min(u.w, u.h)/2);
			let i1 = 0;
			for(i1 = 0; i1 < 6; i1++) {
				v.shape.faces[i1].fill = ["red", "orange", "yellow", "green", "blue", "purple"][i1];
			}
			v.shape = polysubdivide(v.shape, 4);
			for (i1 = 0; i1 < v.shape.faces.length; i1++) {
				if(v.shape.faces[i1].hasOwnProperty("hide")) {
					//delete v.shape.faces[i1].hide;
				};
			}
			v.shape.faces[0].stroke = "white";
		}
		//
		v.dithers = [];
		let numofdithers = 3;
		// NOTE don't make this higher than the number of distinct period.xs
		// there are in dithers.
		let periods = [];
		let lcd = 1;
		let log = [];
		v.dithers[0] = {
			dither: "carpet",
			invert: Math.random() < .5,
			speed: 1,
			color: "white",
		};
		for(i1 = v.dithers.length; i1 < numofdithers; i1++) {
			let temp = structuredClone(Object.keys(dithers));
			let dithername = randomarrayitem(temp);
			let period = (dithers[dithername].hasOwnProperty("period") ? dithers[dithername].period.x : 0);
			for(i2 = 0; (dithername !== "none" || (dithername.startsWith("noise ") && dithername.endsWith("%")) || lcd%period === 0) && i2 < 1000; i2++) {
				dithername = randomarrayitem(temp);
				period = (dithers[dithername].hasOwnProperty("period") ? dithers[dithername].period.x : 0);
			};
			periods[periods.length] = period;
			lcd = mathlcd(periods);
			let speed = (i1 === 0 ? 1 : v.dithers[i1 - 1].speed + 1);
			if(speed !== 1 && period && period%speed === 0) {
			// if it folds evenly into period.x, add to it until it doesn't
				for(; period%speed === 0 && speed < 1000; speed++) {
				}
			}
			v.dithers[i1] = {
				dither: dithername,
				invert: Math.random() < .5,
				speed,
				color: "white",
			};
			log[i1] = (v.dithers[i1].invert ? "inverted " : "") + v.dithers[i1].dither + " (" + v.dithers[i1].speed + ")";
		}
		//console.log(log.join(String.fromCharCode(10)));
		//
		//v.start_func = "circle";
		//v.start_args = [v.pos[0], v.pos[1], u.w/4, "lopsided"];
		//v.start_func = "point";
		//v.start_args = [v.pos[0], v.pos[1]];
		v.start_func = "circle";
		v.start_args = [v.pos[0], v.pos[1], u.w/8, "inside"];
		//v.start_func = "rect";
		//v.start_args = [u.w*3/8, u.h*3/8, u.w/4, u.h/4];
		v.fire = slite.walkers.create(u.w, u.h, v.start_func, v.start_args, null, null, ["direct", Math.PI*3/2]);
		//v.colorfunc = null;
		//v.colorfunc = (num) => "rgb(" + [16*num, 16*num, 16*num].join() + ")";
		//v.colorfunc = (num) => "rgb(" + [Math.max(0, 192 - 12*num), 191 - Math.min(64, 4*num), 191 + Math.min(64, 4*num)].join() + ")";
		//v.colorfunc = (num) => "rgb(" + [Math.min(191, 12*num), 127 + Math.min(64, 4*num), 255 - Math.min(64, 4*num)].join() + ")";
		v.colorfunc = (num) => (num > 8 ? "white" : "cornflowerblue");
		//
		v.cardioid = [];
		for(i1 = 0; i1 < v.duration; i1++) {
			//let coor = slite.spiro(i1/v.duration, [2, 1], [1, 1/2]);
			// cardioid
			let coor = slite.spiro(i1/v.duration, [1, 1], [1/7, 1]);
			coor[2] = 0;
			coor = revolve(Math.PI/2, coor, null, "xy");
			v.cardioid[i1] = [
				(coor[0]*u.w/8) + u.w/2,
				(coor[1]*u.w/8) + u.h/2,
			];
		}
		v.trace = v.duration;//3;
		// number of points it connects at once
		v.tunnel = {spacing: u.w/8, rings: 1};//64};
		// spacing is what it subtracts from z, rings is how many it draws
		//u.viewer.y = u.h*-2/8;
		v.pulse = {
			wavetype: "sine",
			size: 3/2,//1,
			z: v.tunnel.spacing*1,//22/7,
			rhythm: "o---------------",
			duration: 8,
			cutoff: 1,
			invert: true,
			magnitude: [],
		};
		// works like this:
		// - wave() is used to get a number.
		//   - wavetype is whether it's sine or saw or what
		//   - this is run separately for size and z. size is used as a
		//     multiplier for the points' distance from the center, and z is
		//     added to z
		//   - duration is how long one wave is. the frame number is divided by
		//     that.
		// - rhythm is used to determine when a pulse happens. the pulse isn't
		//   an uninterrupted wave, it's a single wave, equilibrium to crest to
		//   etc trough etc equilibrium.
		// - and cutoff cuts that off. so you can make it only go to the halfway
		//   point, and never drop below equilibrium.
		// - magnitude is an array created ahead of time for every frame. works
		//   like v.cardioid, it's more efficient to calculate it ahead of time.
		//   - each item is itself an array: the size, and the z. (for technical
		//     reasons they have to be separate. size compounds through
		//     multiplication, z through addition)
		// - invert inverts the movement of the waves
		for(i1 = 0; i1 < v.duration; i1++) {
			v.pulse.magnitude[i1] = {size: 1, z: 0};
		};
		for(i1 = 0; i1 < v.duration; i1++) {
			let rhythm = rhythmat(v.pulse.rhythm, i1);
			// rhythm is kind of stupid and i need to rehaul it, but for right
			// now, it's enough.
			if(rhythm.toUpperCase() !== rhythm.toLowerCase()) {
			// note on this frame: a wave starts
				for(i2 = 0; i2 < v.pulse.duration; i2++) {
					let frame = (i1 + i2)%v.duration;
					//let frame = posmod(i1 - i2, v.duration);
					let place = i2/v.pulse.duration;
					if(place <= v.pulse.cutoff) {
						let temp = wave(place, v.pulse.wavetype);
						if(temp > 0) {
							v.pulse.magnitude[frame].size *= temp*v.pulse.size + (1 - temp)*1;
						}
						else if(temp < 0) {
							v.pulse.magnitude[frame].size *= -temp*1/v.pulse.size + (1 - -temp)*1;
						}
						else if(temp !== 0) {
							console.log("this shouldn't happen");
						}
						v.pulse.magnitude[frame].z += wave(place, v.pulse.wavetype, 0, v.pulse.z);
					};
				}
			};
		};
		//console.log(v.pulse.magnitude);
		v.wavemod = (input, frame) => [
		// modifies coordinates based on the magnitude array of the given frame.
			(input[0] - v.pos[0])*v.pulse.magnitude[frame].size + v.pos[0],
			(input[1] - v.pos[1])*v.pulse.magnitude[frame].size + v.pos[1],
			input[2] + v.pulse.magnitude[frame].z
		];
		// TODO
		// - split this up into spirograph-drawing code and pulsating tunnel
		//   code
		// - make it smoother, have it define multiple points per frame
		//
		v.blob = [];
		v.bloblength = 4;
		for(i1 = 0; i1 < v.duration; i1++) {
			let temp = easing(i1/v.duration, "in/out", "cube");
			temp = (temp * 1/2) + ((i1/v.duration) * 1/2);
			v.blob[i1] = slite.cardioidblob("getdata", temp, v.pos[0], v.pos[1], u.w/8);
			v.blob[i1][ v.blob[i1].length ] = i1;
		};
		//
		v.star = slite.star.create(u.w/2, u.h/2, u.w/4, 5, 3*Math.PI/2);
		//
		v.average = 0;
		//
		ctx.fillStyle = "black";
		ctx.strokeStyle = "white";
		v.initialized = true;
	};
	suite.test.func = function(frame) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		if(frame === 0) {
			let scene = RoundScene.shirt(u.w/4);
			scene.lamps.push(new TriLamp(0, -u.h/2, -u.w/2, 1, 1, 1));
			scene.render(ctx);
		}
		/*
		if(frame === 0) {
			v.walkers = new WalkerSet();
		}
		let spawn = 32;
		// number to delete/create every frame
		let stabilize = 128;
		// only delete if the population is higher than this
		v.walkers.append("sphere", [...v.pos, u.w/4], spawn);
		// generate new walkers
		let distfromcenter = (walker) => Math.hypot(...Points.subtract(Points.convert(walker), v.pos));
		v.walkers.sort((a, b) => distfromcenter(a) - distfromcenter(b));
		if(v.walkers.length > stabilize) {
		// get rid of the furthest walkers
			let temp = v.walkers.length - stabilize;
			v.walkers.splice(v.walkers.length - temp, temp);
		}
		for(i1 = 0; i1 < v.walkers.length; i1++) {
		// rise upward, further the closer it was to the center (counteracts
		// the way condense makes everything collapse into the center)
			let rise = Points.convert(v.walkers[i1]);
			rise = Math.hypot(...Points.subtract(rise, v.pos));
			rise /= 2*v.walkers.mediandist(v.pos);
			rise = mound(rise);
			rise *= 32;
			v.walkers[i1].velocity.y -= rise;
		}
		v.walkers.direct("angle", null, 4);
		// move back and forth a little
		v.walkers.process();
		// move
		v.walkers.condense(3, v.pos);
		v.walkers.draw(ctx, 0, 0, 0, 0, u.w, u.h, (list) => (
			list.length
			?
			"rgb(255, " + Math.min(Math.floor(list.length*255/4), 255) + ", 0)"
			:
			null
		));
		//*/
		/*
		if(frame === 0) {
			v.log = [];
		}
		let average_x = 0;
		let prev_x = null;
		let prev_y = null;
		let r = u.w/4;
		ctx.strokeStyle = "white";
		for(i1 = 0; i1 <= frame; i1++) {
			let angle = Math.PI*i1/(v.duration - 1);
			let x = r*Math.cos(angle);
			let y = r*Math.sin(angle);
			average_x += x;
			if(prev_x !== null && prev_y !== null) {
				for(i2 = 0; i2 < 2; i2++) {
					linespecial(ctx,
						v.pos[0] + prev_x,
						v.pos[1] + prev_y*(i2 ? -1 : 1),
						v.pos[0] + x,
						v.pos[1] + y*(i2 ? -1 : 1),
					v.pos.slice(0, 2));
				}
			};
			//
			prev_x = x;
			prev_y = y;
		}
		average_x /= frame + 1;
		v.log[v.log.length] = average_x;
		for(i1 = 0; i1 < v.log.length; i1++) {
			ctx.fillRect(v.pos[0] + v.log[i1], v.pos[1] + (v.log.length - 1) - i1, 1, 1);
		}
		ctx.fillStyle = "green";
		*/
		/*
		console.log([
			frame,
			average_x/r,
			Math.asin(frame/(v.duration - 1))/Math.PI,
			Math.acos(frame/(v.duration - 1))/Math.PI
		]);
		function randmove(mode) {
			let x = 0;
			let y = 0;
			if(mode === "eight") {
				let dir = Math.floor(Math.random()*8);
				if(dir%2 === 0) {
					//dir = Math.floor(Math.random()*8);
				};
				// 567
				// 4 0
				// 321
				if([5, 6, 7].includes(dir)) {
					y--;
				}
				else if([3, 2, 1].includes(dir)) {
					y++;
				};
				if([5, 4, 3].includes(dir)) {
					x--;
				}
				else if([7, 0, 1].includes(dir)) {
					x++;
				};
			}
			else if(mode === "four") {
				if(Math.random() < .5) {
					x = Math.random() < .5 ? -1 : 1;
				}
				else {
					y = Math.random() < .5 ? -1 : 1;
				};
			}
			else if(mode === "knight") {
				let angle = Math.floor(Math.random()*8);
				let temp = angle%4;
				temp = temp === 1 || temp === 2;
				x = temp ? 2 : 1;
				y = temp ? 1 : 2;
				if(angle%8 < 4) {
					x *= -1;
				};
				if((angle + 6)%8 < 4) {
					y *= -1;
				};
			}
			else if(mode === "diagonal") {
				x += Math.random() < .5 ? -1 : 1;
				y += Math.random() < .5 ? -1 : 1;
			}
			else if(mode === "hex") {
				let temp = Math.random() < 1/3;
				x = temp ? 0 : 2;
				y = temp ? 2 : 1;
				if(Math.random() < .5) {
					x *= -1;
				};
				if(Math.random() < .5) {
					y *= -1;
				};
			}
			else if(typeof mode === "number") {
				let angle = 2*Math.PI*Math.random();
				x = Math.trunc(Math.cos(angle)*mode);
				y = Math.trunc(Math.sin(angle)*mode);
			}
			else {
				if(typeof mode === "string" && mode.includes(":")) {
					mode = mode.split(":").slice(0, 2);
					mode = [
						Number(mode[0]),
						Number(mode[1])
					];
					if(
						mode[0] >= 0 && Number.isInteger(mode[0])
						&&
						mode[1] >= 0 && Number.isInteger(mode[1])
					) {
						if(Math.random() < .5) {
							x = mode[0];
							y = mode[1];
						}
						else {
							x = mode[1];
							y = mode[0];
						};
						if(Math.random() < .5) {
							x *= -1;
						};
						if(Math.random() < .5) {
							y *= -1;
						};
					};
				}
			}
			return {x, y};
		};
		if(frame === 0) {
			let numofwalkers = 64;
			v.walkers = [];
			for(i1 = 0; i1 < numofwalkers; i1++) {
				v.walkers[i1] = {x: v.pos[0], y: v.pos[1], colornum: Math.floor(Math.random()*3)};
				if(Math.random() < .5) {
				// adjustment for diagonal mode (so it doesn't look
				// checkerboard-y)
					let temp = randmove("four");
					v.walkers[i1].x += temp.x;
					v.walkers[i1].y += temp.y;
				};
			}
			v.data = {};
			// indexed by x position, then y position, value is how many times a
			// walker walked over it
			v.reproduction = 4;
			// modifies the odds of a walker duplicating on any given frame.
			// it's measured as what the population should be multiplied by by
			// the end.
		}
		let mode = "knight";
		// used in randmove
		let multiply = 1;
		// randmove is multiplied by a random number from 1 to this
		let decrement = .5;
		// after being drawn, pixels are decremented by this (and removed if
		// they reach 0)
		let reproduction = v.reproduction**(1/v.duration) - 1;
		// - end population = [start population] * (1 + [individual reproduction
		//   chance])**v.duration
		// - reproduction = (1 + [individual reproduction chance])**v.duration
		// - how did logarithms work again?
		//   - a**b = c, Math.log(c) / Math.log(a) = b
		//   - no, what i need here is the [duration] root of v.reproduction
		//   - which is reproduction ** (1/duration)
		// - individual reproduction chance = reproduction**(1/v.duration) - 1
		for(i1 = 0; i1 < v.walkers.length; i1++) {
		// advance walkers
			let ref = v.walkers[i1];
			if(Math.random() < reproduction) {
				v.walkers.splice(i1 + 1, 0, structuredClone(ref));
				//let temp = randmove("four");
				//v.walkers[i1 + 1].x += temp.x;
				//v.walkers[i1 + 1].y += temp.y;
			};
			let temp = randmove(mode);
			let _multiply = 1 + Math.floor(Math.random()*multiply);
			ref.x += temp.x*_multiply;
			ref.y += temp.y*_multiply;
			v.data[ref.x] ??= {};
			v.data[ref.x][ref.y] ??= 0;
			//v.data[ref.x][ref.y] = Math.floor(v.data[ref.x][ref.y]) + 1 + ref.colornum/10;
			v.data[ref.x][ref.y]++;
		}
		for(i1 in v.data) {
			if(v.data.hasOwnProperty(i1)) {
				for(i2 in v.data[i1]) {
					if(v.data[i1].hasOwnProperty(i2)) {
						let temp = [255, 255, 255];
						//temp[Math.round((v.data[i1][i2]%1)*10)] = Math.min(Math.floor(v.data[i1][i2])*16, 255);
						temp[Math.floor(Math.random()*3)] = Math.min(v.data[i1][i2]*16, 255);
						ctx.fillStyle = "rgb(" + temp.join(", ") + ")";
						//ctx.fillStyle = "rgb(255, " + Math.min(v.data[i1][i2]*16, 255) + ", 0)";
						ctx.fillRect(Number(i1), Number(i2), 1, 1);
						v.data[i1][i2] -= decrement;
						if(v.data[i1][i2] <= 0) {
							delete v.data[i1][i2];
						}
					}
				}
			}
		}
		//*/
		/*
		if(frame === 0) {
			let directions = "672067212364236035701756531453114107054605434174207602124632467";
			let x = 4;
			let y = 0;
			let w = 8;
			let h = 8;
			v.order = [];
			for(i1 = 0; i1 < directions.length; i1++) {
				v.order[i1] = w*y + x;
				let angle = Number(directions[i1]);
				let temp = angle%4;
				temp = temp === 1 || temp === 2;
				let _x = temp ? 2 : 1;
				let _y = temp ? 1 : 2;
				if(angle%8 < 4) {
					_x *= -1;
				};
				if((angle + 6)%8 < 4) {
					_y *= -1;
				};
				x += _x;
				y += _y;
				if(x < 0 || x >= w || y < 0 || y >= h) {
					console.log("this shouldn't happen");
					x = 0;
					y = 0;
				}
			}
			v.order[v.order.length] = w*y + x;
			v.pattern_w = w;
			v.pattern_h = h;
		}
		let w = v.pattern_w;
		let h = v.pattern_h;
		let frameskip = 1;
		let array = [];
		for(i1 = 0; i1 < w*h; i1++) {
			array[i1] = false;
		}
		for(i1 = 0; i1 < frameskip*frame && i1 < v.order.length; i1++) {
			array[v.order[i1]] = true;
		}
		ctx.fillStyle = "white";
		for(i1 = 0; i1 < u.w; i1 += w) {
			for(i2 = 0; i2 < u.h; i2 += h) {
				for(i3 = 0; i3 < array.length; i3++) {
					if(array[i3]) {
						ctx.fillRect(i1 + i3%w, i2 + Math.floor(i3/w), 1, 1);
					}
				}
			}
		}
		//*/
		/*
		if(frame === 0) {
		// trying to make an effect like the stuff in street fighter alpha when
		// you win with a super. it kinda sucks though.
		// - square works but it's as underwhelming as i expected
		//   - maybe i could randomize the value of each sector?
		// - tri looks like an incoherent blob. not sure if i screwed up or if
		//   that's just how it turns out
		// - saw looks wrong. i don't know where the spiralling comes from,
		//   shouldn't it just be a radial gradient?
		// - and i'm not interested enough to fix any of it.
			v.type = ["square", "tri", "saw"][0];
			v.density = 16;
			//v.density = 1 + Math.floor(randexponent(2)*32);
			v.contrast = u.w/2;
			v.colorfunc = (num) => "rgb(" + (Math.floor(wave(num/2, "tri")*255) + ", ").repeat(1) + "255, 255)";
			v.speed = 1;
			// measured in how many cycles it goes through by the end
			v.wavewidth = u.w/2;
			//
			v.breaks = [];
			for(i1 = 0; i1 < v.density; i1++) {
				v.breaks[i1] = Math.random();
			}
			if(v.breaks%2 && (v.type === "square" || v.type === "tri")) {
				v.breaks[v.breaks.length] = Math.random();
			}
			v.breaks.sort((a, b) => a - b);
			// an array of 0-1 numbers for where to place turning points
			v.values = null;
			if(v.type === "tri") {
				let start = Math.floor(Math.random()*v.breaks.length);
				let negative = Math.random() < .5;
				let value = 0;
				v.values = [];
				for(i1 = 0; i1 < v.breaks.length; i1++) {
				// the relationship of angle difference to value difference is
				// totally linear, and always the same slope.
					let _i1 = (start + i1)%v.breaks.length;
					v.values[_i1] = value;
					negative = !negative;
					value += (negative ? -1 : 1)*(
						_i1 === v.breaks.length - 1
						?
						1 - v.breaks[_i1] + v.breaks[0]
						:
						v.breaks[_i1 + 1] - v.breaks[_i1]
					);
				}
			}
			function angletovalue(angle) {
				let num = angle/(2*Math.PI);
				let prevbreak = null;
				let nextbreak = null;
				let difference = null;
				let place = null;
				if(num < v.breaks[0] || num >= v.breaks[v.breaks.length - 1]) {
					prevbreak = v.breaks.length - 1;
					nextbreak = 0;
					difference = 1 - v.breaks[v.breaks.length - 1] + v.breaks[0];
					if(num < v.breaks[0]) {
						place = (1 - v.breaks[prevbreak] + num)/difference;
					}
					else if(num >= v.breaks[prevbreak]) {
						place = (num - v.breaks[prevbreak])/difference;
					};
				}
				for(let i1 = 0; i1 < v.breaks.length - 1; i1++) {
					if(num >= v.breaks[i1] && num < v.breaks[i1 + 1]) {
						prevbreak = i1;
						nextbreak = i1 + 1;
						difference = v.breaks[i1 + 1] - v.breaks[i1];
						place = (num - v.breaks[i1])/difference;
					}
				}
				if(prevbreak === null) {
					console.log("this shouldn't happen");
					return;
				};
				return (
					v.type === "square" ? (prevbreak%2)/2 :
					v.type === "tri" ? (v.values[prevbreak] + place*(v.values[nextbreak] - v.values[prevbreak])) :
					v.type === "saw" ? place :
					null
				);
			}
			v.pixels = [];
			let angle_values = {};
			for(i1 = 0; i1 < u.w; i1++) {
				v.pixels[i1] = [];
				for(i2 = 0; i2 < u.h; i2++) {
					let temp = get2dangle(
						i1 - v.pos[0],
						i2 - v.pos[1],
						true
					);
					temp = typeof temp === "string" ? 0 : temp;
					angle_values[temp] ??= angletovalue(temp);
					v.pixels[i1][i2] = angle_values[temp];
				}
			}
			// for some reason, looking at v.angle_values in the console crashes
			// firefox.
			// - maybe just from the sheer number of properties. 65536 minus any
			//   groups of pixels with the same angle.
			//   - come to think of it, when you open a really big array, it
			//     breaks it up into 100-item chunks. there's no convenient way
			//     to do that for objects...
		}
		for(i1 = 0; i1 < u.w; i1++) {
			for(i2 = 0; i2 < u.h; i2++) {
				let dist = Math.hypot(i1 - v.pos[0], i2 - v.pos[1]);
				temp = v.pixels[i1][i2] + frame/(v.duration/v.speed) - (dist/v.wavewidth);
				temp = posmod(temp, 1);
				ctx.fillStyle = v.colorfunc(temp);
				ctx.fillRect(i1, i2, 1, 1);
			}
		}
		//*/
		/*
		if(frame === 0) {
			v.ants = [];
			for(i1 = 0; i1 < 64; i1++) {
				v.ants[i1] = [
					Math.floor(Math.random()*u.w),
					Math.floor(Math.random()*u.h)
				];
			}
			ctx.fillStyle = "white";
		}
		const speed = 1.5;
		for(i1 = 0; i1 < v.ants.length; i1++) {
			ctx.fillRect(Math.floor(v.ants[i1][0]), Math.floor(v.ants[i1][1]), 1, 1);
			let dir = Math.min(Math.random(), Math.random());
			if(Math.random() < .5) {
				dir *= -1;
			};
			dir = posmod(1 + dir, 4);
			dir *= Math.PI/2;
			v.ants[i1][0] = posmod(v.ants[i1][0] + speed*Math.cos(dir), u.w);
			v.ants[i1][1] = posmod(v.ants[i1][1] + speed*Math.sin(dir), u.h);
		};
		// trying to emulate ant movement. i don't think i did very well.
		// - it kinda resembles snow though.
		//*/
		/*
		if(frame === 0) {
			const w = 8;
			const h = 8;
			v.points = [];
			for(i1 = -(w - 1)/2; i1 <= (w - 1)/2; i1++) {
				for(i2 = -(h - 1)/2; i2 <= (h - 1)/2; i2++) {
					v.points[v.points.length] = {
						x: i1,
						y: i2,
					};
				}
			}
			v.points.sort((a, b) => get2dangle(a.x, a.y) - get2dangle(b.x, b.y));
		}
		const dim = 32;
		const traillength = 8;//v.points.length;
		for(i1 = 0; i1 < Math.min(traillength, v.points.length); i1++) {
			let temp = 255//Math.round(255*i1/traillength);
			ctx.fillStyle = "rgb(" + temp + ", " + temp + ", " + temp + ")";
			let point = v.points[(frame + i1)%v.duration];
			ctx.fillRect(
				v.pos[0] + point.x*dim - dim/2,
				v.pos[1] + point.y*dim - dim/2,
				dim,
				dim
			);
		}
		// i thought this would look weirder.
		//*/
		/*
		let offset = frame/v.duration;
		offset = easing(offset, "out", "sine");
		offset *= 2*2*Math.PI;
		offset = [
			2*Math.cos(offset),
			2*Math.sin(offset)
		];
		let rings = 32;
		ctx.strokeStyle = "white";
		for(let i0 = 0; i0 < 2; i0++) {
			if(i0 === 0) {
				ctx.translate(offset[0], offset[1]);
			}
			else if(i0 === 1) {
				ctx.translate(-2*offset[0], -2*offset[1]);
			};
			for(i1 = 0; i1 < rings; i1 += 2) {
				circledraw(ctx, v.pos[0], v.pos[1], i1);
			}
		}
		ctx.translate(offset[0], offset[1]);
		//*/
		/*
		if(frame === 0) {
			let colors = Color.palette(ctx);
			//(ctx, a, b, c, skin, outline, wildcard)
			let square_w = 48;
			for(i1 = 0; i1 < colors.length; i1++) {
				let x = i1%4;
				let y = Math.floor(i1/4);
				x = v.pos[0] + square_w*(x - 2);
				y = v.pos[1] + square_w*(y - 2);
				ctx.fillStyle = colors[i1];
				ctx.clearRect(x, y, square_w, square_w);
				ctx.fillRect(x, y, square_w, square_w);
			}
		}
		//*/
		/*
		if(frame === 0) {
		// going for something like the herringbone brick pattern
			v.h = [
				Math.sin(3/5*Math.PI/2),
				Math.sin(1/5*Math.PI/2),
				Math.sin((-1/5)*Math.PI/2),
				Math.sin((-3/5)*Math.PI/2)
			];
			// important heights used
			v.legs = 6;
			// number of legs
			const fineness = 64;
			let y = [
				v.h[0],//-1,
				v.h[0],
				v.h[2]
			];
			let xz = [
				1/v.legs,//null,
				1,
				1/v.legs
			];
			// these are used to create points. (xz is 0 to 1 numbers turned
			// into angles turned into cos/sin.) it forms a partial outline
			// that, when duplicated, will be the tesselation we need.
			// this outline, when duplicated, will be the tesselation we need
			// - because it's easier,
			function processleg(y, xz) {
			// converts it from corners/intersections to enough points to
			// actually look like it's projected onto a sphere.
				let points = [];
				let cos = (num) => Math.cos(2*Math.PI*num);
				let sin = (num) => Math.sin(2*Math.PI*num);
				let leg = [];
				for(let i1 = 0; i1 < y.length; i1++) {
					let temp = Math.cos(Math.asin(y[i1]));
					// cosine for whatever angles would create the given y.
					// makes sure it's projected like a sphere, not a cylinder.
					leg[i1] = [
						xz[i1] ? temp*cos(xz[i1]) : 0,
						y[i1],
						xz[i1] ? temp*sin(xz[i1]) : 0
					];
				}
				for(let i1 = 0; i1 < leg.length - 1; i1++) {
					let prev = leg[i1];
					let next = leg[i1 + 1];
					let axis = Plane.frompoints([
						[0, 0, 0],
						prev,
						next
					]).line().angle;
					let magnitude = Angle.compare(
						Angle.get(...prev),
						Angle.get(...next)
					);
					// not sure which direction it's in yet
					let temp = [
						Quat.apply(Quat.new(axis, magnitude), prev),
						Quat.apply(Quat.new(axis, posmod(2*Math.PI - magnitude, 2*Math.PI)), prev)
					];
					magnitude *= (
						Math.hypot(
							temp[1][0] - next[0],
							temp[1][1] - next[1],
							temp[1][2] - next[2]
						)
						<
						Math.hypot(
							temp[0][0] - next[0],
							temp[0][1] - next[1],
							temp[0][2] - next[2]
						)
						?
						// means the inverted version was closer (but -180 to 180
						// angles are easier to divide than 0 to 360 angles)
						-1
						:
						1
					);
					let _fineness = Math.ceil(fineness * magnitude/(2*Math.PI));
					// vanilla fineness is how many sides a circle has, this is
					// how many sides the arc has
					points[points.length] = structuredClone(prev);
					for(let i2 = 1; i2 < _fineness; i2++) {
						let _magn = posmod(magnitude*i2/_fineness, 2*Math.PI);
						points[points.length] = Quat.apply(Quat.new(axis, _magn), prev);
					}
				}
				points[points.length] = leg[leg.length - 1];
				return points;
			}
			v.points = [];
			v.points[0] = processleg(y, xz);
			// each index of points is a group of points, representing an
			// unclosed shape.
			y = [
				v.h[3],//1,
				v.h[3],
				v.h[1]
			];
			xz = [
				1.5/v.legs,//null,
				.5/v.legs,
				1.5/v.legs
			];
			v.points[1] = processleg(y, xz);
			for(i1 = 1; i1 < v.legs; i1++) {
			// rotate to make duplicates
				v.points[2*i1] = revolve(2*Math.PI*i1/v.legs, v.points[0], null, "xz");
				v.points[2*i1 + 1] = revolve(2*Math.PI*i1/v.legs, v.points[1], null, "xz");
			}
		}
		let points = structuredClone(v.points);
		for(i1 = 0; i1 < points.length; i1++) {
			let format = "yz";
			let angle = 2*Math.PI*frame/v.duration;
			if(format === "xz") {
				angle /= v.legs;
			}
			points[i1] = revolve(angle, points[i1], null, format);
			// rotate with each frame
			for(i2 = 0; i2 < points[i1].length; i2++) {
				let ref = points[i1][i2];
				points[i1][i2] = (
					ref[2] < 0
					?
					null
					// hide any that shouldn't be visible from the camera's
					// perspective
					:
					perspectiveconvert(
						u.viewer,
						v.pos[0] + ref[0]*u.w/4,
						v.pos[1] + ref[1]*u.w/4,
						central_z(u.viewer) + ref[2]*u.w/4
					).slice(0, 2)
					// resize, perspective convert
				);
			}
		}
		ctx.strokeStyle = "white";
		for(i1 = 0; i1 < points.length; i1++) {
			for(i2 = 0; i2 < points[i1].length - 1; i2++) {
				let prev = points[i1][i2];
				let next = points[i1][i2 + 1];
				if(prev && next) {
				// if neither are null, draw a line
					linespecial(ctx, ...prev, ...next, v.pos.slice(0, 2));
				}
			}
		}
		//*/
		/*
		if(frame === 0) {
			v.points = slite.bean();
			ctx.fillStyle = "orange";
			ctx.strokeStyle = "white";
		}
		let rand = 0*Math.random()/v.duration;
		let points = revolve(2*Math.PI*(frame/v.duration + rand), v.points, null, "xz");
		//let partrand = (num, factor) => factor*Math.random() + (1 - factor)*num;
		//let points = revolve(2*Math.PI*partrand(frame/v.duration, 1/16), v.points, null, "xz");
		for(i1 = 0; i1 < points.length; i1++) {
			points[i1][0] += v.pos[0];
			points[i1][1] += v.pos[1];
			points[i1][2] += v.pos[2];
			points[i1] = perspectiveconvert(u.viewer, ...points[i1]).slice(0, 2);
		}
		//_2dPoly.draw(ctx, _2dPoly.convexed(points, u.viewer), "both");
		for(i1 = 0; i1 < points.length; i1++) {
			let coor = [
				Math.trunc(points[i1][0]),
				Math.trunc(points[i1][1])
			];
			ctx.strokeRect(
				coor[0] - .5,
				coor[1] - .5,
				2,
				2
			);
		}
		//*/
		/*
		let randpoint = () => [
			Math.floor(Math.random()*u.w),
			Math.floor(Math.random()*u.h)
		];
		if(frame === 0) {
			let shape = addspheroids([[0, 0, 0, 16, 16, 16]]);
			for(i1 = 0; i1 < shape.length; i1++) {
				//console.log(Math.hypot(...shape[i1]));
			}
			//console.log(structuredClone(shape));
			shape = _2dPoly.convexed(shape, !u.viewer, [u.w/2, u.h/2, 0]);
			//console.log(shape);
			ctx.strokeStyle = "white";
			ctx.fillStyle = "orange";
			_2dPoly.draw(ctx, shape, "both");
			let data = _2dPoly.getdata(shape, true);
			ctx.fillStyle = "#3fbf3f7f";
			for(i1 = 0; i1 < data.within.length; i1++) {
				if(data.within[i1]) {
					ctx.fillRect(
						data.rect.x + (i1%data.rect.w),
						data.rect.y + Math.floor(i1/data.rect.w),
					1, 1);
				}
			}
		}
		//*/
		/*
		let shape1 = [randpoint(), randpoint(), randpoint()];
		let shape2 = [randpoint(), randpoint(), randpoint()];
		let merge = _2dPoly.mergedata([
			_2dPoly.getdata(shape1, true),
			_2dPoly.getdata(shape2, true)
		]);
		ctx.fillStyle = "orange";
		for(i1 = 0; i1 < 0*merge.within.length; i1++) {
			if(merge.within[i1]) {
				ctx.fillRect(
					merge.rect.x + (i1%merge.rect.w),
					merge.rect.y + Math.floor(i1/merge.rect.w),
				1, 1);
			}
		}
		_2dPoly.draw(ctx, shape1, "both");
		_2dPoly.draw(ctx, shape2, "both");
		ctx.fillStyle = "#3fbf3f7f";
		for(i1 = 0; i1 < merge.within.length; i1++) {
			if(merge.within[i1]) {
				ctx.fillRect(
					merge.rect.x + (i1%merge.rect.w),
					merge.rect.y + Math.floor(i1/merge.rect.w),
				1, 1);
			}
		}
		//*/
		/*
		let numofpoints = 7;
		let dists = [];
		let points = [];
		for(i1 = 0; i1 < numofpoints; i1++) {
			dists[i1] = (1 - randexponent(2))*Math.min(u.w, u.h)/2;
		}
		for(i1 = 0; i1 < numofpoints; i1++) {
			let angle = 2*Math.PI*i1/numofpoints;
			points[i1] = [
				v.pos[0] + dists[i1] * Math.cos(angle),
				v.pos[1] + dists[i1] * Math.sin(angle)
			];
		}
		ctx.fillStyle = "orange";
		ctx.strokeStyle = "white";
		let start = new Date().valueOf();
		_2dPoly.draw(ctx, points, "both");
		v.average += new Date().valueOf() - start;
		if(frame === v.duration - 1) {
			v.average /= 1000*v.duration;
			//console.log(v.average);
		}
		*/
		/*
		function randpoint() {
			let point = [
				Math.floor(Math.random()*u.w),
				Math.floor(Math.random()*u.h),
				-Math.floor(Math.random()*u.w)
			];
			return perspectiveconvert(u.viewer, ...point).slice(0, 2);
		};
		for(i1 = 0; i1 < 4; i1++) {
			let point = [
				randpoint(),
				randpoint()
			];
			//[u.w/2, u.h/4],
			//[u.w/2, u.h/2]
			let r = randexponent(2)*u.w/2;
			ctx.strokeStyle = "silver";
			circledraw(ctx, ...point[0], Math.hypot(point[1][0] - point[0][0], point[1][1] - point[0][1]));
			ctx.fillStyle = "white";
			ctx.fillRect(...point[0], 1, 1);
			ctx.strokeStyle = "white";
			circledraw(ctx, ...point[1], r);
		};
		//
		let colors = ["white", "cyan", "yellow"];
		let i0 = 0;
		for(i0 = Math.min(frame, colors.length - 1); i0 >= 0; i0--) {
			const time = easing(1 - 2*Math.abs((frame - i0)/v.duration - .5), "out/in");
			const _time = 2*easing((frame - i0)/v.duration, "in/out");
			// - _time is just the rotation
			// - out/in for weirdness and tension, especially since it slows
			//   down at the peak of the rotation speed
			// - the Math.abs crap looks complicated, but it just turns a 0 to 1
			//   number into a 0 to 1 to 0 number
			//   - part of the reason _time is separate is so the rotation
			//     doesn't change direction
			// - the in/out being used on the rotation makes it easier to see
			//   when it forms a star or pentagon
			const r = v.star.r;
			v.star.r *= 1 + i0/4;
			let points = slite.star.points(v.star, v.star.r*time, 2*Math.PI*_time);
			v.star.r = r;
			ctx.strokeStyle = colors[i0];
			for(i1 = 0; i1 < points.length; i1++) {
				for(i2 = 0; i2 < points[i1].length; i2++) {
					linespecial(
						ctx,
						...points[i1][i2],
						[v.star.x, v.star.y]
					);
				}
			}
		}
		//
		function randpoint() {
			let point = [
				Math.floor(Math.random()*u.w),
				Math.floor(Math.random()*u.h),
				-Math.floor(Math.random()*u.w)
			];
			return perspectiveconvert(u.viewer, ...point).slice(0, 2);
		};
		let points = [
			randpoint(),
			randpoint(),
			randpoint(),
			randpoint()
		];
		ctx.strokeStyle = "silver";
		for(i1 = 0; i1 < points.length; i1++) {
			for(i2 = i1 + 1; i2 < points.length; i2++) {
				let r = [
					points[i2][0] - points[i1][0],
					points[i2][1] - points[i1][1]
				];
				if(r[0] > u.w/2) {
					r[0] = u.w - r[0];
				};
				if(r[1] > u.h/2) {
					r[1] = u.h - r[1];
				};
				r = Math.hypot(...r);
				let temp = [
					Math.hypot(
						points[i1][0] - u.w/2,
						points[i1][1] - u.h/2
					),
					Math.hypot(
						points[i2][0] - u.w/2,
						points[i2][1] - u.h/2
					)
				];
				circledraw(ctx, ...points[temp[1] < temp[0] ? i2 : i1], r, false, false, false);
			}
		};
		//
		let data = v.blob.slice(frame - v.bloblength, frame);
		data.sort((a, b) => (-Math.abs(b[3] - v.duration/2)) - (-Math.abs(a[3] - v.duration/2)) );
		for(i1 = 0; i1 < data.length; i1++) {
			ctx.strokeStyle = colormath(ctx, "#bfbfff", "white", i1/(data.length - 1));
			circledraw(ctx, ...data[i1].slice(0, 3), true);
			circledraw(ctx, ...data[i1].slice(0, 3), false);
		}
		ctx.strokeStyle = "white";
		//*/
		// TODO
		// - make this a separate ProcAnim named hypnosis or something
		// - make it play four times, rotating each time but keeping the zero
		//   radius point in the same spot
		//   - make them overlap a little in timing
		//   - have them reverse direction at the right places to make it sort
		//     of draw a clover?
		//   - wait, i can do this with a nested procanim. why don't i do that
		//     more often, timing is always a pain in the ass
		/*
		let shape = [];
		// an array of 3d points. the portion of the cardioid this frame is
		// drawing.
		for(i1 = v.trace; i1 >= 0; i1--) {
			let temp = posmod(frame - i1, v.duration);
			temp = structuredClone(v.cardioid[temp]);
			temp[2] = v.pos[2];
			shape[shape.length] = structuredClone(temp);
		}
		for(i1 = 0; i1 < shape.length - 1; i1++) {
			let point1 = structuredClone(shape[i1]);
			let point2 = structuredClone(shape[i1 + 1]);
			for(i2 = 0; i2 < v.tunnel.rings; i2++) {
				let _point1 = structuredClone(point1);
				let _point2 = structuredClone(point2);
				_point1[2] -= i2*v.tunnel.spacing;
				_point2[2] -= i2*v.tunnel.spacing;
				let _frame = posmod(frame + (v.pulse.invert ? -1 : 1)*i2, v.duration);
				_point1 = v.wavemod(_point1, _frame);
				_point2 = v.wavemod(_point2, _frame);
				_3dline(u.viewer, ctx, ..._point1, ..._point2);
			}
		}
		//
		ctx.fillStyle = "orange";
		ctx.fillRect(0, 0, u.w, u.h);
		v.fire = slite.walkers.flame(v.fire, null, null, [
			v.start_func, v.start_args, null, null, ["direct", Math.PI*3/2]
		]);
		slite.walkers.draw(ctx, v.fire, v.colorfunc);
		//
		ctx.fillStyle = "black";
		ctx.fillRect(0, 0, u.w, u.h);
		ctx.fillStyle = "white";
		ctx.strokeStyle = "white";
		ctx.font = "16px 'fomp2'";
		ctx.strokeStyle = "white";
		ctx.fillStyle = "orange";
		let shape = slite._2dpoly.random(u.w/2, 7, wave(frame/(v.duration*4), "sine", 1, 2), 0);
		for(i1 = 0; i1 < shape.length; i1++) {
			shape[i1][0] += v.pos[0];
			shape[i1][1] += v.pos[1];
		};
		_2dPoly.draw(ctx, shape, "both");
		//slite._2dpoly.colorbydistance(shape, ctx, (value) => "rgb(" + [Math.floor(value*255), 127 + Math.floor(value*255/2), 255].join(",") + ")", u.w/4);
		//
		let x1 = Math.floor(Math.random()*u.w);
		let y1 = Math.floor(Math.random()*u.h);
		let x2 = Math.floor(Math.random()*u.w);
		let y2 = Math.floor(Math.random()*u.h);
		nonaaline(ctx, x1, y1, x2, y2);
		circledraw(ctx, x1, y1, 8);
		circledraw(ctx, x2, y2, 4);
		//
		slite.ditherparallax(frame, ctx, v.dithers);
		slite.jankynumbers(ctx, u.w/2, u.h/2, frame, [" ".repeat(3 - frame.toString().length), "%"], false, 1/32, true);
		let size = 32;
		if(frame === 1) {
			ctx.fillStyle = "gray";
			ctx.fillRect(0, 0, 128, 128);
			for (i1 = 0; i1 < 4; i1++) {
				for (i2 = 0; i2 < 4; i2++) {
					slite.drawtile(ctx, 32*i1, 32*i2, "grass", 32);
				}
			}
			slite.drawtile(ctx, 0, 0, "road", 32, {path: "ul_corner"});
			slite.drawtile(ctx, 32, 0, "road", 32, {path: "u_cross"});
			slite.drawtile(ctx, 64, 0, "road", 32, {path: "ur_corner"});
			slite.drawtile(ctx, 0, 32, "road", 32, {path: "l_cross"});
			slite.drawtile(ctx, 32, 32, "road", 32, {path: "cross"});
			slite.drawtile(ctx, 64, 32, "road", 32, {path: "r_cross"});
			slite.drawtile(ctx, 0, 64, "road", 32, {path: "dl_corner"});
			slite.drawtile(ctx, 32, 64, "road", 32, {path: "d_cross"});
			slite.drawtile(ctx, 64, 64, "road", 32, {path: "dr_corner"});
			//
			slite.drawtile(ctx, 96, 0, "road", 32, {path: "u_end"});
			slite.drawtile(ctx, 96, 32, "road", 32, {path: "d_end"});
			slite.drawtile(ctx, 96, 64, "road", 32, {path: "vert"});
			slite.drawtile(ctx, 0, 96, "road", 32, {path: "l_end"});
			slite.drawtile(ctx, 32, 96, "road", 32, {path: "r_end"});
			slite.drawtile(ctx, 64, 96, "road", 32, {path: "hori"});
			slite.drawtile(ctx, 96, 96, "road", 32, {path: "center"});
			//
			slite.drawtile(ctx, 128, 0, "grass", 32);
			temp = ctx.getImageData(128, 0, 32, 32);
			for (i1 = 0; i1 < 2; i1++) {
				for (i2 = 0; i2 < 2; i2++) {
					ctx.putImageData(temp, 128 + 32*i1, 32*i2);
				}
			}
		}
		//
		let ds_size = 16*2**(frame%3);
		let temp = frame%(3*4);
		temp = Math.floor(temp/3);
		let floor = temp%2 < 1;
		let norepeat = temp%4 < 2;
		if(frame < 12 && norepeat && floor) {
			console.log(ctx);
			for (i1 = 0; i1 < u.w; i1 += ds_size) {
				for (i2 = 0; i2 < u.h; i2 += ds_size) {
					//(input, level) => input*(1 - 1/variation + Math.random()*2/variation)
					diamondsquare(ctx, i1, i2, (norepeat ? 2 : 1) * ds_size, (input, level) => input + 32*randexponent(1, true)*( ( 2**(-1) )**(Math.log2(64) - level) ) + 4*randexponent(1, true), function(ctx, x, y, value) {
						ctx.fillStyle = "rgb(" + [255, (floor ? Math.floor(value/16)*16 : value), 0].join(",") + ")";
						ctx.fillRect(x, y, 1, 1);
					});
				}
			}
		};
		//*/
		//let shape = structuredClone(v.shape);
		//shape.points = revolve(2*Math.PI*frame/16, shape.points, false, "xz");
		//_3dpoly(u.viewer, ctx, shape, v.pos, false, false, false, false);
		//this.revolvingrings.func(frame);
		//this.shimmershape.func(frame, v.shape2d);
		//console.log("frame " + frame + ": " + (32*Math.floor(frame/32) + 16*(frame%32)/32 + easingplacement(0, 16, (frame%32)/32, "in/out", "sine")));
		//this.polaris.func(frame, 0);
		//this.starblast.func(frame);
		//this.rhythmicshine.func(frame, "o   .o   .o   .o   |");
		//
		this.frameend(frame);
	};
	class Animator {
	// a class that creates an animation player.
	// structure:
	// - name
	// - ctx: canvas the animation is displayed on. element id is name +
	//   "_canvas".
	// - frames: array of ImageDatas. it animates by using putImageData with
	//   this. add to this by using .clear to clear the canvas, applying edits,
	//   and using .set to put it in .frames.
	// - background: color to use when clearing the canvas.
	// - a few getters/setters
	// - ui: object describing what buttons/inputs to create. the property
	//   name is the type/name.
	//   - fps (frames per second, number input)
	//   - play (button)
	//   - loop (checkbox)
	//   - pingpong (checkbox, makes it go back and forth)
	//   - sheet (hideable canvas of all the frames. update it with
	//     .updatesheet.)
	//     - hidden by default.
	//     - cols: number of columns.
	//   - "button_" + whatever: extra button
	//   =
	//   - properties of properties:
	//     - br: adds a linebreak before it. (or multiple, if the value is a
	//       number instead of a boolean.)
	//     - space: adds a space before it.
	//     - onclick: function you want run when it's clicked
	//     - text: text you want it to use. (by default, it'll just use the
	//       property name.)
	//   - the html id will be .name + "_" + the property name of the html
	//     element. so fps would be "anim_fps" or whatever.
	//     - except for "button_". it'll omit the beginning of that.
	//   - null is treated the same as an empty object.
	// - fps, looping: getters/setters connected to the html elements if those
	//   exist, primitives if not.
		/*
		new Animator(
			"name",
			{
				fps: {
					br: true,
				},
				play: {
					space: true,
				},
				loop: {
					br: true,
				},
			},
			div, fps, background, w, h
		);
		*/
		constructor(name, ui, div, fps, background, w, h) {
			let i1 = 0;
			if(!div) {
				document.write(`<div id="` + name + `_div"></div>`);
				div = document.getElementById(name + `_div`);
			};
			if(!Number.isInteger(fps) || fps <= 0) {
				fps = 24;
			};
			ui ??= {
				fps: {
					br: true,
				},
				play: {
					space: true,
				},
				loop: {
					br: true,
				},
				pingpong: {
					br: true,
				},
				sheet: {
					br: true,
				},
			};
			w ??= 256;
			h ??= 256;
			background ??= "black";
			this.name = name;
			this.div = div;
			this.defaultfps = fps;
			this.background = background;
			let temp = name + `_canvas`;
			let string = ``;
			string += `<canvas id="` + temp + `" name="` + temp + `" width=` + w + ` height=` + h + `></canvas>`;
			for(i1 in ui) {
				if(ui.hasOwnProperty(i1)) {
					ui[i1] ??= {};
					let obj = ui[i1];
					const text = (
						obj.hasOwnProperty("text") ? obj.text :
						i1.startsWith("button_") ? i1.slice("button_".length) :
						i1
					);
					if(obj.hasOwnProperty("br")) {
						if(Number.isInteger(obj.br) && obj.br >= 0) {
							string += `<br>`.repeat(obj.br);
						}
						else if(obj.br) {
							string += `<br>`;
						};
					};
					if(obj.hasOwnProperty("space") && obj.space) {
						string += ` `;
					};
					if(i1 === "fps") {
						string += `<label>` + text + `: <input type="number" id="` + name + `_fps" value=` + fps + `>`;
					}
					else if(i1 === "play") {
						string += `<button id="` + name + `_play">` + text + `</button></label>`;
					}
					else if(i1 === "loop") {
						string += `<label>` + text + `: <input type="checkbox" id="` + name + `_loop"></label>`;
					}
					else if(i1 === "pingpong") {
						string += `<label>` + text + `: <input type="checkbox" id="` + name + `_pingpong"></label>`;
					}
					else if(i1 === "sheet") {
						string += `<button id="` + name + `_hidesheet">show sheet</button></label>`;
						string += `<br><canvas id="` + name + `_sheet" name="` + temp + `" width=` + w + ` height=` + h + ` hidden></canvas>`;
					}
					else if(i1.startsWith("button_")) {
						string += `<button id="` + name + `_` + i1.slice("button_".length) + `">` + text + `</button>`;
					}
					else {
						console.log("invalid ui property name.");
					};
				}
			}
			div.innerHTML = string;
			this.ctx = document.getElementById(temp).getContext("2d");
			this.ctx.fillStyle = background;
			this.ctx.fillRect(0, 0, w, h);
			this.viewer = {
				x: this.w/2,
				y: this.h/2,
				z: this.w/2,
				ratio: this.w/60,
				// ratio = pixels/degrees, screen_pixels = 60*degrees
				// if ratio === screen_pixels/60
				// screen_pixels = 60*screen_pixels/60
				offset: {
					x: 0,
					y: 0,
					z: 0,
				},
				lamp: {
				// USE .single === true IF THERE'S ONLY ONE LAMP.
					x: this.w,
					y: 0*this.h,
					z: -this.w,
					brightness: 1,
					baselightlevel: -1,
					single: true,
				},
				// baselightlevel
				// until i figure out how to convert colors to rgb, colors should be an
				// array.
			};
			// viewer is kind of a mess and should really be a class. don't try
			// too hard to make sense of this.
			this.frames = [];
			this._frame = 0;
			this._playing = false;
			this.interval = null;
			if(ui.hasOwnProperty("fps")) {
				Object.defineProperty(this, "fps", {
					get() {
						let temp = Number(document.getElementById(this.name + `_fps`).value);
						if(!Number.isInteger(temp) || temp <= 0) {
							temp = this.defaultfps;
							document.getElementById(this.name + `_fps`).value = temp;
						};
						return temp;
					},
					set(value) {
						let temp = Number(value);
						if(!Number.isInteger(temp) || temp <= 0) {
							temp = this.defaultfps;
						};
						document.getElementById(this.name + `_fps`).value = temp;
					},
				})
			}
			else {
				this.fps = fps;
			};
			for(i1 = 0; i1 < 2; i1++) {
				let type = ["loop", "pingpong"][i1];
				let propertyname = ["looping", "pingpong"][i1]
				if(ui.hasOwnProperty(type)) {
					Object.defineProperty(this, propertyname, {
						get() {
							return document.getElementById(this.name + `_` + type).checked;
						},
						set(value) {
							document.getElementById(this.name + `_` + type).checked = !!value;
						},
					})
				}
				else {
					this[propertyname] = false;
				};
			}
			// define fps, loop, and pingpong as a getter/setter if there's an
			// html element, and a primitive if it's not.
			this.reverse = false;
			// boolean for whether it's playing backwards. necessary for
			// pingpong.
			let _this = this;
			for(i1 in ui) {
				if(ui.hasOwnProperty(i1) && ui[i1]) {
				// add event listeners
					if(i1 === "play") {
						document.getElementById(name + `_` + i1).onclick = function() { _this.playpause(_this) };
					}
					else if(i1 === "pingpong") {
						document.getElementById(name + `_` + i1).onclick = function() { _this.reverse = false };
						// keeps reverse from lingering outside of pingpong.
					}
					else if(i1 === "sheet") {
						let ref = document.getElementById(_this.name + `_` + i1);
						this.sheet = ref.getContext("2d");
						this.sheet_cols = ui[i1].cols ?? 0;
						document.getElementById(name + `_hidesheet`).onclick = function() {
							ref.hidden = !ref.hidden;
							document.getElementById(_this.name + `_hidesheet`).innerHTML = (ref.hidden ? "show" : "hide") + " sheet";
						};
						this.updatesheet();
					}
					else if(ui[i1].hasOwnProperty("onclick")) {
						let id = name + "_" + (
							i1.startsWith("button_")
							?
							i1.slice("button_".length)
							:
							i1
						);
						document.getElementById(id).onclick = ui[i1].onclick;
					}
				}
			}
			this.ui = ui;
		}
		get w() {
			return this.ctx.canvas.width;
		}
		set w(value) {
			this.ctx.canvas.width = value;
		}
		get h() {
			return this.ctx.canvas.height;
		}
		set h(value) {
			this.ctx.canvas.height = value;
		}
		get duration() {
			return this.frames.length;
		}
		set duration(value) {
			if(Number.isInteger(value) && value >= 0) {
				if(value < this.duration) {
					this.frames = this.frames.slice(0, value);
				}
				else if(value > this.duration) {
					let temp = this.ctx.getImageData(0, 0, this.w, this.h);
					this.clear();
					let i1 = 0;
					for(i1 = this.duration; i1 < value; i1++) {
						this.frames[i1] = this.ctx.getImageData(0, 0, this.w, this.h);
					}
					this.ctx.putImageData(temp, 0, 0);
				}
			}
		}
		get frame() {
			return this._frame;
		}
		set frame(value) {
			if(this.duration === 0) {
				this._frame = 0;
			}
			else if(Number.isInteger(value)) {
				this._frame = value%this.duration;
			};
		}
		get playing() {
			return this._playing;
		}
		set playing(value) {
			if(this.duration === 0) {
				value = false;
			};
			this._playing = !!value;
			if(value) {
				let _this = this;
				this.interval = setInterval(function() { _this.updateframe(_this) }, 1000/this.fps);
			}
			else {
				clearInterval(this.interval);
				this.interval = null;
			};
			document.getElementById(this.name + `_play`).innerHTML = (value ? "pause" : "play");
		}
		clear() {
			this.ctx.clearRect(0, 0, this.w, this.h);
			this.ctx.fillStyle = this.background;
			this.ctx.fillRect(0, 0, this.w, this.h);
		}
		saveframe(frame, ctx, x, y) {
			ctx ??= this.ctx;
			x ??= 0;
			y ??= 0;
			this.frames[frame] = ctx.getImageData(x, y, this.w, this.h);
			if(this.frames.includes(undefined)) {
				this.clear();
				let i1 = 0;
				for(i1 = 0; i1 < this.duration; i1++) {
					if(!this.frames[i1]) {
						this.frames[i1] = ctx.getImageData(0, 0, this.w, this.h);
					}
				}
				ctx.putImageData(this.frames[frame], 0, 0);
			};
		}
		updateframe(_this) {
			_this ??= this;
			if(_this.duration === 0) {
				_this.clear();
			}
			else {
				if(_this.playing) {
					_this.frame = posmod(_this.frame + (_this.reverse ? -1 : 1), _this.duration);
					// loop back to the opposite end if you reach the end. (that
					// way, when it reaches the end and isn't looping, it stops
					// at the first frame.)
					// - the order isn't 0 1 2 3, it's 1 2 3 0. (since it
					//   already starts at 0, and animations that aren't playing
					//   are supposed to show the first frame.)
				};
				_this.ctx.putImageData(_this.frames[_this.frame], 0, 0);
				if(_this.frame === ((!!_this.reverse === !!_this.pingpong) ? 0 : _this.duration - 1)) {
				// end of the animation, so stop the interval or switch
				// directions
				// - if pingpong is false
				//   - if reverse is false, the last frame is duration - 1, and
				//     it resets back to 0. so end at 0.
				//   - if reverse is true, the last frame is 0, and it resets
				//     back to duration - 1, so end at duration - 1
				// - if pingpong is true
				//   - if reverse is false, it should switch directions at
				//     duration - 1.
				//   - if reverse is true, it should switch directions or end at
				//     0.
				// - 0 if both are false or both are true. duration - 1
				//   otherwise.
					if(_this.pingpong) {
					// if it's not looping and it's already in the second
					// half, stop. no matter what, switch directions.
						if(!_this.looping && _this.reverse) {
							_this.playing = false;
						};
						_this.reverse = !_this.reverse;
					}
					else if(!_this.looping) {
						_this.playing = false;
					};
				};
			};
		}
		playpause(_this) {
			_this ??= this;
			_this.playing = !_this.playing;
		}
		updatesheet(_this, ctx, cols, gap, gapcolor) {
		// makes the specified canvas a spritesheet of all the frames. or if
		// there's no ctx specified and the Animator has a sheet element, it
		// edits that.
			let i1 = 0;
			_this ??= this;
			ctx ??= _this.sheet;
			cols ??= _this.sheet_cols;
			gap ??= 0;
			gapcolor ??= _this.background;
			if((ctx ?? null) === null) {
				console.log("sheet canvas is unspecified.");
				return;
			};
			if((ctx ?? null) === null) {
				console.log("number of rows is unspecified.");
				return;
			};
			cols = cols ? cols : _this.duration;
			// if it's falsy, it'll print them all in one row.
			ctx.canvas.width = cols*_this.w;
			ctx.canvas.height = Math.ceil(_this.duration/cols)*_this.h;
			ctx.fillStyle = gapcolor;
			ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			for(i1 = 0; i1 < _this.duration; i1++) {
				ctx.putImageData(
					_this.frames[i1],
					(i1%cols)*(_this.w + gap),
					Math.floor(i1/cols)*(_this.h + gap)
				);
			}
		}
	};
	document.write(
		`<br><label>tool: <select id="hider_select">
		</select></label>`
	);
	document.write(`<div name="hider" id="hider_procanim">`);
	let anim = new Animator(
		"anim",
		{
			fps: {
				br: true,
			},
			play: {
				space: true,
			},
			loop: {
				br: true,
			},
			pingpong: {
				br: true,
			},
			sheet: {
				br: true,
				cols: 4,
			},
		},
		null,
		null,
		"black"
	);
	anim.run = {
		name: "test",
		ctx: anim.ctx,
		u: {viewer: anim.viewer},
		duration: 64,
		initarguments: null,
		funcarguments: null,
		sheet: null,
		// {ctx, columns, borderwidth}
	};
	/*;
	anim.run.name = "hypnosis";
	anim.run.duration = 16*4;
	anim.run.name = "fireplaceybg";
	anim.run.duration = 48;
	anim.run.name = ["linerevolve", "glr", "rolldir", "linefind", ""][0] + "test";
	anim.run.duration = 90;
	anim.run.name = "linerevolvetest";
	anim.run.duration = 96;
	anim.run.name = "dsrainbow2";
	anim.run.duration = 72;
	anim.run.funcarguments = [3, true];
	anim.run.name = "starblast";
	anim.run.duration = 96;
	//*/
	anim.frames = suite[anim.run.name].render(
		anim.run.ctx,
		anim.run.u,
		anim.run.duration,
		anim.run.initarguments,
		anim.run.funcarguments,
		anim.run.sheet
	).imagedata;
	delete anim.run;
	document.write(`<canvas id="` + anim.name + `_sheet"></canvas></div>`);
	anim.sheet = document.getElementById(anim.name + `_sheet`).getContext("2d");
	anim.updatesheet();
	document.getElementById("anim_hidesheet").click();
	anim.sheet.canvas.style["image-rendering"] = "crisp-edges";
	//
	// cobblestone pseudocode
	// - fill two arrays with random coordinates
	// - create a "radius" array
	// - paint the whole canvas black
	// - for loop
	// - for loop
	//   - for loop that checks for the shortest distance between two points
	//     points, this one checks every point
	//     - this one checks every point before this one
	//       - skip this point if the corresponding radius array index has been
	//         filled
	//         - if the current point is the last one and it does this, exit all
	//           loops
	//       - calculate distance with a2 + b2 = c2
	//       - but you also gotta make sure the measurements wrap around
	//         - if either dimension is larger than half the height/width of the
	//           image, add the height/width to the lower one and calculate
	//           again
	//       - if the other point has a radius, subtract that from the
	//         calculated distance
	//       - and of course etc etc "if this distance is shorter than the
	//         current record for shortest distance, make it the new shortest
	//         distance"
	//   - now that you have your pair...
	//   - if both coordinates have no radius, set the radius as half of the
	//     distance value, and draw a circle of that radius around them using
	//     math bullshit
	//     - remember to draw it in both axes, that way there won't be gaps
	//     - also draw it in white, and subtract 1 from the radius so there's a
	//       small gap between this circle and one that's meant to tangent it
	//     - use paintbucket on the center coordinate
	//   - if one of them has a radius, set the one without a circle's radius as
	//     the full distance and draw it
	// - thin everything out with this for loop (stops looping when erasecount
	//   is less than 1)
	//   - set variable erasecount as 0
	//   - another for loop that checks every pixel
	//     - if it's a black pixel, it has white cardinal neighbors, and every
	//       white cardinal neighbor has a black neighbor in the opposite
	//       direction, make this pixel white
	//       - tick up erasecount
	var userfocus = "none";
	// stores which tool the user last clicked, the character animation canvas
	// or the drawing app canvas.
	// - "pi" or "draw"
	// - this uses var for a reason. for the sake of classes that use it, it
	//   needs to be retrievable.
	function changefocus(focus) {
	// 99% of the time all this does is change the userfocus variable.
		let prevfocus = userfocus;
		userfocus = focus;
		if(prevfocus !== focus) {
			if(prevfocus === "fg") {
				clearInterval(fg.interval);
				fg.interval = null;
			}
			else if(focus === "fg") {
				fg.interval = setInterval(function() {
					fg.process(1/fg.fps);
				}, 1000/fg.fps);
			};
		};
	};
	function clickxy(e, focusname) {
		if(typeof focusname === "string") {
			changefocus(focusname);
		};
		return [
			Math.floor(e.clientX - e.target.getBoundingClientRect().left),
			Math.floor(e.clientY - e.target.getBoundingClientRect().top)
		];
	};
	function keyinterpreter(key) {
		if(key.length === 1) {
			key = key.toLowerCase();
			// so that w and W don't have to be mapped separately.
			let temp = ")!@#$%^&*(";
			if(temp.includes(key)) {
				key = temp.indexOf(key).toString();
			};
			// same with the symbols mapped to number keys
		};
		return key;
	};
	document.onkeydown = function(e) {
		if(["textarea", "input"].includes(document.activeElement.tagName.toLowerCase())) {
			return;
		};
		function radiocycling(radioname) {
			let i1 = 0;
			let i2 = 0;
			let cyclestatus = "before";
			// before: it hasn't found the active radio button yet
			// during: it has found the active radio button and turned it off, but
			// it hasn't turned on the next yet
			// after: it's done
			for (i1 in document.getElementsByName(radioname)) {
				if (document.getElementsByName(radioname).hasOwnProperty(i1)) {
					if(document.getElementsByName(radioname)[i1].checked) {
						document.getElementsByName(radioname)[i1].checked = false;
						cyclestatus = "during";
					}
					else if(cyclestatus === "during") {
						document.getElementsByName(radioname)[i1].checked = true;
						cyclestatus = "after";
					};
				};
			}
			if(cyclestatus === "before" || cyclestatus === "during") {
			// the former happens if no radio buttons are checked, (happens
			// sometimes, i dunno why. complications from the page refreshing?)
			// the latter happens if the active button was the last one, meaning
			// it couldn't find a next button to activate.
				for (i1 in document.getElementsByName(radioname)) {
					if (
						document.getElementsByName(radioname).hasOwnProperty(i1)
						&&
						(
							cyclestatus === "before"
							||
							cyclestatus === "during"
						)
					) {
						document.getElementsByName(radioname)[i1].checked = true;
						cyclestatus = "after";
					};
				}
			};
		}
		//console.log(e.key);
		//console.log(e.shiftKey);
		//console.log(e.ctrlKey);
		let key = keyinterpreter(e.key);
		if(userfocus === "draw") {
			draw.buttonaction(e, true);
		}
		else if(["aa", "aapa"].includes(userfocus)) {
		// if it isn't in a textarea/input...
			let keymap = (aa.control.editmode ? aa.pa.ui.keymap : aa.ui.keymap);
			if(keymap.hasOwnProperty(key)) {
				let action = keymap[key];
				if(typeof action !== "string") {
					if(action.length > 2) {
						action = (
							e.ctrlKey
							?
							action.slice(2)
							:
							action.slice(0, 2)
						);
					};
					if(action.length === 1) {
						action = action[0];
					}
					else if(action.length === 2) {
						action = action[Number(e.shiftKey)];
					}
					else {
						console.log("this shouldn't happen");
					};
				};
				if(action) {
					e.preventDefault();
					if(aa.control.editmode) {
						aa.pa.ui.action(action, e.shiftKey, e.ctrlKey);
					}
					else {
						aa.ui.action(action, e.shiftKey, e.ctrlKey);
					}
				};
			};
		}
		else if(userfocus === "fg") {
			fg.keydown(e);
		}
		else if(userfocus === "fpt") {
			if(e.ctrlKey && key === "z") {
				if(e.shiftKey) {
					fpt.states.redo();
				}
				else {
					fpt.states.undo();
				};
			};
		};
	};
	document.onkeyup = function(e) {
		if(userfocus === "fg") {
			fg.keyup(e);
		};
	};
	document.write(`<div name="hider" id="hider_drawing_app">`);
	let draw = {
		scale: 1,
		// the drawing area dimensions will be this times 256 and 192
		menuorientation: "horizontal",
		// used in createbuttons to figure out how the ui should work, where it
		// should go. at present all there is is vertical (below drawing area)
		// and horizontal (to the right of the drawing area)
		mouse: {
		// stores information about your current actions
			oldx: [],
			oldy: [],
			// this stores all the mouse positions of the stroke.
			//numofpositions: 10,
			// length of oldx and oldy
			// - now obsolete. there shouldn't be a limit, that makes it hard to
			//   do anything that has to be done on mouseup.
			x: null,
			y: null,
			tool: "pen",
			// tool currently selected.
			subtool: {
				pen: 0,
				paint: 0,
				eraser: 0,
			},
			// index of which kind of tool you're using (for example, which
			// brush, or dither)
			inversion: {
				pen: false,
				paint: false,
				eraser: false,
			},
			// stores whether the subtool is its inverse (for example, for paint
			// it's an inversion of the dither pattern. for pens it's a modified
			// form that's different for each.)
			strokedata: null,
			// stores stuff that has to be applied per stroke, like the pattern
			// for the smear pen
			clicktype: "none",
			// stores what kind of click it is so it won't draw between you
			// clicking a tool and ending your click, and it won't draw without
			// you actually clicking either
		},
		// works like pi.click.
		undodata: [],
		// stores imagedatas.
		// - NOTE: lower indexes are more recent. every new imagedata is put at
		//   the beginning.
		undoindex: 0,
		maxundos: 20,
		// setting for how many imagedatas it should be allowed to hold, how
		// many actions it can undo.
		colors: [],
		color1: 1,
		// color you draw with
		color2: 0,
		// color you erase with
		buttons: [],
		// rectangle x/y/w/h of the upper left corner of each button.
		rect: new Path2D(),
		// this will be used for "clip", a way of preventing drawing on the
		// margins. but it's also useful for other things, like resetting one
		// part of the ui using putImageData and the buttons rectangles
		pensize: 1,
		paintsize: 32,
		page: 0,
		// current page of the menu the program is on.
		misc: {
			rainbow: [],
			rainbowmode: false,
			// boolean that stores whether to actually use this.
			rainbowindex: 0,
			epilepsywarning: false,
			// boolean for whether the user has responded to the epilepsy warning
			// with "yes"
			epilepsytext: `PHOTOSENSITIVITY WARNING: this button turns on rainbow mode, which can result in rapid color changes, especially with large pen/paint sizes, or pens like sunset that involve a lot of redrawing. type "yes" if you have acknowledged the risk.\n\nset both pen size and paint size to smaller numbers if you're photosensitive. (pens often use both pen size and paint size. for example, the width of the sunset pen and the diameter of the spray pen are both determined by paint size.)`,
		},
		// place for storing misc data like rainbow.
	};
	draw.createbuttons = function() {
	// creates draw.buttons, draw.drawingarea, sets canvas dimensions
	// - NOTE this is where buttons are written, by the way. this isn't like one
	//   of those go-between functions that acts on existing data. if you wanna
	//   add a new button, you do that by defining it here.
		let x0 = null;
		let y0 = null;
		let i1 = 0;
		let i2 = 0;
		this.drawingarea = {
			x: 0,
			y: 0,
			w: 256 * this.scale,
			h: 192 * this.scale,
		}
		if(this.menuorientation === "horizontal") {
			this.ctx.canvas.width = this.drawingarea.w * 2;
			this.ctx.canvas.height = this.drawingarea.h;
			x0 = this.drawingarea.w;
			y0 = 0;
		}
		else if(this.menuorientation === "vertical") {
			this.ctx.canvas.width = this.drawingarea.w;
			this.ctx.canvas.height = this.drawingarea.h * 2;
			x0 = 0;
			y0 = this.drawingarea.h;
		}
		else {
			console.log("this shouldn't happen");
			return;
		};
		// same resolution as the ds.
		//
		// x0 and y0 are the top left corner of the menu. (as in where x should
		// be if it's "0".) everything will be measured relative to that.
		this.ctx.fillStyle = "white";
		this.buttons = [];
		// NOTE structure of draw.buttons:
		// - .buttons (array)
		//   - .buttons[0] (object storing the buttons of page 1)
		//     - .buttons[0][buttonname] (button object)
		//       - x, y, w, h (defines the rectangle)
		//       - tags (string or array storing strings for categories and
		//         stuff. like if i wanna check if it's a color button.)
		//       - split (string or array of "up", "down", "left", or "right",
		//         indicates that you should draw imaginary diagonal lines
		//         across the rectangle and only consider the input valid if
		//         it's within one of those quadrants)
		//       - hide (boolean, keeps drawbuttons from doing anything.)
		//       - key (the KeyboardEvent.key string of the key that should do
		//         the same thing as clicking this. use "ctrl + " to specify
		//         that ctrl must be held.)
		//       - image (drawImage() parameters)
		//         - file (file path)
		//         - sx, sy, sw, sh (rectangle parameters for the portion of the
		//           image you're using)
		//         =
		//         - the dx/dy/dw/dh parameters are just the button rectangle
		//           stuff, obviously
		//         - note that this is not affected by split, so... in cases
		//           like the subtool controls, only one button holds the image
		//           for all of them.
		//         - that might get complicated later though. i'm not
		//           implementing "active" images yet. (that is, images that
		//           appear only when the button is clicked)
		let block = 32 * draw.scale;
		// the width of one "block" of the golden ratio shit i planned this
		// around
		let temp = {
			x: null,
			y: y0,
			w: 5*block,
			h: 5*block,
		};
		temp.x = x0 + this.drawingarea.w - temp.w;
		// this is the palette area
		this.buttons[0] = {};
		// page 1.
		this.buttons[0].rainbow = {
			x: temp.x,
			y: temp.y,
			w: .5*block,
			h: .5*block,
			key: "1",
		};
		this.buttons[0].changerainbow = {
			x: temp.x + temp.w - .5*block,
			y: temp.y,
			w: .5*block,
			h: .5*block,
			key: "2",
		};
		this.buttons[0].colorchange = {
			x: temp.x,
			y: temp.y + temp.h - .5*block,
			w: .5*block,
			h: .5*block,
			key: "3",
		};
		this.buttons[0].colorstrings = {
			x: temp.x + temp.w - .5*block,
			y: temp.y + temp.h - .5*block,
			w: .5*block,
			h: .5*block,
			key: "4",
		};
		for(i1 = 0; i1 < this.colors.length; i1++) {
			this.buttons[0]["color_" + i1] = {
				x: temp.x + block*(.5 + i1%4),
				y: temp.y + block*(.5 + Math.floor(i1/4)),
				w: block,
				h: block,
				tags: "palette",
			};
		}
		temp = {
			x: temp.x,
			y: temp.y,
			w: 3*block,
			h: 3*block,
			key: "e",
		};
		temp.x -= temp.w;
		this.buttons[0].tool = structuredClone(temp);
		// button for switching tools
		temp = {
			x: temp.x,
			y: temp.y + temp.h,
			w: 2*block,
			h: 2*block,
			tags: "subtool",
		};
		this.buttons[0].subtool_u = structuredClone(temp);
		this.buttons[0].subtool_d = structuredClone(temp);
		this.buttons[0].subtool_l = structuredClone(temp);
		this.buttons[0].subtool_r = structuredClone(temp);
		this.buttons[0].subtool_u.split = "up";
		this.buttons[0].subtool_d.split = "down";
		this.buttons[0].subtool_l.split = "left";
		this.buttons[0].subtool_r.split = "right";
		this.buttons[0].subtool_u.key = "w";
		this.buttons[0].subtool_l.key = "a";
		this.buttons[0].subtool_d.key = "s";
		this.buttons[0].subtool_r.key = "d";
		// controls for switching subtools
		temp = {
			x: temp.x + temp.w,
			y: temp.y + temp.h,
			w: block,
			h: block,
		};
		temp.y -= temp.h;
		this.buttons[0].sizedown = structuredClone(temp);
		this.buttons[0].sizedown.key = "f";
		temp.y -= temp.h;
		this.buttons[0].sizeup = structuredClone(temp);
		this.buttons[0].sizeup.key = "r";
		temp = {
			x: x0,
			y: y0 + 5*block,
			w: 3*block,
			h: .5*block,
			hide: true,
		};
		this.buttons[0].subtoolnumber = structuredClone(temp);
		this.buttons[0].subtoolname = structuredClone(temp);
		this.buttons[0].subtoolname.y += temp.h;
		// these aren't really "buttons" but i gotta define where they are
		// somehow.
		// - two rows of text. subtoolnumber displays "[tool name] [subtool
		//   index]", subtoolname displays the name.
		this.buttons[0].undo = {
			x: temp.x + temp.w,
			y: temp.y,
			w: block,
			h: block,
			key: "ctrl + z",
		};
		this.buttons[0].redo = structuredClone(this.buttons[0].undo);
		this.buttons[0].redo.x += this.buttons[0].undo.w;
		this.buttons[0].redo.key = "ctrl + y";
		this.buttons[0].page = {
			x: null,
			y: null,
			w: block,
			h: block,
			split: [
				"down",
				"right"
			],
			key: "q",
		};
		this.buttons[0].page.x = x0 + this.drawingarea.w - this.buttons[0].page.w;
		this.buttons[0].page.y = y0 + this.drawingarea.h - this.buttons[0].page.h;
		// page 0 button defining
		this.buttons[0].tool.image = {
			file: new Image(),
			sx: 0,
			sy: null,
			sw: 96,
			sh: 96,
		};
		switch (this.mouse.tool) {
			case "pen":
				this.buttons[0].tool.image.file.sy = 0;
			break;
			case "paint":
				this.buttons[0].tool.image.file.sy = 96;
			break;
			case "eraser":
				this.buttons[0].tool.image.file.sy = 192;
			break;
			default:
				console.log("this shouldn't happen")
				this.mouse.tool = "pen";
				this.buttons[0].tool.image.file.sy = 0;
			break;
		};
		this.buttons[0].tool.image.file.src = "draw_tools.png";
		//this.buttons[0].tool.image.file.src = "https://barky.neocities.org/draw_tools.png";
		this.buttons[0].subtool_u.image = {
			file: new Image(),
			sx: 0,
			sy: 0,
			sw: 64,
			sh: 64,
		};
		this.buttons[0].subtool_u.image.file.src = "draw_subtoolcontrol.png";
		//this.buttons[0].subtool_u.image.file.src = "https://barky.neocities.org/draw_subtoolcontrol.png";
		temp = ["sizedown", "sizeup", "undo", "redo", "page"];
		for(i1 = 0; i1 < temp.length; i1++) {
			this.buttons[0][temp[i1]].image = {
				file: new Image(),
				sx: 0,
				sy: 32*i1,
				sw: 32,
				sh: 32,
			};
			this.buttons[0][temp[i1]].image.file.src = "draw_etc.png";
			//this.buttons[0][temp[i1]].image.file.src = "https://barky.neocities.org/draw_etc.png";
		}
		// page 0 image defining
		for(i1 = 1; i1 < this.buttons.length; i1++) {
			this.buttons[i1].page = structuredClone(this.buttons[0].page);
			delete this.buttons[i1].page.key;
			// otherwise, pressing the page key might trigger the page action
			// multiple times, for every single copy of the page button.
		}
		// create clones of page, so that it's on every page.
		this.menucorner = [x0, y0];
	};
	draw.drawbuttons = function() {
	// draws the buttons
		let i1 = "";
		this.ctx.fillStyle = "white";
		this.ctx.fillRect(this.menucorner[0], this.menucorner[1], this.drawingarea.w, this.drawingarea.h);
		this.ctx.strokeStyle = "#2f2f5f";
		let center = [null, null];
		for (i1 in this.buttons[this.page]) {
			if (
				this.buttons[this.page].hasOwnProperty(i1)
				&&
				(
					!this.buttons[this.page][i1].hasOwnProperty("hide")
					||
					!this.buttons[this.page][i1].hide
				)
			) {
				if(this.buttons[this.page][i1].hasOwnProperty("tags") && this.buttons[this.page][i1].tags.includes("palette")) {
					this.ctx.fillStyle = this.colors[Number(i1.slice(i1.indexOf("color_") + "color_".length))];
					this.ctx.fillRect(this.buttons[this.page][i1].x, this.buttons[this.page][i1].y, this.buttons[this.page][i1].w, this.buttons[this.page][i1].h);
				};
				if(this.buttons[this.page][i1].hasOwnProperty("split")) {
					/*
					center = fourpointintersect(
						this.buttons[this.page][i1].x, this.buttons[this.page][i1].y,
						this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h,
						this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y,
						this.buttons[this.page][i1].x, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h,
					);
					if(this.buttons[this.page][i1].split.includes("up")) {
						_2dPoly.draw(this.ctx, [
							[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y],
							[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y],
							center
						], "stroke", this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("down")) {
						_2dPoly.draw(this.ctx, [
							[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h],
							[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h],
							center
						], "stroke", this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("left")) {
						_2dPoly.draw(this.ctx, [
							[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h],
							[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y],
							center
						], "stroke", this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("right")) {
						_2dPoly.draw(this.ctx, [
							[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y],
							[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h],
							center
						], "stroke", this.scale);
					};
					//*/
					this.ctx.fillStyle = "#2f2f5f";
					if(this.buttons[this.page][i1].split.includes("up")) {
						this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y - this.scale, this.buttons[this.page][i1].w + 2*this.scale, 2*this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("down")) {
						this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h - this.scale, this.buttons[this.page][i1].w + 2*this.scale, 2*this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("left")) {
						this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y - this.scale, 2*this.scale, this.buttons[this.page][i1].h + 2*this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("right")) {
						this.ctx.fillRect(this.buttons[this.page][i1].x + this.buttons[this.page][i1].w - this.scale, this.buttons[this.page][i1].y - this.scale, 2*this.scale, this.buttons[this.page][i1].h + 2*this.scale);
					};
				}
				else {
					/*
					_2dPoly.draw(this.ctx, [
						[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y],
						[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y],
						[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h],
						[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h]
					], "stroke", this.scale);
					//*/
					this.ctx.fillStyle = "#2f2f5f";
					this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y - this.scale, this.buttons[this.page][i1].w + 2*this.scale, 2*this.scale);
					this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h - this.scale, this.buttons[this.page][i1].w + 2*this.scale, 2*this.scale);
					this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y - this.scale, 2*this.scale, this.buttons[this.page][i1].h + 2*this.scale);
					this.ctx.fillRect(this.buttons[this.page][i1].x + this.buttons[this.page][i1].w - this.scale, this.buttons[this.page][i1].y - this.scale, 2*this.scale, this.buttons[this.page][i1].h + 2*this.scale);
				};
				//*
				if(this.buttons[this.page][i1].hasOwnProperty("image")) {
					/*
					this.ctx.drawImage(
						this.buttons[this.page][i1].image.file,
						this.buttons[this.page][i1].image.sx,
						this.buttons[this.page][i1].image.sy,
						this.buttons[this.page][i1].image.sw,
						this.buttons[this.page][i1].image.sh,
						this.buttons[this.page][i1].x,
						this.buttons[this.page][i1].y,
						this.buttons[this.page][i1].w,
						this.buttons[this.page][i1].h
					);
					//*/
					// this causes a domexception error, says anything that
					// involves undodata is insecure.
					// - the reason for this is the "same-origin policy"; a
					//   script may access the data of a second webpage, but
					//   only if they share a common origin.
					// - and apparently, existing in the same folder does not
					//   count as sharing a common origin.
					// - i saw someone say you can get around this by using a
					//   dropbox (somehow????? why the fuck is that good enough
					//   but an actual shared origin isn't????) so i uploaded
					//   the images to neocities. they do not display, but they
					//   don't cause domexception errors either.
					// - maybe it'll work when i upload it! i don't give a shit
					//   though! i don't want to upload it! i don't want to do
					//   all my programming in a fairly basic ide that's just
					//   meant for styling!
					//   - also the procedural animation is a fucking mess and
					//     totally unfinished. needta make that into functions
					//     or something first.
				};
				//*/
			};
		}
		// for now, i'm just gonna draw the outlines... i don't feel like
		// learning drawImage right now.
	};
	draw.checkbutton = function(keyboardevent) {
	// returns the string of the button clicked
	// - keyboardevent: this should be a KeyboardEvent. if there's a value here,
	//   it'll assume this function was run by the keyboard event listeners
	//   instead of the mouse event listeners.
		let i1 = "";
		let i2 = "";
		let i0 = null;
		let temp = 0;
		if(keyboardevent) {
			let key = keyboardevent.key;
			if(key.length === 1 && key.charCodeAt(0) >= 65 && key.charCodeAt(0) < 91) {
				key = key.toLowerCase();
			};
			// if it's a capital letter, make it lowercase. (whether is is or isn't
			// capital doesn't matter, e.shiftKey is the only thing that could be
			// relevant.)
			for(i0 = 0; i0 < this.buttons.length; i0++) {
			// search every page
				for (i1 in this.buttons[i0]) {
					if (
						this.buttons[i0].hasOwnProperty(i1)
						&&
						this.buttons[i0][i1].hasOwnProperty("key")
					) {
						if(this.buttons[i0][i1].key.slice(0, "ctrl + ".length) === "ctrl + ") {
							if(this.buttons[i0][i1].key.slice("ctrl + ".length) === key && keyboardevent.ctrlKey) {
								return i1;
							};
						}
						else if(this.buttons[i0][i1].key === key) {
							return i1;
						};
					};
				}
			}
		}
		else {
			for (i1 in this.buttons[this.page]) {
				if (
					this.buttons[this.page].hasOwnProperty(i1)
					&&
					withinrect(this.mouse.x, this.mouse.y, this.buttons[this.page][i1])
				) {
				// the click is within this button.
					if(this.buttons[this.page][i1].hasOwnProperty("split")) {
						temp = fourpointintersect(
							this.buttons[this.page][i1].x, this.buttons[this.page][i1].y,
							this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h,
							this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y,
							this.buttons[this.page][i1].x, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h,
						);
						temp = get2dangle(this.mouse.x - temp[0], this.mouse.y - temp[1], true);
						// angle relative to center of button
						if(temp === null) {
						// click is right in the center
							return i1;
						}
						temp = posmod(Math.round(temp/(Math.PI/2)), 4);
						temp = ["right", "down", "left", "up"][temp];
						if(this.buttons[this.page][i1].split.includes(temp)) {
							return i1;
						};
					}
					else {
						return i1;
					};
				}; // for if
			} // for
		} // else
		return "none";
	};
	draw.buttonaction = function(e, iskeyboardevent) {
	// there's two places this runs:
	// - ui mouse click: key is not specified, so checkbutton checks mouse x/y
	//   to figure out what the key is
	// - keyboard event: checkbutton just uses the keyboard event directly
	// - arguments
	//   - e: event. used to check if the ctrl button was held or whatever.
	//   - iskeyboardevent: determines how it runs checkbutton
		let action = null;
		let inversion = !!e.shiftKey;
		// if the shift key is held while pressing the tool/subtool selection
		// keys, or if the tool/subtool buttons are right-clicked, it's supposed
		// to select an inverse. this stores if there was a shift or right
		// click.
		// boolean storing if the shift
		this.clearclip();
		// allow drawing anywhere (since graphical ui-changy stuff will require that)
		if(iskeyboardevent) {
			action = this.checkbutton(e);
		}
		else {
			action = this.checkbutton();
			if(e.button === 2 || e.button === 1) {
				inversion = true;
			};
		};
		//console.log(action);
		if(action === "none") {
			// don't do anything
		}
		else if(this.buttons[this.page][action].hasOwnProperty("tags")) {
			if(this.buttons[this.page][action].tags.includes("palette")) {
				this.misc.rainbowmode = false;
				let temp = invertboolean( invertboolean(true, this.mouse.tool === "eraser") , inversion);
				temp = (temp ? "color1" : "color2");
				// change color1, unless you're using the eraser. change the
				// other color if inversion is on.
				this[temp] = Number(action.slice(action.indexOf("colors_") + "colors_".length));
				//this.colorselectgraphic();
			}
			else if(this.buttons[this.page][action].tags.includes("subtool")) {
				if(action === "subtool_r") {
					this.mouse.subtool[this.mouse.tool]++;
					// cycle up in the array where the subtools are stored
				}
				else if(action === "subtool_l") {
					this.mouse.subtool[this.mouse.tool] += this[this.mouse.tool].length - 1;
				}
				else if(action === "subtool_u") {
					this.mouse.subtool[this.mouse.tool] += this[this.mouse.tool].length - 4;
				}
				else if(action === "subtool_d") {
					this.mouse.subtool[this.mouse.tool] += 4;
				};
				this.mouse.subtool[this.mouse.tool] %= this[this.mouse.tool].length;
				if(inversion) {
					this.mouse.inversion[this.mouse.tool] = true;
				}
				else {
					this.mouse.inversion[this.mouse.tool] = false;
				};
				this.subtooltext();
				//console.log([this.mouse.clicktype, this.mouse.tool, this[this.mouse.tool][this.mouse.subtool[this.mouse.tool]].name].join(", "));
				// good night, sweet prince. i finally don't need you,
			};
		}
		else if(action === "tool") {
			let temp = ["pen", "paint", "eraser"];
			this.mouse.tool = temp[(temp.indexOf(this.mouse.tool) + 1)%temp.length];
			if(inversion) {
				this.mouse.inversion[this.mouse.tool] = true;
			}
			else {
				this.mouse.inversion[this.mouse.tool] = false;
			};
			this.subtooltext();
			//console.log([this.mouse.clicktype, this.mouse.tool, this[this.mouse.tool][this.mouse.subtool[this.mouse.tool]].name].join(", "));
			// TODO change icon
		}
		else if(["sizedown", "sizeup"].includes(action)) {
			let temp = invertboolean( invertboolean(true, this.mouse.tool === "pen") , inversion);
			temp = (temp ? "paintsize" : "pensize");
			// in other words, modify paintsize. but if the current tool is pen,
			// modify pensize instead. but if inversion is on, modify the other
			// size instead.
			this[temp] = Math.max(this[temp] + (action === "sizedown" ? -1 : action === "sizeup" ? 1 : 0), 1);
			// decrease by one, but don't go below one.
			this.subtooltext();
		}
		else if(action === "undo") {
			this.undo();
		}
		else if(action === "redo") {
			this.redo();
		}
		else if(action === "rainbow") {
			if(draw.misc.rainbowmode || draw.misc.epilepsywarning) {
				this.misc.rainbowmode = !this.misc.rainbowmode;
			}
			else {
			// safety first kiddos
			// - good thing prompt is so easy to use. it'd be a real pain in
			//   the ass to make a system for creating prompts in canvas.
			// - then again, maybe i'll have to do that eventually anyway.
				let temp = prompt(draw.misc.epilepsytext);
				if(temp === "yes") {
					this.misc.rainbowmode = !this.misc.rainbowmode;
					draw.misc.epilepsywarning = true;
					// turn off photosensitivity warnings
				};
			};
		}
		else if(action === "changerainbow") {
			let input = prompt(`type a list of color indexes, separated by spaces. the rainbow mode will shift through those instead. (type "pong" at the beginning to make it pingpong between the beginning and end colors, and type "reset" to use the default rainbow.)`);
			if(input) {
				input = removewhitespace(input);
				let pingpong = input[0] === "pong";
				if(pingpong) {
					input.splice(0, 1);
				}
				if(input.length === 1 && input[0] === "reset") {
					this.createrainbow();
				}
				else if(input.length > 1) {
					let i1 = 0;
					let error = false;
					for(i1 = 0; i1 < input.length; i1++) {
						input[i1] = Number(input[i1]);
						if(!Number.isInteger(input[i1]) || input[i1] < 0 || input[i1] >= this.colors.length) {
							alert("invalid index.");
							error = true;
							i1 += input.length;
						};
					}
					if(!error) {
						if(pingpong) {
							for(i1 = input.length - 2; i1 >= 1; i1--) {
								input[input.length] = input[i1];
							}
						}
						this.misc.rainbow = structuredClone(input);
					};
				}
				else {
					alert("invalid input.");
				};
			}
		}
		else if(action === "colorchange") {
			let input = prompt("type a palette number, a colon, and a color to change the color of that palette slot. (you can input multiple colors by separating them with asterisks.)");
			if(input) {
				input = removewhitespace(input, "").split("*");
				let i1 = 0;
				let index = -1;
				for(i1 = 0; i1 < input.length; i1++) {
					index++;
					index %= this.colors.length;
					let temp = input[i1].indexOf(":");
					if(temp !== -1) {
						let num = Number(input[i1].slice(0, temp));
						input[i1] = input[i1].slice(temp + 1);
						if(Number.isInteger(num) && 0 <= num && num < this.colors.length) {
							index = num;
						};
					};
					this.colors[index] = input[i1].trim();
				}
				this.drawbuttons();
				this.subtooltext();
			};
		}
		else if(action === "colorstrings") {
			let text = structuredClone(this.colors);
			let i1 = 0;
			for(i1 = 0; i1 < text.length; i1++) {
				text[i1] = i1 + ": " + text[i1];
			};
			alert("the current palette is:" + String.fromCharCode(10) + text.join(" *" + String.fromCharCode(10)));
		}
		else if(action === "page") {
		};
	};
	draw.colorselectgraphic = function() {
	// draws a border around the colors that you have selected as color1 and
	// color2.
		this.ctx.putImageData(this.buttons.colors.image, this.buttons.colors.x, this.buttons.colors.y);
		// erase whatever selection borders were there before
		let temp = {
			r: Math.floor(this.buttons.colors.w/16),
			// diameter is half of one subbutton
			margin: Math.floor(this.buttons.colors.w/32),
			// an eighth of one subbutton
		};
		this.ctx.fillStyle = "#ffdfbf";
		circledraw(this.ctx, this.buttons.colors.sub[this.color2].x + this.buttons.colors.sub[this.color2].w - (temp.r + temp.margin) + 1, this.buttons.colors.sub[this.color2].y + this.buttons.colors.sub[this.color2].h - (temp.r + temp.margin) + 1, temp.r, true);
		this.ctx.fillStyle = "white";
		circledraw(this.ctx, this.buttons.colors.sub[this.color2].x + this.buttons.colors.sub[this.color2].w - (temp.r + temp.margin), this.buttons.colors.sub[this.color2].y + this.buttons.colors.sub[this.color2].h - (temp.r + temp.margin), temp.r, true);
		this.ctx.fillStyle = "#2f2f5f";
		circledraw(this.ctx, this.buttons.colors.sub[this.color1].x + temp.r + temp.margin + 1, this.buttons.colors.sub[this.color1].y + temp.r + temp.margin + 1, temp.r, true);
		this.ctx.fillStyle = "black";
		circledraw(this.ctx, this.buttons.colors.sub[this.color1].x + temp.r + temp.margin, this.buttons.colors.sub[this.color1].y + temp.r + temp.margin, temp.r, true);
		/*
		if(this.color1 === this.color2) {
			this.ctx.strokeStyle = "#ffdfbf";
			this.ctx.drawborder(this.buttons.colors.sub[this.color1].x, this.buttons.colors.sub[this.color1].y, this.buttons.colors.sub[this.color1].w, this.buttons.colors.sub[this.color1].h, 3);
			this.ctx.strokeStyle = "#2f2f5f";
			this.ctx.fillStyle = "black";
			this.ctx.drawborder(this.buttons.colors.sub[this.color1].x + 1, this.buttons.colors.sub[this.color1].y + 1, this.buttons.colors.sub[this.color1].w - 1, this.buttons.colors.sub[this.color1].h - 1, 2, 1);
		}
		else {
			this.ctx.strokeStyle = "#ffdfbf";
			this.ctx.fillStyle = "white";
			this.ctx.drawborder(this.buttons.colors.sub[this.color2].x, this.buttons.colors.sub[this.color2].y, this.buttons.colors.sub[this.color2].w, this.buttons.colors.sub[this.color2].h, 3, -2);
			this.ctx.strokeStyle = "#2f2f5f";
			this.ctx.fillStyle = "black";
			this.ctx.drawborder(this.buttons.colors.sub[this.color1].x, this.buttons.colors.sub[this.color1].y, this.buttons.colors.sub[this.color1].w, this.buttons.colors.sub[this.color1].h, 3, 2);
		};
		//*/
	};
	draw.subtooltext = function() {
		this.ctx.textBaseline = "bottom";
		let temp = [];
		let i1 = 0;
		this.clearclip();
		this.ctx.font = "16px 'fomp2'";
		for(i1 = 0; i1 < 2; i1++) {
			temp[0] = "subtool" + ["number", "name"][i1];
			// the lengths i go for DRY.
			if(this.buttons[this.page].hasOwnProperty(temp[0])) {
				// if the ui is on the page the subtool number/name display is on,
				this.clearclip();
				this.rect = new Path2D();
				this.rect.rect(this.buttons[this.page][temp[0]].x + 1, this.buttons[this.page][temp[0]].y + 1, this.buttons[this.page][temp[0]].w - 2, this.buttons[this.page][temp[0]].h - 2);
				// the top row is part of the boxes of the buttons above it
				this.ctx.clip(this.rect);
				// make sure it doesn't go out of bounds
				if(i1 === 1 && this.mouse.inversion[this.mouse.tool]) {
					this.ctx.fillStyle = "black";
					this.ctx.fillRect(this.buttons[this.page][temp[0]].x + 1, this.buttons[this.page][temp[0]].y + 1, this.buttons[this.page][temp[0]].w - 2, this.buttons[this.page][temp[0]].h - 2);
					// clear it
					this.ctx.fillStyle = "white";
				}
				else {
					this.ctx.fillStyle = "white";
					this.ctx.fillRect(this.buttons[this.page][temp[0]].x + 1, this.buttons[this.page][temp[0]].y + 1, this.buttons[this.page][temp[0]].w - 2, this.buttons[this.page][temp[0]].h - 2);
					// clear it
					this.ctx.fillStyle = "#2f2f5f";
				};
				if(i1 === 0) {
					temp[1] = this.mouse.subtool[this.mouse.tool];
					// the number index
					temp[1] = numalign([temp[1], Math.max(this.pen.length, this.paint.length, this.eraser.length) - 1])[0];
					// makes sure it has whatever number of spaces will make
					// the ones digit in the same place every time
					temp[1] = this.mouse.tool + " ".repeat(6 - this.mouse.tool.length) + " " + temp[1];
					temp[1] += " " + numalign([this.mouse.tool === "pen" ? this.pensize : this.paintsize, 100])[0] + "px";
				}
				else if(i1 === 1) {
					temp[1] = this[this.mouse.tool][ this.mouse.subtool[this.mouse.tool] ].name;
				};
				//console.log(temp.join(": "));
				this.ctx.fillText(
					temp[1],
					this.buttons[this.page][temp[0]].x + 2,
					this.buttons[this.page][temp[0]].y + this.buttons[this.page][temp[0]].h - 1
				);
			};
		};
		this.ctx.fillStyle = (this.mouse.inversion[this.mouse.tool] ? "white" : "#2f2f5f");
		let grid = {
			ref: this.buttons[this.page].subtoolname,
		};
		grid.x = grid.ref.x + grid.ref.w - 1;
		grid.y = grid.ref.y + 2;
		grid.scale = 2;
		grid.rowwidth = 4;
		grid.maxrows = Math.floor((grid.ref.y + grid.ref.h - grid.y - 1)/grid.scale) + 1;
		grid.numofgroups = Math.ceil(Math.ceil(this[this.mouse.tool].length/grid.rowwidth)/grid.maxrows);
		for(i1 = 0; i1 < this[this.mouse.tool].length; i1++) {
			let row = Math.floor(i1/grid.rowwidth);
			let col = i1%grid.rowwidth;
			let group = Math.floor(row/grid.maxrows);
			row %= grid.maxrows;
			let coor = [
				grid.x + grid.scale*(-grid.rowwidth + col),
				grid.y + grid.scale*row
			];
			coor[0] += grid.scale*(group - (grid.numofgroups - 1))*(grid.rowwidth + 1);
			if(i1 === this.mouse.subtool[this.mouse.tool]) {
				this.ctx.fillRect(coor[0] - 1, coor[1] - 1, 3, 3);
			}
			else {
				this.ctx.fillRect(coor[0], coor[1], 1, 1);
			}
		}
		this.ctx.textBaseline = "alphabetic";
		this.clearclip();
		// allow it to draw anywhere again
		//
		// i can't figure this out at all, what the fuuuuck
		// - i'm debugging this and i just don't get why the second line doesn't
		//   write. the text is right, the fillStyle is right, the dimensions
		//   and positions are right, i just don't get it...
		//   - well for one thing the clip needs to be saved and restored, not
		//     redefined
		// - you would think the way this works is:
		//   - save() before any paths are defined
		//   - .restore() every time you're about to define a path, to be sure
		//     it's a blank slate first
		//   - define path, clip
		//   - draw
		//   - restore()
		//   =
		//   - but that doesn't work and i can't even begin to wrap my head
		//     around where it breaks since this shit carries over from one
		//     thing to another to another...
		// - also i just learned .save() and .restore() save things like
		//   fillStyle and strokeStyle too, so i'm gonna need an alternative
		//   approach
	};
	draw.clearclip = function() {
	// - for some reason mdn neglects to mention that it doesn't just clear
	//   the settings but also the image. could not tell you why.
	// - or, for that matter, why i cannot find the data for the current clip
	//   region anywhere in the context properties. that'd make all of this a
	//   lot more simple.
		let canvastemp = {};
		let i1 = "";
		for (i1 in this.ctx) {
			if (["string", "number", "boolean"].includes(typeof this.ctx[i1])) {
			// forgoing "this.ctx.hasOwnProperty(i1)" because things specific to
			// it being a canvas context (ie fillStyle, shit like that. what i'm
			// trying to save.) don't count
				canvastemp[i1] = this.ctx[i1];
			};
		}
		// saves all the simple data, avoids stuff like the object references
		// and class methods. font, fillStyle, strokeStyle, etc
		let imagetemp = this.ctx.getImageData(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
		this.ctx.reset();
		for (i1 in canvastemp) {
			if (canvastemp.hasOwnProperty(i1)) {
				this.ctx[i1] = canvastemp[i1];
			};
		}
		this.ctx.putImageData(imagetemp, 0, 0);
		// restore everything
	}
	draw.ready = function(skipclearing) {
	// makes sure everything's ready for the user to start drawing.
		this.clearclip();
		this.rect = new Path2D();
		// creates a path
		this.rect.rect(this.drawingarea.x, this.drawingarea.y, this.drawingarea.w, this.drawingarea.h);
		// path method that makes it a rectangle
		this.ctx.clip(this.rect);
		// canvas method that makes it only draw within that area
		let color = (this.mouse.tool === "eraser" ? this.colors[this.color2] : this.colors[this.color1]);
		color = Color.rgb(this.ctx, color);
		color[color.length] = 1;
		color = "rgba(" + color.join() + ")";
		this.ctx.fillStyle = color;
		this.ctx.strokeStyle = color;
		/*
		for(i1 = 0; i1 < this.mouse.numofpositions; i1++) {
			this.mouse.oldx[i1] = null;
			this.mouse.oldy[i1] = null;
		}
		//*/
		if(!skipclearing) {
			draw.mouse.oldx = [];
			draw.mouse.oldy = [];
			// this needs to be cleared so it doesn't keep around positions from the
			// previous stroke.
		};
	};
	draw.setmousecoor = function(e) {
		this.mouse.oldx.splice(0, 0, this.mouse.x);
		this.mouse.oldy.splice(0, 0, this.mouse.y);
		//this.mouse.oldx.splice(this.mouse.numofpositions, 1);
		//this.mouse.oldy.splice(this.mouse.numofpositions, 1);
		// add something new to the beginning, shift up
		let click = clickxy(e, "draw");
		this.mouse.x = click[0];
		this.mouse.y = click[1];
	};
	draw.undo = function() {
		if(this.undoindex + 1 < this.undodata.length) {
			this.undoindex += 1;
			this.ctx.putImageData(this.undodata[this.undoindex], this.drawingarea.x, this.drawingarea.y);
		};
		//console.log("undoindex: " + this.undoindex);
	};
	draw.redo = function() {
		if(this.undoindex > 0) {
			this.undoindex -= 1;
			this.ctx.putImageData(this.undodata[this.undoindex], this.drawingarea.x, this.drawingarea.y);
		};
		//console.log("undoindex: " + this.undoindex);
	};
	draw.pen = [
	// array of subtools, storing names and functions.
	// - the down/move/up functions are always run with draw and the inversion
	//   boolean as parameters, so keep that in mind if you create any special
	//   arguments for internal use.
	// - other properties:
	//   - epilepsy: brushes that redraw enough to seem kind of dangerous if
	//     rainbow mode is on. draw.mousemove will prompt the user before
	//     they're allowed to use it.
		{
			name: "basic",
			move: function(draw, inversion) {
				//nonaaline(draw.ctx, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, (inversion ? draw.paintsize : draw.pensize));
				linespecial(function(x, y, progress) {
					circledraw(draw.ctx, x, y, 2*(inversion ? draw.paintsize : draw.pensize) - 1.5, true);
				}, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y);
			},
		},
		{
			name: "scratchy A",
			move: function(draw, inversion) {
				// this is fun as hell when you go back 10 positions, but maybe
				// that's overdoing it a little.
				// - not sure whether to go with 3 or 5.
				// - 5 looks kinda like, uh... palm from hunter x hunter's hair?
				//   weird. messy. wiry. it's possible to get the geometric,
				//   net-shaped stuff from higher levels if you go fast enough.
				// - 3 looks more stable, but...
				// - ah fuck it both are prone to getting wonky at times. it
				//   looks better with 5 because the change isn't sudden.
				let temp = (inversion ? 10 : 5);
				if(draw.mouse.oldx[temp - 1] !== null && draw.mouse.oldy[temp - 1] !== null) {
					nonaaline(draw.ctx, draw.mouse.oldx[temp - 1], draw.mouse.oldy[temp - 1], draw.mouse.x, draw.mouse.y, draw.pensize);
				};
				//draw.ctx.strokeStyle = draw.colors[draw.color2];
				//temp = 3;
				//if(draw.mouse.oldx[temp - 1] !== null && draw.mouse.oldy[temp - 1] !== null) {
				//	nonaaline(draw.ctx, draw.mouse.oldx[temp - 1], draw.mouse.oldy[temp - 1], draw.mouse.x, draw.mouse.y);
				//};
				//draw.ctx.strokeStyle = draw.colors[draw.color1];
			},
		},
		{
			name: "scratchy B",
			move: function(draw) {
				let numoflines = 3;
				let variation = 4;
				let positionsback = 1;
				let condensefactor = 3;
				//
				let rand = [];
				let i1 = 0;
				//nonaaline(draw.ctx, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.pensize);
				if(draw.mouse.oldx[positionsback] !== null && draw.mouse.oldy[positionsback] !== null) {
					for(i1 = 0; i1 < numoflines; i1++) {
						rand = [
							Math.trunc(randexponent(condensefactor, true)*(variation + 1)),
							Math.trunc(randexponent(condensefactor, true)*(variation + 1))
						];
						nonaaline(draw.ctx, draw.mouse.oldx[positionsback] + rand[0], draw.mouse.oldy[positionsback] + rand[1], draw.mouse.x + rand[0], draw.mouse.y + rand[1], draw.pensize);
					}
				};
				// TODO: use strokedata to make it use random numbers from last
				// time?
				// - specifically, for every numoflines, a line is created that
				//   randomly varies from the previous in a new way.
				// - each random position is built off of the last.
				// 3312
			},
		},
		{
			name: "spray paint",
			move: function(draw, inversion) {
				let numofsprays = (inversion ? 2 : 1)*4;
				// this is how many spray thingies are made between mousemove
				// positions. make this higher, and the line gets smoother but
				// also denser.
				let numofdots = (inversion ? 2 : 1)*16/((8**2)*Math.PI);
				// the same ratio of dots per area as 16 dots in a radius of 8
				let sprayradius = draw.paintsize;
				numofdots *= (sprayradius**2) * Math.PI;
				// multiply by area
				let condensefactor = (inversion ? 4 : 2);
				//
				let spray_x = 0;
				let spray_y = 0;
				// temps for storing the center of the current spray
				let temp = null;
				for(i1 = 1; i1 <= numofsprays; i1++) {
					spray_x = Math.floor(draw.mouse.oldx[0] + (draw.mouse.x - draw.mouse.oldx[0])*i1/numofsprays);
					spray_y = Math.floor(draw.mouse.oldy[0] + (draw.mouse.y - draw.mouse.oldy[0])*i1/numofsprays);
					for(i2 = 0; i2 < numofdots; i2++) {
						temp = [
							randexponent(condensefactor)*sprayradius,
							Math.random()*2*Math.PI
						];
						temp = [
							Math.trunc(temp[0]*Math.cos(temp[1])),
							Math.trunc(temp[0]*Math.sin(temp[1]))
						];
						circledraw(
							draw.ctx,
							spray_x + temp[0],
							spray_y + temp[1],
							draw.pensize/2,
							true,
						);
						/*
						draw.ctx.fillRect(
							spray_x + Math.trunc(randexponent(condensefactor, true)*(sprayradius + 1)),
							spray_y + Math.trunc(randexponent(condensefactor, true)*(sprayradius + 1)),
							1,
							1
						);
						//*/
						// the +1 is so the range is 0 and radius, instead of 0
						// and radius - 1.
					}
				}
				// nailed the settings on my first try. wow.
				// - that said, this should scale based on... i dunno, i guess
				//   the paint size? which i want to be variable.
			},
		},
		{
			name: "smear",
			down: function(draw, inversion) {
				let numofdots = 16/((8**2)*Math.PI);
				// proper ratio of dots per area.
				let smearradius = .5*draw.paintsize;
				numofdots *= (smearradius**2) * Math.PI;
				// multiply by area
				if(inversion) {
					numofdots *= 2;
				};
				draw.mouse.strokedata = [];
				for(i1 = 0; i1 < numofdots; i1++) {
					draw.mouse.strokedata[draw.mouse.strokedata.length] = [
						Math.trunc(randexponent(1, true)*(smearradius + 1)),
						Math.trunc(randexponent(1, true)*(smearradius + 1))
					];
				}
			},
			move: function(draw) {
				draw.ctx.lineexecute(draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, 8, function(context, x, y, weight) {
					let i1 = 0;
					for(i1 = 0; i1 < draw.mouse.strokedata.length; i1++) {
						circledraw(
							draw.ctx,
							Math.floor(x + draw.mouse.strokedata[i1][0]),
							Math.floor(y + draw.mouse.strokedata[i1][1]),
							draw.pensize/2,
							true,
						);
						//context.fillRect(Math.floor(x + draw.mouse.strokedata[i1][0]), Math.floor(y + draw.mouse.strokedata[i1][1]), 1, 1);
					}
				}, true);
				// hmmmm.
				// - the way i wanted it was that the smear array is created at
				//   mousedown, and remains the same the whole stroke
				//   - it's 4am and i am not doing that.
				// - but this does look sort neat in its own right. it might be
				//   able to replace the heavier version of spray i was
				//   considering? but that'd probably mean i'd have to give up
				//   on what i wanted before, unless i can differentiate them
				//   somehow.
				// - eh. i dunno how good this looks. it looks amateurish, and
				//   not in a good way... like the kind of thing that looks
				//   "neat" but not good or actually useful
				// -
				// - i finished it. it looks very nice. it'd be good for
				//   imitating a paintbrush, or texturing something like wood
			},
		},
		{
			name: "boxy",
			move: function(draw) {
				if(Math.abs(draw.mouse.oldx[0] - draw.mouse.x) > Math.abs(draw.mouse.oldy[0] - draw.mouse.y)) {
					draw.mouse.y = draw.mouse.oldy[0];
				}
				else {
					draw.mouse.x = draw.mouse.oldx[0];
				};
				nonaaline(draw.ctx, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.pensize);
			},
		},
		{
			name: "octo",
			move: function(draw) {
				let roundfactor = 8;
				//
				let dist = Math.hypot(draw.mouse.x - draw.mouse.oldx[0], draw.mouse.y - draw.mouse.oldy[0]);
				let angle = get2dangle(draw.mouse.x - draw.mouse.oldx[0], draw.mouse.y - draw.mouse.oldy[0], true);
				let anglechange = 0;
				let oldx = null;
				let oldy = null;
				if(draw.mouse.strokedata === null) {
					oldx = Math.round(draw.mouse.oldx[0]/roundfactor)*roundfactor;
					oldy = Math.round(draw.mouse.oldy[0]/roundfactor)*roundfactor;
				}
				else {
					oldx = draw.mouse.strokedata[1];
					oldy = draw.mouse.strokedata[2];
				};
				let newx = draw.mouse.x;
				let newy = draw.mouse.y;
				if(angle !== null) {
					angle /= 2*Math.PI;
					angle = Math.round(angle*8)%8;
					if(draw.mouse.strokedata !== null) {
						anglechange = angle - draw.mouse.strokedata[0];
						if(Math.abs(anglechange) > 4) {
							anglechange *= -1;
						};
						if(anglechange < 0) {
							angle = posmod(draw.mouse.strokedata[0] - 1, 8);
						}
						else if(anglechange > 0) {
							angle = posmod(draw.mouse.strokedata[0] + 1, 8);
						}
						else if(anglechange === 0) {
							angle = draw.mouse.strokedata[0];
						}
						else {
							console.log("this shouldn't happen");
						};
					};
					draw.mouse.strokedata = [];
					draw.mouse.strokedata[0] = angle;
					// store it for the next line to check, a number from 0 to 7
					angle *= 2*Math.PI/8;
					// turn it into a 1/8 angle
					newx = oldx + Math.round(dist*Math.cos(angle)/roundfactor)*roundfactor;
					newy = oldy + Math.round(dist*Math.sin(angle)/roundfactor)*roundfactor;
					draw.mouse.strokedata[1] = newx;
					draw.mouse.strokedata[2] = newy;
					// make sure the angle is whatever the closest 1/8 angle is,
					// and round it to the nearest %2 === 0 position.
				}
				nonaaline(draw.ctx, oldx, oldy, newx, newy, draw.pensize);
				// unfinished. it goes totally haywire. i think i get what the
				// problem is though.
				// - all it is is the draw.mouse.x/y redefinings piling up until
				//   the place where you're actually moving the mouse and the
				//   place it thinks the mouse is are totally different.
				// - i'm gonna have to make it so it modifies new variables
				//   based on draw.mouse.x/y and oldx/y, and has nonaaline use
				//   that while the originals remain unchanged.
			},
		},
		{
			name: "sunset",
			move: function(draw, inversion) {
				let blobw = (inversion ? draw.pensize : draw.paintsize);
				let blobh = (inversion ? draw.paintsize : draw.pensize);
				let positionsback = 16;
				//
				let i1 = 0;
				for(i1 = 0; i1 < positionsback; i1++) {
					if((draw.mouse.oldx[positionsback - i1] || draw.mouse.oldx[positionsback - i1] === 0) && (draw.mouse.oldy[positionsback - i1] || draw.mouse.oldy[positionsback - i1] === 0)) {
					// skip this position if it's nullish
						draw.ctx.lineexecute(draw.mouse.oldx[positionsback - i1], draw.mouse.oldy[positionsback - i1], draw.mouse.oldx[positionsback - (i1 + 1)], draw.mouse.oldy[positionsback - (i1 + 1)], (positionsback - i1 + 1)/(positionsback + 1), function(context, x, y, weight) {
							circledraw(context, x, y, [Math.ceil(weight*blobw/2), Math.ceil(weight*blobh/2)], true);
						}, true);
					};
				}
				if((draw.mouse.oldx[0] || draw.mouse.oldx[0] === 0) && (draw.mouse.oldy[0] || draw.mouse.oldy[0] === 0)) {
					draw.ctx.lineexecute(draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, 1/positionsback, function(context, x, y, weight) {
						circledraw(context, x, y, [Math.ceil(weight*blobw/2), Math.ceil(weight*blobh/2)], true);
					}, true);
				};
				// draws with an elliptical particle, but for the last 5
				// positions the particle is smaller
			},
		},
		{
			name: "stroke",
			move: function(draw) {
				nonaaline(draw.ctx, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.paintsize + 2*draw.pensize);
			},
			up: function(draw) {
				let i1 = 0;
				draw.ctx.strokeStyle = draw.colors[draw.color2];
				for(i1 = Math.min(draw.mouse.oldx.length, draw.mouse.oldy.length) - 1; i1 > 0; i1--) {
					nonaaline(draw.ctx, draw.mouse.oldx[i1], draw.mouse.oldy[i1], draw.mouse.oldx[i1 - 1], draw.mouse.oldy[i1 - 1], draw.paintsize);
				}
				nonaaline(draw.ctx, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.paintsize);
				draw.ctx.strokeStyle = draw.colors[draw.color1];
			},
		},
		{
			name: "diamond dots",
			move: function(draw) {
				let i0 = 0;
				let i1 = 0;
				let i2 = 0;
				let grid = 4;
				let sizes = [1, 2, 3, 4];
				// each iteration of i0 will increase the radius of the dots it
				// draws to this.
				let easing = "linear";
				// applied to the different radii. but apparently linear works
				// best anyway...
				//
				let temp = null;
				let radius = 0;
				// this is the radius of the area it finds dot coordinates in.
				for(i0 = 0; i0 < sizes.length; i0++) {
					radius = easingplacement(0, draw.paintsize/2, ((sizes.length - i0)/sizes.length), "out", easing);
					for(i1 = Math.floor(draw.mouse.x - radius); i1 <= Math.ceil(draw.mouse.x + radius); i1++) {
						for(i2 = Math.floor(draw.mouse.y - radius); i2 <= Math.ceil(draw.mouse.y + radius); i2++) {
							if(
								(i1%(2*grid) === 0 && i2%(2*grid) === 0)
								||
								(i1%(2*grid) === grid && i2%(2*grid) === grid)
							) {
								temp = Math.hypot(i1 - draw.mouse.x, i2 - draw.mouse.y)/radius;
								if(temp <= 1) {
									circledraw(draw.ctx, i1, i2, sizes[i0], true);
								};
							}
						}
					}
				}
			},
		},
		{
			name: "wom wom wom",
			// this one's more of a toy than anything. i guess it'd be good for
			// drawing intestines. or poop.
			down: function(draw) {
				draw.mouse.strokedata = 0;
			},
			move: function(draw, inversion) {
				let ctx = draw.ctx;
				const numofangles = 24;//*4;
				// number of different box dimensions it draws before repeating
				// itself.
				const numofboxes = 1;//*4;
				// number of boxes it draws between this position and the last.
				let r = draw.paintsize/2;
				let dist = [
					draw.mouse.x - draw.mouse.oldx[0],
					draw.mouse.y - draw.mouse.oldy[0]
				];
				let i1 = 0;
				for(i1 = 1; i1 <= numofboxes; i1++) {
					pos = [
						draw.mouse.oldx[0] + dist[0]*i1/numofboxes,
						draw.mouse.oldy[0] + dist[1]*i1/numofboxes,
					];
					draw.mouse.strokedata++;
					draw.mouse.strokedata %= numofangles;
					if(i1 > 1 && draw.misc.rainbowmode) {
						draw.advancerainbow();
					}
					let anglenum = Math.PI*(
						inversion
						?
						Math.random()
						:
						(draw.mouse.strokedata/numofangles)
					);
					anglenum = [Math.cos(anglenum), Math.sin(anglenum)];
					let rect = [
						Math.floor(pos[0] - anglenum[0]*r),
						Math.floor(pos[1] - anglenum[1]*r),
						// x, y
						Math.floor(pos[0] + anglenum[0]*r),
						Math.floor(pos[1] + anglenum[1]*r)
						// x2, y2
					];
					rect[2] -= rect[0];
					rect[3] -= rect[1];
					// w, h
					ctx.fillRect(
						rect[0],
						rect[1],
						rect[2],
						draw.pensize
					);
					// top
					ctx.fillRect(
						rect[0] + rect[2],
						rect[1],
						draw.pensize,
						rect[3]
					);
					// right
					ctx.fillRect(
						rect[0] + draw.pensize,
						rect[1] + rect[3],
						rect[2],
						draw.pensize
					);
					// bottom
					ctx.fillRect(
						rect[0],
						rect[1] + draw.pensize,
						draw.pensize,
						rect[3]
					);
					// left
				}
			},
		},
		{
			name: "motion",
			move: function(draw) {
				let ctx = draw.ctx;
				const numofpatches = 2;
				// number of patches it draws between this position and the last.
				const linesperpatch = 1;
				const positionrange = draw.paintsize/2;
				// the amount it can stray from the line between this position
				// and the last.
				const condensefactor = 1;
				// for randexponent
				const linelength = draw.paintsize;
				let dist = [
					draw.mouse.x - draw.mouse.oldx[0],
					draw.mouse.y - draw.mouse.oldy[0]
				];
				let anglenum = get2dangle(...dist, true);
				if(anglenum === null) {
					return;
				};
				anglenum = [Math.cos(anglenum), Math.sin(anglenum)];
				let i1 = 0;
				let i2 = 0;
				for(i1 = 1; i1 <= numofpatches; i1++) {
					pos = [
						draw.mouse.oldx[0] + dist[0]*i1/numofpatches,
						draw.mouse.oldy[0] + dist[1]*i1/numofpatches,
					];
					if(i1 > 1 && draw.misc.rainbowmode) {
						draw.advancerainbow();
					};
					for(i2 = 0; i2 < linesperpatch; i2++) {
						let temp = [
							Math.random()*2*Math.PI,
							positionrange*randexponent(condensefactor)
						];
						temp = [
							pos[0] + temp[1]*Math.cos(temp[0]),
							pos[1] + temp[1]*Math.sin(temp[0])
						];
						let x1 = Math.floor(temp[0] - anglenum[0]*linelength/2);
						let y1 = Math.floor(temp[1] - anglenum[1]*linelength/2);
						let x2 = Math.floor(temp[0] + anglenum[0]*linelength/2);
						let y2 = Math.floor(temp[1] + anglenum[1]*linelength/2);
						nonaaline(ctx, x1, y1, x2, y2, draw.pensize);
					}
				}
			},
		}
		/*
		{
			name: "",
			move: function(draw) {
				//
			},
		}
		//*/
		//
		// - coiling line
		// - line that has a wavy thickness
		// - smear (every stroke it picks a few random positions in a
		//   circular area then sets that to be pasted on every mousemove)
		// - spray paint (da classic) (also just really good for coloring in
		//   general)
		//   - same smear shit applies
		// - denser spray paint
		//   - i'm not gonna bother with any pen settings besides width, but
		//     two versions should be enough options.
		//   - not sure if this will mean more dots or closer positions
		//     though.
		// - hollow
		//draw.ctx.lineexecute(x1, y1, x2, y2, weight, code, true);
	];
	draw.paint = [];
	// same thing, except paint functions work a little different.
	// - there's no down, move, or up functions, all there is is a name, which
	//   can be used in the dithers global object
	// - dithers have a function that either returns true or false.
	// - you can add a boolean property, "erases", to make false results draw in
	//   color2 instead of just not drawing anything.
	// - inversions don't work how they do for pens. the modifying stuff is done
	//   in the place whether .dither is run, not here. the boolean is inverted.
	// - for the sake of consistency and avoiding redundancy and shit like that,
	//   do not create dithers that are true for more than 50% of pixels.
	// - if there's a "period" property, x will be %ed by period.x and y will be
	//   %ed by period.y. this makes logic simpler, and makes it possible to
	//   calculate how much coverage there is
	//
	// neat combinations:
	// - pythagorean + 2x2 squared
	//   - has an interesting texture to it. creates these roundish 5-pixel
	//     formations in a tilted grid of repetitions
	//   - 59/80 pixels covered, and the area before it repeats is 20x20
	// - inverted pythagorean + inverted 3x3
	//   - tesselated plusses with dotted outlines
	// - inverted triangle + inverted 3x3
	//   - 23/24, 12x12
	//   - inverted triangle, but bigger and dotted
	// - inverted pinwheel + hardware
	//   - there's like an outer grid that's sorta chewed on, and an inner grid
	//     that looks formulaic and techy
	//   - 2/3, 12x12
	//   - resembles plaid
	// - inverted sand + sierpinski
	//   - makes it look less patterny
	//   - hard to even see where it repeats, really
	// - inverted sand + inverted sierpinski
	//   - 1279/1296, (~80/81) 72x72
	//   - doesn't look very patterny
	//   - you know how sometimes combining dithers creates like a grid where
	//     the first dither breaks, so it just looks like a bunch of clusters of
	//     dither in a grid formation? this is like that, except the clusters
	//     are positioned like sand's pixels are.
	// - inverted sand + hardware
	//   - creates a grid
	// - inverted sand + inverted hardware
	// - inverted sand + pythagorean
	//   - tilted grid, except not quite, the cells aren't squares
	// - inverted sand + inverted pythagorean
	//   - same thing
	// - houndstooth + inverted sierpinski
	// - houndstooth + inverted pythagorean
	// - houndstooth + inverted 2x2 dots
	// - houndstooth + inverted 3x3 dots
	draw.eraser = [];
	draw.eraser[draw.eraser.length] = {
		name: "basic",
		move: function(draw) {
			draw.ctx.lineexecute(draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.paintsize, function(context, x, y, weight) {
				context.fillRect(Math.floor(x - weight/2), Math.floor(y - weight/2), weight, weight);
			}, true);
		},
	};
	draw.initialize = function() {
	// does all the stuff that starts it up. except defining functions i guess.
	// - this doesn't have to be a function, but there was a problem i thought
	//   it'd solve, and i figure it's better to have everything neatly wrapped
	//   in one anyway.
		for (i1 in dithers) {
			if (dithers.hasOwnProperty(i1)) {
				draw.paint[draw.paint.length] = {
					name: i1,
				};
				//if(["noise .78125%", "noise 25%", "noise 50%"].includes(i1)) {
				if(dithers[i1].hasOwnProperty("erases") && dithers[i1].erases) {
					draw.paint[draw.paint.length - 1].erases = true;
				};
			}
		}
		let temp = [];
		temp[0] = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
		temp[1] = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
		// this should get the dimensions of the screen.
		if(temp[1] > temp[0]) {
			this.menuorientation = "vertical";
		}
		else {
			this.menuorientation = "horizontal";
		};
		document.write("<br><canvas id='draw_canvas' alt='canvas of a simple drawing app.' width=1 height=1></canvas>");
		// dimensions will be set by .createbuttons
		this.ctx = document.getElementById("draw_canvas").getContext("2d");
		//this.ctx.save();
		// this saves the clip data, so i can restore() it back to being able to
		// draw anywhere.
		// - not that i can find for the life of me *where* it's stored. mdn won't
		//   give up shit.
		let lightest = [null, null];
		let darkest = [null, null];
		// lightness value, and index
		for(i1 = 0; i1 < 16; i1++) {
			let array = [
				Math.floor(Math.random()*360),
				Math.floor(Math.random()*100)
			];
			if(i1 === 0) {
				array[2] = Math.floor((1 - randexponent(3))*100);
				// a mostly white color
			}
			else if(i1 === 1) {
				array[2] = Math.floor(randexponent(3)*100);
				// a mostly black color
			}
			else {
				array[2] = Math.floor((.5 + randexponent(3, true)/2)*100);
			};
			if(lightest[0] === null || array[2] > lightest[0]) {
				lightest = [array[2], i1];
			};
			if(darkest[0] === null || array[2] < darkest[0]) {
				darkest = [array[2], i1];
			};
			array[1] += "%";
			array[2] += "%";
			this.colors[i1] = "hsl(" + array.join(", ") + ")";
			// random colors, bimches.
		}
		temp = [
			lightest[1],
			darkest[1]
		];
		// only the indexes matter
		lightest = this.colors[temp[0]];
		darkest = this.colors[temp[1]];
		this.colors.splice(temp[0], 1);
		this.colors.splice(temp[1], 1);
		this.colors.splice(0, 0, darkest);
		this.colors.splice(0, 0, lightest);
		// put the lightest and darkest at the beginning
		this.createrainbow();
		/*
		for(i1 = 0; i1 < this.mouse.numofpositions; i1++) {
			this.mouse.oldx[i1] = null;
			this.mouse.oldy[i1] = null;
		}
		//*/
		this.createbuttons();
		this.ctx.canvas.style["image-rendering"] = "crisp-edges";
		// there we go bitches. only took way way way too long for me to learn
		// there was a way to turn that off...
		this.drawbuttons();
		this.ctx.fillStyle = this.colors[this.color2];
		this.ctx.fillRect(this.drawingarea.x, this.drawingarea.y, this.drawingarea.w, this.drawingarea.h);
		// untransparent it
		this.undodata.splice(this.undoindex, 0, this.ctx.getImageData(this.drawingarea.x, this.drawingarea.y, this.drawingarea.w, this.drawingarea.h));
		// if you don't do this, it won't have data to recall when trying to undo
		// the first action.
		// - NOTE if you're tearing your hair out wondering what firefox's
		//   fucking problem is... i don't have an answer for you, but i do know
		//   this is only seen as a problem because of the drawImage command in
		//   drawbuttons. that's what causes this error.
		// - my best, very vague guess is...
		//   - to draw an image, you first have to create a new Image Object or
		//     whatever, right?
		//   - i think maybe it's getting anxious about this being somewhat sort
		//     of somewhat close to a hacker being able to hijack the asset
		//     images, modify them somehow?
		//   - it doesn't like that i'm using getImageData after i do that
		//     because somehow,
		this.ctx.font = "16px 'fomp2'";
		//this.colorselectgraphic();
		this.subtooltext();
		this.ready();
	};
	draw.createrainbow = function() {
	// creates draw.misc.rainbow, an array of numbers that, when used as
	// draw.colors indexes, will give you the colors in order of hue.
	// - this should be run every time the palette changes.
		this.misc.rainbow = [];
		let temp = null;
		let minsaturation = 25;
		for(i1 = 0; i1 < this.colors.length; i1++) {
			temp = gethsv(this.colors[i1], this.ctx);
			if(temp[1] >= minsaturation) {
				this.misc.rainbow[this.misc.rainbow.length] = {
					index: i1,
					hue: temp[0],
				};
			};
		}
		function huesort(a, b) {
			return a.hue - b.hue;
		};
		this.misc.rainbow.sort(huesort);
		for(i1 = 0; i1 < this.misc.rainbow.length; i1++) {
			this.misc.rainbow[i1] = this.misc.rainbow[i1].index;
		}
		// use draw.mouse.oldx.length%draw.misc.rainbow.length as an index,
		// and this will give you an order of draw.colors indexes that
		// creates a rainbow.
	};
	draw.advancerainbow = function() {
		//draw.color1 = draw.misc.rainbow[draw.mouse.oldx.length%draw.misc.rainbow.length];
		this.misc.rainbowindex++;
		this.misc.rainbowindex %= this.misc.rainbow.length;
		this.color1 = this.misc.rainbow[this.misc.rainbowindex];
		this.ctx.strokeStyle = this.colors[this.color1];
		this.ctx.fillStyle = this.colors[this.color1];
	};
	function symboldrawing(ctx, name, offset, size, color) {
	// draws various icons used in graphics.
	// - actually i drew them in aseprite first but as it turns out, those can't
	//   be used unless the html is on an actual server. because of "same origin
	//   policy", which protects me from the dangers of using a file on my
	//   computer with another file on my computer.
	//   - *scuttle scuttle scuttle* ...did you hear that? *scuttle scuttle
	//     scuttle* it sounds like it's coming from... the ceiling-- *the tiles
	//     give out under the weight of a stream of programming redditors
	//     explaining why this makes perfect sense actually and i'm the one
	//     being unreasonable*
	//     - if a tool feels stupid, convoluted, and nonsensical to the person
	//       using it, it's a bad tool.
	// - NOTE don't use the pen, erase, or paint. those were written back when
	//   this system was astoundingly shitty
		let i1 = 0;
		let i2 = 0;
		offset ??= [0, 0];
		function drawshape(shape, strokeorfill, etc) {
			if(strokeorfill !== "stroke") {
				_2dPoly.draw(ctx, shape, "fill", false, offset, etc);
			};
			if(["stroke", "both"].includes(strokeorfill)) {
				_2dPoly.draw(ctx, shape, "stroke", false, [offset[0] - 0, offset[1] - 0], etc);
				_2dPoly.draw(ctx, shape, "stroke", false, [offset[0] - 1, offset[1] - 0], etc);
				_2dPoly.draw(ctx, shape, "stroke", false, [offset[0] - 0, offset[1] - 1], etc);
				_2dPoly.draw(ctx, shape, "stroke", false, [offset[0] - 1, offset[1] - 1], etc);
			};
		}
		function drawline(x1, y1, x2, y2) {
			let styletemp = ctx.fillStyle;
			ctx.fillStyle = ctx.strokeStyle;
			if(offset) {
				x1 += offset[0];
				y1 += offset[1];
				x2 += offset[0];
				y2 += offset[1];
			}
			ctx.lineexecute(x1, y1, x2, y2, false, function(ctx, x, y, weight) {
				ctx.fillRect(x - 1, y - 1, 2, 2);
			});
			ctx.fillStyle = styletemp;
		}
		function convertpoints(multiply) {
			//let styletemp = ctx.fillStyle;
			//ctx.fillStyle = "orange";
			let i1 = 0;
			let i2 = 0;
			multiply ??= 1;
			for (i1 in points) {
				if (points.hasOwnProperty(i1)) {
					for(i2 = 0; i2 < points[i1].length; i2++) {
						points[i1][i2] = {
							x: multiply*points[i1][i2][0],
							y: multiply*points[i1][i2][1],
						};
						//ctx.fillRect(points[i1][i2].x - 2, points[i1][i2].y - 2, 4, 4);
					}
				};
			}
			//ctx.fillStyle = styletemp;
		}
		color ??= ["black", "white", "gray"];
		let multiply = 1;
		if(["pen", "paint", "eraser"].includes(name)) {
			color = [
				"#2f2f5f",
				"white",
				"#63639f"
			];
			multiply = 4;
			ctx.fillStyle = color[0];
			ctx.fillRect(offset[0], offset[1], multiply*24, multiply*24);
		};
		let points = {};
		if(name === "pen") {
			points.top = [
				[16, 16],
				[17, 16],
				[22, 11],
				[22, 8],
				[16, 2]
			];
			points.side = [
				structuredClone(points.top[points.top.length - 1]),
				[7, 11],
				[7, 13],
				[3, 15],
				[2, 22]
			];
			points.slot = [
				structuredClone(points.side[points.side.length - 1]),
				[6, 18]
			]
			convertpoints(multiply);
			points.side[2].elbow = {x: multiply*6, y: multiply*15};
			points.side[3].elbow = {direction: "d"};
			ctx.strokeStyle = color[2];
			ctx.fillStyle = color[1];
			let shape = new Shape2d(points.top).path;
			drawshape(shape, "stroke", "skiplaststroke");
			// from the end of the clip to the top
			shape = new Shape2d(points.side).path;
			drawshape(shape, "stroke", "skiplaststroke");
			// top to tip
			let mirror = (coor) => [multiply*24 - coor[1], multiply*24 - coor[0]];
			let diagonals = [];
			for(i1 = 0; i1 < 3; i1++) {
				let ref = points.side[i1];
				let temp = [ref.x, ref.y];
				if(i1 === 0) {
					temp[0] += -1*multiply;
					temp[1] += 1*multiply;
				};
				diagonals[i1] = temp.concat(mirror(temp));
			};
			drawshape([
				diagonals[0].slice(0, 2),
				diagonals[0].slice(2, 4),
				diagonals[1].slice(2, 4),
				diagonals[1].slice(0, 2),
			], "fill");
			for(i1 = 0; i1 < shape.length; i1++) {
				shape[i1] = mirror(shape[i1]);
			}
			drawshape(shape, "stroke", "skiplaststroke");
			// other side
			for(i1 = 0; i1 < diagonals.length; i1++) {
				drawline(...diagonals[i1]);
			}
			// diagonal lines
			let temp = [points.slot[0].x, points.slot[0].y, points.slot[1].x, points.slot[1].y];
			drawline(...temp);
			ctx.fillStyle = color[2];
			circledraw(ctx, points.slot[1].x, points.slot[1].y, multiply + 1, true);
			//paintbucket(ctx, offset[0] + 48, offset[1] + 48);
		}
		else if(name === "pencil") {
			size ??= 24;
			let points = {
				top: [
					[7, 0],
					[7 + 1.5, 0 + 1.5],
					[7 + 3.5, 0 + 3.5],
					[7 + 5, 0 + 5]
				],
				edge: [],
				// edge where the sharpened part meets the unsharpened part
				graphite: [
					[9.5, 0],
					[12, 2.5]
				],
				tip: [[0, 12]],
			};
			for(i1 = 0; i1 < points.top.length; i1++) {
				points.edge[i1] = [
					points.top[i1][0] - 7,
					points.top[i1][1] + 7
				];
			};
			convertpoints(size/12);
			let temp = [
				structuredClone(points.top[0]),
				structuredClone(points.top[ points.top.length - 1 ]),
				structuredClone(points.edge[0]),
				structuredClone(points.edge[ points.edge.length - 1 ]),
			];
			ctx.fillStyle = color[0];
			_2dPoly.draw(ctx, temp, "fill", false, offset);
			for(i1 = 1; i1 < points.top.length - 1; i1++) {
				ctx.strokeStyle = color[1];
				let coor = [
					offset[0] + points.top[i1][0], offset[1] + points.top[i1][1],
					offset[0] + points.edge[i1][0], offset[1] + points.edge[i1][1]
				];
				nonaaline(ctx, ...coor);
				ctx.fillStyle = color[0];
				ctx.fillRect(...coor.slice(0, 2), 1, 1);
				ctx.fillRect(...coor.slice(2, 4), 1, 1);
			};
			temp = [
				structuredClone(points.graphite[0]),
				structuredClone(points.graphite[1]),
				structuredClone(points.tip[0])
			];
			_2dPoly.draw(ctx, temp, "fill", false, offset);
			temp = [
				structuredClone(points.edge[0]),
				structuredClone(points.edge[ points.edge.length - 1 ]),
				structuredClone(points.tip[0])
			];
			ctx.strokeStyle = color[0];
			_2dPoly.draw(ctx, temp, "stroke", false, offset);
		}
	}
	draw.initialize();
	draw.mousedown = function(e) {
		//changefocus("draw");
		//console.log(e);
		draw.setmousecoor(e);
		//console.log([userfocus, draw.mouse.x, draw.mouse.y]);
		let i1 = 0;
		if(!withinrect(draw.mouse.x, draw.mouse.y, draw.drawingarea)) {
		// the user clicked outside the drawing area
			draw.mouse.clicktype = "ui";
			draw.buttonaction(e);
		}
		else {
			draw.mouse.clicktype = "drawing";
			if(["pen", "paint"].includes(draw.mouse.tool) && draw.misc.rainbowmode) {
			// rainbow mode
				draw.advancerainbow();
			};
			if(draw[draw.mouse.tool][draw.mouse.subtool[draw.mouse.tool]].hasOwnProperty("down")) {
				draw[draw.mouse.tool][draw.mouse.subtool[draw.mouse.tool]].down(draw, draw.mouse.inversion[draw.mouse.tool]);
			};
			// set strokedata
		};
		draw.ready();
		draw.mousemove(e);
	};
	draw.mousemove = function(e) {
		if(draw.mouse.clicktype !== "drawing") {
			return;
		};
		draw.setmousecoor(e);
		let temp = [];
		let i1 = 0;
		let i2 = 0;
		if(["pen", "paint"].includes(draw.mouse.tool) && draw.misc.rainbowmode) {
		// rainbow time.
			draw.advancerainbow();
		};
		draw.ready(true);
		if(draw.mouse.tool === "pen") {
			if(draw.pen[draw.mouse.subtool.pen].hasOwnProperty("move")) {
				draw.pen[draw.mouse.subtool.pen].move(draw, draw.mouse.inversion[draw.mouse.tool]);
			};
		}
		else if(draw.mouse.tool === "paint") {
			if(dithers.hasOwnProperty(draw.paint[draw.mouse.subtool.paint].name)) {
			// used to be
			// "draw.paint[draw.mouse.subtool.paint].hasOwnProperty("dither")",
			// but for
				draw.ctx.lineexecute(draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.paintsize, function(context, x, y, weight) {
					let i1 = 0;
					let i2 = 0;
					let temp = "";
					for(i1 = Math.floor(x - weight/2); i1 < Math.floor(x - weight/2) + weight; i1++) {
						for(i2 = Math.floor(y - weight/2); i2 < Math.floor(y - weight/2) + weight; i2++) {
							temp = dither_interpreter(draw.paint[draw.mouse.subtool.paint].name, i1, i2, draw.mouse.inversion[draw.mouse.tool]);
							// this will either return true, or false.
							// - for dithers, inversion reverses the true/false
							//   outcome. "inversion" is a more fitting term for
							//   these than it is for alternate versions of a
							//   brush
							if(temp) {
								context.fillRect(i1, i2, 1, 1);
							}
							else if(draw.paint[draw.mouse.subtool.paint].hasOwnProperty("erases") && draw.paint[draw.mouse.subtool.paint].erases) {
							// the erases property makes it so it erases instead
							// of just not doing anything
								context.fillStyle = draw.colors[draw.color2];
								context.fillRect(i1, i2, 1, 1);
								context.fillStyle = draw.colors[draw.color1];
							};
						}
					}
				}, true);
			}
			else {
				console.log("i made a new kind of dither and forgot to make draw.mousemove accommodate it.");
			};
		}
		else if(draw.mouse.tool === "eraser") {
			if(draw.eraser[draw.mouse.subtool.eraser].hasOwnProperty("move")) {
				draw.eraser[draw.mouse.subtool.eraser].move(draw, draw.mouse.inversion[draw.mouse.tool]);
			};
		}
		else {
			console.log("this shouldn't happen");
		};
	};
	draw.mouseup = function(e) {
		draw.setmousecoor(e);
		if(draw.mouse.clicktype === "drawing") {
			if(draw[draw.mouse.tool][draw.mouse.subtool[draw.mouse.tool]].hasOwnProperty("up")) {
				draw[draw.mouse.tool][draw.mouse.subtool[draw.mouse.tool]].up(draw, draw.mouse.inversion[draw.mouse.tool]);
			};
			//console.log("undoindex (before changes): " + draw.undoindex);
			draw.undodata.splice(draw.undoindex, 0, draw.ctx.getImageData(draw.drawingarea.x, draw.drawingarea.y, draw.drawingarea.w, draw.drawingarea.h));
			draw.undodata = structuredClone(draw.undodata.slice(0, draw.maxundos));
			// trim away anything past .maxundos
			draw.undodata.splice(0, draw.undoindex);
			// if undoindex is higher than zero, (ie the user had done some
			// undos before this) delete everything more recent
			draw.undoindex = 0;
			//console.log("undoindex (after changes): " + draw.undoindex);
		};
		draw.mouse.clicktype = "none";
	};
	//document.getElementById("draw_canvas").addEventListener("mousedown", draw.mousedown);
	//document.getElementById("draw_canvas").addEventListener("mousemove", draw.mousemove);
	//document.getElementById("draw_canvas").addEventListener("mouseup", draw.mouseup);
	document.getElementById("draw_canvas").addEventListener("pointerdown", draw.mousedown);
	document.getElementById("draw_canvas").addEventListener("pointermove", draw.mousemove);
	document.getElementById("draw_canvas").addEventListener("pointerup", draw.mouseup);
	document.getElementById("draw_canvas").addEventListener("pointerleave", draw.mouseup);
	document.getElementById("draw_canvas").style["touch-action"] = "none";
	// drawing tablet compatibility, (probably) phone compatibility.
	// - pointer events are a more broad event that can apply to tablets and
	//   touch. apparently mouse events are incompatible. (they can still
	//   trigger click events though?)
	//   - i'm confused how this works. when i have nothing but mouse events on,
	//     i can still make dots with the tablet... i assumed that was because
	//     only mousedown was compatible, but replacing pointerdown with that
	//     doesn't work.
	// - touch-action is a css property that determines what touching it with a
	//   finger or tablet does... that is, most of the time it just scrolls, but
	//   you can disable that with this.
	// - hopefully this works on mobile. guess i'll just have to wait and see.
	class App {
	// a class for creating a basic canvas app, with clickable areas and stuff.
	// - NOTE: draw is NOT one of these. the structure is similar because draw
	//   was the prototype.
		constructor() {
			this.prefix = "";
			// this is used for html element ids and shit like that
			this.clickarea = "none";
			// stores whether it clicked on the ui, the active area, the
			// mobile canvas, or none
			this.undodata = [];
			// stores data to be restored with undo/redo.
			// - NOTE: lower indexes are more recent. every new imagedata is put at
			//   the beginning.
			this.undoindex = 0;
			this.maxundos = 20;
			// setting for how many imagedatas it should be allowed to hold, how
			// many actions it can undo.
			this.uicolor = ["black", "white"];
			this.font = "16px 'fomp2'";
			this.buttons = {};
			this.page = 0;
			this.savechange = false;
			// this is turned off at the start of a click or key press, and
			// turned on if the action the user took happens to be one that
			// actually edits things. (for example, a drawing app would turn
			// it on in mousedown if the user clicked on the canvas.)
			this.misc = {};
			// place for storing misc data.
			/*
			this = {
				prefix: "",
				clickarea: "none",
				undodata: [],
				undoindex: 0,
				maxundos: 20,
				uicolor: ["black", "white"],
				font: "16px 'fomp2'",
				buttons: {},
				savechange: false,
				misc: {},
			};
			//*/
		}
		appinitA(prefix, canvases, uicolor) {
		// does all the stuff that starts it up. creates the div and canvases,
		// sets dimensions and colors, fills the canvases, creates event
		// listeners. this does NOT run createbuttons and drawbuttons.
		// - prefix: this should be the same string as the main app object.
		//   this.prefix gets set as that, and it's used for html element ids
		//   and crap like that
		// - canvases: an object.
		//   - for each property, it creates a canvas with the same name, and
		//     the w/h specified.
		//   - if there's no properties but w and h, it'll just create one
		//     canvas called "main".
		// - uicolor: array of colors that uicolor will be defined as.
		//   - really this is just a reminder to actually change it. just like
		//     prefix.
		//   - this can be an object instead of an array. but do create a "0"
		//     and "1" color, those are the default colors for outlines and
		//     non-outlines
		// - i wanna save the word "initialize" for stuff specific to each
		//   function.
		// - this is to be paired with appinitB, which is run at the end of your
		//   initialize. (it saves data to undodata, after all. that should be
		//   probably be done after you set things up.)
			this.prefix = prefix;
			document.write("<br><div id='" + this.prefix + "_area'></div>");
			this.div = document.getElementById(this.prefix + "_area");
			// so that the innerHTML can be accessed easily...
			if(uicolor) {
				this.uicolor = structuredClone(uicolor);
			};
			this.ctx = {};
			// ctx stores multiple contexts, all named. whenever a function
			// edits one, you should probably use an object reference variable
			// so you don't have to type all this out.
			//
			if(typeof canvases !== "object") {
				console.log("invalid canvases input.");
			};
			if(compareobject(Object.keys(canvases), ["w", "h"])) {
				let i1 = "main";
				this.div.innerHTML += "<canvas id='" + this.prefix + "_" + i1 + "canvas' width=" + canvases.w + " height=" + canvases.h + "></canvas>";
				this.ctx[i1] = document.getElementById(this.prefix + "_" + i1 + "canvas").getContext("2d");
			}
			else {
				let i1 = "";
				for (i1 in canvases) {
					if (canvases.hasOwnProperty(i1) && canvases[i1].hasOwnProperty("w") && canvases[i1].hasOwnProperty("h")) {
						this.div.innerHTML += "<br><canvas id='" + this.prefix + "_" + i1 + "canvas' width=" + canvases[i1].w + " height=" + canvases[i1].h + "></canvas>";
						this.ctx[i1] = document.getElementById(this.prefix + "_" + i1 + "canvas").getContext("2d");
					};
				}
				if(this.div.innerHTML.slice(0, "<br>".length) === "<br>") {
					this.div.innerHTML = this.div.innerHTML.slice("<br>".length);
				};
			};
			if(compareobject(this.ctx, {})) {
				console.log("invalid canvases input.");
			};
			function eventlisteners(ctx, app) {
				ctx.canvas.addEventListener("pointerdown", app.mousedown);
				ctx.canvas.addEventListener("pointermove", app.mousemove);
				ctx.canvas.addEventListener("pointerup", app.mouseup);
				ctx.canvas.addEventListener("pointerleave", app.mouseup);
				ctx.canvas.style["touch-action"] = "none";
				// event listeners compatible with drawing tablets and phones.
			};
			this.resetstyle();
			let i1 = "";
			for (i1 in this.ctx) {
				if(this.ctx.hasOwnProperty(i1)) {
					let ctx = this.ctx[i1];
					ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
					// untransparent it
					//ctx.canvas.style["image-rendering"] = "crisp-edges";
					// my personal preference...
					//eventlisteners(ctx, this);
					// this has to be done in a function because using "this" in an
					// event listener just gives you... the event, i think? or the
					// target?
				}
			}
			/*
			document.addEventListener("keydown", new Function("e", `
				if(userfocus === "` + this.prefix + `") {
					` + this.prefix + `.buttonaction(e, true);
				};
			`);
			//*/
			// haha yeah i'm not risking that
			// - i don't know shit about security risks but this isn't far from
			//   eval
			// - also this is less efficient than a normal anonymous function,
			//   not that i know shit about why
		}
		appinitB(saveddata) {
			this.undodata.splice(this.undoindex, 0, structuredClone(saveddata));
			// if you don't do this, it won't have data to recall when trying to
			// undo the first action.
			this.setgraphics();
		}
		resetstyle() {
		// resets all three canvases so that black is the stroke color, white is
		// the fill color, and this.font is the font.
			let i1 = "";
			for (i1 in this.ctx) {
				if(this.ctx.hasOwnProperty(i1)) {
					this.ctx[i1].fillStyle = this.uicolor[1];
					this.ctx[i1].strokeStyle = this.uicolor[0];
					this.ctx[i1].font = this.font;
				};
			}
		}
		drawbuttons(noimage, extracode) {
		// draws the buttons.
		// - any buttons without images, it'll draw the outline instead.
		// - noimage: if true, it'll skip the drawImage(). you might need this,
		//   sometimes drawImage causes domexception errors on every use of
		//   getImageData because of "same-origin policy". look it up.
		// - extracode: function it runs at the end.
		//   - for example, if you want to draw palette buttons, drawbuttons
		//     will not fill each button in its color, but you could do that by
		//     adding .hide to all of them and having extracode do that.
			let i0 = "";
			let i1 = "";
			let i2 = "";
			this.resetstyle();
			let center = [null, null];
			if(!compareobject(Object.keys(this.buttons), Object.keys(this.ctx))) {
				console.log("the property names of .buttons and .ctx don't match. that shouldn't happen");
			};
			for (i0 in this.buttons) {
			// this.buttons is divided up by canvas
				if(this.buttons.hasOwnProperty(i0)) {
					for (i1 in this.buttons[i0]) {
						if (
							this.buttons[i0].hasOwnProperty(i1)
							&&
							(
								!this.buttons[i0][i1].hasOwnProperty("hide")
								||
								!this.buttons[i0][i1].hide
							)
							&&
							(
								!this.buttons[i0][i1].hasOwnProperty("condition")
								||
								this.buttons[i0][i1].condition(this)
							)
						) {
							if(!noimage && this.buttons[i0][i1].hasOwnProperty("image")) {
								//*
								this.ctx[i0].drawImage(
									this.buttons[i0][i1].image.file,
									this.buttons[i0][i1].image.sx,
									this.buttons[i0][i1].image.sy,
									this.buttons[i0][i1].image.sw,
									this.buttons[i0][i1].image.sh,
									this.buttons[i0][i1].x,
									this.buttons[i0][i1].y,
									this.buttons[i0][i1].w,
									this.buttons[i0][i1].h
								);
								//*/
							}
							else if(this.buttons[i0][i1].hasOwnProperty("split")) {
								/*
								center = fourpointintersect(
									this.buttons[i0][i1].x, this.buttons[i0][i1].y,
									this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y + this.buttons[i0][i1].h,
									this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y,
									this.buttons[i0][i1].x, this.buttons[i0][i1].y + this.buttons[i0][i1].h,
								);
								if(this.buttons[i0][i1].split.includes("up")) {
									_2dPoly.draw(this.ctx[i0], [
										[this.buttons[i0][i1].x, this.buttons[i0][i1].y],
										[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y],
										center
									], "stroke");
								};
								if(this.buttons[i0][i1].split.includes("down")) {
									_2dPoly.draw(this.ctx[i0], [
										[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y + this.buttons[i0][i1].h],
										[this.buttons[i0][i1].x, this.buttons[i0][i1].y + this.buttons[i0][i1].h],
										center
										], "stroke"
									);
								};
								if(this.buttons[i0][i1].split.includes("left")) {
									_2dPoly.draw(this.ctx[i0], [
									[this.buttons[i0][i1].x, this.buttons[i0][i1].y + this.buttons[i0][i1].h],
									[this.buttons[i0][i1].x, this.buttons[i0][i1].y],
									center
									], "stroke");
								};
								if(this.buttons[i0][i1].split.includes("right")) {
									_2dPoly.draw(this.ctx[i0], [
									[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y],
									[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y + this.buttons[i0][i1].h],
									center
									], "stroke");
								};
								//*/
								//*
								if(this.buttons[i0][i1].split.includes("up")) {
									this.ctx[i0].strokeRect(this.buttons[i0][i1].x - .5, this.buttons[i0][i1].y - .5, this.buttons[i0][i1].w + 1, 1);
								};
								if(this.buttons[i0][i1].split.includes("down")) {
									this.ctx[i0].strokeRect(this.buttons[i0][i1].x + .5, this.buttons[i0][i1].y + this.buttons[i0][i1].h - .5, this.buttons[i0][i1].w + 1, 1);
								};
								if(this.buttons[i0][i1].split.includes("left")) {
									this.ctx[i0].strokeRect(this.buttons[i0][i1].x - .5, this.buttons[i0][i1].y - .5, 1, this.buttons[i0][i1].h + 1);
								};
								if(this.buttons[i0][i1].split.includes("right")) {
									this.ctx[i0].strokeRect(this.buttons[i0][i1].x + this.buttons[i0][i1].w - .5, this.buttons[i0][i1].y - .5, 1, this.buttons[i0][i1].h + 1);
								};
								//*/
							}
							else {
								_2dPoly.draw(this.ctx[i0], [
									[this.buttons[i0][i1].x, this.buttons[i0][i1].y],
									[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y],
									[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y + this.buttons[i0][i1].h],
									[this.buttons[i0][i1].x, this.buttons[i0][i1].y + this.buttons[i0][i1].h]
								], "stroke");
							};
						}; // i1 if
					} // i1
				}; // i0 if
			} // i0
			if(extracode) {
				extracode();
			};
		}
		keycheck(keyboardevent) {
		// checks if the key you pressed is associated with a button, and
		// returns the name and object, in an array.
			let i0 = "";
			let i1 = "";
			let i2 = 0;
			let temp1 = 0;
			let temp2 = [];
			let buttonkey = "";
			let ctrl = false;
			let shift = false;
			// stores which key the button wants, and whether ctrl and/or shift
			// are needed
			//
			let key = keyboardevent.key;
			if(key.length === 1 && key.charCodeAt(0) >= 65 && key.charCodeAt(0) < 91) {
				key = key.toLowerCase();
			};
			// if it's a capital letter, make it lowercase. (whether is is or isn't
			// capital doesn't matter, e.shiftKey is the only thing that could be
			// relevant.)
			for (i0 in this.buttons) {
			// search every canvas
				if(this.buttons.hasOwnProperty(i0)) {
					for (i1 in this.buttons[i0]) {
						if (
							this.buttons[i0].hasOwnProperty(i1)
							&&
							this.buttons[i0][i1].hasOwnProperty("key")
						) {
							buttonkey = this.buttons[i0][i1].key;
							ctrl = false;
							shift = false;
							if(buttonkey.includes("ctrl + ")) {
								buttonkey = buttonkey.replaceAll("ctrl + ", "");
								ctrl = true;
							};
							if(buttonkey.includes("shift + ")) {
								buttonkey = buttonkey.replaceAll("shift + ", "");
								shift = true;
							};
							if(
								key === buttonkey
								&&
								keyboardevent.ctrlKey === ctrl
								&&
								keyboardevent.shiftKey === shift
								&&
								(
									!this.buttons[i0][i1].hasOwnProperty("keycondition")
									||
									this.buttons[i0][i1].keycondition(this)
								)
							) {
								// if the key pressed and the ctrl/shift usage match,
								// and there's no keycondition or the keycondition is
								// fulfilled, register it.
								return [i1, this.buttons[i0][i1]];
							};
						};
					} // i1

				}; // i0 if
			} // i0
			return ["none", {}];
		}
		mousecheck(mouseevent) {
		// checks if the place you clicked is a button, and returns the name and
		// object, in an array.
			let mouse = clickxy(mouseevent, this.prefix);
			mouse = {
				x: mouse[0],
				y: mouse[1],
			};
			let i1 = "";
			let i2 = 0;
			let temp1 = 0;
			let temp2 = [];
			let canvas = "";
			// the string for the ctx of the canvas you clicked on
			for (i1 in this.ctx) {
				if(this.ctx.hasOwnProperty(i1) && e.target === this.ctx[i1].canvas) {
					canvas = i1;
				}
			}
			for (i1 in this.buttons[canvas]) {
				if (
					this.buttons[canvas].hasOwnProperty(i1)
					&&
					withinrect(mouse.x, mouse.y, this.buttons[canvas][i1])
				) {
				// the click is within this button.
					if(this.buttons[canvas][i1].hasOwnProperty("split")) {
						temp1 = fourpointintersect(
							this.buttons[canvas][i1].x, this.buttons[canvas][i1].y,
							this.buttons[canvas][i1].x + this.buttons[canvas][i1].w, this.buttons[canvas][i1].y + this.buttons[canvas][i1].h,
							this.buttons[canvas][i1].x + this.buttons[canvas][i1].w, this.buttons[canvas][i1].y,
							this.buttons[canvas][i1].x, this.buttons[canvas][i1].y + this.buttons[canvas][i1].h,
						);
						temp1 = get2dangle(mouse.x - temp1[0], mouse.y - temp1[1], true);
						// angle relative to center of button
						if(temp1 === null) {
							// click is right in the center
							return [i1, this.buttons[canvas][i1]];
						}
						else {
							temp1 /= 2*Math.PI;
							temp1 = (temp1 + 1/8)%1;
							// now it's a measure of circumferences. (and shifted 1/8 so
							// it's easier to work with.)
							temp2 = ["right", "down", "left", "up"];
							for(i2 = 0; i2 < temp2.length; i2++) {
								if(
									this.buttons[canvas][i1].split.includes(temp2[i2])
									&&
									temp1 >= i2/4
									&&
									temp1 < (i2 + 1)/4
									&&
									(
										!this.buttons[canvas][i1].hasOwnProperty("condition")
										||
										this.buttons[canvas][i1].condition(this)
									)
								) {
									return [i1, this.buttons[canvas][i1]];
								};
							}
						};
					}
					else if (
						!this.buttons[canvas][i1].hasOwnProperty("condition")
						||
						this.buttons[canvas][i1].condition(this)
					) {
						return [i1, this.buttons[canvas][i1]];
					};
				};
			}
			return ["none", {}];
		}
		undo() {
			if(this.undoindex + 1 < this.undodata.length) {
				this.undoindex += 1;
				this.putundodata(this.undodata[this.undoindex]);
			};
		}
		redo() {
			if(this.undoindex > 0) {
				this.undoindex -= 1;
				this.putundodata(this.undodata[this.undoindex]);
			};
		}
		saveundodata() {
		// saves undodata. should be run at mouseup and keyup.
			if(this.savechange) {
				this.undodata.splice(this.undoindex, 0, structuredClone(saveddata));
				// use whatever you use as saveddata parameter in appinitB.
				this.undodata = structuredClone(this.undodata.slice(0, this.maxundos));
				// trim away anything past .maxundos
				this.undodata.splice(0, this.undoindex);
				// if undoindex is higher than zero, (ie the user had done some
				// undos before this) delete everything more recent
				this.undoindex = 0;
			};
		}
		clearclip() {
		// clears the clip region for every canvas context.
			let i1 = "";
			let i2 = "";
			let canvastemp = {};
			let imagetemp = null;
			for (i1 in this.ctx) {
				if(this.ctx.hasOwnProperty(i1)) {
					//
					canvastemp = {};
					for (i2 in this.ctx[i1]) {
						if (["string", "number", "boolean"].includes(typeof this.ctx[i1][i2])) {
							// forgoing "this.ctx.hasOwnProperty(i1)" because things specific to
							// it being a canvas context (ie fillStyle, shit like that. what i'm
							// trying to save.) don't count
							canvastemp[i2] = this.ctx[i1][i2];
						};
					}
					// saves all the simple data, avoids stuff like the object references
					// and class methods. font, fillStyle, strokeStyle, etc
					imagetemp = this.ctx[i1].getImageData(0, 0, this.ctx[i1].canvas.width, this.ctx[i1].canvas.height);
					// .reset() also clears the image, so you gotta save that
					this.ctx[i1].reset();
					console.log("reset");
					// clear clip
					for (i2 in canvastemp) {
						if (canvastemp.hasOwnProperty(i2)) {
							this.ctx[i1][i2] = canvastemp[i2];
						};
					}
					// restore the simple data
					this.ctx[i1].putImageData(imagetemp, 0, 0);
					// restore the image
					//
				}
			}
		}
		// TODO
		// - areas
		//   - i'm getting rid of activearea, but a system like it should exist.
		//     a system like buttons. a rectangle area it defines, and that
		//     clickarea detects.
		//   - clickarea will be the canvas name if no areas were clicked, and
		//     the area name if one was
		//   - just like buttons, area is split up by canvas
		// - add and implement mobilecanvas by default
		//   - gonna add booleans to the constructor for "ctrlbutton" and
		//     "shiftbutton"
		//   - keycheck does not check these. these buttons exist in the first
		//     place because the user presumably doesn't have access to a
		//     keyboard.
		//   - ctrl and shift are used for button shortcuts, but that's entirely
		//     different from how this is used. these are "action modifiers".
		//   - actually in that case i should just divorce it from ctrl/shift
		//     entirely.
		// - troubleshoot. the canvases aren't filled even though they should
		//   be.
		// - make it so .save is part of things.
		//   - not just an easy thing to set up
		//   - add import/export tools using JSON.stringify and JSON.parse
		//     (NOTE: that means functions can't be used in .save unless i set
		//     up toString and use the function constructor)
		// - done
		//   - add keyboard event listener
		//   - doublecheck that the canvas event listeners don't disappear once
		//     appinitA ends
		//     - i did a test. yeah, they stick around after the function that
		//       made them ends.
		//   - convert checkbutton and buttonaction
		//   - make it so buttons are separated by area.
		//     - there's pages AND areas. that's pretty annoying.
		//     - my current page system also only allows one set of pages...
		//     - i guess that's gonna need to get restructured.
		//     - the thing is, here's what makes the most sense to me, what seems
		//       the most versatile...
		//       - canvases
		//         - page groups
		//           - pages
		//             - buttons
		//               - properties
		//     - i assume you can tell why that's a hell no? that'd be so damn
		//       convoluted dude
		//     - i think i got it. instead of pages there are conditions.
		//       - buttons can have a boolean function that it uses to check
		//         this.page or whatever
		//       - a separate property called keycondition is used in keycheck
		//       - and the structure is:
		//         - canvases
		//           - buttons
		//             - properties
		//   - maybe make the ctxs more open-ended?
		//     - something like this:
		//       - ctx
		//         - active, ui, mobile (contexts)
		//     - hmmm.
		//     - i don't want to make it difficult to add more windows later on,
		//       but i don't want to make it take way too long to type a ctx...
		//     - then again, i don't think i'll actually type the ctx too much
		//       when programming.
		//       - graphics changes like setgraphics and drawbuttons will probably
		//         make a reference variable at the beginning anyway.
		//     - it'd also be good to have some consistency between the html ids
		//       and the ctx names. prefix + "_" + ctx property name + "canvas"
		//   - i'm probably gonna do away with the active/ui/mobile structure
		//     appinitA sets up. those will be the default used in the template,
		//     but appinitA will just use an object input. each property is a
		//     canvas, and has a w and h
	};
	// functions you're supposed to write yourself:
	// - .initialize: stuff that sets everything up.
	// - .createbuttons. the structure of buttons is:
	//   - .buttons (object, a property for each ctx.)
	//     - .buttons.ui (object storing the buttons of the ui canvas.)
	//       - .buttons.ui[buttonname] (button object)
	//         - x, y, w, h: defines the rectangle. this is the only
	//           mandatory field.
	//         - tags: string or array storing strings for categories and
	//           stuff. like if i wanna check if it's a color button.
	//         - split: string or array of "up", "down", "left", or "right",
	//           indicates that you should draw imaginary diagonal lines
	//           across the rectangle and only consider the input valid if
	//           it's within one of those quadrants
	//         - hide: boolean, keeps drawbuttons from doing anything.
	//         - key: the KeyboardEvent.key string of the key that should do
	//           the same thing as clicking this. use "ctrl + " and/or
	//           "shift + " to specify those buttons must be held.
	//         - image: drawImage() parameters
	//           - file: file path
	//           - sx, sy, sw, sh: rectangle parameters for the portion of the
	//             image you're using
	//           =
	//           - the dx/dy/dw/dh parameters are just the button rectangle
	//             stuff, obviously
	//           - note that this is not affected by split, so... in cases
	//             like the subtool controls, only one button holds the image
	//             for all of them.
	//           - that might get complicated later though. i'm not
	//             implementing "active" images yet. (that is, images that
	//             appear only when the button is clicked)
	//         - savechange: boolean. this should be true if the button edits
	//           the data that gets saved in undodata. it turns on the App
	//           object's savechange boolean, which triggers conditionals that
	//           trigger the functions that save stuff to undodata.
	//         - condition: a simple arrow function that returns a boolean. if
	//           it's false, the button won't be drawn and won't be clickable.
	//           - this can be used to make a page system.
	//           - why the workaround, you ask? because otherwise the structure
	//             of this.buttons has to be this.buttons > canvases > set of
	//             pages > individual pages > buttons > properties. which is. no
	//           - if there's no condition, it will always appear.
	//         - keycondition: an arrow function that's run on key presses.
	//           - buttons should generally be possible to activate by key no
	//             matter what, but, maybe an action is inapplicable under some
	//             circumstances. there's more uses for condition than just a
	//             page system, after all.
	//           - if a button fails to meet condition, it won't be drawn. that
	//             is not true for keycondition.
	// - setgraphics: evaluates the status of everything and enacts graphics
	//   changes
	// - putundodata: used by undo and redo, places whatever data is stored in
	//   undodata. for example, a drawing app would save ImageDatas, so this
	//   would just do putImageData wherever the drawing area is.
	// - mousedown, mousemove, mouseup
	//   - mousedown, you need to run buttonaction and all that in whatever way
	//     makes sense
	//   - mousemove, you probably don't need at all
	//   - mouseup adds to undodata and resets .clickarea
	//   - you should probably copy the template, for all of them.
	// - buttonaction: takes the name of a button (inputted using keycheck or
	//   mousecheck) and runs whatever code makes sense.
	// - keydown event listener: triggers buttonaction. userfocus has to match
	//   this.prefix though, so it doesn't run when the viewer isn't actually
	//   using this.
	// - keyup event listener: triggers saveundodata if .savechange is true
	// -
	// other crap to keep in mind:
	// - if this.savechange is not turned on during a click or key press, any
	//   changes it enacted will not be saved to undodata. buttons can turn this
	//   on with a .savechange property of their own, or you could type
	//   this.savechange = true during the action somewhere.
	// - .page is not actually part of the App class. i just have it in the
	//   template crap because it's a common thing to want.
	/*
	template. copy all this, replace all the XXXX, finish the functions, and it
	should work. probably.
	-
	let XXXX = new App();
	XXXX.initialize = function() {
		this.appinitA(
			"XXXX",
			// canvases
			{
				active: {
					w: 256,
					h: 192,
				},
				ui: {
					w: 256,
					h: 192,
				},
				mobile: {
					w: 128,
					h: 96,
				},
			},
			uicolor
		);
		this.createbuttons();
		let extracode = function() {
			//
		};
		// probably don't need this though
		this.drawbuttons(noimage, extracode);
		this.ctx.active.canvas.alt = "";
		this.ctx.ui.canvas.alt = "";
		this.ctx.mobile.canvas.alt = "";
		// type brief descriptions, for screen readers or unsupported browsers
		this.page = 0;
		//
		// extra shit goes here.
		//
		this.appinitB(saveddata);
	};
	XXXX.createbuttons = function() {
		let i1 = 0;
		let i2 = 0;
		this.buttons = {};
		for (i1 in this.ctx) {
		// buttons are divided up by which canvas they're on.
			if(this.ctx.hasOwnProperty(i1)) {
				this.buttons[i1] = {};
			};
		}
		let block = 32;
		// useful as an increment or whatever.
		let temp = {
			x: 0,
			y: 0,
			w: block,
			h: block,
		};
		canvas = "ui";
		// the buttons on the ui canvas.
		this.buttons[canvas].button1 = structuredClone(temp);
		this.buttons[canvas].button1.key = "ctrl + g";
		temp = {
			x: temp.x + temp.w,
			y: 0,
			w: block,
			h: block,
		};
		this.buttons[canvas].button2 = structuredClone(temp);
		temp = {
			x: temp.x + temp.w,
			y: temp.y + temp.h,
			w: block,
			h: block,
		};
		this.buttons[canvas].page = {
			x: this.ctx[canvas].canvas.width,
			y: this.ctx[canvas].canvas.height,
			w: block,
			h: block,
			split: [
				"down",
				"right"
			],
			key: "q",
		};
		// condition is purposefully omitted so it shows up on every page.
		this.buttons[canvas].page.x -= this.buttons[canvas].page.w;
		this.buttons[canvas].page.y -= this.buttons[canvas].page.h;
		// ui canvas button defining
		for (i1 in this.buttons[canvas]) {
			if (this.buttons[canvas].hasOwnProperty(i1) && !this.buttons[canvas][i1].hasOwnProperty("condition") && i1 !== "page") {
				this.buttons[canvas][i1].condition = (app) => app.page === 0;
				// type something like this, and the button will only be visible and
				// clickable if the this.page is 0. there's no page system built
				// into App inherently, but that's one way of doing it.
			}
		}
		// ui canvas condition defining (this example sets all buttons up to
		// this point to page 0. apparently, functions cannot be cloned easily.)
		this.buttons[canvas].page.image = {
			file: new Image(),
			sx: 0,
			sy: 0,
			sw: block,
			sh: block,
		};
		this.buttons[canvas].page.image.file.src = "filename.png";
		// ui canvas image defining
	};
	XXXX.setgraphics = function() {
		// type up shit that changes things
	};
	XXXX.putundodata = function(data) {
		// place what's there with the undodata provided.
	};
	XXXX.buttonaction = function(e, iskeyevent) {
	// - e: MouseEvent or KeyboardEvent
		let action = null;
		let button = null;
		if(iskeyboardevent) {
			action = this.keycheck(e);
			button = action[1];
			action = action[0];
		}
		else {
			action = this.mousecheck(e);
			button = action[1];
			action = action[0];
		};
		let i1 = 0;
		let i2 = "";
		switch (action) {
			case "none":
			break;
			case "undo":
				this.undo();
			break;
			case "redo":
				this.redo();
			break;
			case "page":
				//
			break;
		};
		if(button.hasOwnProperty("savechange") && button.savechange) {
			this.savechange = true;
		};
	};
	XXXX.mousedown = function(e) {
		//changefocus(XXXX.prefix);
		// userfocus is a global variable, makes sure keyboard events only
		// affect what's relevant
		XXXX.savechange = false;
		let mouse = clickxy(e, XXXX.prefix);
		mouse = {
			x: mouse[0],
			y: mouse[1],
		};
		let i1 = "";
		XXXX.clickarea = null;
		for (i1 in XXXX.ctx) {
			if(XXXX.ctx.hasOwnProperty(i1) && e.target === XXXX.ctx[i1].canvas) {
				XXXX.clickarea = i1;
			};
		};
		switch (XXXX.clickarea) {
			case "ui":
				draw.buttonaction(e);
			break;
			case "active":
				draw.buttonaction(e);
			break;
			case "mobile":
				draw.buttonaction(e);
			break;
		};
		draw.mousemove(e);
	};
	XXXX.mousemove = function(e) {
		let mouse = clickxy(e);
		mouse = {
			x: mouse[0],
			y: mouse[1],
		};
	};
	XXXX.mouseup = function(e) {
		let mouse = clickxy(e);
		mouse = {
			x: mouse[0],
			y: mouse[1],
		};
		if(XXXX.savechange) {
			XXXX.saveundodata();
		};
		XXXX.clickarea = "none";
	};
	XXXX.initialize();
	document.addEventListener("keydown", function(e) {
		XXXX.savechange = false;
		if(userfocus === "XXXX") {
			XXXX.buttonaction(e, true);
		};
	});
	document.addEventListener("keyup", function(e) {
		if(userfocus === "XXXX") {
			XXXX.saveundodata();
		};
	});
	//*/
	document.write(`</div>`);
	//
	document.write(`<div name="hider" id="hider_armature_artist">`);
	let aa = {
	// "armature artist", a simpler version of what i wanted from the posing
	// interface.
	// - a lot of the code for this is in the AAX object in my graphics script.
	//   basically, anything i was gonna use in other armature-related tools
	//   went there. you'll have to read that too to get a lot of this.
		pa: {
			part: {
			// all the data that will be sent to the rest of aa
				front: [],
				// data for the front view of the part. it's like ImageData, an
				// array of what value each pixel has, left to right, top to
				// bottom. 0 is unfilled, 1 is filled, 2 is filled in color2.
				// - color1 pixels are only drawn on the armature if they're on
				//   the outside, color2 are drawn regardless.
				// - color2 can be used for guides and stuff.
				right: [],
				// counterpart for the side
				size: 8,
				oddness: [false, false, false],
				get box() {
					return aa.box(this.size, this.oddness);
				},
				dim: function(right) {
					const box = this.box;
					return [box[right ? "d" : "w"], box.h];
				},
				// this will create an object like: {x: -4, y: -4, z: 4, w: 9,
				// h: 9, d: 9}
				// - the pixels of the part are mapped to relative coordinates
				//   of the part's placement on the canvas.
				// - the coordinates represent the corner of the box that's the
				//   lowest in each axis. (ie the leftmost, topmost, backmost.)
				rect: function(right) {
					const dim = this.dim(right);
					return {
						x: (dim[0] - 1)*(-1/2),
						y: (dim[1] - 1)*(-1/2),
						w: dim[0],
						h: dim[1],
					};
				},
				color1: "#ef007f",
				color2: "black",
				//"#ef007f", // violet red
				//"#bfef1f", // lime
				//"#007fef", // azure
				//"#7f00ef" // purple
			},
			ctx: {
				front: null,
				right: null,
				ui: null,
			},
			// canvas contexts
			grid_color: "silver",
			// color used for grid lines and empty pixels. this isn't really
			// important, it's only changeable so you can fix it if it blends in
			// with the part color.
			empty_color: "gray",
			grid_w: 1,
			block_w: 7,
			editright: false,
			// boolean for whether actions done in the ui like the doubleclick
			// ellipse should be done on the front view or the right view. this
			// is set as false when you click the front view, true when you
			// click the right view.
			// - it's also used as a faster way of checking which canvas was
			//   clicked to trigger the function.
			tool: "pen1",
			// string for what to use when the canvas is clicked.
			strokedata: null,
			// stores data used within the action of a mousedown and mouseup.
			clicktype: null,
			// string for the canvas you're currently clicking
			editactions: [
				"changedimensions",
				"ellipse",
				"rotate",
				"rotate90",
				"clear",
				"xmirror",
				"ymirror",
				"move_l",
				"move_r",
				"move_u",
				"move_d",
				"fullellipse",
				"swap"
			],
			redraw: function() {
				let i0 = 0;
				let i1 = 0;
				for(i0 = 0; i0 < 2; i0++) {
					let ctx = this.ctx[i0 ? "right" : "front"];
					let image = this.part[i0 ? "right" : "front"];
					let w = this.part.rect(i0).w;
					// screen width, not box.w.
					if(true) {
						image = AAX.sq_raster.fill(image, w);
					};
					ctx.canvas.width = (this.grid_w + this.block_w)*w;
					ctx.canvas.height = (this.grid_w + this.block_w)*this.part.rect(i0).h;
					ctx.fillStyle = this.grid_color;
					ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
					//
					let coor = [
						-this.part.rect(i0).x,
						-this.part.rect(i0).y
					];
					coor = [
						(coor[0] * (this.grid_w + this.block_w)) + this.grid_w + Math.floor(this.block_w/2 - this.grid_w/2),
						(coor[1] * (this.grid_w + this.block_w)) + this.grid_w + Math.floor(this.block_w/2 - this.grid_w/2),
					];
					ctx.fillStyle = this.empty_color;
					ctx.fillRect(0, coor[1], ctx.canvas.width, this.grid_w);
					ctx.fillRect(coor[0], 0, this.grid_w, ctx.canvas.height);
					// draw lines at the zeroes.
					for(i1 = 0; i1 < image.length; i1++) {
						let coor = [
							i1 % w,
							Math.floor(i1/w)
						];
						// column and row
						coor = [
							(coor[0] * (this.grid_w + this.block_w)) + this.grid_w,
							(coor[1] * (this.grid_w + this.block_w)) + this.grid_w,
						];
						// x and y, in pixels
						if(image[i1] === 0) {
							ctx.fillStyle = this.empty_color;
						}
						else if([1, 2].includes(image[i1])) {
							ctx.fillStyle = this.part["color" + image[i1]];
						}
						else if(image[i1] === "fill") {
							ctx.fillStyle = aa.color.part_interior;
						}
						else {
							console.log("invalid aa.pa.part pixel data.");
							return;
						};
						ctx.fillRect(...coor, this.block_w, this.block_w);
					}
				}
			},
			clickrowcol: function(x, y, giveindex) {
			// converts canvas coordinates to block coordinates on the thing.
			// - returns null if it's off the canvas.
			// - giveindex: returns the number index instead
				const right = this.clicktype === "right";
				let ctx = this.ctx[right ? "right" : "front"];
				if(x < 0 || x >= ctx.canvas.width || y < 0 || y >= ctx.canvas.height) {
					return null;
				};
				const block = (this.grid_w + this.block_w);
				let coor = [
					Math.floor(x/block),
					Math.floor(y/block)
				];
				return (
					giveindex
					?
					coor[1]*this.part.rect(right).w + coor[0]
					:
					coor
				);
			},
			ui: {
			// PART ARTIST
			// functions/variables related to the buttons
				scale: 1,
				buttons: {},
				// object of buttons.
				// - each button is just a rectangle object. x, y, w, h
				create: function() {
					let i1 = 0;
					let i2 = 0;
					let block = AAX.ui.block;
					let ref = this.buttons;
					let area = {x: 0, y: 0, w: 6*block, h: 4*block};
					ref.switch = structuredClone(area);
					ref.switch_no_export = structuredClone(area);
					ref.switch_no_export.x += area.w;
					area.y += area.h + block;
					area.w = 8*block;
					area.h = 2*block;
					let array = ["clear", "fullellipse", "xmirror", "ymirror", "rotate90", "swap"];
					for(i1 = 0; i1 < array.length; i1++) {
						if(i1 === 2) {
							area.h = 1*block;
						};
						ref[ array[i1] ] = structuredClone(area);
						area.y += area.h;
					}
					area.x += area.w;
					area.w = 4*block;
					area.h = 4*block;
					area.y -= area.h;
					ref.move = structuredClone(area);
					area.y -= 4*block;
					area.x += 1*block;
					area.w = 3*block;
					area.h = 1.5*block;
					array = ["grid_color", "empty_color"];
					for(i1 = 0; i1 < array.length; i1++) {
						ref[ array[i1] ] = structuredClone(area);
						area.y += area.h;
					}
					area = {
						x: area.x + area.w + block,
						y: 0,
						w: 7*block,
						h: 1*block,
					};
					array = ["heading", "pen1", "pen2", "ellipse", "rotate"];
					for(i1 = 0; i1 < array.length; i1++) {
						ref[ "tool_" +  array[i1] ] = structuredClone(area);
						area.y += area.h;
					}
					area.y += area.h;
					area.h = 3*block;
					ref.changedimensions = structuredClone(area);
					// - switch, switch without export (same place it is in the main ui)
					// - tools (ie, buttons that change what clicks do)
					//   - pen1, pen2 (3)
					//   - ellipse (5)
					//   - rotate (4)
					// - edits (buttons that apply changes by themselves)
					//   - clear (4)
					//   - full ellipse (8)
					//   - move (special case)
					//   - x mirror (6)
					//   - y mirror (6)
					//   - rotate 90
					//   - swap (3)
					// - settings changes
					//   - grid_color, empty_color (special cases)
					//   - change dimensions (7 x 2)
				},
				keymap: {
					q: ["switch", "switch_no_export"],
					w: "move_u",
					a: "move_l",
					s: "move_d",
					d: "move_r",
					"1": "tool_pen1",
					"2": "tool_pen2",
				},
				draw: function() {
				// for now this is going to be stunningly half-assed.
				// - this also acts as a "reset graphics" function, and it changes
				//   the ui canvas dimensions too.
					let i1 = 0;
					let i2 = 0;
					let color = aa.color.buttons;
					let ctx = aa.pa.ctx.ui;
					let ranges = [0, 0];
					for (i1 in this.buttons) {
						if (this.buttons.hasOwnProperty(i1)) {
							let ref = this.buttons[i1];
							ranges[0] = Math.max(ranges[0], ref.x, ref.x + ref.w);
							ranges[1] = Math.max(ranges[1], ref.y, ref.y + ref.h);
						};
					}
					ranges[0]++;
					ranges[1]++;
					ctx.canvas.width = ranges[0];
					ctx.canvas.height = ranges[1];
					ctx.clearRect(0, 0, ...ranges);
					ctx.font = AAX.ui.font;
					ctx.textAlign = "center";
					ctx.textBaseline = "middle";
					const margin = AAX.ui.margin;
					const spacednames = [
						"full ellipse",
						"x mirror",
						"y mirror",
						"rotate 90",
						"change dimensions"
					];
					for (i1 in this.buttons) {
						if (this.buttons.hasOwnProperty(i1)) {
							let ref = this.buttons[i1];
							let text = (i1.startsWith("tool_") ? i1.slice("tool_".length) : i1).replaceAll("_", " ");
							if(i1 === "tool_heading") {
								text = "tools";
							}
							else if(i1 === "switch_no_export") {
								text = "switch without export";
							}
							else {
								for(i2 = 0; i2 < spacednames.length; i2++) {
									if(spacednames[i2].replaceAll(" ", "") === text) {
										text = spacednames[i2];
										i2 += spacednames.length;
									};
								}
							};
							let align = (i1.startsWith("tool_") && i1 !== "tool_heading") ? "left" : "center";
							let selected = Number(i1.startsWith("tool_") && aa.pa.tool === i1.slice("tool_".length));
							ctx.strokeStyle = color[ posmod(- selected, color.length) ];
							ctx.fillStyle = color[ posmod(1 - selected, color.length) ];
							if(i1 !== "tool_heading") {
								ctx.fillRect(ref.x, ref.y, ref.w, ref.h);
								Rect.fauxstroke(ref, ctx);
							};
							if(["color1", "color2", "grid_color", "empty_color"].includes(i1)) {
								ctx.fillStyle = ["grid_color", "empty_color"].includes(i1) ? aa.pa[i1] : aa.pa.part[i1];
								ctx.fillRect(ref.x, ref.y, ref.w, ref.h);
								Rect.fauxstroke(ref, ctx);
							}
							else if(i1 === "move") {
								linespecial(ctx, ref.x, ref.y, ref.x + ref.w, ref.y + ref.h);
								linespecial(ctx, ref.x + ref.w, ref.y, ref.x, ref.y + ref.h);
								// x
								linespecial(ctx,
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*1/8),
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*2/8)
								);
								linespecial(ctx,
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*6/8),
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*7/8)
								);
								linespecial(ctx,
								Math.floor(ref.x + ref.w*1/8),
								Math.floor(ref.y + ref.h/2),
								Math.floor(ref.x + ref.w*2/8),
								Math.floor(ref.y + ref.h/2)
								);
								linespecial(ctx,
								Math.floor(ref.x + ref.w*6/8),
								Math.floor(ref.y + ref.h/2),
								Math.floor(ref.x + ref.w*7/8),
								Math.floor(ref.y + ref.h/2)
								);
							}
							else {
								if((2*margin[0] + 5*text.length - 1) > ref.w) {
									text = text.split(" ");
								};
								if(!Array.isArray(text)) {
									text = [text];
								};
								ctx.textAlign = align;
								ctx.fillStyle = ctx.strokeStyle;
								for(i2 = 0; i2 < text.length; i2++) {
									ctx.fillText(
										text[i2],
										Math.floor(ref.x + (align === "center")*(ref.w/2) + margin[0]) - (text[i2].length%2 && align === "center")/2,
										Math.floor(ref.y + ref.h/2 + margin[1] + 8*(-(text.length - 1)/2 + i2))
									);
								};
							};
						};
					}
				},
				action: function(action, shift, ctrl) {
					let i1 = 0;
					if(action.endsWith("heading")) {
					}
					else if(shift && action === "ellipse") {
						aa.pa.edit("fullellipse");
					}
					else if(action === "switch") {
						const part = aa.control.part;
						const view = aa.control.view;
						const ref = aa.pa.part;
						const prompttext = "the current part image doesn't have the same oddness as the part you're trying to apply it to. the center rows/columns might be collapsed or expanded.";
						let no_export = false;
						if(aa.control.perspectived) {
						// - save the aa.pa oddness
						// - if it's different:
						//   - prompt confirmation
						//   - changeoddness
						// - then crop it with imagefunc.crop
							const right = !!(view%2);
							let image = structuredClone(ref[right ? "right" : "front"]);
							const pa_oddness = [ref.oddness[right ? 2 : 0], ref.oddness[1]];
							const new_oddness = part.image_oddness(view);
							no_export = (
								pa_oddness[0] !== new_oddness[0]
								||
								pa_oddness[1] !== new_oddness[1]
							);
							if(no_export && confirm(prompttext)) {
							// if the oddness is different, confirm that oddness
							// edits are ok
								no_export = false;
								image = AAX.sq_raster.changeoddness(image, pa_oddness, new_oddness);
								// oddness differences change the image
							};
							if(!no_export) {
								part._perspective[view] = AAX.sq_raster.autocrop(image, new_oddness);
								// autocrop it so all the pixels just barely fit
								// inside
							};
						}
						else {
							let image = [
								structuredClone(ref.front),
								structuredClone(ref.right)
							];
							const new_oddness = [
								part.image_oddness("front"),
								part.image_oddness("right")
							];
							no_export = (
								ref.oddness[0] !== new_oddness[0][0]
								||
								ref.oddness[1] !== new_oddness[0][1]
								||
								ref.oddness[1] !== new_oddness[1][1]
								||
								ref.oddness[2] !== new_oddness[1][0]
							);
							// ref.oddness is 3d, new_oddness [0] and [1] are
							// 2d.
							if(no_export && confirm(prompttext)) {
							// correct for oddness
								no_export = false;
								image = [
									AAX.sq_raster.changeoddness(image[0], [ref.oddness[0], ref.oddness[1]], new_oddness[0]),
									AAX.sq_raster.changeoddness(image[1], [ref.oddness[2], ref.oddness[1]], new_oddness[1])
								];
								// oddness differences change the image
							};
							if(!no_export) {
								part._image.front = AAX.sq_raster.autocrop(image[0], new_oddness[0]);
								part._image.right = AAX.sq_raster.autocrop(image[1], new_oddness[1]);
								// autocrop
							};
						};
						// i'm not using the size setters because it has to edit
						// the image for oddness anyway.
						aa.refresh(no_export ? "states" : null);
						aa.editmodetoggle();
					}
					else if(action === "switch_no_export") {
						aa.editmodetoggle();
					}
					else if(action.startsWith("tool_")) {
						aa.pa.tool = action.slice("tool_".length);
						// so that it knows what to do with the next canvas click
						aa.pa.ui.draw();
						// so that graphics changes take effect
					}
					else if(action.startsWith("move_") && ["l", "r", "u", "d", "ul", "ur", "dl", "dr"].includes(action.slice("move_".length))) {
						aa.pa.edit(action);
					}
					else if(aa.pa.editactions.includes(action) && !["ellipse", "move"].includes(action)) {
						aa.pa.edit(action);
					}
					else if(["color1", "color2", "grid_color", "empty_color"].includes(action)) {
						aa.pa.changecolor(action);
					};
				},
				mousedown: function(e, doubleclick) {
					let i1 = 0;
					let click = clickxy(e, "aapa");
					let _this = aa.pa.ui;
					let action = null;
					for (i1 in _this.buttons) {
						if (_this.buttons.hasOwnProperty(i1) && withinrect(click[0], click[1], _this.buttons[i1])) {
							if(i1 === "move") {
								let angle = get2dangle(
									click[0] - (_this.buttons[i1].x + _this.buttons[i1].w/2),
									click[1] - (_this.buttons[i1].y + _this.buttons[i1].h/2),
									true
								) ?? 0;
								angle = posmod(angle + 2*Math.PI/8, 2*Math.PI);
								angle = "rdlu"[Math.floor(angle/(2*Math.PI/4))];
								action = i1 + "_" + angle;
							}
							else {
								action = i1;
							}
						};
					}
					if(action !== null) {
						_this.action(action, doubleclick);
					};
				},
			},
			mousedown: function(e) {
				let click = clickxy(e, "aapa");
				let _this = aa.pa;
				if(e.target.id === "aapa_front") {
					_this.editright = false;
					_this.clicktype = "front";
				}
				else if(e.target.id === "aapa_right") {
					_this.editright = true;
					_this.clicktype = "right";
				}
				else {
					console.log("this shouldn't happen");
					console.log(e.target.id);
				};
				if(["pen1", "pen2"].includes(_this.tool)) {
					_this.penaction(...click);
					_this.pen(...click);
				}
				else if(_this.tool === "ellipse") {
					_this.strokedata = {
						start: _this.clickrowcol(...click),
						image: structuredClone(_this.part[_this.clicktype]),
					};
				}
				else if(_this.tool === "rotate") {
					let canvas = _this.ctx[_this.clicktype].canvas;
					_this.strokedata = {
						start: get2dangle(
							click[0] - canvas.width/2,
							click[1] - canvas.height/2,
							true
						) ?? 0,
						image: structuredClone(_this.part[_this.clicktype]),
					};
					// save the starting angle
				}
			},
			mousemove: function(e, finish) {
				if(e.target.id !== "aapa_" + aa.pa.clicktype) {
					return;
				};
				let click = clickxy(e);
				let _this = aa.pa;
				if(["pen1", "pen2"].includes(_this.tool)) {
					if(!finish) {
						_this.pen(...click);
					};
				}
				else if(_this.tool === "ellipse" && _this.strokedata.start !== null) {
				// reset it to how it was before the click, and create an
				// ellipse
					let temp = _this.clickrowcol(...click);
					if(temp !== null) {
						_this.edit("ellipse", _this.strokedata.start.concat(temp));
						// redraws too
					};
					if(!finish) {
						_this.part[_this.clicktype] = structuredClone(_this.strokedata.image);
					};
				}
				else if(_this.tool === "rotate") {
				// same thing, but rotate
					let canvas = _this.ctx[_this.clicktype].canvas;
					let angle = get2dangle(
						click[0] - canvas.width/2,
						click[1] - canvas.height/2,
						true
					) ?? 0;
					angle = posmod(angle - _this.strokedata.start, 2*Math.PI);
					_this.edit("rotate", [angle]);
					if(!finish) {
						_this.part[_this.clicktype] = structuredClone(_this.strokedata.image);
					};
				};
				if(finish) {
					_this.strokedata = null;
					_this.clicktype = null;
				};
			},
			mouseup: function(e) {
				if(e.target.id !== "aapa_" + aa.pa.clicktype) {
					return;
				};
				aa.pa.mousemove(e, true);
			},
			// functions below this line are what happens when you click the
			// buttons.
			penaction: function(x, y) {
			// sets this.strokedata as the action this stroke will take. (that
			// is, whether to fill or erase. this depends on the value of the
			// pixel you clicked.)
				let value = this.part[this.clicktype][ this.clickrowcol(x, y, true) ];
				// value of the pixel being clicked on
				if(this.tool === "pen1") {
					this.strokedata = (value === 0 ? 1 : 0);
				}
				else if(this.tool === "pen2") {
					this.strokedata = (value === 2 ? "2 to 1" : 2);
				}
				else {
					console.log("this shouldn't happen");
				};
			},
			pen: function(x, y) {
				let action = this.strokedata;
				let index = this.clickrowcol(x, y, true);
				if(index === null) {
					return;
				};
				let image = this.part[this.clicktype];
				if([0, 1, 2].includes(action)) {
					image[index] = action;
				}
				else if(action === "2 to 1") {
					if(image[index] === 2) {
						image[index] = 1;
					};
				}
				else {
					console.log("this shouldn't happen");
				};
				this.redraw();
			},
			changecolor: function(type) {
			// prompts the user and changes color accordingly.
				let text = {
					color1: "main color.",
					color2: "secondary color.",
					grid_color: "color for the grid.",
					empty_color: "color for unfilled blocks.",
				};
				if(!text.hasOwnProperty(type)) {
					console.log("this shouldn't happen");
					return;
				};
				text = "type the " + text[type];
				const color = prompt(text);
				if(!color) {
					return;
				};
				if(["color1", "color2"].includes(type)) {
					this.part[type] = color;
				}
				else {
					this[type] = color;
				}
				this.ui.draw();
				this.redraw();
			},
			edit: function(action, args) {
			// all-purpose function for most editing tools.
			// - action: the string of the function in Raster you plan
			//   to use
			//   - there's also fullellipse and switch. those aren't imagefunc
			//     functions, but there's code for those.
			//   - go to aa.pa.editactions for the full list of actions.
			// - args: an array of arguments to pass on. (not counting image and
			//   w. it can figure those out on its own.)
			//   - ellipse: x1, y1, x2, y2
			//   - move is figured out from the direction suffix.
				args ??= [];
				const box = structuredClone(this.part.box);
				let rect = this.part.rect(this.editright);
				let image = this.part[this.editright ? "right" : "front"];
				const w = rect.w;
				if(action.startsWith("move_")) {
					action = action.split("_");
					args = {
						l: [-1, 0],
						r: [1, 0],
						u: [0, -1],
						d: [0, 1],
						ul: [-1, -1],
						ur: [1, -1],
						dl: [-1, 1],
						dr: [1, 1],
					}[action[1]];
					action = action[0];
				};
				//
				if(action === "changedimensions") {
				// changedimensions only thinks in 2d. this prompts the user to
				// create a changes object, then applies edits to both front and
				// right.
					let text = prompt([
						`type dimension changes here to expand the canvas.`,
						`dimensions and coordinates are created with an overall size number, and "oddness" booleans for each axis.`,
						`the box the part is within will always center on [0, 0, 0] and all its dimensions will be mostly equal.`,
						`but depending on the axis' oddness, dimensions might be size + 1.`,
						`type "size:" and a number to change size, and an axis letter with a colon and boolean to change oddness. use commas to separate multiple commands.`,
					].join(String.fromCharCode(10).repeat(2)));
					if(!text) {
						return;
					};
					text = text.split(",");
					for(i1 = 0; i1 < text.length; i1++) {
						let value = text[i1].split(":");
						let name = value[0].trim();
						value = (
							name === "size"
							?
							Number(value[1])
							:
							value[1].trim()
						);
						if(name === "size" && Number.isInteger(value) && value >= 0) {
							this.part.size = value;
						}
						else if("xyz".includes(name) && name.length === 1 && ["true", "false"].includes(value)) {
							this.part.oddness["xyz".indexOf(name)] = value === "true";
						};
					}
					const new_box = structuredClone(this.part.box);
					this.part.front = Raster.redimension(this.part.front, box.w, new_box.w, new_box.h);
					this.part.right = Raster.redimension(this.part.right, box.d, new_box.d, new_box.h);
				}
				else if(["ellipse", "rotate", "clear", "xmirror", "ymirror", "move"].includes(action)) {
					this.part[this.editright ? "right" : "front"] = Raster[action](image, w, ...args);
				}
				else if(action === "fullellipse") {
					this.edit("ellipse", [0, 0, rect.w - 1, rect.h - 1]);
					return;
					// avoids .redraw since this new running of .edit will do
					// that
				}
				else if(action === "swap") {
					let temp = Raster.redimension(this.part.front, box.w, box.d, box.h);
					this.part.front = Raster.redimension(this.part.right, box.d, box.w, box.h);
					this.part.right = structuredClone(temp);
					// dimensions might be different, because of oddness and all
					// that.
				}
				else if(action === "rotate90") {
					this.part[this.editright ? "right" : "front"] = Raster.rotate(image, w, Math.PI/2);
				};
				this.redraw();
			},
		},
		drawsettings: new AAX.DrawSettings,
		// stuff is here if it's data that only affects how things are
		// visualized, not stuff that affects processing like which tool is
		// selected.
		// - NOTE color doesn't count. that's separate.
		color: new AAX.Color,
		// object storing the colors of various things.
		ctx: {
			main: null,
			ui: null,
		},
		div: {
			editmodetrue: null,
			editmodefalse: null,
			coor: null,
		},
		version_history: "v1.0 v1.0.1 v1.1 v1.1.1".split(" "),
		get version() {
			return aa.version_history[aa.version_history.length - 1];
		},
		partinfo_is_default: function(part, view, suffix) {
			let _default = false;
			if(["connection", "silhouette", "shape"].includes(suffix)) {
				//_default = part["_" + suffix] === "default";
				_default = part.getwithoutredirects(suffix) === "default";
			}
			else if(["name", "colors"].includes(suffix)) {
				_default = true;
			}
			else if(suffix === "hide") {
				_default = part.bodyref[suffix] === part[suffix];
			}
			else if(suffix === "coor") {
				_default = compareobject(AAX.relcoor(part.bodyref), part.relcoor);
			}
			else if(suffix === "image") {
				_default = (
					part._image.front === "default"
					&&
					part._image.right === "default"
				);
			}
			else if(suffix === "perspective_coor") {
				_default = part._perspective.coor[view] === "default";
			}
			else if(suffix === "perspective_image") {
				_default = part._perspective[view] === "default";
			}
			else if(suffix === "shape_settings") {
				_default = part.stretch === 1 && part.widen === 1 && part.orient.w === 1;
			}
			else {
				console.log("there are partinfo properties the logic doesn't account for. (" + suffix + ")");
			};
			return _default;
		},
		hidelist: function(partname, suffix) {
		// makes an array of parts based on the partname and the type of hide.
		// for example, making an array of the body the part is part of, or the
		// branch made from it.
			let i1 = 0;
			let loop = new Loop("aa.hidelist");
			let array = [];
			let minus = null;
			if(suffix.includes("_minus_")) {
				suffix = suffix.split("_minus_");
				minus = suffix[1];
				suffix = suffix[0];
			};
			if(suffix === "part") {
				array = [partname];
			}
			else if(suffix === "group") {
				let num = aa.currpose[partname].silhouette[0];
				for(i1 in aa.currpose) {
					loop.tick(1);
					if(aa.currpose.hasOwnProperty(i1) && aa.currpose[i1].silhouette[0] === num) {
						array[array.length] = i1;
					}
				}
				loop.end();
			}
			else if(suffix === "branch" || suffix === "body") {
				let start = suffix === "body" ? AAX.getstem(aa.currpose, partname) : partname;
				array = AAX.getdesc(aa.currpose, start);
				array.splice(0, 0, start);
			}
			else if(suffix === "all") {
				for(i1 in aa.currpose) {
					loop.tick(1);
					if(aa.currpose.hasOwnProperty(i1)) {
						array[array.length] = i1;
					}
				}
				loop.end();
			}
			else {
				console.log("this shouldn't happen");
			};
			if(minus) {
				minus = aa.hidelist(partname, minus);
				for(i1 = 0; i1 < minus.length; i1++) {
					loop.tick(1);
					let temp = array.indexOf(minus[i1]);
					if(temp !== -1) {
						array.splice(temp, 1);
					}
				}
				loop.end();
			}
			return array;
		},
		ishidden: function(partname, suffix) {
		// used with the hide/show buttons, to tell whether the button should be
		// highlighted, and whether clicking it should show or hide the parts
		// involved.
			let i1 = 0;
			let loop = new Loop("aa.");
			let array = aa.hidelist(partname, suffix);
			for(i1 = 0; i1 < array.length; i1++) {
				loop.tick(1);
				if(!aa.currpose[ array[i1] ].hide) {
					return false;
				};
			}
			loop.end();
			return true;
		},
		inbetweenvalues: function(num, curve, easeA, easeB) {
		// used by the inbetween visual and creation.
		// - one of those things that's only a function because it bothers me to
		//   write the same code twice.
			let array = [];
			let ease = (
				easeA
				?
				(easeB ? "out" : "out/in")
				:
				(easeB ? "in/out" : "in")
			);
			let _array = null;
			if(curve < 0) {
			// makes it look sorta wonky and random.
				_array = [];
				curve = Math.abs(curve);
				for(let i1 = 0; i1 < num; i1++) {
					_array[_array.length] = (Math.random() + (i1 + 1)/(num + 1))/2;
				}
				_array.sort((a, b) => a - b);
			}
			for(let i1 = 0; i1 < num; i1++) {
				array[i1] = easing(_array ? _array[i1] : (i1 + 1)/(num + 1), ease, curve);
			}
			return array;
		},
		ui: {
		// ARMATURE ARTIST
		// functions/data specific to ui, like what creates/draws buttons. and
		// some other stuff, like arrays of valid values for string properties
			buttons: {},
			create: function() {
				let i1 = 0;
				let i2 = 0;
				let loop = new Loop("aa.ui.create");
				let areas = [
					{
						prefix: "states",
						first: {
							suffix: "undo redo".split(" "),
							w: 4, h: 2,
							horizontal: true,
						},
						actions: [
							["expand", "limit", "d", 2]
						],
					},
					{
						prefix: "frame",
						first: {
							suffix: "display",
							w: 3, h: 3,
						},
						actions: [
							["expand", "previous", "l", 2],
							["expand", "next", "r", 2],
							["subtract", "previous", "u", 1],
							["subtract", "next", "u", 1],
							["column", "blank duplicate delete move_up move_down".split(" "), "d", 7, 1]
						],
					},
					{
						prefix: "inbetween",
						first: {
							suffix: "curve",
							w: 6, h: 1,
						},
						actions: [
							["expand", "easeA easeB".split(" "), "d", 1, true],
							["expand", "visual", "d", 1],
							["expand", "add number subtract".split(" "), "r", 2],
							["expand", "create", "d", 3],
							["expand", "apply", "d", 3],
						],
					},
					{
						prefix: "hide",
						first: {
							suffix: [],
							w: 8, h: 1,
						},
					},
					{
						prefix: "misc",
						first: {
							suffix: "autoperspective",
							w: 8, h: 4,
						},
						actions: [
							["expand", "clearimage editshape".split(" "), "d", 2, true],
							["expand", "stretch_widen", "d", 2],
							["expand", "rerendershape", "d", 2]
						],
					},
					{
						prefix: "view",
						first: {
							suffix: "0 1 2 3".split(" "),
							w: 1.5, h: 1,
							horizontal: true,
						},
					},
					{
						prefix: "oddify",
						direction: "d",
						first: {
							suffix: "x y z".split(" "),
							w: 2, h: 1,
							horizontal: true,
						},
					},
					{
						prefix: "invert",
						gap: 0,
						first: {
							suffix: "x y z".split(" "),
							w: 2, h: 1,
							horizontal: true,
						},
					},
					{
						prefix: "switch",
						first: {
							suffix: " no_export".split(" "),
							w: 6, h: 3,
						},
						heading: 2,
					},
					{
						prefix: "posetool",
						previous: 0,
						direction: "d",
						first: {
							suffix: AAX.valid.posetools,
							w: 8, h: 1,
						},
					},
					{
						prefix: "partinfo",
						first: {
							suffix: "name",
							w: 20,
							h: 1,
						},
						actions: [],
					},
					{
						prefix: "drawsettings",
						direction: "r",
						first: {
							suffix: "grid standpoint range".split(" "),
							w: 12, h: 1,
						},
						actions: [
							["expand", "cell vp camera".split(" "), "d", 3, true],
							["expand", "fineness", "d", 1]
						],
					},
					{
						prefix: "color",
						direction: "d",
						first: {
							suffix: [],
							w: 1, h: 4,
							horizontal: true,
						},
					},
					{
						prefix: "",
						previous: 0,
						direction: "u",
						gap: 1,
						first: {
							suffix: "save load".split(" "),
							w: 4, h: 2,
							horizontal: true,
						},
					},
					{
						prefix: "",
						direction: "u",
						gap: 0,
						first: {
							suffix: "title",
							w: Math.ceil(((AAX.ui.charwidth + 1)*("armature artist " + aa.version).length - 1 + 3)/AAX.ui.block), h: 1,
						},
						actions: [
							["expand", "projectname", "r", 1],
							["align", "projectname", "r"],
						],
					},
					{
						prefix: "anim",
						previous: -2,
						direction: "r",
						gap: 0,
						first: {
							suffix: "menu",
							w: 16, h: 1,
							horizontal: true,
						},
						actions: [
							["row", "blank duplicate delete".split(" "), "d", 6, 1],
							["align", "menu", "r"],
						],
					}
				];
				for(i1 = 0; i1 < areas.length; i1++) {
					let prefix = areas[i1].prefix;
					if(prefix && prefix !== "anim" && prefix !== "color") {
						areas[i1].heading ??= 1;
					}
				}
				// add heading
				let temp = "zxcvbnm";
				for(i1 = 0; i1 < AAX.valid.posetools.length; i1++) {
					this.keymap[ temp[i1] ] ??= [];
					this.keymap[ temp[i1] ][0] = "posetool_" + AAX.valid.posetools[i1];
				};
				// pose tools keymap
				let array = [
					"part",
					"branch",
					"group",
					"body_minus_part",
					"body_minus_branch",
					"body_minus_group",
					"all",
					"body",
					"all_minus_body"
				];
				temp = areas.find((element) => element.prefix === "hide");
				temp.first.suffix = structuredClone(array);
				for(i1 = 0; i1 < array.length; i1++) {
					this.keymap[(i1 + 1).toString()] ??= [null];
					this.keymap[(i1 + 1).toString()][1] = "hide_" + array[i1];
					// add 1 so it doesn't start at 0
				}
				// hide keymap
				array = [];
				for(i1 in AAX.DrawSettings.template) {
					if(AAX.DrawSettings.template.hasOwnProperty(i1) && (typeof AAX.DrawSettings.template[i1] === "boolean" || AAX.valid.hasOwnProperty(i1))) {
						array[array.length] = i1;
					};
				}
				temp = areas.find((element) => element.prefix === "drawsettings");
				temp.actions[temp.actions.length] = ["column", array, "l", 7, 1];
				for(i1 = 0; i1 < array.length; i1++) {
					this.keymap[(i1 + 1).toString()] ??= [];
					this.keymap[(i1 + 1).toString()][0] = "drawsettings_" + array[i1];
				}
				// finish drawsettings
				array = [
					"colors",
					"coor",
					"perspective_coor",
					"shape",
					"image",
					"perspective_image",
					"shape_settings",
					"hide",
					"connection",
					"silhouette"
				];
				temp = areas.find((element) => element.prefix === "partinfo");
				for(i1 = 0; i1 < array.length; i1++) {
					let h = (
						array[i1] === "coor" ? 6 :
						array[i1] === "connection" || array[i1] === "shape_settings" ? 2 :
						1
					);
					temp.actions[temp.actions.length] = ["expand", array[i1], "d", h];
					// - relative coordinates title and numbers on
					//   two lines, absolute coordinates on two
					//   lines, and the current and original
					//   hypotenuse on two lines.
					// - connections need a line for the type, and a
					//   line for the value
					// - stretch and widen both get their own lines
				}
				// finish partinfo
				array = [];
				for(i1 in AAX.Color.template) {
					if(AAX.Color.template.hasOwnProperty(i1)) {
						array[array.length] = i1;
					}
				}
				array.splice(3, 0, null);
				array.splice(11, 0, null);
				temp = areas.find((element) => element.prefix === "color");
				temp.first.suffix = structuredClone(array);
				// finish colors
				aa.ui.buttons = Rect.ui(areas);
				//
				let ref = aa.ui.buttons;
				for(i1 in ref) {
					if(ref.hasOwnProperty(i1)) {
						ref[i1].x *= AAX.ui.block;
						ref[i1].y *= AAX.ui.block;
						ref[i1].w *= AAX.ui.block;
						ref[i1].h *= AAX.ui.block;
					};
				}
			},
			keymap: {
			// property names are keys, the values are which button is supposed
			// to trigger.
			// - keys should be named the same as they are in KeyboardEvent.key,
			//   except single letters should be lowercase.
			// - if they're arrays:
			//   - 1: action when shift is held
			//   - 2: action when ctrl is held
			//   - 3: action when both are held
				w: ["posetool_previous", null],
				a: ["frame_previous", "view_previous"],
				s: ["posetool_next", null, "save"],
				d: ["frame_next", "view_next"],
				//
				q: ["switch", "switch_no_export"],
				e: "posetool_invert",
				//
				t: "select_parent",
				f: "select_prevsibling",
				g: "select_child",
				h: "select_nextsibling",
				//
				j: "frame_blank",
				i: "frame_duplicate",
				k: "frame_delete",
				o: "frame_move_up",
				l: "frame_move_down",
				//
				z: [null, null, "states_undo", "states_redo"],
				o: [null, null, "load"],
			},
			// keys added automatically:
			// - the number keys are drawsettings toggles, and hide toggles when
			//   shift is held
			// - zxcvbnm is pose tools
			get buttons_w() {
				let loop = new Loop("aa.ui.buttons_w");
				let w = 0;
				let buttons = aa.ui.buttons;
				for(let i1 in buttons) {
					loop.tick(1);
					if(buttons.hasOwnProperty(i1)) {
						w = Math.max(w, buttons[i1].x + buttons[i1].w);
					}
				};
				loop.end();
				return w;
			},
			get buttons_h() {
				let loop = new Loop("aa.ui.buttons_h");
				let h = 0;
				let buttons = aa.ui.buttons;
				for(let i1 in buttons) {
					loop.tick(1);
					if(buttons.hasOwnProperty(i1)) {
						h = Math.max(h, buttons[i1].y + buttons[i1].h);
					}
				};
				loop.end();
				return h;
			},
			animtabwidth: 8,
			// measured in blocks
			draw: function(depress) {
			// draws the buttons. this needs to be run every time...
			// - the current part changes
			// - the oddness of the current part changes
			// - the selected posetool changes
			// =
			// - depress: argument for which button is currently being animated
			//   as having been pressed.
				let i1 = 0;
				let i2 = 0;
				let i3 = 0;
				let loop = new Loop("aa.ui.draw");
				loop.tick(1);
				loop.tick(2);
				loop.end();
				let w = aa.ui.buttons_w;
				let h = aa.ui.buttons_h;
				w++;
				h++;
				// add 1 so there's room for the bottom/right edges of buttons
				let buttons = aa.ui.buttons;
				let ctx = aa.ctx.ui;
				ctx.canvas.width = w;
				ctx.canvas.height = h;
				let color = aa.color.buttons;
				//ctx.fillStyle = color[1];
				//ctx.fillRect(0, 0, w, h);
				ctx.clearRect(0, 0, w, h);
				const part = aa.control.part;
				const view = aa.control.view;
				const oddness = part.oddness;
				const image_oddness = AAX.image_oddness(aa.currpose, part.name, view);
				let relcoor = part.relcoor;
				const margin = AAX.ui.margin;
				const lineheight = AAX.ui.lineheight;
				const charwidth = AAX.ui.charwidth;
				let text_x = (button, align, text) => Math.floor(button.x + (
					align === "center" ? button.w/2 :
					align === "right" ? button.w - margin[0] :
					margin[0]
				)) + (align === "center" && !((text.length*(AAX.ui.charwidth + 1) - 1)%2) ? .5 : 0);
				ctx.font = AAX.ui.font;
				ctx.textAlign = "left";
				ctx.textBaseline = "middle";
				for(i1 in buttons) {
					loop.tick(1);
					if(buttons.hasOwnProperty(i1)) {
						let prefix = PreSuf.get(i1);
						let suffix = prefix[1];
						prefix = prefix[0];
						//let prefix = i1.includes("_") ? i1.slice(0, i1.indexOf("_")) : i1;
						//let suffix = i1.slice(prefix.length + 1);
						let text = (
							suffix === "heading" ? (
								prefix === "posetool" ? "pose tools" :
								prefix === "hide" ? "hide/show" :
								prefix === "switch" ? "part artist".split(" ") :
								prefix === "frame" ? "frames" :
								prefix === "partinfo" ? "part information" :
								prefix === "drawsettings" ? "draw settings" :
								prefix
							) :
							prefix === "misc" ? (
								suffix === "autoperspective" ? "automate perspective coordinates".split(" ") :
								suffix === "clearimage" ? "clear image".split(" ") :
								suffix === "editshape" ? "edit shape".split(" ") :
								suffix === "stretch_widen" ? "stretch /widen".split(" ") :
								suffix === "rerendershape" ? "rerender shape".split(" ") :
								null
							) :
							(prefix === "hide" && suffix.includes("_minus_")) ? suffix.replaceAll("_minus_", "-") :
							i1 === "switch" ? " switch ".split(" ") :
							i1 === "switch_no_export" ? "switch without export".split(" ") :
							prefix === "drawsettings" ? (
								suffix === "background" ? aa.drawsettings[suffix] :
								suffix === "cell" ? "cell w: h:".split(" ") :
								(suffix === "grid" || suffix === "standpoint" || suffix === "range" || suffix === "fineness") ? suffix + ":" :
								suffix === "vp" ? "vp x: y:".split(" ") :
								suffix === "camera" ? "camera xz: yz:".split(" ") :
								null
							) :
							i1 === "title" ? ("armature artist " + aa.version) :
							i1 === "projectname" ? aa.control.projectname :
							i1 === "states_limit" ? "limit: truncator:".split(" ") :
							null
						);
						text ??= (!suffix ? prefix : suffix).replaceAll("_", " ");
						let right_text = (
							prefix === "drawsettings" ? (
								suffix === "cell" ? ["", aa.drawsettings.cell.w, aa.drawsettings.cell.h] :
								suffix === "grid" ? aa.drawsettings.grid.join(",") :
								suffix === "standpoint" ? [
									(aa.drawsettings.standpoint.x - aa.drawsettings.cell.w/2),
									(aa.drawsettings.standpoint.y - aa.drawsettings.cell.h/2)
								].join(", ") :
								suffix === "vp" ? [
									"",
									(aa.drawsettings.vp.x - aa.drawsettings.standpoint.x),
									(aa.drawsettings.vp.y - aa.drawsettings.standpoint.y)
								] :
								suffix === "range" ? aa.drawsettings.range :
								suffix === "camera" ? [
									"",
									Math.round(Angle.convert(aa.drawsettings.camera.xz)),
									Math.round(Angle.convert(aa.drawsettings.camera.yz))
								] :
								suffix === "fineness" ? aa.drawsettings[suffix] :
								null
							) :
							i1 === "states_limit" ? [aa.states_limit, aa.states_truncator] :
							null
						);
						right_text ??= "";
						if(prefix === "inbetween") {
							let ref = aa.control.inbetween;
							text = (
								suffix === "heading" ? "inbetweens" :
								suffix === "add" ? "+" :
								suffix === "subtract" ? "-" :
								suffix === "number" ? ref.number :
								suffix === "curve" ? (ref.curve < 0 ? "?" : "^") + roundspecial(Math.abs(ref.curve), -5) :
								suffix === "easeA" || suffix === "easeB" ? (
									suffix === "easeB" && ref.easeA === ref.easeB ? "" :
									ref[suffix] ? "out" : "in"
								) :
								suffix === "create" ? "create inbetweens".split(" ") :
								suffix === "apply" ? "apply tweening".split(" ") :
								""
							);
							if(!text && suffix !== "visual" && suffix !== "easeB") {
								console.log("this shouldn't happen");
							}
						}
						if(Array.isArray(text)) {
							for(i2 = 0; i2 < text.length; i2++) {
								text[i2] += "";
							}
						}
						else {
							text += "";
						};
						// make sure it isn't a number, so it can use .length
						let selected = Number(
							(prefix === "posetool" && suffix === aa.control.posetool)
							||
							(prefix === "oddify" && (
									aa.control.perspectived
									?
									["x", "y"].includes(suffix) && image_oddness["xy".indexOf(suffix)]
									:
									["x", "y", "z"].includes(suffix) && oddness["xyz".indexOf(suffix)]
								)
							)
							||
							(prefix === "invert" && ["x", "y", "z"].includes(suffix) && relcoor["xyz".indexOf(suffix)] < 0)
							||
							(prefix === "view" && aa.control.view === Number(suffix))
							||
							(
								prefix === "drawsettings"
								&&
								aa.drawsettings.hasOwnProperty(suffix)
								&&
								typeof aa.drawsettings[suffix] === "boolean"
								&&
								aa.drawsettings[suffix]
							)
							||
							(prefix === "hide" && suffix !== "heading" && aa.ishidden(aa.control.partname, suffix))
							||
							(
								prefix === "inbetween"
								&&
								(suffix === "easeA" || suffix === "easeB")
								&&
								aa.control.inbetween[suffix]
							)
							//||
							//i1 === "projectname"
						);
						if(prefix === "drawsettings" && AAX.valid.hasOwnProperty(suffix)) {
							selected = AAX.valid[suffix].indexOf(aa.drawsettings[suffix]);
						}
						else if(suffix === "heading") {
						}
						else if(
							(prefix === "invert" && ["x", "y", "z"].includes(suffix) && relcoor["xyz".indexOf(suffix)] === 0)
							||
							(prefix === "posetool" && selected && aa.control.posetool_inversion)
							||
							(aa.control.perspectived && prefix === "oddify" && suffix === "z")
							// 2 in this instance means "not applicable"
							||
							(prefix === "hide" && aa.hidelist(aa.control.partname, suffix).length === 0)
							//||
							//(prefix === "inbetween" && suffix === "easeB" && aa.control.inbetween.easeA === aa.control.inbetween.easeB)
							||
							i1 === "title"
						) {
							selected = 2;
						};
						if(depress && i1 === depress) {
							selected = posmod(selected + 1, 3);
						};
						let ref = buttons[i1];
						let center = [Math.floor(ref.x + ref.w/2) + .5, Math.floor(ref.y + ref.h/2)];
						ctx.strokeStyle = color[ posmod(- selected, color.length) ];
						ctx.fillStyle = color[ posmod(1 - selected, color.length) ];
						if(prefix !== "color" && suffix !== "heading" && i1 !== "anim_menu") {
							ctx.fillRect(ref.x, ref.y, ref.w, ref.h);
							Rect.fauxstroke(ref, ctx);
						};
						//console.log([prefix, suffix]);
						let align = (
							(Array.isArray(text) && prefix !== "drawsettings" && prefix !== "states")
							||
							(suffix === "heading" && prefix !== "partinfo")
							||
							(prefix === "states" && (suffix === "undo" || suffix === "redo"))
							||
							["view", "save", "load"].includes(prefix)
							||
							(prefix === "inbetween" && (suffix === "add" || suffix === "subtract" || suffix === "number"))
						);
						align = align ? "center" : "left";
						if(prefix === "partinfo" && suffix !== "heading") {
							ctx.fillStyle = ctx.strokeStyle;
							const nondefault = "!";
							// character to use for these
							// - everything gets an space before it if it's
							//   "default", or an exclamation point if it isn't.
							let _default = aa.partinfo_is_default(part, view, suffix);
							const digits = 5;
							function convertnumber(num, addsign) {
								let text = "" + num;
								if(addsign && Math.sign(num) === 1) {
									text = "+" + text;
								};
								text += ".0".repeat(!text.includes("."));
								let index = text.indexOf(".");
								if(index > digits) {
									text = text.slice(index - digits);
								}
								else if(index < digits) {
									text = " ".repeat(digits - index) + text;
								};
								return text;
							};
							// numbers always have .0 or .5, and if the left
							// digits plus sign are longer than 5, they get
							// cut off. spaces are added if it's shorter, so
							// it's always the same length.
							if(suffix === "coor") {
								text = [
									(_default ? " " : nondefault) + "relative coordinates",
									null,
									" absolute coordinates",
									null,
									" hypotenuse:",
									" default:"
								];
								let relcoor = part.relcoor;
								let abscoor = part.abscoor;
								for(i2 = 0; i2 < 3; i2++) {
									loop.tick(2);
									relcoor[i2] = convertnumber(relcoor[i2], true);
									abscoor[i2] = convertnumber(abscoor[i2], false);
								}
								loop.end();
								text[1] = relcoor.join(" ");
								text[3] = abscoor.join(" ");
								for(i2 = 0; i2 < text.length; i2++) {
									loop.tick(2);
									ctx.textAlign = ([1, 3].includes(i2) ? "center" : "left");
									const x = (ctx.textAlign === "center" ? center[0] : ref.x + margin[0]);
									const y = Math.floor(ref.y + ref.h*(i2 + .5)/text.length + margin[1]);
									ctx.fillText(text[i2], x, y);
									if([4, 5].includes(i2)) {
										ctx.textAlign = "right";
										let string = "" + (i2 === 4 ? Math.hypot(...part.relcoor) : AAX.hypot(part.body, part.pose, part.name));
										if(!string.includes(".")) {
											string += " ".repeat(1 + 2);
										}
										else {
											let num = string.length - (string.indexOf(".") + 1);
											// number of decimal places
											num = 2 - num;
											// -1 is one too many, +1 is one too
											// few
											if(num > 0) {
												string += " ".repeat(num);
											}
											else if(num < 0) {
												string = string.slice(0, num);
											};
										}
										ctx.fillText(
											string,
											ref.x + ref.w - margin[0],
											y
										);
									};
								};
								loop.end();
								ctx.textAlign = "left";
							}
							else if(suffix === "connection" || suffix === "shape_settings") {
								if(suffix === "connection") {
									let num = part[suffix].value;
									let type = part[suffix].type;
									if(type === "generation") {
										let array = structuredClone(num);
										if(num[0] === 0) {
											num = num[1];
										}
										else if(num[1] === 0) {
											num = -num[0];
										}
										else {
											num = null;
										}
										// [1, 0] = -1, [0, 1] = 1
										text = [
											(_default ? " " : nondefault) + array + " " + type + " connection" + (num !== null ? ":" : ""),
											" " + (
												num === -2 ? "connect back to grandparent" :
												num === -1 ? "connect to parent" :
												num === 0 ? "no connection" :
												num === 1 ? "connect to children" :
												num === 2 ? "connect up to grandchildren" :
												num > 0 ? "connect to next " + num + " generations" :
												num < 0 ? "connect " + num + " generations back" :
												""
											)
										];
									}
									else {
										text = [
											(_default ? " " : nondefault) + part[suffix].type + " connection:",
											" " + num,
										];
									}
								}
								else if(suffix === "shape_settings") {
								// two lines, and a circle on the right showing the
								// orient.
									text = [
										(_default ? " " : nondefault) + "stretch:",
										" widen:"
									];
									const sphere = {};
									sphere.r = Math.floor((Math.min(ref.w, ref.h) - margin[0])/2);
									sphere.x = ref.x + ref.w - (sphere.r + margin[0]);
									sphere.y = Math.floor(ref.y + ref.h/2);
									// sphere the orient will be visualized in
									let basis = Quat.basis(part.orient);
									basis[0][3] = "x";
									basis[1][3] = "y";
									basis[2][3] = "z";
									basis.sort((a, b) => a[2] - b[2]);
									// z sort
									const styletemp = [ctx.fillStyle, ctx.strokeStyle];
									//ctx.fillStyle = aa.color.buttons[2];
									//circledraw(ctx, sphere.x, sphere.y, sphere.r, true);
									for(i2 = 0; i2 < 3; i2++) {
										loop.tick(2);
										ctx.strokeStyle = ["red", "green", "blue"]["xyz".indexOf(basis[i2][3])];
										linespecial(ctx,
											sphere.x,
											sphere.y,
											sphere.x + sphere.r*basis[i2][0],
											sphere.y + sphere.r*basis[i2][1],
											[sphere.x, sphere.y]
										);
									};
									loop.end();
									//ctx.strokeStyle = aa.color.buttons[0];
									ctx.strokeStyle = aa.color.buttons[2];
									circledraw(ctx, sphere.x, sphere.y, sphere.r, false);
									ctx.fillStyle = styletemp[0];
									ctx.strokeStyle = styletemp[1];
									// draw orient sphere
									ctx.textAlign = "right";
									for(i2 = 0; i2 < 2; i2++) {
										loop.tick(2);
										ctx.fillText(
											convertnumber(part[i2 ? "widen" : "stretch"]),
											ref.x + ref.w - 2*(sphere.r + margin[0]),
											// make room for the orient sphere
											Math.floor(ref.y + ref.h*(i2 + .5)/2 + margin[1])
										);
									}
									loop.end();
									ctx.textAlign = "left";
								}
								for(i2 = 0; i2 < text.length; i2++) {
									loop.tick(2);
									ctx.fillText(
										text[i2],
										ref.x + margin[0],
										Math.floor(ref.y + ref.h*(i2 + .5)/text.length + margin[1])
									);
								};
								loop.end();
							}
							else {
							// properties that aren't too complex for a simple
							// text + ":" + value structure...
								let value = null;
								if(suffix === "silhouette") {
									text += " group";
									value = part[suffix].join("");
								}
								else if(suffix === "name") {
									text = part[suffix];
									value = "";
								}
								else if(suffix === "colors") {
									value = [part.bodyref.color1, part.bodyref.color2].join(", ");
								}
								else if(suffix === "image") {
									let temp = [
										(_default ? part.bodyref.image.front : part._image.front) !== null,
										(_default ? part.bodyref.image.right : part._image.right) !== null,
									]
									value = (
										temp[0]
										?
										// front exists
										(temp[1] ? "both" : "front")
										:
										// right exists
										(temp[1] ? "right" : "none")
									);
								}
								else if(suffix === "perspective_coor") {
									value = part["perspective_coor_" + view].join(", ");
									if((_default ? part.bodyref.perspective.coor[view] : part._perspective.coor[view]) === "auto") {
										value = "(auto) " + value;
									};
								}
								else if(suffix === "perspective_image") {
									text += " " + view;
									value = (
										(_default ? part.bodyref.perspective[view] : part._perspective[view]) === null
										?
										"absent"
										:
										""
									);
								}
								else if(suffix === "hide") {
									value = part[suffix] ? "on" : "off";
								}
								else if(suffix === "shape") {
									value = "";
								}
								else {
									console.log("there are partinfo properties the logic doesn't account for. (" + suffix + ")");
								};
								if(!["name", "shape", "perspective_image"].includes(suffix) || (suffix === "perspective_image" && value)) {
									text += ":";
								};
								// coor, connection: special code
								// name
								// - omit suffix + ":"
								// - center the value
								// colors
								// - needs to use integer colors, which requires bodyref
								// - needs to be be joined with a space
								// image
								// - no value
								// - no colon
								// perspective coor
								// - need to add the view number
								// - need to check if it's auto
								// perspective image
								// - no value unless it's null
								// - no colon unless it's null
								ctx.fillText((_default ? " " : nondefault) + text, ref.x + margin[0], center[1] + margin[1]);
								ctx.textAlign = "right";
								ctx.fillText(value, ref.x + ref.w - margin[0], center[1] + margin[1]);
								ctx.textAlign = "left";
							};
						}
						else if(prefix === "frame" && ["previous", "next"].includes(suffix)) {
							const w = (suffix === "previous" ? -1 : 1)*ref.w/2;
							const h = ref.h*1/2;
							const points = [
								[
									center[0] - w/2,
									center[1] - h/2,
								],
								[
									center[0] + w/2,
									center[1],
								],
								[
									center[0] - w/2,
									center[1] + h/2,
								]
							];
							_2dPoly.linespecial(ctx, points, center);
						}
						else if(prefix === "frame" && suffix === "display") {
							linespecial(ctx,
								center[0] - ref.w*3/8,
								center[1],
								center[0] + ref.w*3/8,
								center[1],
							center);
							ctx.fillStyle = ctx.strokeStyle;
							const coor = [
								center[0] - 1,
								Math.floor(ref.y + ref.h/4 + margin[1])
							];
							ctx.fillText(aa.currframe + 1, ...coor);
							coor[1] = Math.floor(coor[1] + ref.h/2);
							ctx.fillText(aa.frames.length, ...coor);
						}
						else if(prefix === "color") {
							let num = Number( suffix.slice(suffix.lastIndexOf("_") + 1) );
							if(suffix.includes("_") && !isNaN(num)) {
							// one index of a non-variable length array
								ctx.fillStyle = aa.color[suffix.split("_").slice(0, -1).join("_")][num];
								ctx.fillRect(ref.x, ref.y, ref.w, ref.h);
							}
							else if(Array.isArray(aa.color[suffix])) {
							// variable length array
								for(i2 = 0; i2 < aa.color[suffix].length; i2++) {
									loop.tick(2);
									ctx.fillStyle = aa.color[suffix][i2];
									ctx.fillRect(
										ref.x,
										ref.y + ref.h*i2/aa.color[suffix].length,
										ref.w,
										ref.h/aa.color[suffix].length
									);
								}
								loop.end();
							}
							else {
							// single color
								ctx.fillStyle = aa.color[suffix];
								ctx.fillRect(ref.x, ref.y, ref.w, ref.h);
							}
							Rect.fauxstroke(ref, ctx);
						}
						else if(suffix !== "heading" && ["oddify", "invert", "image"].includes(prefix)) {
							ctx.fillStyle = ctx.strokeStyle;
							ctx.textAlign = "center";
							ctx.fillText(suffix, center[0], center[1] + margin[1]);
							ctx.textAlign = "left";
						}
						else if(prefix === "inbetween" && suffix === "visual") {
							let start = ref.x + ref.h/2;
							let end = ref.x + ref.w - ref.h/2;
							ctx.strokeStyle = color[2];
							linespecial(ctx, start, center[1], end, center[1], center);
							for(i2 = 0; i2 <= 1; i2 += 1/4) {
								let x = start + i2*(end - start);
								let tick = i2 === 0 || i2 === 1 ? 3 : i2 === .5 ? 2 : 1;
								linespecial(ctx, x, center[1] - tick, x, center[1] + tick, center);
							}
							ctx.fillStyle = color[0];
							let ref2 = aa.control.inbetween;
							ref2.values = aa.inbetweenvalues(ref2.number, ref2.curve, ref2.easeA, ref2.easeB);
							circledraw(ctx, start + .5, center[1] + .5, 2.5, true);
							for(i2 = -1; i2 <= ref2.values.length; i2++) {
								circledraw(ctx, start + ref2.values[i2]*(end - start) + .5, center[1] + .5, 2.5, true);
							}
							circledraw(ctx, end + .5, center[1] + .5, 2.5, true);
						}
						else if(i1 === "title") {
							ctx.fillStyle = color[0];
							for(i2 = -1; i2 <= 1; i2++) {
								for(i3 = -1; i3 <= 1; i3++) {
									ctx.fillText(text, ref.x + margin[0] + i2, center[1] + margin[1] + i3);
								}
							}
							ctx.fillStyle = color[1];
							ctx.fillText(text, ref.x + margin[0], center[1] + margin[1]);
						}
						else if(prefix === "anim" && suffix === "menu") {
							ctx.fillStyle = color[2];
							ctx.fillRect(ref.x, ref.y + Math.floor(ref.h/2), ref.w, 1);
							let tabwidth = Math.min(aa.ui.animtabwidth*AAX.ui.block, ref.w/aa.anims.length);
							let divides = [];
							for(i2 = 0; i2 <= aa.anims.length; i2++) {
								divides[i2] = Math.floor(i2*tabwidth);
							}
							for(i2 = 0; i2 <= aa.anims.length; i2++) {
								if(i2 !== aa.anim_index) {
									let index = i2 === aa.anims.length ? aa.anim_index : i2;
									// make sure the selected tab is drawn last
									let rect = [ref.x + divides[index], ref.y, divides[index + 1] - divides[index], ref.h];
									let style = i2 === aa.anims.length ? 2 : 0;
									style = [
										color[posmod(style + 0, 3)],
										color[posmod(style + 2, 3)]
									];
									ctx.fillStyle = style[0];
									ctx.strokeStyle = style[1];
									ctx.fillRect(...rect);
									Rect.fauxstroke(Rect.new(...rect), ctx);
									let name = aa.getanimname(index);
									let width = margin[0] + (charwidth + 1)*name.length;
									// how wide the tab has to be to fit the
									// name
									let ellipses = false;
									// whether to draw an ellipses after it
									if(width > tabwidth) {
										if(margin[0] + 6 > tabwidth) {
										// even an ellipse wouldn't fit, just
										// make it blank.
											name = "";
										}
										else {
										// cut it off with an ellipses
											name = name.slice(0, Math.floor((tabwidth - (margin[0] + 6))/(charwidth + 1)));
											width = margin[0] + (charwidth + 1)*name.length;
											ellipses = true;
										}
									}
									ctx.fillStyle = style[1];
									ctx.fillText(name, ref.x + divides[index] + margin[0], center[1] + margin[1]);
									if(ellipses) {
										for(i3 = 0; i3 < 3; i3++) {
											ctx.fillRect(ref.x + divides[index] + width + 2*i3, center[1] + 0*margin[1], 1, 1);
											// adding margin would put it right
											// at the level of a normal period
											// but i like it better in the
											// middle. i think dragon quest 3
											// drew them like that, and it makes
											// it look less like text.
										}
									}
								}
							}
						}
						else {
							ctx.fillStyle = ctx.strokeStyle;
							ctx.textAlign = align;
							if(Array.isArray(text)) {
								const start_y = Math.floor(center[1] - lineheight*(text.length - 1)/2 + margin[1]);
								for(i2 = 0; i2 < text.length; i2++) {
									const start_x = text_x(ref, align, text[i2]);
									const right_edge = text_x(ref, "right", right_text[i2]);
									loop.tick(2);
									const coor = [
										start_x,
										start_y + i2*lineheight
									];
									ctx.fillText(
										text[i2],
										...coor
									);
									if(right_text || right_text === 0) {
										ctx.textAlign = "right";
										ctx.fillText(
											right_text[i2],
											right_edge,
											coor[1]
										);
										ctx.textAlign = align;
									};
								};
								loop.end();
							}
							else {
								ctx.fillText(text, text_x(ref, align, text), center[1] + margin[1]);
								if(right_text || right_text === 0) {
									ctx.textAlign = "right";
									ctx.fillText(
										right_text,
										text_x(ref, "right", right_text),
										center[1] + margin[1]
									);
								};
							};
							ctx.textAlign = "left";
						};
					}
				};
				loop.end();
			},
			action: function(button, shift, ctrl, click) {
			// do whatever action the indicated button name does. can run both
			// from clicks or keys.
			// - shift: indicates that the shift key was held, or the click was
			//   a doubleclick.
			// - ctrl: indicates that ctrl was held. not sure if i'll use this
			//   though.
			// - click: coordinates of the click. (relative to the canvas, not
			//   the button.)
				let i1 = 0;
				let i2 = 0;
				let prefix = PreSuf.get(button);
				let suffix = prefix[1];
				prefix = prefix[0];
				//let prefix = button.includes("_") ? button.slice(0, button.indexOf("_")) : button;
				//let suffix = button.slice(prefix.length + 1);
				let refresh = {};
				let loop = new Loop("aa.ui.action");
				for(i1 = 0; i1 < AAX.valid.refresh.length; i1++) {
					loop.tick(1);
					refresh[AAX.valid.refresh[i1]] = true;
				}
				loop.end();
				refresh.states = false;
				// an object of booleans for which refresh actions to perform.
				// by default, it's everything but states.
				// - switch, switch without export: skip draw and ui (unless the switch is
				//   happening in the part artist.)
				// - frame actions: don't skip states
				//   - previous/next
				//   - duplicate
				//   - delete
				//   - move up
				//   - move down
				//   =
				//   - move up/down could skip draw
				//   - previous/next could skip states
				// - view buttons, family selection keys, partinfo_name: skip draw
				// - pose tool switches (including up/down): skip draw (unless if the new
				//   tool or old tool is perspective.)
				// - oddify, invert, other partinfo, automate perspective coordinates:
				//   don't skip states
				let no_refresh = (
					(prefix === "states" && (suffix === "undo" || suffix === "redo"))
					||
					["switch", "save", "load"].includes(prefix)
					||
					suffix === "heading"
					||
					["misc_editshape", "inbetween_visual", "title"].includes(button)
				);
				// switch means changing to the part artist, so a refresh
				// wouldn't be seen. (and the switch button over there runs
				// refresh, so you're fine.) undo/redo/save/load either don't
				// need a refresh or run it in their respective functions. and
				// headings and displays don't do anything.
				// - misc_editshape just opens a <dialog>, and the buttons in
				//   there are what cause edits.
				const part = aa.control.part;
				const view = aa.control.view;
				if(!aa.ui.buttons.hasOwnProperty(button)) {
				// it's not like these have to be separate, i just wanna group
				// all key-only actions in the same place.
					if(["previous", "next"].includes(suffix)) {
						let index = null;
						let remainder = null;
						if(prefix === "posetool") {
							index = AAX.valid.posetools.indexOf(aa.control.posetool);
							remainder = AAX.valid.posetools.length;
						}
						else if(prefix === "view") {
							index = aa.control.view;
							remainder = 4;
						};
						if(index === null || remainder === null) {
							console.log("this shouldn't happen, or there's button-only actions i forgot to write.");
						};
						if(suffix === "next") {
							index++;
						}
						else if(suffix === "previous") {
							index--;
						};
						index = posmod(index, remainder);
						if(prefix === "posetool") {
							refresh.draw = (aa.control.posetool === "perspective") !== (AAX.valid.posetools[index] === "perspective");
							aa.control.posetool = AAX.valid.posetools[index];
						}
						else if(prefix === "view") {
							aa.control.view = index;
							refresh.draw = false;
						}
						else {
							no_refresh = true;
						};
					}
					else if(prefix === "select") {
					// lets you select the parent of the current part, the first
					// child, or cycle through siblings.
						if(suffix === "parent") {
							if(part.parent !== "standpoint") {
								aa.control.partname = part.parent;
							};
						}
						else if(suffix === "child") {
							let array = AAX.getchildren(aa.currpose, part.name);
							if(array.length >= 1) {
								aa.control.partname = array[0];
							};
						}
						else {
							let array = AAX.getchildren(aa.currpose, part.parent);
							let index = array.indexOf(part.name);
							if(suffix === "prevsibling") {
								index--;
							}
							else if(suffix === "nextsibling") {
								index++;
							}
							else {
								console.log("this shouldn't happen");
								return;
							};
							aa.control.partname = array[posmod(index, array.length)];
						};
						refresh.draw = false;
					}
					else if(button === "posetool_invert") {
						aa.control.posetool_inversion = !aa.control.posetool_inversion;
						refresh.draw = false;
					}
					else {
						no_refresh = true;
						console.log("this shouldn't happen, or there's button-only actions i forgot to write.");
					};
				}
				else if(suffix === "heading") {
				}
				else if(prefix === "posetool") {
					refresh.draw = (aa.control.posetool === "perspective") !== (suffix === "perspective");
					if(aa.control.posetool === suffix) {
						aa.control.posetool_inversion = !aa.control.posetool_inversion;
					}
					else {
						aa.control.posetool = suffix;
					};
				}
				else if(button === "switch") {
					const ref = aa.pa.part;
					ref.color1 = part.color1;
					ref.color2 = part.color2;
					if(aa.control.perspectived) {
					// export only the image of the view you have selected.
						const right = !!(view%2);
						const _old_w = ref.dim(!right)[0];
						// width of the image not being replaced. (need to
						// remember it for changedimensions later.)
						let new_image = structuredClone(part["perspective_" + view]);
						let oddness = part.image_oddness(view);
						ref.size = Math.max(
							AAX.sq_raster.cropsize(ref[!right ? "right" : "front"], [ref.oddness[!right ? 2 : 0], ref.oddness[1]], true),
							// image not being replaced
							AAX.sq_raster.cropsize(new_image, oddness, true)
							// new image
						);
						// expand the size if it's too small for both images to
						// fit and rotate freely
						ref.oddness[right ? 2 : 0] = oddness[0];
						ref.oddness[1] = oddness[1];
						// apply changes to .oddness
						// - NOTE since oddness can be different per view,
						//   exporting multiple perspective views at once could
						//   cause dimensional inconsistencies.
						ref[right ? "right" : "front"] = Raster.redimension(
							new_image,
							//part.dim(view)[0],
							part.dim(view, new_image.length)[0],
							...ref.dim(right)
						);
						ref[!right ? "right" : "front"] = Raster.redimension(
							ref[!right ? "right" : "front"],
							_old_w,
							...ref.dim(!right)
						);
						// make sure both images conform to the new dimensions.
					}
					else {
					// export both unperspectiveds
						ref.front = part.image_front;
						ref.right = part.image_right;
						const old_w = [
							part.dim("front", ref.front.length)[0],
							part.dim("right", ref.right.length)[0]
						];
						ref.oddness = structuredClone(part.oddness);
						ref.size = Math.max(
							AAX.sq_raster.cropsize(ref.front, [ref.oddness[0], ref.oddness[1]], true),
							AAX.sq_raster.cropsize(ref.right, [ref.oddness[2], ref.oddness[1]], true)
						);
						ref.front = Raster.redimension(
							ref.front,
							old_w[0],
							...ref.dim(false)
						);
						ref.right = Raster.redimension(
							ref.right,
							old_w[1],
							...ref.dim(true)
						);
					};
					aa.pa.redraw();
					aa.editmodetoggle();
				}
				else if(button === "switch_no_export") {
					aa.editmodetoggle();
				}
				else if(prefix === "oddify") {
					let part = aa.control.part;
					let axis = suffix;
					if(aa.control.perspectived) {
						if(axis !== "z") {
							const view = aa.control.view;
							let temp = structuredClone(part["perspective_coor_" + view]);
							const index = "xy".indexOf(axis);
							temp[index] = Math.floor(temp[index]) + !(temp[index]%1)*.5;
							// change the oddness of that axis
							part["perspective_coor_" + view] = structuredClone(temp);
							// you have to set both at once, or the setter won't
							// run.
							refresh.states = true;
						};
					}
					else {
						let oddify = part.oddify(axis);
						// new relative coordinates.
						// - looks at the current relative coordinates, changes the
						//   oddness of the specified axis, and returns whatever
						//   relative coordinates are within 1 in each axis to how it
						//   was before, while still fitting in the hypotenuse.
						part.x = oddify[0];
						part.y = oddify[1];
						part.z = oddify[2];
						refresh.states = true;
					}
				}
				else if(prefix === "invert") {
					let desc = aa.control.part.descendants;
					refresh.states = false;
					for(i1 = 0; i1 < desc.length; i1++) {
						let partname = i1 === -1 ? aa.control.partname : desc[i1];
						refresh.states = refresh.states || aa.currpose[partname] !== 0;
						aa.currpose[partname][suffix] *= -1;
					}
				}
				else if(prefix === "frame") {
					refresh.states = true;
					if(suffix === "previous" || suffix === "next") {
						aa.currframe = posmod(aa.currframe + (suffix === "previous" ? -1 : suffix === "next" ? 1 : 0), aa.frames.length);
						refresh.states = false;
					}
					else if(suffix === "display") {
						let num = Number(prompt(`which frame do you want to switch to?`)) - 1;
						if(Number.isInteger(num) && num >= 0 && num < aa.frames.length) {
							aa.currframe = num;
						}
						refresh.states = false;
					}
					else if(["blank", "duplicate"].includes(suffix)) {
						aa.frames.splice(aa.currframe + 1, 0, (suffix === "duplicate" ? aa.frameclone(aa.currframe) : aa.newpose()));
						aa.currframe++;
						// splice it into the position after this one, and
						// switch to it.
					}
					else if(suffix === "delete") {
						if(aa.frames.length === 1) {
						// clear the pose instead
							aa.frames.splice(aa.currframe, 1, aa.newpose());
						}
						else {
							aa.frames.splice(aa.currframe, 1);
							aa.currframe--;
						};
					}
					else if(["move_up", "move_down"].includes(suffix)) {
						let newframe = aa.currframe + (suffix === "move_up" ? 1 : suffix === "move_down" ? -1 : 0);
						if(newframe >= 0 && newframe < aa.frames.length) {
							let temp = aa.frames[aa.currframe];
							aa.frames.splice(aa.currframe, 1);
							aa.frames.splice(newframe, 0, temp);
							aa.currframe = newframe;
							refresh.draw = false;
						}
						else {
							no_refresh = true;
						};
					};
					aa.clampframe();
					// make sure it isn't out of bounds.
				}
				else if(prefix === "view") {
					aa.control.view = Number(suffix);
					refresh.draw = false;
				}
				else if(prefix === "misc") {
					if(suffix === "autoperspective") {
						let choice = prompt(`automate perspective for the part, frame, or all frames? (add "(one view)" to only do this for one view.)`);
						if(choice) {
							const one_view = choice.includes("(one view)");
							if(one_view) {
								choice = choice.replace("(one view)", "");
							};
							choice = choice.trim();
							function automate(frame, part, view) {
								if(one_view) {
									aa.frames[frame][part]._perspective.coor[aa.control.view] = "auto";
								}
								else {
									let i1 = 0;
									let loop = new Loop("aa.ui.action automate");
									for(i1 = 0; i1 < 4; i1++) {
										loop.tick(1);
										aa.frames[frame][part]._perspective.coor[i1] = "auto";
									}
									loop.end();
								};
							};
							refresh.states = true;
							if(choice === "part") {
								automate(aa.currframe, aa.control.partname);
							}
							else if(["frame", "all frames"].includes(choice)) {
								for(i1 = 0; i1 < aa.frames.length; i1++) {
									loop.tick(1);
									if(choice === "all frames" || i1 === aa.currframe) {
										for(i2 in aa.currpose) {
											loop.tick(2);
											if(aa.currpose.hasOwnProperty(i2)) {
												automate(i1, i2);
											};
										}
										loop.end();
									};
								}
								loop.end();
							}
							else {
								alert(`invalid choice. it must be "part", "frame", or "all frames".`);
								refresh.states = false;
							};
						}
					}
					else if(suffix === "clearimage") {
						refresh.states = true;
						if(aa.control.perspectived) {
							part._perspective[view] = null;
						}
						else {
							part._image.front = null;
							part._image.right = null;
						};
					}
					else if(suffix === "editshape") {
						document.getElementById("aa_editshape_dialog").showModal();
					}
					else if(suffix === "stretch_widen") {
						refresh.states = true;
						let input = prompt([
							`enter two numbers for stretch/widen, separated by a comma.`,
							`stretch stretches the 3d shape along the line to the part's parent, widen expands it in the other directions.`,
							`enter a single number to set both at once.`,
							`enter a single number with a comma after to only change the stretch, and a number with a comma before to only change widen.`
						].join("\n\n"));
						let valid = input !== null;
						if(valid) {
							input = input.trim();
							if(input.includes(",")) {
								input = input.split(",");
								input = [
									AAX.strings.float(input[0]),
									AAX.strings.float(input[1])
								];
								if(input[0] === null && input[1] === null) {
									valid = false;
								}
								else {
									if(input[0] !== null) {
										part.stretch = input[0];
									};
									if(input[1] !== null) {
										part.widen = input[1];
									};
								};
							}
							else {
								input = AAX.strings.float(input);
								if(input === null) {
									valid = false;
								}
								else {
									part.stretch = input;
									part.widen = input;
								};
							};
						};
						if(!valid) {
							refresh.states = false;
						};
					}
					else if(suffix === "rerendershape") {
						part.clearcache("orientedshape");
						refresh.ui = false;
					};
				}
				else if(prefix === "partinfo" && suffix === "name") {
					let hidden = [];
					for(i1 in aa.currpose) {
						loop.tick(1);
						if(aa.currpose.hasOwnProperty(i1) && aa.currpose[i1].hide) {
							hidden[hidden.length] = i1;
						}
					}
					loop.end();
					let select = prompt("enter a part name to select." + (hidden.length ? " (hidden parts: " + hidden.join(", ") + ")" : ""));
					if(aa.currpose.hasOwnProperty(select)) {
						aa.control.partname = select;
						refresh.draw = false;
					}
					else if(select) {
						alert("invalid part name.");
					};
				}
				else if(prefix === "partinfo") {
					const part = aa.control.part;
					const view = aa.control.view;
					let temp = suffix.replaceAll("_", " ");
					if(temp.endsWith("coor")) {
						temp += "dinates";
					};
					if(!aa.partinfo_is_default(part, view, suffix) && confirm("reset " + temp + " to default?")) {
					// reset to default
						if(["hide", "connection", "silhouette", "shape"].includes(suffix)) {
							part[suffix] = "default";
						}
						else if(suffix === "coor") {
							part.x = "default";
							part.y = "default";
							part.z = "default";
						}
						else if(suffix === "image") {
							part[suffix + "_front"] = "default";
							part[suffix + "_right"] = "default";
						}
						else if(suffix === "perspective_coor") {
							part["perspective_coor_" + view] = "default";
						}
						else if(suffix === "perspective_image") {
							part["perspective_" + view] = "default";
						}
						else if(suffix === "shape_settings") {
							part.orient = Quat.new();
							part.stretch = 1;
							part.widen = 1;
						}
						else if(!["name", "colors"].includes(suffix)) {
							console.log("this button is unaccounted for in the ui.action partinfo logic.")
						};
						refresh.states = true;
					};
				}
				else if(prefix === "drawsettings") {
					let valid = true;
					if(["cell", "standpoint", "vp", "camera", "grid", "fineness"].includes(suffix)) {
						let prompttext = null;
						if(suffix === "cell") {
							prompttext = `enter the new width and height of the cell, separated by a comma.`;
						}
						else if(suffix === "standpoint") {
							prompttext = `enter two coordinates for the standpoint, separated by a comma, and relative to the center of the cell.`;
						}
						else if(suffix === "vp") {
							prompttext = `enter two coordinates for the vanishing point, separated by a comma, and relative to the standpoint point.`;
						}
						else if(suffix === "camera") {
							prompttext = `enter an xz and yz angle for it to rotate the armature by, separated by a comma, and measured in degrees.`;
						}
						else if(suffix === "grid") {
							prompttext = `enter new grid increments, separated by commas.` + String.fromCharCode(10).repeat(2) + `each number is a multiplier, so "4, 3, 7" would create lines at every 4 pixels, every 4*3 pixels, and every 4*3*7 pixels. enter 0 anywhere in the list to draw a single set of lines at the standpoint.`;
						}
						else if(suffix === "fineness") {
							prompttext = `enter the level of detail for the spheroids. basically, how many sides a circle has. higher numbers are more taxing.`;
						};
						if(suffix === "grid") {
							prompttext += String.fromCharCode(10).repeat(2) + `remember that you have to edit the grid colors to match, so that there's a color for every increment. if there's more increments than colors, the last color will be used for the extra increments, meaning no change will be visible.`;
						}
						else if(suffix === "fineness") {
							prompttext += String.fromCharCode(10).repeat(2) + `if fineness is 0, it will use an alternate algorithm that's guaranteed to be as high-detail as possible, but can be taxing if the spheroid is too big.`;
						}
						else {
							prompttext += String.fromCharCode(10).repeat(2) + `you can leave a value as it was by not typing anything in that place.`;
							// not happy with that wording.
						};
						let input = prompt(prompttext);
						if(typeof input === "string" && (input.includes(",") || ["grid", "camera", "fineness"].includes(suffix))) {
							if(suffix === "fineness") {
								input = Number(input);
								valid = Number.isInteger(Math.round(input));
								// avoid non-numbers and values like Infinity or NaN
								input = Math.round(Math.abs(input)/4)*4;
								// positive integer divisible by 4
							}
							else {
								input = input.split(",");
								for(i1 = 0; i1 < (suffix === "grid" ? input.length : 2) && valid; i1++) {
									loop.tick(1);
									if(suffix !== "grid" && (i1 >= input.length || !input[i1].trim())) {
										input[i1] = "no change";
										// this way you can set just the yz angle by typing ", 30". stuff like that.
									}
									else {
										input[i1] = Number(input[i1]);
										if(
											isNaN(input[i1])
											||
											(input[i1] < 0 && ["cell", "grid"].includes(suffix))
											||
											(input[i1] === 0 && suffix === "cell")
										) {
											valid = false;
										};
										if(suffix === "cell") {
											input[i1] = Math.round(input[i1]*2)/2;
										}
										else if(suffix !== "camera") {
											input[i1] = Math.round(input[i1]);
										};
										// no decimals allowed for most of these
									}
								}
								loop.end();
							}
							//
							if(valid) {
								if(["grid", "fineness"].includes(suffix)) {
									aa.drawsettings[suffix] = structuredClone(input);
								}
								else {
									for(i1 = 0; i1 < 2; i1++) {
										loop.tick(1);
										if(input[i1] !== "no change") {
											if(suffix === "cell") {
												let temp = aa.drawsettings.cell["wh"[i1]];
												aa.drawsettings.cell["wh"[i1]] = input[i1];
												aa.drawsettings.standpoint["xy"[i1]] = aa.drawsettings.cell["wh"[i1]]/2 + (aa.drawsettings.standpoint["xy"[i1]] - temp/2);
												aa.drawsettings.vp["xy"[i1]] = aa.drawsettings.cell["wh"[i1]]/2 + (aa.drawsettings.vp["xy"[i1]] - temp/2);
												// adjust coordinates so that these are
												// always in the same place.
											}
											else if(suffix === "standpoint") {
												let temp = aa.drawsettings.standpoint["xy"[i1]];
												aa.drawsettings.standpoint["xy"[i1]] = aa.drawsettings.cell["wh"[i1]]/2 + input[i1];
												aa.drawsettings.vp["xy"[i1]] = aa.drawsettings.standpoint["xy"[i1]] + (aa.drawsettings.vp["xy"[i1]] - temp);
												// same here.
											}
											else if(suffix === "vp") {
												aa.drawsettings.vp["xy"[i1]] = aa.drawsettings.standpoint["xy"[i1]] + input[i1];
											}
											else if(suffix === "camera") {
												input[i1] = (posmod(input[i1], 360)/360)*2*Math.PI;
												// make them radians between 0 and 2 pi
												aa.drawsettings.camera["xy"[i1] + "z"] = input[i1];
											};
										}
									}
									loop.end();
								};
							}
						}
					}
					else if(suffix === "range") {
						let input = prompt(`input a new range for the perspective.\n\ndepending on whether something is 0 degrees or 180 degrees from the vanishing point, it'll be between 0 and this many pixels away from it. smaller numbers have more curvature.\n\ntype "none" to have no perspective, just camera xz/yz.`);
						if(input === "none") {
							aa.drawsettings.range = input;
						}
						else {
							input = AAX.strings.float(input);
							if(input && input > 0) {
							// must be positive
								aa.drawsettings.range = input;
							};
						};
					}
					else if(AAX.valid.hasOwnProperty(suffix)) {
						let index = AAX.valid[suffix].indexOf(aa.drawsettings[suffix]);
						aa.drawsettings[suffix] = AAX.valid[suffix][(index + 1)%AAX.valid[suffix].length];
					}
					else if(typeof aa.drawsettings[suffix] === "boolean") {
						aa.drawsettings[suffix] = !aa.drawsettings[suffix];
					};
					if(valid) {
						if(["fineness", "vp", "range", "camera"].includes(suffix)) {
						// clear the cache
						// - fineness affects the shape, the rest affect
						//   perspective.
							let type = (
								suffix === "fineness"
								?
								"orientedshape"
								// clear .oriented and .rasterize
								:
								"rasterize perspective"
								// clear .rasterize, but only the perspective
								// views.
							);
							for(let i0 = 0; i0 <= aa.states.length; i0++) {
							// for every state,
								loop.tick(0);
								let ref = i0 === aa.states.length ? aa.frames : aa.states[i0].poseobjs;
								for(i1 = 0; i1 < ref.length; i1++) {
								// for every frame,
									loop.tick(1);
									for(i2 in ref[i1]) {
										if(ref[i1].hasOwnProperty(i2)) {
										// for every body part.
											loop.tick(2);
											AAX.clearcache(ref[i1], i2, type);
											// this isn't an AAX., so we
											// can't use the method.
										}
									}
									loop.end();
								}
								loop.end();
							}
							loop.end();
						};
					};
				}
				else if(prefix === "color") {
					let prompttext = "";
					let addendum = "\n\nenter a blank string to reset it to the default color.";
					if(["grid", "parts", "silhouette"].includes(suffix)) {
						prompttext = "enter the colors for the ";
						if(suffix === "grid") {
							prompttext += "grids";
						}
						else if(suffix === "parts") {
							prompttext += "parts";
						}
						else if(suffix === "silhouette") {
							prompttext += "silhouette groups";
						};
						prompttext += ", separated by asterisks.";
						//let temp = String.fromCharCode(10) + String.fromCharCode(9);
						let temp = " ";
						temp = " (current:" + temp + aa.color[suffix].join(" *" + temp) + ")";
						prompttext += String.fromCharCode(10).repeat(2) + temp;
						prompttext += addendum;
						let input = prompt(prompttext);
						if(typeof input === "string") {
							if(input.trim()) {
								input = input.split("*");
								for(i1 = 0; i1 < input.length; i1++) {
									loop.tick(1);
									input[i1] = input[i1].trim();
									// this is unnecessary but it bothers me.
								};
								loop.end();
								aa.color[suffix] = structuredClone(input);
							}
							else {
								aa.color[suffix] = structuredClone(AAX.Color.template[suffix]);
							}
						}
						else {
							no_refresh = true;
						};
					}
					else {
						prompttext = "enter the";
						let place = aa.color;
						let _place = AAX.Color.template;
						let name = suffix;
						if(["interface_0", "interface_1", "interface_2", "buttons_0", "buttons_1", "buttons_2"].includes(suffix)) {
							let temp = suffix.split("_");
							temp = [
								temp.slice(0, -1).join("_"),
								temp[temp.length - 1]
							];
							place = place[temp[0]];
							_place = _place[temp[0]];
							name = temp[1];
							prompttext += " " + ["primary", "secondary", "tertiary"][temp[1]] + " color for the";
							if(temp[0] === "interface") {
								prompttext += " clickable interface.";
							}
							else if(temp[0] === "buttons") {
								prompttext += " ui buttons.";
							};
						}
						else if(suffix === "side_tint") {
							prompttext += " color it tints the left/right view backgrounds in.";
						}
						else {
							prompttext += " color it draws the " + name.replaceAll("_", " ");
							if(suffix === "perspective") {
								prompttext += " lines";
							}
							else if(suffix === "part_interior") {
								prompttext += "s";
							};
							prompttext += " in.";
							// part_interior
							// nodes
							// skeleton
							// silhouette_fill
							// perspective
						};
						prompttext += " (current: " + place[name] + ")";
						prompttext += addendum;
						let color = prompt(prompttext);
						if(typeof color === "string") {
							if(color.trim()) {
								place[name] = color;
							}
							else {
								place[name] = _place[name];
							};
						}
						else {
							no_refresh = true;
						};
					}
				}
				else if(prefix === "states") {
					if(suffix === "undo" || suffix === "redo") {
						// aa.undo();
						// aa.redo();
						aa[suffix]();
					}
					else if(suffix === "limit") {
						no_refresh = true;
						refresh.ui = true;
						let value = prompt([
							`enter new numbers for the states limit and the states truncator, separated by a comma.`,
							`the state limit is how many undo/redo states it can store before it starts deleting the oldest states. you can undo that many times before you hit a wall.`,
							`the state truncator is applied when you switch away from an animation. it trims the states so that this number is the maximum undos and maximum redos kept. (ex: if the truncator is 12, it'll keep a maximum of 12 past states and a maximum of 12 future states, so up to 25 states.)`,
							`if you're having performance issues, lowering these numbers might help. for every animation, there's states, and for every state, there's frames. if you had 3 animations, 8 frames each, and with a limit of 25 and a truncator of 12, that could be 600 poses it has to store.`
						].join(`\n\n`));
						if(value) {
							value = value.split(",");
							for(i1 = 0; i1 < 2; i1++) {
								if(i1 < value.length && value[i1].trim()) {
									let num = Number(value[i1]);
									if(Number.isInteger(num) && num >= Number(!i1)) {
									// needs to be 1 or more if it's the limit,
									// 0 or more if it's the truncator. (can't
									// let the number of states be less than 1.)
										aa["states_" + (i1 ? "truncator" : "limit")] = num;
										no_refresh = false;
									}
								}
							}
						}
					}
					else {
						console.log("this shouldn't happen");
					}
				}
				else if(prefix === "save" || prefix === "load") {
					// aa.save();
					// aa.load();
					aa[prefix]();
				}
				else if(prefix === "hide") {
					const value = !aa.ishidden(aa.control.partname, suffix);
					const array = aa.hidelist(aa.control.partname, suffix);
					for(i1 = 0; i1 < array.length; i1++) {
						loop.tick(1);
						aa.currpose[ array[i1] ].hide = value;
					};
					loop.end();
					refresh.states = true;
				}
				else if(prefix === "inbetween") {
					refresh.draw = false;
					// only create affects the pose, and nothing else affects
					// the visuals like drawsettings.
					let ref = aa.control.inbetween;
					if(suffix === "add") {
						ref.number++;
					}
					else if(suffix === "subtract") {
						if(ref.number >= 2) {
							ref.number--;
						}
						else {
							no_refresh = true;
						}
					}
					else if(suffix === "number") {
						let num = prompt(`enter how many inbetweens to make.`);
						if(num === null) {
							no_refresh = true;
						}
						else {
							num = Number(num);
							if(Number.isInteger(num) && num >= 1) {
								ref.number = num;
							}
							else {
								alert(`invalid number. must be an integer greater than zero.`);
								no_refresh = true;
							};
						}
					}
					else if(suffix === "curve") {
						let num = prompt(`enter the curve factor. (2 is like square easing, 3 is like cubic, etc. look up stuff about easing. the default value is the square root of 3, which makes it very close to a sine curve.)`);
						if(num === null) {
							no_refresh = true;
						}
						else {
							num = Number(num);
							if(Number.isInteger(Math.round(num))) {
								ref.curve = num;
							}
							else {
								alert(`invalid number.`);
								no_refresh = true;
							};
						}
					}
					else if(suffix === "easeA" || suffix === "easeB") {
						ref[suffix] = !ref[suffix];
						if(suffix === "easeA") {
						// this makes a weird sort of sense.
							ref.easeB = !ref.easeB;
						}
					}
					else if(suffix === "create" || suffix === "apply") {
						refresh.draw = true;
						refresh.states = true;
						const apply = suffix === "apply";
						let values = aa.control.inbetween.values;
						if(apply && aa.frames.length < values.length + 2) {
							alert(`not counting the start and end frame, there's ` + (aa.frames.length - 2) + ` frames, but you're trying to apply tweening to ` + values.length + ` frames.`);
							no_refresh = true;
						}
						else {
							AAX.inbetweening(aa, aa.body, aa.frames, aa.currframe, values, apply);
							aa.currframe++;
							// switch to the first inbetween.
						}
					}
					else {
						no_refresh = true;
					}
				}
				else if(button === "projectname") {
					let name = prompt(`enter a name for the project.`);
					if(name) {
						aa.control.projectname = name;
					}
					else {
						no_refresh = true;
					};
				}
				else if(prefix === "anim") {
					if(suffix === "menu") {
						let ref = aa.ui.buttons[button];
						let tabwidth = Math.min(aa.ui.animtabwidth*AAX.ui.block, ref.w/aa.anims.length);
						let index = Math.floor((click[0] - ref.x)/tabwidth);
						if(index === aa.anim_index) {
						// rename the animation
							let name = prompt(`enter a name for the animation.`);
							if(name === null) {
								no_refresh = true;
							}
							else {
								aa.curranim.name = name;
							};
						}
						else if(index >= 0 && index < aa.anims.length) {
							aa.anim_index = index;
						}
						else {
							no_refresh = true;
						};
					}
					else if(suffix === "blank") {
						aa.anims.splice(aa.anim_index + 1, 0, aa.newanim());
						aa.anim_index++;
					}
					else if(suffix === "duplicate") {
						aa.anims.splice(aa.anim_index + 1, 0, structuredClone(aa.curranim));
						let prevanim = aa.curranim;
						aa.anim_index++;
						aa.curranim.name = prevanim.name ? prevanim.name + " - copy" : "";
						// it's fine if names are shared.
						aa.curranim.states = [structuredClone(prevanim.states[prevanim.state_index])]
						// keep only the current state
					}
					else if(suffix === "delete") {
						if(aa.anims.length > 1 && confirm(`deleting animations cannot be undone/redone. are you sure?`)) {
							let old = aa.anim_index;
							let islast = old === aa.anims.length - 1;
							aa.anim_index = islast ? aa.anims.length - 2 : aa.anim_index + 1;
							// trigger the setter
							aa.anims.splice(old, 1);
							// delete the old animation
							if(old <= aa.anim_index) {
							// decrement the index, but be sneaky about it.
								aa._anim_index--;
							}
						}
						else {
							no_refresh = true;
						}
					}
				};
				let depress = (
					prefix === "switch"
					||
					(prefix === "frame" && suffix !== "display")
					||
					(prefix === "inbetween" && (suffix === "add" || suffix === "subtract" || suffix === "create" || suffix === "apply"))
					||
					(prefix === "states" && (suffix === "undo" || suffix === "redo"))
					||
					button === "save" || button === "load"
					||
					(prefix === "misc" && suffix !== "autoperspective" && suffix !== "stretch_widen")
					||
					(prefix === "anim" && (suffix === "blank" || suffix === "duplicate" || suffix === "delete"))
				);
				// boolean for whether to animate it being depressed.
				// - there aren't actually a lot of buttons worth depressing.
				//   most of them are toggles, prompts, stuff like that.
				if(depress) {
				// it'll get redrawn for the depressing, so the other refresh
				// would just be redundant.
					refresh.ui = false;
				}
				let temp = [];
				for(i1 in refresh) {
					loop.tick(1);
					if(refresh.hasOwnProperty(i1) && !refresh[i1]) {
						temp[temp.length] = i1;
					}
				}
				loop.end();
				// now it's an array of what to skip.
				if(!no_refresh) {
					aa.refresh(temp);
				}
				if(depress) {
					aa.ui.draw(button);
					// draw the button depressed
					setTimeout(function() {aa.ui.draw()}, 1000*AAX.ui.depress);
					// draw it undepressed after a little bit.
				}
			},
			mousedown: function(e, doubleclick) {
			// searches the buttons for where your click was, and runs .action.
				let i1 = 0;
				let click = clickxy(e, "aa");
				aa.control.clicktype = "ui";
				let buttons = aa.ui.buttons;
				for(i1 in buttons) {
					if(buttons.hasOwnProperty(i1)) {
						let ref = buttons[i1];
						if(
							click[0] >= ref.x
							&&
							click[0] < ref.x + ref.w
							&&
							click[1] >= ref.y
							&&
							click[1] < ref.y + ref.h
						) {
							aa.ui.action(i1, doubleclick, false, click);
							aa.control.clicktype = null;
							return;
						};
					};
				}
				aa.control.clicktype = null;
			},
		},
		control: {
		// stores various data that changes based on what you're trying to do,
		// like which node you have selected and which posing tool you're using.
			view: 0,
			partname: "",
			// this CANNOT be left empty, everything in the interactivity and
			// part-editing buttons uses it. .initialize will set it.
			get part() {
				return aa.currpose[this.partname];
			},
			get node() {
				return aa.getnode(this.view, this.partname);
			},
			// don't use this too much, obviously. run it at the start of the
			// function, don't use it multiple times in one expression
			get perspectived() {
				return aa.control.posetool === "perspective";
			},
			// boolean for whether .draw should draw it perspectived or
			// unperspectived.
			// - a getter is easier to edit. i don't know when i might change
			//   the conditions of perspectived imaging.
			_posetool: "rotate",
			posetool_inversion: false,
			// a boolean for an alternate mode for each pose tool. selecting the
			// pose tool you already have selected toggles this, and switching
			// pose tools turns it off.
			// - it used to be a double-click, but those don't work on mobile.
			//   or maybe they do and it's just a pain in the ass.
			get posetool() {
				return this._posetool;
			},
			set posetool(value) {
				if(this._posetool === value) {
					this.posetool_inversion = false;
					return;
				};
				if(!AAX.valid.posetools.includes(value)) {
					console.log("this shouldn't happen");
					value = AAX.valid.posetools[0];
				};
				this._posetool = value;
				this.posetool_inversion = false;
			},
			moveaway: false,
			// boolean for if the third axis should be whatever sign moves
			// things away from the screen rather than towards it.
			partclicked: false,
			// boolean for whether the user's mousedown actually clicked a part
			// or not
			// - i can't just check if the node is null, because the last
			//   clicked node is stored between clicks so the buttons know what
			//   to edit.
			strokedata: null,
			// stores mid-stroke data, like the starting angle for rotate.
			clicktype: null,
			// used to tell if mouse events should trigger. (it's like a boolean
			// for whether they're in the middle of a click. except i have to
			// specify whether it's the main area or the ui, or ui clicks could
			// register for main and vice versa.)
			all_frames_posetext: false,
			// boolean for whether pose text input and output shows all frames.
			activeonly_cache: true,
			// boolean that makes it clear the part caches in an animation when
			// switching away from it.
			editmode: false,
			// boolean for whether the part artist should be visible instead of
			// the multiview.
			strokecache: null,
			// stores images for each part/view. this is filled at mousedown and
			// cleared at mouseup.
			// - this wouldn't actually be necessary if not for shapes.
			//   Part.rasterize is too slow to run every mousemove.
			// =
			// - [parts]
			//   - front, right (or 0-3 numbers if it's in perspective mode):
			//     images
			inbetween: {
				number: 3,
				curve: Math.sqrt(3),
				// a good approximation of a sine curve.
				easeA: false,
				easeB: false,
				// false means in, true means out.
				values: [.5],
				// this stores the values generated during aa.ui.draw for the
				// visualization.
				// - ...it sounds weird, but it's useful for the negative curve
				//   thing, where the easing has randomness to it
				// - the default value should never be used, but just in case, i
				//   want one value in there. (aa.currframe ticks up one when
				//   create inbetween is used. if there's no values, there's no
				//   inbetweens, so currframe could end up out of bounds.)
			},
			projectname: "untitled",
		},
		get oddify_deform() {
			return aa.control.posetool === "deform";
		},
		// used in AAX.oddify.
		nodes: [[], [], [], []],
		// screen positions and names of all the parts, divided up by view.
		// they're ordered by z, with the further parts being first.
		// - structure:
		//   - x, y, z: screen coordinates. x includes view offset, and x and y
		//     include perspective offset if the multiview was drawn in
		//     perspective.
		//   - name: part name string
		//   - parent: reference to the parent's node, or if it's standpoint,
		//     just a "standpoint" string.
		// - iterate in order when drawing parts using this, iterate backward
		//   when checking which node the user clicked.
		images: null,
		// an object of ImageDatas, which the interface uses to correct overflow
		// or reverse the changes it made.
		pasteimages: function(invert, view) {
		// - invert === false: paste the image for the specified view.
		//   (reverses changes.)
		// - invert === true: paste all images except the one for the specified
		//   view. (corrects overflow.)
			view ??= aa.control.view;
			const ctx = aa.ctx.main;
			const cell = aa.drawsettings.cell;
			let i1 = 0;
			let loop = new Loop("aa.pasteimages");
			for(i1 = 0; i1 < 4; i1++) {
				loop.tick(1);
				if(invertboolean(i1 === view, invert)) {
					ctx.putImageData(aa.images[i1], cell.w*i1, 0);
				};
			}
			loop.end();
		},
		noderadius: 1,
		// how close a click has to be to count as clicking the node.
		nodecheck: function(click, view) {
			let i1 = 0;
			let loop = new Loop("aa.nodecheck");
			for(i1 = aa.nodes[view].length - 1; i1 >= 0; i1--) {
			// search backwards, so it finds the closer nodes first.
				loop.tick(1);
				let node = aa.nodes[view][i1];
				let hypot = Math.hypot(
					node.x - click[0],
					node.y - click[1]
				);
				if(hypot < aa.noderadius + .5 && (!aa.currpose[node.name].hide || !aa.drawsettings.total_hide)) {
				// if the part is hidden and total hide is on, don't allow the
				// node to be selected or clicked.
					return node;
				};
			}
			loop.end();
			return null;
		},
		getnode: function(view, name) {
		// returns the node of the given view and name.
			let ref = aa.nodes[view];
			let loop = new Loop("aa.getnode");
			for(let i1 = 0; i1 < ref.length; i1++) {
				loop.tick(1);
				if(ref[i1].name === name) {
					return ref[i1];
				}
			}
			loop.end();
			console.log("this shouldn't happen");
			return null;
		},
		xz_radius: function(view) {
		// returns the radius used to calculate angle in inverted rotate mode.
		// (ie xz rotation)
		// - radius is whatever the highest x/z hypotenuse there is among the
		//   current part's descendants. (relative to the current part's
		//   abscoor)
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let loop = new Loop("aa.xz_radius");
			const part = aa.control.part;
			const abscoor = part.abscoor;
			const desc = AAX.getdesc(aa.currpose, part.name);
			let r = 0;
			const searchshapes = true;
			for(i1 = -searchshapes; i1 < desc.length; i1++) {
				loop.tick(1);
				let _part = i1 === -1 ? part : aa.currpose[ desc[i1] ];
				let coor = _part.abscoor;
				coor = [
					coor[0] - abscoor[0],
					0,
					coor[2] - abscoor[2]
				];
				// coordinates relative to the main part
				r = Math.max(r, Math.hypot(...coor));
				if(searchshapes) {
				// what we're looking for is the furthest point it influences,
				// so search these too
					let shape = _part.orientedshape;
					for(i2 = 0; i2 < shape.length; i2++) {
						loop.tick(2);
						for(i3 = 0; i3 < shape[i2].length; i3++) {
							loop.tick(3);
							let point = shape[i2][i3];
							r = Math.max(r, Math.hypot(
								coor[0] + point[0],
								coor[2] + point[2]
							));
						}
						loop.end();
					}
					loop.end();
				}
			}
			loop.end();
			if(r) {
				let float = aa.control.node.x%1;
				r = Math.ceil(r - float) + float;
				// if the floats match, the boundaries of the cylinder will be at
				// integers.
			};
			return r;
		},
		xz_angle: function(click, view) {
		// used in the xz rotate mode.
			const r = aa.xz_radius();
			let acos = (cos) => (
				false
				?
				Math.acos(cos)
				:
				(1 - cos)*Math.PI/2
			);
			// make it true, and it'll do the acos stuff. make it false, and
			// it'll be a linear relationship between x position and angle. the
			// former is harder to control in practice.
			if(r) {
				const center = aa.control.node.x;
				let cos = (click[0] - center)/r;
				// Math.cos of the angle.
				// 4-3-2-1-0-1-2-3-4
				// d r u l d r u l d
				cos = posmod(cos + 1, 4) - 1;
				// 1-0-1-2-3
				// l d r u l
				if(cos >= 1) {
					cos = (cos - 1)*(-1) + 1;
					return 2*Math.PI - acos(cos);
				}
				else {
					return acos(cos);
				};
			}
			else {
				return 0;
				// always return the same angle, so that the relative angle is
				// always 0 too.
			}
		},
		mousedown: function(e) {
			let i1 = 0;
			let i2 = 0;
			let click = clickxy(e, "aa");
			const cell = aa.drawsettings.cell;
			const view = Math.floor(click[0]/cell.w);
			aa.control.view = view;
			let node = aa.nodecheck(click, view);
			aa.control.partclicked = node !== null;
			if(aa.control.partclicked) {
				aa.control.partname = node.name;
			}
			else {
				node = aa.control.node;
			};
			if((aa.control.posetool === "tilt" || aa.control.posetool === "rotate") && !aa.control.partclicked) {
			// if it's rotate mode and they didn't click a part, save the angle.
			// (when you click a part, it acts like select mode. otherwise, it
			// rotates based on the start and end angle.)
				let angle = null;
				if(aa.control.posetool_inversion) {
					let r = aa.xz_radius();
					let center = node.x;
					const ctx = aa.ctx.main;
					ctx.strokeStyle = aa.color.interface[0];
					linespecial(
						ctx,
						center - r,
						0,
						center - r,
						ctx.canvas.height,
						[node.x, node.y]
					);
					linespecial(
						ctx,
						center + r,
						0,
						center + r,
						ctx.canvas.height,
						[node.x, node.y]
					);
					angle = aa.xz_angle(click, view);
				}
				else {
					angle = get2dangle(([2, 3].includes(view) ? -1 : 1)*(click[0] - node.x), click[1] - node.y, true) ?? 0;
				}
				aa.control.strokedata = angle;
			};
			aa.control.strokecache = {};
			for(i1 in aa.currpose) {
				if(aa.currpose.hasOwnProperty(i1)) {
					let _part = aa.currpose[i1];
					aa.control.strokecache[i1] = (
						aa.control.perspectived
						?
						{
							0: _part.perspective_0,
							1: _part.perspective_1,
							2: _part.perspective_2,
							3: _part.perspective_3,
						}
						:
						{
							front: _part.image_front,
							right: _part.image_right,
						}
					);
					let ref = aa.control.strokecache[i1];
					for(i2 in ref) {
						if(ref.hasOwnProperty(i2)) {
							ref[i2] = AAX.sq_raster.fill(ref[i2], _part.dim(i2, ref[i2].length)[0]);
							//ref[i2] = AAX.sq_raster.fill(ref[i2], _part.dim(i2, ref[i2].length)[0]);
						}
					}
				}
			}
			// fill strokecache (lets it reuse images so it doesn't run rasterize
			// every mousemove)
			aa.control.clicktype = "main";
		},
		mousemove: function(e, finish) {
		// - finish: boolean used in mouseup. means it should enact the changes
		//   it's calculating. that happens here because it already has to do a
		//   lot of the math to visualize things.
			let i1 = 0;
			let i2 = 0;
			let click = clickxy(e);
			const ctx = aa.ctx.main;
			const cell = aa.drawsettings.cell;
			const view = (aa.control.clicktype === "main" ? aa.control.view : Math.floor(click[0]/cell.w));
			const coor = aa.coorfromcanvas(click[0], click[1], view);
			if([0, 1, 2, 3].includes(view)) {
			// draw coordinates
			// - unless it's perspectived, ie coorfromcanvas doesn't really make
			//   sense
			// - or code for move, deform, or perspective will be run, which
			//   draws relative coordinates instead
			// - the conditional is here for really dumb reasons. if you hover
			//   over the right edges, the view can be calculated as 4.
				let text = [
					"",
					"xz"[view%2] + ": " + coor["xz"[view%2]],
					"y: " + coor.y
				];
				if(aa.control.perspectived) {
					text[1] = "";
					text[2] = "";
				};
				// coorfromcanvas doesn't work for perspective mode, and that
				// wouldn't make sense anyway.
				if(aa.control.clicktype !== "main") {
					let node = aa.nodecheck(click, view);
					aa.pasteimages(false);
					aa.pasteimages(true);
					if(node !== null) {
						//aa.control.view = view;
						//aa.ui.draw();
						text[0] = node.name;
						// display the name
						node = aa.noderect(node.x, node.y);
						ctx.strokeStyle = aa.color.interface[0];
						ctx.fillStyle = aa.color.interface[1];
						ctx.strokeRect(node.x - .5, node.y - .5, node.w + 1, node.h + 1);
						ctx.fillRect(node.x, node.y, node.w, node.h);
						aa.pasteimages(true, view);
					}
					// you can make this slightly less wasteful at the cost of
					// making it select nodes, by deleting the
					// aa.pasteimages(true) command and un-commenting the lines
					// that set aa.control.view and run aa.ui.draw.
					// - actually, running aa.ui.draw needlessly is more
					//   wasteful. whatever.
				};
				aa.writecoordinates(text);
			};
			if(aa.control.clicktype !== "main") {
				return;
			};
			//
			aa.pasteimages(false);
			aa.writecoordinates(null);
			ctx.strokeStyle = aa.color.interface[0];
			ctx.fillStyle = aa.color.interface[1];
			const mode = (
				aa.control.posetool === "move" && aa.control.part.parent === "standpoint"
				?
				"deform"
				:
				aa.control.posetool
			);
			const inversion = aa.control.posetool_inversion;
			const node = aa.control.node;
			const part = aa.control.part;
			let parent_node = node.parent;
			if(node.parent === "standpoint") {
				parent_node = aa.coortocanvas([0, 0, 0], view, true, true);
				parent_node = {
					x: parent_node[0],
					y: parent_node[1],
					name: parent,
				};
			};
			// a node-like object for standpoint, or the .parent reference.
			const parent_part = (node.parent === "standpoint" ? null : aa.currpose[ parent_node.name ]);
			if(aa.control.partclicked) {
			// don't do anything if this is false
				const parent_abs = (
					node.parent === "standpoint"
					?
					[0, 0, 0]
					:
					parent_part.abscoor
				);
				const oddness = part.oddness;
				let relcoor = part.relcoor;
				const floats = [
					posmod(relcoor[0], 1),
					posmod(relcoor[1], 1),
					posmod(relcoor[2], 1)
				];
				if(view%2) {
					relcoor[2] = coor.z + oddness[2]/2 - parent_abs[2];
				}
				else {
					relcoor[0] = coor.x + oddness[0]/2 - parent_abs[0];
				}
				relcoor[1] = coor.y + oddness[1]/2 - parent_abs[1];
				// add oddness so it retains the same floats, subtract parent.
				relcoor = [
					Math.round(relcoor[0]*2)/2,
					Math.round(relcoor[1]*2)/2,
					Math.round(relcoor[2]*2)/2
				];
				// make sure nothing's infinitesimally close to a .0/.5
				const float_check = [
					posmod(relcoor[0], 1) === floats[0],
					posmod(relcoor[1], 1) === floats[1],
					posmod(relcoor[2], 1) === floats[2]
				];
				if(float_check.includes(false)) {
					console.log([
						"new oddness doesn't match old oddness.",
						floats,
						[
							posmod(relcoor[0], 1),
							posmod(relcoor[1], 1),
							posmod(relcoor[2], 1)
						]
					].join(String.fromCharCode(10)));
					if(finish) {
						aa.control.clicktype = null;
						aa.control.strokedata = null;
						aa.pasteimages(false);
						aa.writecoordinates(null);
					};
					return;
				};
				const hypot = aa.hypot(part.name, mode === "move" && inversion);
				// use the altered hypotenuse in inverted move mode.
				if(["move", "deform"].includes(mode)) {
				// draw circles, to show its range and where the fulcrum is
					circledraw(ctx, parent_node.x, parent_node.y, Math.floor(hypot));
					let temp = ctx.fillStyle;
					ctx.fillStyle = ctx.strokeStyle;
					circledraw(ctx, parent_node.x, parent_node.y, aa.noderadius, true);
					ctx.fillStyle = temp;
				};
				if(mode === "deform") {
					let rect = {
						x: Math[([1, 2].includes(view) ? "ceil" : "floor")](parent_node.x) + .5,
						y: Math[([1, 2].includes(view) ? "ceil" : "floor")](parent_node.y) + .5,
						// floor/ceil it so it's what the coortocanvas would be
						// without floats, and add .5 so it's in the center of
						// the pixels.
						w: ([1, 2].includes(view) ? -1 : 1)*Math.trunc(relcoor[view%2 ? 2 : 0]),
						h: Math.trunc(relcoor[1]),
					};
					ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
					aa.writecoordinates(relcoor);
				}
				else if(mode === "move") {
					aa.nodeline(
						ctx,
						parent_node.x, parent_node.y,
						click[0] + ([1, 2].includes(view) ? -1 : 1)*floats[0], click[1] + floats[1],
						view,
						true
					);
					//nonaaline(ctx, Math.floor(parent_node.x), Math.floor(parent_node.y), ...click);
					let sign3 = (
						invertboolean([2, 3].includes(view), aa.control.moveaway)
						?
						-1
						:
						1
					);
					relcoor = aa.movecoor(part, hypot, relcoor[view%2 ? 2 : 0], relcoor[1], sign3, "xz"[view%2] + "y");
					aa.writecoordinates(relcoor);
				}
				else if(mode === "perspective" && !inversion) {
					const unperspective_coor = aa.coortocanvas(part.abscoor, view, true, true);
					// unperspectived canvas coordinates.
					const rotated_coor = aa.coortocanvas(
						AAX.camerarotations(part.abscoor, null, aa.drawsettings.camera.xz, aa.drawsettings.camera.yz, "same floats"),
						view, true, true
					);
					// perspective lines are drawn from the rotated coordinates,
					// so that it resembles a line to the vanishing point.
					// - view is null because coortocanvas doesn't expect the
					//   view number rotation.
					const old_coor = part["perspective_coor_" + view];
					relcoor = [
						click[0] - unperspective_coor[0] + posmod(unperspective_coor[0] + old_coor[0], 1),
						click[1] - unperspective_coor[1] + posmod(unperspective_coor[1] + old_coor[1], 1)
					];
					ctx.strokeStyle = aa.color.perspective;
					aa.nodeline(ctx, ...rotated_coor, ...click, view, true);
					aa.writecoordinates([
						part.name,
						"screen x: " + (relcoor[0] > 0 ? "+" : relcoor[0] === 0 ? " " : "") + relcoor[0],
						"screen y: " + (relcoor[1] > 0 ? "+" : relcoor[1] === 0 ? " " : "") + relcoor[1]
					]);
				};
				// no logic for select mode because it doesn't do anything.
				// (rotate mode acts like select mode if a part was clicked.)
				if(finish) {
					if(["move", "deform"].includes(mode)) {
						if(mode === "deform" && inversion) {
							let change = [
								Math.trunc(relcoor[0] - part.x),
								Math.trunc(relcoor[1] - part.y),
								Math.trunc(relcoor[2] - part.z)
							];
							// these should all be integers to begin with, but.
							let children = AAX.getchildren(aa.currpose, part.name);
							for(i1 = 0; i1 < children.length; i1++) {
								let ref = aa.currpose[ children[i1] ];
								ref.x -= change[0];
								ref.y -= change[1];
								ref.z -= change[2];
							};
							// apply an inverse change to all children, so that they
							// stay in place.
						}
						part.x = relcoor[0];
						part.y = relcoor[1];
						part.z = relcoor[2];
						// descendants will follow, since it's relative.
					}
					else if(mode === "perspective" && !inversion) {
						part["perspective_coor_" + view] = structuredClone(relcoor);
					}
				};
			}
			else if(mode === "tilt" || mode === "rotate") {
				let angle = null;
				let axis = ["xy", "yz"][view%2];
				if(inversion) {
					axis = "xz";
					angle = aa.xz_angle(click, view);
				}
				else {
					angle = get2dangle(([2, 3].includes(view) ? -1 : 1)*(click[0] - node.x), click[1] - node.y, true) ?? 0;
				};
				angle = posmod(angle - aa.control.strokedata, 2*Math.PI);
				// now it's a relative angle instead of absolute
				aa.writecoordinates(Angle.convert(angle) + " " + axis);
				let partname = aa.control.partname;
				let rotatecoor = mode === "tilt" ? null : aa.rotatecoor(partname, angle, axis);
				let basis = Quat.basis(Quat.rotate(part.orient, axis, angle));
				// basis to display
				let check = Basis.check(basis);
				if(Basis.check(basis)) {
					console.log(check);
					console.log(basis);
				};
				if(finish) {
				// apply the new relative coordinates in rotatecoor
					//console.log("before:" + String.fromCharCode(10) + Quat.string(part.orient));
					part.orient = structuredClone(Quat.rotate(part.orient, axis, angle));
					//console.log(Quat.string(part.orient));
					if(mode !== "tilt") {
						for(i1 in rotatecoor) {
							if(rotatecoor.hasOwnProperty(i1)) {
								aa.currpose[i1].x = rotatecoor[i1][0];
								aa.currpose[i1].y = rotatecoor[i1][1];
								aa.currpose[i1].z = rotatecoor[i1][2];
								aa.currpose[i1].orient = structuredClone(Quat.rotate(aa.currpose[i1].orient, axis, angle));
							}
						}
					}
				}
				else {
				// use rotatecoor with aa.draw (only the parts not being rotated
				// are drawn, then the rotated parts are drawn as nodes/skeleton
				// in the colors of the interface.)
					aa.draw_background();
					aa.draw(rotatecoor, {[partname]: basis});
				}
			};
			if((mode !== "tilt" && mode !== "rotate") || aa.control.partclicked) {
			// get rid of overflow
				aa.pasteimages(true);
			};
			if(finish) {
				aa.control.strokecache = null;
				aa.control.clicktype = null;
				aa.control.strokedata = null;
				aa.refresh( (
					mode === "select"
					||
					((mode === "tilt" || mode === "rotate") && aa.control.partclicked)
					||
					(mode === "perspective" && inversion)
				) ? "states" : null );
				// don't edit datatext or states if all you did was select
				// something.
				aa.writecoordinates(null);
			};
		},
		mouseup: function(e) {
			if(aa.control.clicktype !== "main") {
				return;
			};
			aa.mousemove(e, true);
		},
		writecoordinates: function(text) {
		// you can enter arrays or coordinate arrays. it interprets null as
		// "reset to default", which is generally however many line breaks
		// guarantees that the stuff after this won't be moving back and forth.
			if(Array.isArray(text)) {
				if(text.length === 3 && typeof text[0] === "number" && typeof text[1] === "number" && typeof text[2] === "number") {
					text = [
						"x: " + text[0],
						"y: " + text[1],
						"z: " + text[2]
					];
				};
				text = text.join(String.fromCharCode(10));
			}
			else if(text === null) {
				text = "";
			}
			else if(typeof text === "number") {
				text += "";
			};
			text = text.split(String.fromCharCode(10));
			if(text.length > 3) {
				text = text.slice(0, 3);
			}
			else if(text.length < 3) {
				text[0] ??= "";
				text[1] ??= "";
				text[2] ??= "";
			};
			let i1 = 0;
			let loop = new Loop("aa.writecoordinates");
			for(i1 = 0; i1 < text.length; i1++) {
				loop.tick(1);
				if(!text[i1]) {
					text[i1] = "&#160;";
				};
			}
			loop.end();
			text = text.join("<br>");
			aa.div.coor.innerHTML = text;
		},
		noderect: function(x, y) {
			return {
				x: Math.floor(x),
				y: Math.floor(y),
				w: 1 + !!(x%1),
				h: 1 + !!(y%1),
			};
		},
		nodeline: function(ctx, x1, y1, x2, y2, view, viewoffset) {
			let temp = aa.coortocanvas([0, 0, 0], view, true, viewoffset);
			temp[0] += .5;
			temp[1] += .5;
			// center of the standpoint pixel
			linespecial(ctx, x1, y1, x2, y2, temp);
		},
		body: null,
		bodytext: null,
		anims: [],
		// anims and states:
		// - each item of anims represents a different animation.
		//   - for example, a walking animation, jumping animation
		//   - they're all based on the same body, but they're distinct in the
		//     undo/redo system.
		// - structure of an anim:
		//   - name: the name displayed for it. it can be a number or string. if
		//     it's invalid, it'll use the index of the animation within
		//     aa.anims.
		//   - states: an array of states for it to undo/redo between.
		//   - state_index: which index of states is the one to use right now.
		//     (undo/redo move this up and down.)
		// - structure of a state:
		//   - states are what the undo/redo system saves/loads. they store the
		//     state of a single animation. all of its frames, and some data
		//     about aa.control stuff at the time. (like what frame you were on,
		//     or what pose tool you were using)
		//   - newer states come earlier in a states array.
		//   - state arrays never get longer than aa.states_limit.
		//   =
		//   - poseobjs: an array of AAX.poseobjs for each frame.
		//     - a poseobj is an armature of partobjs, and partobjs are trimmed
		//       versions of AAX.s. partobjs have no getters/setters or
		//       methods, and properties that are "default" are omitted entirely.
		//     - generally, not even functions like AAX.dim work on them. some of
		//       them might, like AAX.abscoor, but in general they written with
		//       the assumption of being used on aa.body or AAX.s/aa.frames.
		//   - currframe: what frame you were on when this state was saved
		//   - view, partname, posetool_inversion, _posetool: aa.control values
		//     at the time this state was saved
		// - various properties like aa.currframe, aa.states, aa.state_index are
		//   getters/setters for the properties of the animation.
		// - however, AA.FRAMES IS NOT. aa.frames is a copy of the current state
		//   the current animation, where every part is a genuine AAX.
		//   instead of just using AAX.poseobj.
		//   - every time states are saved during aa.refresh, it makes sure the
		//     current state's poseobjs match the changes made.
		_anim_index: 0,
		get anim_index() {
			return aa._anim_index;
		},
		set anim_index(value) {
			let ref = aa.curranim;
			if(value !== aa._anim_index) {
				//ref.states = ref.states.slice(ref.state_index, ref.state_index + aa.states_truncator);
				//ref.state_index = 0;
				ref.states = ref.states.slice(ref.state_index - aa.states_truncator, ref.state_index + 1 + aa.states_truncator);
				ref.state_index = Math.min(ref.state_index, aa.states_truncator);
				// apply states_truncator
				// - if state_index is higher than the truncator, it should become
				//   the truncator, since it can only store that many redos. if it's
				//   lower, don't change it at all, since only undos would be
				//   deleted.
				if(aa.control.activeonly_cache) {
					// clear the cache for inactive animations.
					for(let i1 = 0; i1 < ref.states.length; i1++) {
						// for every state,
						let _ref = ref.states[i1].poseobjs;
						for(let i2 = 0; i2 < _ref.length; i2++) {
							// frame,
							for(let i3 in _ref[i2]) {
								if(_ref[i2].hasOwnProperty(i3)) {
									// part.
									let __ref = _ref[i2][i3];
									__ref.cache = structuredClone(AAX.cache_init);
								}
							}
						}
					}
				}
			};
			aa._anim_index = value;
			aa.loadstate(aa.state_index, true);
			// apply those changes to aa.frames.
			// - skip refresh. this is only set in .initialize and buttons for
			//   changing it, so refresh will run anyway.
		},
		newstate: function() {
			return {
				poseobjs: [],
				currframe: 0,
				view: aa.control.view,
				partname: aa.control.partname,
				posetool_inversion: aa.control.posetool_inversion,
				_posetool: aa.control._posetool,
			};
		},
		newanim: function() {
			let anim = {
				name: "",
				states: [aa.newstate()],
				state_index: 0,
			};
			anim.states[0].poseobjs = [AAX.poseobj(aa.newpose())];
			return anim;
		},
		get curranim() {
			return aa.anims[aa.anim_index];
		},
		getanimname: (index) => aa.anims[index].name ? aa.anims[index].name : "anim " + index,
		// use this whenever an animation name is displayed.
		frames: [],
		// an array of posed armatures. the structure is as follows:
		get states() {
			return aa.curranim.states;
		},
		set states(value) {
			if(Array.isArray(value)) {
				aa.curranim.states = value;
			}
			else {
				console.log("this shouldn't happen");
			}
		},
		get state_index() {
			return aa.curranim.state_index;
		},
		set state_index(value) {
			if(Number.isInteger(value) && value >= 0 && value < aa.states.length) {
				aa.curranim.state_index = value;
			}
			else {
				console.log("this shouldn't happen");
			}
		},
		get currstate() {
			return aa.states[aa.state_index];
		},
		get currframe() {
			return aa.currstate.currframe;
		},
		set currframe(value) {
			if(Number.isInteger(value) && value >= 0 && value < aa.frames.length) {
				aa.currstate.currframe = value;
			}
			else {
				console.log("this shouldn't happen (" + value + ")");
			}
		},
		get poseobjs() {
			return aa.currstate.poseobjs;
		},
		get currpose() {
			return aa.frames[aa.currframe];
		},
		get currposeobj() {
			return aa.poseobjs[aa.currframe];
		},
		states_limit: 32,
		// poses aren't very big, but i really don't want it to swell
		// infinitely. having to start over because it crashed or whatever would
		// suck.
		states_truncator: 4,
		// when it switches away from an animation, it truncates it so only this
		// many undos/redos are kept.
		clampframe: function() {
			aa.currframe = Math.min(aa.frames.length - 1, Math.max(aa.currframe, 0));
		},
		savestate: function() {
			let loop = new Loop("aa.savestate");
			let currframe = aa.currframe;
			if(aa.state_index > 0) {
			// clear redo
				aa.states.splice(0, aa.state_index);
				aa.state_index = 0;
			};
			aa.states.splice(0, 0, aa.newstate());
			aa.currframe = currframe;
			let ref = aa.poseobjs;
			for(let i1 = 0; i1 < aa.frames.length; i1++) {
				loop.tick(1);
				ref[i1] = AAX.poseobj(aa.frames[i1]);
			}
			loop.end();
			if(aa.states.length > aa.states_limit) {
			// keep it within states_limit
				aa.states.splice(aa.states_limit, aa.states.length - aa.states_limit);
			};
		},
		loadstate: function(index, skiprefresh) {
		// using in undo/redo, and the anim_index setter. applies the changes
		// stored in a state.
			let i1 = 0;
			let loop = new Loop("aa.loadstate");
			let ref = aa.states[index];
			for(i1 in ref) {
				loop.tick(1);
				if(ref.hasOwnProperty(i1) && i1 !== "poseobjs" && i1 !== "currframe") {
					if(i1 === "_posetool" && (ref[i1] === "perspective") !== (aa.control[i1] === "perspective")) {
					// only do posetool changes if it changes whether it's
					// perspectived or not (since some things are only visible
					// in one mode or another.)
						aa.control[i1] = ref[i1];
						// move this outside the conditional to apply changes to
						// view and partname.
						// - it sounds more intuitive, but it isn't. so it's in
						//   here.
						aa.control.posetool_inversion = ref.posetool_inversion;
						if(ref[i1] === "perspective") {
							aa.control.view = ref.view;
						};
					};
				};
			}
			loop.end();
			aa.frames = [];
			// clearing this prevents problems with length differences
			for(i1 = 0; i1 < ref.poseobjs.length; i1++) {
				loop.tick(1);
				aa.frames[i1] = aa.posefromobj(ref.poseobjs[i1]);
			}
			loop.end();
			aa.currframe = ref.currframe;
			// this comes after the changes to aa.frames, since the currframe
			// setter doesn't accept values outside the current aa.frames
			// length.
			aa.clampframe();
			if(!skiprefresh) {
				aa.refresh("states");
			}
			aa.filldatatext();
		},
		undo: function() {
			if(aa.state_index < aa.states.length - 1) {
				aa.state_index++;
				aa.loadstate(aa.state_index);
			};
		},
		redo: function() {
			if(aa.state_index > 0) {
				aa.state_index--;
				aa.loadstate(aa.state_index);
			};
		},
		anim: null,
		updateanimation: function(view) {
		// updates the animation.
		// - this is to be used sparingly, with a button. to avoid drawsettings
		//   inconsistency, it needs to draw every frame again to save it.
		// - view: specify a view number, and it'll only save one view.
			let i1 = 0;
			let loop = new Loop("aa.updateanimation");
			view = [0, 1, 2, 3].includes(view) ? view : null;
			let ctx = aa.ctx.main;
			let ref = aa.animator;
			ref.w = (view === null ? 4 : 1)*aa.drawsettings.cell.w;
			ref.h = aa.drawsettings.cell.h;
			ref.frames = [];
			ref.duration = aa.frames.length;
			let currframe = aa.currframe;
			// this is going to change, so save what it is right now
			ref.saveframe(
				currframe,
				ctx,
				(view === null ? 0 : view*ref.w)
			);
			for(i1 = 0; i1 < aa.frames.length; i1++) {
				loop.tick(1);
				if(i1 !== currframe) {
					aa.currframe = i1;
					aa.draw_background();
					aa.draw();
					ref.saveframe(
						i1,
						ctx,
						(view === null ? 0 : view*ref.w)
					);
				}
			}
			loop.end();
			aa.currframe = currframe;
			ctx.putImageData(ref.frames[currframe], 0, 0);
			if(ref.duration >= 1) {
				ref.frame = 0;
				ref.ctx.putImageData(ref.frames[0], 0, 0);
			};
			ref.sheet_cols = view === null ? 1 : 0;
			// display them horizontally if it's one view, vertically if it's
			// all views.
			ref.updatesheet();
		},
		initialize: function() {//yyyaai
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let i4 = 0;
			let loop = new Loop("aa.initialize");
			//
			if(typeof aa.bodytext !== "string") {
				aa.bodytext = AAX.Body.templates.standard;
				aa.body = AAX.Body.new(aa.bodytext);
			};
			if(typeof aa.body !== "object" || aa.body === null) {
				console.log("this shouldn't happen" + (typeof aa.body === "string" ? " (error is \"" + aa.body + "\")" : ""));
				return;
			};
			//console.log(aa.body);
			// make sure a body exists
			//
			let string = `a character animation system that's featured out the ass. works best with a mouse/touchpad. read the manual.`;
			string += `<div id="aa_editmodetrue">`;
			string += `<div id="aa_editmodetrue_active">`;
			let ref = aa.pa.ctx;
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aapa_" + i1;
					if(["front", "ui"].includes(i1)) {
						string += `<br>`;
					}
					else if(i1 === "right") {
						string += ` `;
					};
					string += `<canvas id="` + id + `"></canvas>`;
					if(i1 === "right") {
						string += `</div>`;
						// end active area
					};
				}
			};
			loop.end();
			string += `</div>`;
			// end editmodetrue div
			//string = `<div hidden>` + document.getElementById("hider_armature_artist").innerHTML + `</div>` + string;
			string += `\n<details>`;
			string += `\n\t<summary>manual</summary><ul>`;
			let manual = [
				`pose tools`,
				[
					`the deform pose tool lets you move parts anywhere, even if it changes how far the part is from their parent. (useful for body parts connected by a spine instead of a bone.)`,
					`the move pose tool lets you move parts, but keeps it as far away from the parent as it is in the default pose. (the third axis will be whatever positivity/negativity brings it closer to the camera for that view. if you're on the front view, it will move forward, if it's the back view it will move backward.)`,
					`if you click a part in the rotate pose tool, it will select that part. if you click anywhere else, you can rotate the selected part and its descendants.`,
					[
						`tilt is similar, but doesn't affect descendants.`
					],
					`the perspective pose tool lets you create an offset for each view, letting you position things around a vanishing point.`,
					`certain graphical changes only apply in perspective mode, namely the perspective offsets, and camera angle. perspective mode is for visualizing what the pose/animation will look like at the end, while the other modes are meant to be easier to understand and edit, like an engineering multiview.`,
					`selecting the pose tool you already have selected "inverts" it, making it work differently.`,
					[
						`inverted move will use the current hypotenuse of the part, rather than the hypotenuse it has in the default pose. (useful if you used deform to lengthen limbs or something.)`,
						`inverted deform will move the part without moving its descendants.`,
						`inverted tilt/rotate does xz rotation.`,
						`inverted perspective selects parts without editing them. (useful while editing different perspective images)`
					]
				],
				`editing/switching bodies`,
				[
					`open the "bodytext" thing.`,
					`by editing the content in that text area and clicking "apply changes", you can edit or replace the body. a lot of part properties can only be changed in here.`,
					`there's also a dropdown with some example bodytexts to use or start from, like a hand.`,
					`structure of a bodytext`,
					[
						`the first area defines parts, their names, parent structure, and coordinates.`,
						[
							`if a part name starts with "l_" or "r_", a symmetrical counterpart will be made.`,
							[
								`coordinates, shapes, and images are x-mirrored, and if the part's parent has a symmetrical counterpart, it will be parented to that.`,
								`this can be avoided. see the "no_mirror" command below.`
							]
						],
						`the second area is images.`,
						[
							`type a bracketed part name to make lines after that part of that part's shapes/images.`,
							`use "||" lines to transition from a part's shape to its unperspectived images, or from that to its perspectived images.`,
							`read the "shape system" and "image system" sections for more about how shapes/images work and how to write them.`
						],
						`the third area is other properties. enter a part name and colon, then...`,
						[
							`color1(), color2(): enter numbers in the parentheses to set first and second colors for the part and all its descendants.`,
							[
								`these numbers represent items of the list of part colors. (you can edit that list by clicking that rainbowy button.)`,
								`you can enter multiple numbers, separated by commas. this will make colors alternate between generations. (ex: "color1(1, 2)" will make the part's color1 the first color in the part colors list, and make all its children use the second color in that list. then the grandchildren use the first color, great-grandchildren use the second, etc.)`,
								`if you use "color1*()" or "color2*()" instead, descendants won't be affected.`
							],
							`generation(), capsule(), silhouette(): these affect the silhouette/connection system.`,
							[
								`when the silhouettes toggle in draw settings is on, it draws an approximation of the armature's silhouette, using these properties.`,
								`generation(): enter two numbers in the parentheses. this type of connection forms silhouette shapes by convexing multiple images. the part, and some of its ancestors and/or descendants. for example, "generation(1, 2)" makes it combine the part's image, its parent's image, all of its childrens' images, and all of its grandchildrens' images.`,
								`capsule(): enter one number in the parentheses. this type of connection form a silhouette shape with the part's image, and a capsule shape from the center of the part to the center of the part's parent. the number represents the capsule diameter.`,
								[
									`the "i have to make it look at least kind of like a neck" type.`
								],
								`silhouette(): enter a number, and maybe follow it with letters. this defines the "silhouette group", which helps differentiate different limbs.`,
								[
									`if parts have the same number <i>and</i> letters, they're drawn together, with no outlines between their silhouette shapes.`,
									`if parts have the same number but different letters, they're drawn like separate shapes, but in the same color.`,
									`the number is used to select one of the silhouette colors. there's a color button that lets you edit those. the dark blue/green/red one.`,
									`if an l_ or r_ part has no letters in their silhouette group, when it gets a symmetrical counterpart, the left one will get "l" and the right one will get "r".`,
									[
										`this doesn't happen if the silhouette group was 0. (the assumption is that if it's 0, you didn't want these limbs differentiated from the rest of the body anyway.)`
									],
									`just like color1 and color2, silhouette has a "silhouette*()" counterpart that doesn't affect descendants.`
								],
								`no_mirror(): avoids the creation of a symmetrical counterpart.`,
								`hide(): the part is hidden by default.`,
								`perspective(): lets you predefine perspective offset? this isn't very useful, but it's there.`,
								[
									`enter view 0's x, view 0's y, view 1's x, etc.`,
									`you can also enter "auto". that counts for two coordinates, since it applies to a whole view`,
									`by default, all views have automatic perspective.`
								]
							]
						]
					],
					`writing // anywhere in a bodytext makes a comment, ie the rest of that line is ignored.`,
					`poses can survive bodytext changes, for the most part. if a part with the same name exists in both the old and new body, it'll adopt changes in coordinates and the like, while accounting for the angle/hypotenuse difference the part has in the default pose.`
				],
				`shape system`,
				[
					`parts usually use 3d shapes to generate 2d images.`,
					`these shapes are defined in bodytext, but you can also redefine them with the "edit shape" button.`,
					`shapes are lists of points, broken up into groups. each line is a point, and a "|" line starts a new group.`,
					`every group is drawn as a convex shape. you can make simple convex shapes like pyramids/cubes/etc by just placing all the points. the order of the points doesn't matter.`,
					`concave shapes are impossible with just that, so that's what point groups are for. you can form concave shapes by breaking it up into multiple convex parts.`,
					`points can be made into spheres/spheroids by writing more than three numbers. if there's four, the fourth is used as the diameter of a sphere. if there's six, the last three numbers are used for width, height, and depth.`,
					`you can rotate spheroids, too. anything past the sixth number is used for that, either through xy/yz/xz rotations (axis, colon, 0 to 1 number, ex: "xy: 1/4, xz: .37") or a quaternion. (ex: "w: .707, x: 0, y: 0, z: .707")`,
					`if you enter a point index with axis letters before it, it'll be a duplicate that's inverted in those axes. (it doesn't affect rotation.) if you don't include an index, it'll copy the last non-duplicate/inversion point.`,
					`you can type a point that's nothing but axis letters to copy the previous point with those coordinates inverted. useful for designing symmetrical shapes.`,
					`if you type axis letters and a point index, you can make copies of other points. (the first point is 0. negative indexes will start from the most recent points, so -1 means "the point before this one".)`,
					`the "orient" part property rotates the shape. the rotate and tilt pose tools can edit this. the part information window visualizes it by showing the directions of the x/y/z axes of the shape.`,
					`"stretch" and "widen" scale the shape. stretch scales it along the line from the part to its parent, and widen scales it in other directions.`,
					`extra notes`,
					[
						`// comments are especially useful in shapes, to remember how the shape is structured.`,
						`symmetrical counterparts x-mirror the shape as well, but at the moment, they can't invert spheroid rotations.`
					]
				],
				`image system`,
				[
					`shapes are generally more useful than 2d images. things are designed around them more than they're designed around 2d images.`,
					`but 2d images are useful for things like hands, that are important but can't be drawn with shapes. that's what "part artist" is for, creating 2d images manually.`,
					`a part can have a shape, unperspectived images, and perspectived images. if it has multiple, unperspectived is used over shapes, and perspectived is used over unperspectived.`,
					`there can be two unperspectived images per part. a front view, and right view. (it's mirrored for the other two views.)`,
					`there can be four perspectived images. one per view. this is only shown when the selected pose tool is perspective.`,
					`structure of images, in bodytext:`,
					[
						`make a rectangle of characters. any dimensions are fine.`,
						`- for empty pixels, % for the first color, * for the second color.`,
						`use a | line to switch to the next image.`,
					],
					`the "switch" button in armature artist copies the current part's 2d image to part artist and switches over to part artist so you can edit it.`,
					`the "switch" button in part artist applies your changes to the part in armature artist and switches back to it.`,
					`extra notes`,
					[
						`the "switch without export" buttons switch between the two without doing any image import/export.`,
						`when the pose tool is "perspective", switching to/from part artist will import/export the perspective image of the current part, in the current selected view. (the selected view is whatever view you last clicked to edit. there's view buttons to indicate/change the view.)`,
						`when the pose tool is anything else, switching to/from part artist will import/export both the front and right unperspectived images.`,
						`the "clear image" button follows the same rules.`,
						`if said 2d image doesn't exist, part artist imports/exports whatever the 3d shape draws.`,
						`if you ever get mixed up which images exist and don't exist, check the part information window.`,
						`the difference between the first and second color is that for the first color, any interior pixels will use the "part fill" color, with only the edges being the part's color. this isn't true for the second color.`,
						[
							`the first color is meant to define the shape, the second marks reference points or whatever.`
						]
					]
				],
				`hide/show`,
				[
					`"part" hide/show: hides/shows the selected part.`,
					`"branch" hide/show: hides/shows the selected part and its descendants.`,
					`"group" hide/show: hides/shows all parts in the same silhouette group.`,
					`"body" hide/show: hides/shows all parts in the same body. (if you have parts that are unconnected objects or even separate characters, those won't be affected.)`,
					`"body-branch" hide/show: short for "body minus branch". hides all parts part of the same body but not the same branch.`,
					`hide/shows with similar names work the same way. hiding/showing everything that fits into the first type but not the second.`,
					`hidden parts aren't selectable, unless the "total hide" setting is off. it's useful for animating complex bodies or multiple characters at once, without irrelevant characters/parts getting in the way.`
				],
				`other part properties`,
				[
					`relative coordinates are the part's coordinates relative to the part's parent.`,
					`perspective coor is the offset the perspective pose tool creates. it's only shown in perspective mode. if it's set to "auto", it'll be calculated automatically, based on the draw settings vanishing point and range.`,
				],
				`draw settings`,
				[
					`grid: increments for the grid lines. "2, 2, 4" would mean lines are drawn every 2 pixels in the first grid color, then every 2*2 pixels in the second grid color, then every 2*2*4 pixels in the third grid color. putting a 0 anywhere makes it draw lines at the standpoint and only the standpoint.`,
					`standpoint: parts that are at (0, 0, 0) will appear at this position in the cell, relative to the cell's center.`,
					`range: used in automatic perspective. when a point has perspective applied, no matter where it is, it's placed within this radius from the vanishing point. lower numbers mean more curvature, higher numbers mean less.`,
					`cell: cell dimensions.`,
					`vp: "vanishing point". used in the automatic perspective. the coordinates are relative to the standpoint.`,
					`camera: an xz and yz angle. when it's in perspective mode, everything is rotated by these.`,
					`fineness: used in shape spheroids. spheroids are drawn as if a circle has this many sides. higher numbers are a bit more taxing, but if you're making shapes big enough to see flat sides in your spheroids, increasing this will fix that.`,
					`toggles`,
					[
						`grid: between the background being a grid, color but no grid, or totally transparent. useful when generating images from your animation.`,
						`silhouette: connects parts' images to form a somewhat realistic-looking silhouette. switches between them being shown, shown with different silhouette groups being distinguished, or no silhouettes at all.`,
						[
							`differentiating different limbs is the whole point of silhouette groups, but they only clutter up the image unless you actually need to see those interior outlines at the moment.`
						],
						`parts: toggles whether parts' images are drawn. (the pink setting makes it so all images' outlines are visible, even if they would normally be covered up by another image's fill.)`,
						`vertices: when it generates 2d images from the part's shape, it draws the points that make up the shape in the part's second color. this is a toggle for that.`,
						`skeleton: lines between parts and their parents`,
						`perspective: draws lines between where parts are in and out of perspective mode.`,
						`nodes: highlights the center of each part`,
						`total hide: when this is off, some things are still drawn even for hidden parts. just enough to know where they are and edit them. (the nodes are visible, and so is their skeleton if they have unhidden descendants.)`
					],
					`colors`,
					[
						`the left set of colors affects the grid.`,
						`the middle set of colors affects the elements of an armature. (in about the same order as the draw settings toggles for those elements, and the order they're layered.)`,
						`the right set of colors is interface stuff. stuff used in pose tool graphics, and the ui.`,
						`but if you forget which is which, the button prompts will tell you what they are.`,
					],
					`extra notes`,
					[
						`if you use a bodytext with a part named "head", the vanishing point's y will automatically be set as the y that part has in the default pose. like placing the camera at eye level.`,
						`hitting "cancel" on a color prompt will keep it as it is, but hitting "ok" without typing anything will reset the color to default.`,
						`the standpoint grid lines move while in perspective mode, but that only represents where a [0, 0, 0] point would be perspectived to. it's not like it changes which pixels are what coordinates or anything.`
					]
				],
				`keymap`,
				[
					`w, a, s, d: lets you switch pose tools and frames.`,
					`shift+a, shift+d: change which view you have selected. (relevant to buttons that edit perspective images or perspective coordinates, and the "update animation" button.)`,
					`e: inverts or uninverts the pose tool`,
					`q, shift+q: switches to/from the image editor, with or without exporting.`,
					`t, f, g, h: selects parts by moving through the family structure. t selects the parent of the current part, g selects the first child of the part, and f and h cycle through siblings.`,
					`j, i, k, o, l: frame actions (blank, duplicate, delete, etc)`,
					`ctrl+z, ctrl+shift+z: undo, redo`,
					`ctrl+s, ctrl+o: save, load`
				],
				`etc`,
				[
					`the part information window shows which properties are different from the default pose by marking them with a !. click that line of the window to reset that property to default.`,
					`oddify makes it so the part is centered on a .5 coordinate instead of a .0 coordinate, and vice versa. the images are edited to match, so the center row/column(s) might be deleted or expanded. it can also be used in perspective mode, to affect perspective offset.`,
					`when changing something like the cell dimensions or vanishing point, you can leave a spot empty to leave it how it is. (for example, entering "72," for the cell dimensions would set the width as 72 and leave the height unchanged.)`,
					`you can load files by drag-and-dropping them onto the multiview canvas, or with ctrl+o.`,
					`if multiple nodes are on the same screen position, clicking it will select whichever one is closest to the camera. the text below the multiview shows the name of the part you're about to click.`,
					`if it's running slow:`,
					[
						`lower the state limit and truncator. (every state stores every frame's pose, and depending on how many animations you have, it can store a lot. the maximum amount it could be storing is limit + (number of animations - 1) * (2*truncator + 1).`,
						`turn off silhouettes`,
						`create perspectived/unperspectived images so it doesn't have to convert shapes. (i went through a lot of caching hell to avoid this process slowing things down, but still.)`,
						`lower fineness`
					]
					/*
					//`if you switch to the image editor while using the perspective pose tool, you'll only edit how it looks in the current view, while perspectived. you can use this to make a part bigger or smaller depending on how far it is from the camera.`,
					//`if you write a part name at the beginning of a shape point group, or a part name + a colon before a point, that group/point will follow the orientation and scaling of the named part, instead of the part the shape is part of. (this is useful for certain anatomy, like elbows.)`,
					//`if you type a negative number for the inbetween curve factor, the positions will be somewhat random.`,
					`"create inbetweens" creates new frames between the current frame and the next frame that act as a bridge between the two. "apply tweening" modifies existing frames instead. (ex: if you're on frame 2 and you "create" 5 inbetweens, it'll insert 5 inbetweens that start like frame 2 and end like frame 3. if you "apply" instead, existing frames 3-7 will be made into inbetweens for frames 2 and 8.)`,
					`when you use create or apply tweening, it doesn't do anything for parts that are hidden on the starting pose. for "create", those parts will stay like how they are in the starting pose the whole way through. for "apply", they'll stay how they were before. this is what makes "apply" tweening useful: you can keep the poses mostly the same while only tweening one character, one limb, etc.`
					*/
				]
			];
			for(i1 = 0; i1 < manual.length; i1++) {
				if(typeof manual[i1] == "string") {
					if(Array.isArray(manual[i1 + 1] ?? null)) {
						string += [
							``,
							`<details>`,
							`\t<summary>` + manual[i1] + `</summary>`,
							`\t` + arraytoul(manual[i1 + 1], 1).replaceAll(`\n`, `\n\t`),
							`</details>`
						].join(`\n`).replaceAll(`\n`, `\n\t`);
						i1++;
					}
				}
			}
			string += `\n</ul></details>`;
			string += [
				`<details>`,
				`\t<summary>bodytext</summary>`,
				`\t<button id="aa_bodychanges">apply changes</button> <select id="aa_bodychoices"></select>`,
				`\t<br><textarea id="aa_bodytext" cols=48></textarea>`,
				`</details>`
			].join(`\n`);
			string += [
				`<details>`,
				`\t<summary>posetext</summary>`,
				`\t<button id="aa_allframes">show ` + (aa.control.all_frames_posetext ? `one frame` : `all frames`) + `</button>`,
				`\t<br><button id="aa_posechanges">apply changes</button>`,
				`\t<br><textarea id="aa_posetext" cols=48></textarea>`,
				`</details>`
			].join(`\n`);
			document.write(string);
			aa.div.editmodetrue_active = document.getElementById("aa_editmodetrue_active");
			// the _active divs are used to make sure the height of
			// the active area is always the same, so the ui doesn't
			// jump around when you switch modes.
			aa.div.editmodetrue = document.getElementById("aa_editmodetrue");
			// hide everything in the part artist inside a div.
			aa.div.editmodetrue.hidden = true;
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aapa_" + i1;
					let canvas = document.getElementById(id);
					canvas.style["image-rendering"] = "crisp-edges";
					ref[i1] = canvas.getContext("2d");
					if(i1 === "ui") {
						//canvas.addEventListener("mousedown", aa.pa.ui.mousedown);
						canvas.onpointerdown = aa.pa.ui.mousedown;
					}
					else {
						//canvas.addEventListener("mousedown", aa.pa.mousedown);
						//canvas.addEventListener("mousemove", aa.pa.mousemove);
						//canvas.addEventListener("mouseup", aa.pa.mouseup);
						canvas.onpointerdown = aa.pa.mousedown;
						canvas.onpointermove = aa.pa.mousemove;
						canvas.onpointerup = aa.pa.mouseup;
					}
				}
			};
			loop.end();
			//
			for(i1 = 0; i1 < 2; i1++) {
				loop.tick(1);
				let ref = aa.pa.part[i1 ? "right" : "front"];
				let temp = aa.pa.part.rect(i1);
				temp = temp.w*temp.h;
				for(i2 = 0; i2 < temp; i2++) {
					loop.tick(2);
					ref[i2] = 0;
				};
				loop.end();
			}
			loop.end();
			// the initial defining has the image as an empty array. this
			// multiplies the right dimensions to create an array of zeroes, of
			// the right length
			aa.pa.redraw();
			aa.pa.ui.create();
			aa.pa.ui.draw();
			// aa.pa initialized.
			//
			ref = aa.ctx;
			string = ``;
			string += `<div id="aa_editmodefalse">`;
			string += `<div id="aa_editmodefalse_active">`;
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aa_" + i1;
					if(i1 !== "ui") {
						string += `<br>`;
					};
					string += `<canvas id="` + id + `"></canvas>`;
					if(i1 === "main") {
						string += `<div id="aa_div_coor"></div>`;
						string += `</div>`;
						// end of active div
					}
				}
			};
			loop.end();
			string += `</div>`;
			// end of editmodefalse div
			string += `<br>`;
			// data text
			string += [
				`<dialog id="aa_editshape_dialog" autofocus>`,
				`enter new text to define the shape.`,
				`<br><textarea id="aa_editshape_input"></textarea>`,
				`<br><button id="aa_editshape_enter">enter</button>`,
				`<button id="aa_editshape_close">close</button>`,
				`</dialog>`
			].join("\n");
			document.write(string);
			aa.div.editmodefalse = document.getElementById("aa_editmodefalse");
			// enclose it all in another div, so it can switch which one is
			// hidden.
			aa.div.editmodefalse_active = document.getElementById("aa_editmodefalse_active");
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aa_" + i1;
					let canvas = document.getElementById(id);
					canvas.style["image-rendering"] = "crisp-edges";
					ref[i1] = canvas.getContext("2d");
					if(i1 === "ui") {
						//canvas.addEventListener("mousedown", aa.ui.mousedown);
						canvas.onpointerdown = aa.ui.mousedown;
					}
					else {
						//canvas.addEventListener("mousedown", aa.mousedown);
						//canvas.addEventListener("mousemove", aa.mousemove);
						//canvas.addEventListener("mouseup", aa.mouseup);
						canvas.onpointerdown = aa.mousedown;
						canvas.onpointermove = aa.mousemove;
						canvas.onpointerup = aa.mouseup;
						// like mouse events, except they work for phones and
						// drawing tablets.
						canvas.style["touch-action"] = "none";
						// this keeps it from sliding around when you're using a
						// phone.
						canvas.ondragover = function(e) {
							e.preventDefault();
						};
						canvas.ondrop = function(e) {
							let files = e.dataTransfer.items;
							if(files.length >= 1 && files[0].kind === "file") {
								aa.readfile(files[0].getAsFile());
							};
							e.preventDefault();
						};
						// lets you load things by dropping files onto the
						// canvas.
					}
				}
			};
			loop.end();
			aa.div.coor = document.getElementById("aa_div_coor");
			aa.div.coor.style["text-shadow"] = "silver .5px .5px";
			aa.div.coor.style["font-size"] = "8px";
			let temp = document.getElementById("aa_bodytext");
			temp.value = aa.bodytext;
			temp.rows = temp.value.split(String.fromCharCode(10)).length;
			temp.style["-moz-tab-size"] = 4;
			temp.style["vertical-align"] = "top";
			temp = document.getElementById("aa_posetext");
			temp.rows = temp.value.split(String.fromCharCode(10)).length;
			temp.style["-moz-tab-size"] = 4;
			temp.style["vertical-align"] = "top";
			aa.writecoordinates(null);
			string = [];
			for(i1 in AAX.Body.templates) {
				if(AAX.Body.templates.hasOwnProperty(i1)) {
					string[string.length] = `<option value="` + i1 + `">` + i1 + `</option>`;
				}
			}
			string = [
				`<option value="current">current</option>`,
				`<hr>`
			].concat(string).concat([
				`<hr>`,
				`<option value="custom">custom</option>`
			]);
			temp = document.getElementById("aa_bodychoices");
			temp.innerHTML += `\n\t` + string.join(`\n\t`) + `\n`;
			temp.onchange = function() {
				let name = document.getElementById("aa_bodychoices").value;
				let ref = document.getElementById("aa_bodytext");
				if(name === "current") {
					ref.value = aa.bodytext;
				}
				else if(AAX.Body.templates.hasOwnProperty(name)) {
					ref.value = AAX.Body.templates[name];
				}
				else if(name !== "custom") {
					console.log("this shouldn't happen");
				}
			};
			document.getElementById("aa_bodytext").onkeyup = function() {
			// using keyup instead of change, since this changes the bodychoices
			// selection, and the bodychoices selection edits the body textarea.
			// that could cause an infinite loop.
				let value = document.getElementById("aa_bodytext").value;
				let options = document.getElementById("aa_bodychoices").options;
				let bool = false;
				let select = "custom";
				if(value === aa.bodytext) {
					select = "current";
				}
				else {
					for(let i1 = 0; i1 < options.length && select === "custom"; i1++) {
						let name = options[i1].innerHTML;
						if(name !== "custom" && name !== "current" && value === AAX.Body.templates[name]) {
							// if the body textarea matches the value of an option,
							// select that option.
							select = name;
						}
					}
				}
				document.getElementById("aa_bodychoices").value = select;
			}
			document.getElementById("aa_bodychanges").addEventListener("pointerdown", function() {
				let text = document.getElementById("aa_bodytext").value;
				let body = AAX.Body.new(text);
				if(typeof body !== "object") {
				// errors from invalid input
					alert(body);
				}
				else if(confirm([
					`if you change the body text, the poses will be edited to fit the new body.`,
					`- ALL UNDO/REDO HISTORY will be cleared.`,
					`- all poses will be converted to a blank pose, carrying over whatever it can from the old version. (properties, where the coordinates are relative to where they were in the old and new default pose)`,
					`continue?`
				].join(`\n\n`))) {
					let i1 = 0;
					let i2 = 0;
					let i3 = 0;
					let old_rel = AAX.all_rel(aa.body);
					let old_abs = AAX.all_abs(aa.body);
					// the coordinates every part had in the old body's default
					// pose
					let old_body = aa.body;
					aa.bodytext = text;
					aa.body = body;
					if(aa.body.hasOwnProperty("head")) {
						aa.drawsettings.vp.y = aa.drawsettings.standpoint.y + AAX.abscoor(aa.body, "head")[1];
					};
					// set the camera at eye level
					for(i1 = 0; i1 < aa.anims.length; i1++) {
					// for every frame of every animation, edit the coordinates
					// to be like they're derivative of the new body instead of
					// the old body.
					// - don't use the anim_index setter. it'd be convenient in
					//   some ways, but that makes it use AAX.posefromobj with
					//   the new body instead of the old. that causes errors if
					//   the structure is different.
						let anim = aa.anims[i1];
						anim.states = [ anim.states[ anim.state_index ] ];
						anim.state_index = 0;
						// delete undo/redo history (i don't think it'd cause
						// problems if i converted it like everything else, but
						// it's wasteful to bother with every state when most of
						// them won't be used.)
						// - most importantly, the body change itself doesn't
						//   fit in the undo/redo system at all, so... there's
						//   not much point in previous states if they still
						//   have the biggest possible change applied despite
						//   being before it.
						let poseobjs = anim.states[ anim.state_index ].poseobjs;
						for(i2 = 0; i2 < poseobjs.length; i2++) {
							let pose = AAX.posefromobj(aa, old_body, poseobjs[i2]);
							// they have to be AAX.Parts at the time, or
							// coordinate setters and stuff like abscoor won't
							// run.
							let old_odd = AAX.all_abs(pose);
							for(i3 in old_odd) {
								if(old_odd.hasOwnProperty(i3)) {
									old_odd[i3] = [
										!!(old_odd[i3][0]%1) !== !!(old_abs[i3][0]%1),
										!!(old_odd[i3][1]%1) !== !!(old_abs[i3][1]%1),
										!!(old_odd[i3][2]%1) !== !!(old_abs[i3][2]%1)
									];
								}
							}
							let old_pose_rel = AAX.all_rel(pose);
							//
							let oldpose = AAX.poseobj(pose);
							// non-default stuff in the old pose
							let newpose = AAX.poseobj(aa.newpose());
							// default pose of the new body
							for(i3 in oldpose) {
								if(oldpose.hasOwnProperty(i3) && newpose.hasOwnProperty(i3)) {
								// copy properties, but only for parts shared
								// between old and new
									delete oldpose[i3].cache;
									// cache is obsolete after the body change
									let relcoor = AAX.relcoor(newpose[i3]);
									delete oldpose[i3].x;
									delete oldpose[i3].y;
									delete oldpose[i3].z;
									// these would overwrite the relative
									// coordinates. it needs to start from the
									// new body's default pose. the coordinates
									// part of the pose will be done in
									// AAX.bodychange.
									newpose[i3] = structuredClone(oldpose[i3]);
									newpose[i3].x = relcoor[0];
									newpose[i3].y = relcoor[1];
									newpose[i3].z = relcoor[2];
								}
							}
							poseobjs[i2] = AAX.bodychange(aa, aa.body, newpose, old_rel, old_pose_rel, old_odd);
							// copy the coordinate parts of the pose
							//console.log(objectdifference(logging, AAX.poseobj(pose)));
							if(i1 === aa.anim_index) {
								aa.frames[i2] = aa.posefromobj(poseobjs[i2]);
							};
						}
					}
					//aa.loadstate(aa.state_index, true);
					if(!aa.body.hasOwnProperty(aa.control.partname)) {
					// can't have partname be a part that doesn't exist anymore.
						let done = false;
						for(i1 in aa.body) {
							if(aa.body.hasOwnProperty(i1) && !done && aa.body[i1].parent === "standpoint") {
								aa.control.partname = i1;
							}
						}
						if(!done) {
							console.log("this shouldn't happen");
						}
					}
					aa.refresh("states");
					// it'd be redundant to make a new state.
				};
			});
			document.getElementById("aa_posechanges").addEventListener("pointerdown", function() {
				let text = document.getElementById("aa_posetext").value;
				if(aa.control.all_frames_posetext) {
					text = text.split("\n***\n");
					aa.frames = [];
					for(let i1 = 0; i1 < text.length; i1++) {
						aa.frames[i1] = aa.texttopose(text[i1]);
					};
					aa.clampframe();
				}
				else {
					aa.frames[aa.currframe] = aa.texttopose(text);
					// can't use currpose because that's just a getter.
				};
				aa.refresh();
			});
			document.getElementById("aa_allframes").addEventListener("pointerdown", function(e) {
				aa.control.all_frames_posetext = !aa.control.all_frames_posetext;
				e.target.innerHTML = `show ` + (aa.control.all_frames_posetext ? `one frame` : `all frames`);
				aa.refresh(["draw", "ui", "states"]);
				aa.filldatatext();
			});
			// div creation, non-canvas buttons
			document.getElementById("aa_editshape_enter").onpointerdown = function(e) {
				let shape = AAX.strings.shape(document.getElementById("aa_editshape_input").value, aa.currpose, aa.control.partname);
				if(shape) {
					aa.control.part.shape = structuredClone(shape);
					aa.refresh();
					// don't skip anything
				}
				else {
					alert(`invalid shape input.`);
				};
				document.getElementById("aa_editshape_input").value = "";
				document.getElementById("aa_editshape_dialog").close();
			};
			document.getElementById("aa_editshape_close").onpointerdown = function(e) {
				document.getElementById("aa_editshape_input").value = "";
				document.getElementById("aa_editshape_dialog").close();
			};
			aa.drawsettings.standpoint.x = Math.floor(aa.drawsettings.cell.w/2 + aa.drawsettings.standpoint.x);
			aa.drawsettings.standpoint.y = Math.floor(aa.drawsettings.cell.h/2 + aa.drawsettings.standpoint.y);
			// they start out relative to the center
			let body = aa.body;
			if(typeof body !== "object") {
				alert(body);
				return;
			};
			for(i1 in body) {
				loop.tick(1);
				if(body.hasOwnProperty(i1) && body[i1].parent === "standpoint") {
					aa.control.partname = i1;
				}
			}
			loop.end();
			if((aa.control.partname ?? null) === null) {
				console.log("invalid initial body text.");
				return;
			};
			aa.drawsettings.vp.x = aa.drawsettings.standpoint.x;
			if(aa.body.hasOwnProperty("head")) {
				aa.drawsettings.vp.y = aa.drawsettings.standpoint.y + AAX.abscoor(aa.body, "head")[1];
			}
			else {
				aa.drawsettings.vp.y = Math.floor(aa.drawsettings.vp.y/2);
			}
			// this has to be done here so that head is fully defined
			aa.anims[0] = aa.newanim();
			let canvas = aa.ctx.main.canvas;
			canvas.addEventListener("mousedown", aa.mousedown);
			canvas.addEventListener("mousemove", aa.mousemove);
			canvas.addEventListener("mouseup", aa.mouseup);
			aa.ctx.main.font = "6px 'thick 4x4'";
			aa.ui.create();
			temp = new Date();
			temp = [temp.getFullYear().toString(), (temp.getMonth() + 1).toString(), temp.getDate().toString()];
			for(i1 = 1; i1 < temp.length; i1++) {
				temp[i1] = "0".repeat(2 - temp[i1].length) + temp[i1];
			}
			aa.control.projectname = temp.join("_") + " " + aa.control.projectname;
			aa.anim_index = 0;
			// it was already 0, but the setter will fill aa.frames.
			aa.refresh("states");
			aa.animator = new Animator(
				"aa_animator",
				{
					fps: {
						br: true,
					},
					play: {
						space: true,
					},
					loop: {
						br: true,
					},
					pingpong: {
						br: true,
					},
					button_update: {
						br: true,
						onclick: aa.updateanimation,
					},
					button_update_alt: {
						space: true,
						onclick: function() { aa.updateanimation(aa.control.view) },
						text: "update (one view)",
					},
					sheet: {
						br: true,
						cols: 0,
					},
				}
			);
			for(i1 = 0; i1 < 2; i1++) {
				loop.tick(1);
				let canvas = aa.animator[i1 ? "sheet" : "ctx"].canvas;
				canvas.style["image-rendering"] = "crisp-edges";
				canvas.ondragover = function(e) {
					e.preventDefault();
				};
				canvas.ondrop = function(e) {
					e.preventDefault();
				};
				// it's easy to mistake these canvases for the main canvas. for
				// me, it opens the txt in the browser, ie i have to hit back to
				// return to where i was. depending on your browser, that might
				// be the same as refreshing the page and wiping everything you
				// did.
			}
			loop.end();
			//string = aa.animator.name + `_update`;
			//aa.animator.div.innerHTML += `<br><button id="` + string + `">update</button>`;
			//document.getElementById(string).onclick = aa.updateanimation;
			aa.updateanimation();
		},
		editmodetoggle: function() {
			let div = [
				aa.div.editmodefalse,
				aa.div.editmodetrue
			];
			let activediv = [
				aa.div.editmodefalse_active,
				aa.div.editmodetrue_active
			];
			activediv[0].height = undefined;
			activediv[1].height = undefined;
			const h = Math.max(activediv[0].getBoundingClientRect().height, activediv[1].getBoundingClientRect().height);
			aa.control.editmode = !aa.control.editmode;
			div[Number(!aa.control.editmode)].hidden = true;
			div[Number(aa.control.editmode)].hidden = false;
			//activediv[Number(aa.control.editmode)].style.height = h;
			// i went to the trouble of creating separate "active area" divs,
			// and this doesn't even work. oh well.
			// - the problem is that .height is not how you change heights. i
			//   don't know how you do this.
		},
		filldatatext: function() {
			document.getElementById("aa_bodychoices").value = "current";
			let textarea = document.getElementById("aa_bodytext");
			textarea.value = aa.bodytext;
			// you'd think the event listener would do this, but it seems like
			// onchange doesn't fire just from .value being changed.
			textarea.rows = aa.bodytext.split("\n").length;
			// the body textarea should generally be aa.bodytext, but i don't
			// want to reset it to that in the "apply body changes" event
			// listener because that's a really bad time to clear their input...
			// (the two instances where it doesn't use the body text are when
			// the body text has a syntax error, and when the user changes their
			// mind so they don't clear the frames. in neither case should their
			// input be wiped.)
			let text = "";
			if(aa.control.all_frames_posetext) {
				text = [];
				for(let i1 = 0; i1 < aa.poseobjs.length; i1++) {
					text[i1] = aa.poseobjtotext(aa.poseobjs[i1]);
				}
				text = text.join("\n***\n");
				// it isn't super efficient to calculate every one of them
				// but..! tragically..! i can't give a shit about that!
				// - i'd have to create a second array that has to be spliced
				//   with the main array, or create a {pose, text} structure
				//   that's annoying and dumb in its own right. especially since
				//   there's nothing guaranteeing that the text stay accurate.
				// - maybe i'll do it if i ever have a third thing to store per
				//   frame. i'll make sure to have a getter structure, where
				//   _text gets set as null every refresh, and the getter
				//   generates it again if it's null
			}
			else {
				text = aa.poseobjtotext(aa.currposeobj);
			};
			textarea = document.getElementById("aa_posetext");
			textarea.value = text;
			textarea.rows = text.split("\n").length;
		},
		refresh: function(skip) {
		// refreshes everything to account for changes.
		// - multiview
		// - ui graphics
		// - pose text textarea
		// - .images
		// =
		// - i should add arguments for specifying which changes there were. or
		//   which there weren't, probably.
		//   - pose
		//   - ui graphics
		//   - pose text
		// - skip: string or array of strings for specifying steps that should
		//   be skipped. it should be one of the strings in .valid.refresh.
		//   - "draw": .draw, and saving aa.images
		//   - "ui": ui.draw
		//   - "states": updating bodytext/posetext, and adding to the .states
		//     array that undo/redo use. (this one's used the most often. lots
		//     of actions cause .refresh, but not all of those are worth being
		//     undo-able.)
		//     - datatext used to be a separate skip thing, but 90% of the time,
		//       it's skipped when states are. use aa.filldatatext for the
		//       remaining 10%.
			let starttime = new Date().valueOf();
			let i1 = 0;
			let loop = new Loop("aa.refresh");
			if(typeof skip === "string") {
				skip = [skip];
			}
			else if(!Array.isArray(skip)) {
				skip = [];
			}
			if(!skip.includes("draw")) {
				aa.draw_background();
				aa.draw();
				const ctx = aa.ctx.main;
				const cell = aa.drawsettings.cell;
				aa.images = [];
				for(i1 = 0; i1 < 4; i1++) {
					loop.tick(1);
					aa.images[i1] = ctx.getImageData(cell.w*i1, 0, cell.w, cell.h);
				}
				loop.end();
				// save images, which are used to reverse graphical changes in
				// the clickable interface
			};
			if(!skip.includes("ui")) {
				aa.ui.draw();
			};
			if(!skip.includes("states")) {
				aa.savestate();
				aa.filldatatext();
			};
			//console.log("aa.refresh() took " + (new Date().valueOf() - starttime)/1000 + " seconds.");
		},
		box: function(size, oddness) {
		// uses size and oddness to return a box centered on [0, 0, 0], with the
		// right dimension changes from oddness.
		// - even number sizes get +1 if the dimension is odd, odd numbers get
		//   -1 if the dimension is odd.
			let dim = [
				AAX.onedim(size, oddness[0]),
				AAX.onedim(size, oddness[1]),
				AAX.onedim(size, oddness[2])
			];
			return {
				x: -(dim[0] - 1)/2,
				y: -(dim[1] - 1)/2,
				z: -(dim[2] - 1)/2,
				w: dim[0],
				h: dim[1],
				d: dim[2],
			};
		},
		rect: function(size, oddness, right) {
			if(oddness.length === 3) {
				oddness = [oddness[0], oddness[right ? 2 : 1]];
			};
			let rect = aa.box(size, oddness);
			delete rect.z;
			delete rect.d;
			return rect;
		},
		hypot: (partname, deform) => AAX.hypot(aa.body, aa.currpose, partname, deform),
		//AAX.image_oddness(body, name, view);
		//AAX.onedim(size, odd)
		//aa.box(size, oddness)
		//AAX.l_dim(length, oddness, right)
		//AAX.dim(body, part, view, length, size)
		//aa._rect(size, oddness, right)
		//aa.hypot(partname, deform)
		movecoor: function(part, hypot, coor1, coor2, sign3, axes) {
		// what the main move mode uses. returns a full set of coordinates,
		// relative to the parent.
		// - coor1, coor2, axes: new relative coordinates for both axes, and a
		//   two-letter string for what axes those are.
		//   - axes should be a two-letter string of the axes coor1 and coor2
		//     are.
		// - it applies move1 and move2 to the relative coordinates it already
		//   had, then calculates the third axis by what fits within the
		//   hypotenuse, has a Math.sign matching sign3, and has the same
		//   posmod(coordinate, 1)s as before.
		// - NOTE this is not allowed to move in decimal numbers. that's what
		//   oddify is for.
		// - this is used to display numbers on the screen, too.
			let i1 = 0;
			if(typeof axes !== "string" || axes.length < 2 || !"xyz".includes(axes[0]) || !"xyz".includes(axes[1]) || axes[0] === axes[1]) {
				console.log("invalid axes.");
				return;
			}
			else if(![-1, 1].includes(sign3)) {
				console.log("invalid sign3. must be 1 or -1.");
			};
			hypot ??= aa.hypot(part.name);
			// reference the hypotenuse in body (using the pose's hypotenuse
			// would make it subject to rounding decay)
			let axis1 = "xyz".indexOf(axes[0]);
			let axis2 = "xyz".indexOf(axes[1]);
			let axis3 = "xyz".indexOf( "xyz".replace(axes[0], "").replace(axes[1], "") );
			let float = part.rel_oddness;
			float = [
				float[0]/2,
				float[1]/2,
				float[2]/2
			];
			const old_relcoor = part.relcoor;
			const diff = [
				Math.round( (old_relcoor[axis1] - coor1) *2)/2,
				Math.round( (old_relcoor[axis2] - coor2) *2)/2
			];
			if(diff[0] === 0 && diff[1] === 0) {
			// no change
				return old_relcoor;
			}
			else if(
				!Number.isInteger( diff[0] )
				||
				!Number.isInteger( diff[1] )
			) {
				console.log("invalid coor1 or coor2. the difference between them and the original must be an integer.");
				return;
			};
			let point = structuredClone(old_relcoor);
			point[axis1] = coor1;
			point[axis2] = coor2;
			let temp = (hypot + .5)**2 - (point[axis1]**2 + point[axis2]**2);
			point[axis3] = (
				temp <= 0
				?
				0
				// fixfloats will take care of trimming the other two.
				:
				sign3*Math.sqrt(temp)
			);
			point = AAX.fixfloats(point, float, hypot, true, "hypot");
			// list of valid points, sorted by highest hypotenuse first
			if(diff[0] === 0) {
			// pick the first point whose axis1 is still the same as it is in
			// old_relcoor (if you didn't move it in that axis, you wouldn't
			// expect a change in that axis. but the math in fixfloats sort of
			// encourages that.)
				for(i1 = 0; i1 < point.length; i1++) {
					if(point[i1][axis1] === old_relcoor[axis1]) {
						return point[i1];
					}
				}
			}
			else if(diff[1] === 0) {
				for(i1 = 0; i1 < point.length; i1++) {
					if(point[i1][axis2] === old_relcoor[axis2]) {
						return point[i1];
					}
				}
			}
			return point[0];
		},
		rotatecoor: function(fulcrum, angle, format) {
		// returns new relative coordinates for all parts involved in a
		// rotation. (like .movecoor and .oddify, it does not modify the pose,
		// just shows how it should be modified.)
		// - fulcrum: name of the part that acts as a fulcrum, with all
		//   descendants rotating around it
		// - angle, format: radians and "xy", "xz", or "yz"
			let i1 = 0;
			if(!["yz", "xz", "xy"].includes(format)) {
				console.log("invalid format.");
				return;
			};
			let temp = AAX.getdesc(aa.currpose, fulcrum);
			if(temp.length === 0) {
			// there's no parts to rotate.
				return {};
			};
			let body = {};
			for(i1 = 0; i1 < temp.length; i1++) {
				body[ temp[i1] ] = aa.currpose[ temp[i1] ].relcoor;
			}
			// all that matters is the relative coordinates of the fulcrum's
			// descendants.
			let part = "";
			for(part in body) {
				if(body.hasOwnProperty(part)) {
					body[part] = [
						Math.round(body[part][0]*2)/2,
						Math.round(body[part][1]*2)/2,
						Math.round(body[part][2]*2)/2
					];
					let hypot = aa.hypot(part, true);
					let float = [
						posmod(body[part][0], 1),
						posmod(body[part][1], 1),
						posmod(body[part][2], 1)
					];
					let point = revolve(angle, body[part], null, format);
					let array = AAX.fixfloats(point, float, hypot, true);
					point = null;
					let zeroaxis = ["yz", "xz", "xy"].indexOf(format);
					// the axis that should have no change compared to before
					// rotation.
					for(i1 = 0; point === null && i1 < array.length; i1++) {
						if(array[i1][zeroaxis] === body[part][zeroaxis]) {
							point = structuredClone(array[i1]);
						}
					}
					point ??= array[0];
					// if none of them matched the zeroaxis thing, just pick the
					// the first one.
					body[part] = structuredClone(point);
				}
			};
			return body;
		},
		coortocanvas: (point, view, nonulls, viewoffset) => AAX.coortocanvas(aa.drawsettings.cell, aa.drawsettings.standpoint, point, view, nonulls, viewoffset),
		coorfromcanvas: function(x, y, view) {
		// returns an object of two coordinates, based on where you clicked the
		// canvas.
		// - view: if specified, it won't calculate view automatically. (this
		//   way, if you want to get the coordinates of a view 0 click that
		//   drifted off to view 1, it won't screw up.)
			view ??= Math.floor(x/aa.drawsettings.cell.w);
			const standpoint = aa.coortocanvas([0, 0, 0], view, true, true);
			let coor = [
				x - standpoint[0],
				y - standpoint[1]
			];
			if([1, 2].includes(view)) {
				coor[0] *= -1;
			};
			return {
				["xz"[view%2]]: coor[0],
				y: coor[1],
			};
		},
		newpose: () => AAX.newpose(aa, aa.body),
		frameclone: (frame) => AAX.poseclone(aa, aa.body, aa.frames[frame]),
		posefromobj: (obj) => AAX.posefromobj(aa, aa.body, obj),
		posetext: function(frame, anim_index) {
		// converts a pose to text.
		// - use the poseobj so it only keeps the data worth keeping
		// - convert images to text
		// - objtotext
			anim_index ??= aa.anim_index;
			let anim = aa.anims[anim_index];
			let state = anim.states[anim.state_index];
			frame ??= state.currframe;
			return aa.poseobjtotext(state[frame]);
		},
		poseobjtotext: function(_obj) {
			_obj ??= aa.currposeobj;
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let loop = new Loop("aa.posetext");
			let obj = structuredClone(_obj);
			// clone it, since it'll be edited
			for(i1 in obj) {
				loop.tick(1);
				if(obj.hasOwnProperty(i1)) {
					delete obj[i1].cache;
					// by definition, cache does not save anything worth saving.
					// it'd clutter up the posetext too.
					for(i2 = 0; i2 < 2; i2++) {
					// stringify all images.
					// - remember, AAX.poseobj omits "default"s, empty objects,
					//   and objects with nothing but "default"s, so the logic
					//   has to account for that weird structure.
						loop.tick(2);
						let temp = i2 ? "perspective" : "image";
						if(obj[i1].hasOwnProperty(temp) && typeof obj[i1] === "object" && obj[i1]) {
							const imageobj = obj[i1][temp];
							for(i3 in imageobj) {
								loop.tick(3);
								if(imageobj.hasOwnProperty(i3)) {
									let view = Number(i3);
									view = isNaN(i3) ? i3 : view;
									if(AAX.valid.view.includes(view) && !["default", null].includes(imageobj[view])) {
									// without the help of AAX..dim, it is a
									// bitch to get the right dimensions.
										const w = AAX.l_dim(imageobj[view].length, AAX.partobj_image_oddness(aa.body, i1, obj[i1], view))[0];
										imageobj[view] = "\n" + Raster.totext(imageobj[view], w) + "\n";
										// add line breaks so it doesn't have an
										// awkward indentation skew at the first
										// line. (fromtext uses .trim(), so it's
										// fine.)
									}
								}
							}
							loop.end();
						}
					}
					loop.end();
				}
			};
			loop.end();
			return objtotext(obj);
			// bracketindent JSON.stringify-s when used with an object
		},
		texttopose: function(text) {
			let i1 = 0;
			let loop = new Loop("aa.texttopose");
			let obj = texttoobj(text);
			// this should be the same as a poseobj object, except the images
			// are text.
			for(i1 in obj) {
				loop.tick(1);
				if(obj.hasOwnProperty(i1)) {
					obj[i1].cache = structuredClone(AAX.cache_init);
					// the text omitted the cache, so recreate it.
					for(i2 = 0; i2 < 2; i2++) {
					// unstringify all images.
						loop.tick(2);
						let temp = i2 ? "perspective" : "image";
						if(obj[i1].hasOwnProperty(temp) && typeof obj[i1] === "object" && obj[i1]) {
							const imageobj = obj[i1][temp];
							for(i3 in imageobj) {
								loop.tick(3);
								if(imageobj.hasOwnProperty(i3)) {
									let view = Number(i3);
									view = isNaN(i3) ? i3 : view;
									if(AAX.valid.view.includes(view) && !["default", null].includes(imageobj[view])) {
										const w = pose[i1].dim(view)[0];
										imageobj[view] = Raster.fromtext(imageobj[view]).raster;
									}
								}
							}
							loop.end();
						}
					}
					loop.end();
				}
			};
			loop.end();
			return aa.posefromobj(obj);
		},
		posetoshape: function() {
		// creates a shape from an entire posed body, using the silhouette
		// system.
			let i1 = 0;
			let i2 = 0;
			let loop = new Loop("aa.posetoshape");
			let pose = aa.currpose;
			let groups = [];
			let capsules = [];
			function addgroup(group) {
				let loop = new Loop("aa.posetoshape addgroup");
				let bool = false;
				// boolean for whether it found an existing group that has all the same parts
				for(let i1 = 0; !bool && i1 < groups.length; i1++) {
					loop.tick(1);
					if(groups[i1].length >= group.length) {
						bool = true;
						for(let i2 = 0; bool && i2 < group.length; i2++) {
							loop.tick(2);
							if(!groups[i1].includes(group[i2])) {
								bool = false;
							}
						}
						loop.end();
					}
				}
				loop.end();
				if(!bool) {
					groups[groups.length] = structuredClone(group);
				}
			}
			for(i1 in pose) {
				loop.tick(1);
				if(pose.hasOwnProperty(i1)) {
					if(!pose[i1].hide) {
						let conn = pose[i1].connection;
						if(conn.type === "generation") {
							addgroup(pose[i1].silhouettelist);
						}
						else if(conn.type === "capsule") {
							capsules[capsules.length] = i1;
							addgroup([i1]);
						}
						else {
							console.log("this shouldn't happen");
						}
					}
				}
			}
			loop.end();
			let _partshapes = {};
			function addoffset(points, offset) {
				let _points = [];
				let loop = new Loop("aa.posetoshape addoffset");
				for(let i1 = 0; i1 < points.length; i1++) {
					loop.tick(1);
					_points[i1] = structuredClone(points[i1]);
					_points[i1][0] += offset[0];
					_points[i1][1] += offset[1];
					_points[i1][2] += offset[2];
				}
				loop.end();
				return _points;
			}
			function partshape(partname) {
			// use this like a getter
				_partshapes[partname] ??= addoffset(
					pose[partname].orientedshape.flat(1),
					pose[partname].abscoor
				);
				return _partshapes[partname];
			}
			let points = structuredClone(groups);
			for(i1 = 0; i1 < points.length; i1++) {
			// for each group
			loop.tick(1);
				for(i2 = 0; i2 < points[i1].length; i2++) {
				// for each part name
				loop.tick(2);
					points[i1][i2] = partshape(points[i1][i2]);
				}
				loop.end();
				points[i1] = points[i1].flat(1);
			}
			loop.end();
			for(i1 = 0; i1 < capsules.length; i1++) {
				loop.tick(1);
				let part = pose[capsules[i1]];
				let temp = part.connection.value;
				points[points.length] = addspheroids([
					part.abscoor.concat(temp),
					pose[part.parent].abscoor.concat(temp)
				], aa.drawsettings.fineness);
			}
			loop.end();
			return {
				points,
				external: {
					points: {},
					groups: {},
				},
			};
		},
		draw_background: function() {
			AAX.draw_background(aa.ctx.main, aa.drawsettings, aa.color, aa.control.perspectived, 4);
		},
		draw: function(rotatecoor, poles) {
			aa._draw(
				aa.ctx.main, aa.drawsettings, aa.color, aa.control.perspectived, 4,
				aa.currpose, aa.nodes, aa.control.strokecache, rotatecoor, poles
			);
		},
		_draw: function(
			ctx, drawsettings, color, perspectived, numofcells,
			pose, nodes, strokecache, rotatecoor, poles
		) {//yyyaad
		// draws or redraws the main canvas, the one with the multiview on it.
		// - NOTE it also defines the nodes.
		// - rotatecoor: the return of an aa.rotatecoor running, with the
		//   absolute argument as true. used in the rotate pose tool's mid-click
		//   visualization. parts in here will be drawn differently.
		// - poles: the return of an aa.poles running. used to draw axes.
			//let time = new Date().valueOf();
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let loop = new Loop("AAX.draw", 10000);
			let view = 0;
			let ds = drawsettings;
			numofcells ??= 4;
			nodes ??= {};
			let coortocanvas = (point, view, nonulls, viewoffset) => AAX.coortocanvas(ds.cell, ds.standpoint, point, view, nonulls, viewoffset);
			let imagedata = [];
			for(i1 = 0; i1 < numofcells; i1++) {
				loop.tick(1);
				imagedata[i1] = ctx.getImageData(i1*ds.cell.w, 0, ds.cell.w, ds.cell.h);
			}
			loop.end();
			let abs = AAX.all_abs(pose);
			// all absolute coordinates
			rotatecoor ??= {};
			poles ??= {};
			// so i don't have to tack on "typeof rotatecoor !== "object" ||"
			// onto everything.
			let fulcrum_name = null;
			// name of the fulcrum. only used in rotatecoor code
			if(!objectisempty(rotatecoor)) {
			// absolutes the coordinates.
			// - thanks to getdesc, it should iterate in an order where the
			//   parent will always have been rotated and absoluted first.
				rotatecoor = structuredClone(rotatecoor);
				// unreference it
				for(part in rotatecoor) {
					loop.tick("part");
					if(rotatecoor.hasOwnProperty(part)) {
						let parent = pose[part].parent;
						fulcrum_name ??= parent;
						// the first properties should be children of the
						// fulcrum
						if(parent === fulcrum_name) {
							parent = pose[parent].abscoor;
						}
						else if(rotatecoor.hasOwnProperty(parent)) {
							parent = rotatecoor[parent];
						}
						else {
							console.log("this shouldn't happen");
						};
						rotatecoor[part][0] += parent[0];
						rotatecoor[part][1] += parent[1];
						rotatecoor[part][2] += parent[2];
					}
				}
				loop.end();
			};
			ctx.canvas.width = ds.cell.w;
			ctx.canvas.height = ds.cell.h;
			function visible(part, element) {
			// returns a boolean for whether a given element and part should be
			// drawn, based on .hide and rotatecoor. (but NOT the booleans in
			// drawsettings.)
				if(part.hide && ds.total_hide) {
					return false;
				}
				else if(["silhouette", "parts", "perspective"].includes(element)) {
					return !rotatecoor.hasOwnProperty(part.name) && !part.hide;
				}
				else if(element === "skeleton") {
					if(
						part.parent === "standpoint"
						||
						rotatecoor.hasOwnProperty(part.name)
						||
						(
							part.pose[part.parent].hide
							&&
							ds.total_hide
						)
					) {
						return false;
					};
					let hidden = part.hide;
					if(hidden) {
					// override if it has descendants that aren't hidden
						let temp = AAX.getdesc(pose, part.name);
						let i1 = 0;
						for(i1 = 0; hidden && i1 < temp.length; i1++) {
							loop.tick(1);
							if(!pose[ temp[i1] ].hide) {
								hidden = false;
							};
						}
						loop.end();
					};
					return !hidden;
				}
				else if(element === "nodes") {
					return !rotatecoor.hasOwnProperty(part.name);
				};
			};
			function drawpoles(_poles, coor, view, axis) {
			// _poles should be the poles for a single part, not the whole
			// object.
			// - coor: coordinates of the start of the axes. (don't include view
			//   offset.)
				let i1 = 0;
				let loop = new Loop("AAX.draw drawpoles");
				const styletemp = ctx.strokeStyle;
				ctx.strokeStyle = color.interface[2];
				let __poles = revolve(view*Math.PI/2, _poles, null, "xz");
				//revolve(angle, points, center, format)
				let check = Basis.check(__poles);
				if(check) {
				// log it if the lengths are wrong, or the angles between axes
				// aren't perpendicular
					console.log(check);
					console.log(view);
					console.log(__poles);
				}
				if(view === 0) {
					let _axis = (
						aa.control.posetool_inversion ? 1 :
						aa.control.view%2 ? 0 : 2
					);
					//console.log(__poles[_axis]);
				}
				const length = Math.hypot(
					ds.cell.w,
					ds.cell.h
				);
				// longest possible line within the cell
				const length2 = 8;
				// circles are drawn on the lines to measure foreshortening.
				// this is how far along the line they should be.
				let center = coortocanvas([0, 0, 0], view, true);
				__poles[0][3] = "x";
				__poles[1][3] = "y";
				__poles[2][3] = "z";
				__poles.sort((a, b) => a[2] - b[2]);
				// z sort
				for(i1 = 0; i1 < 3 + (false && axis !== null); i1++) {
					loop.tick(1);
					let pole = (
						i1 === 3
						?
						[
							roundspecial(axis[0]),
							roundspecial(axis[1])
						]
						:
						[
							roundspecial(__poles[i1][0]),
							roundspecial(__poles[i1][1])
						]
					);
					ctx.strokeStyle = i1 === 3 ? color.interface[2] : ["red", "green", "blue"][ "xyz".indexOf(__poles[i1][3]) ];
					if(pole[0] || pole[1]) {
					// skip it if it's perpendicular to the camera
						circledraw(
							ctx,
							coor[0] + pole[0]*length2,
							coor[1] + pole[1]*length2,
							2,
							false
						);
						let hypot = Math.hypot(...pole);
						pole[0] /= hypot;
						pole[1] /= hypot;
						// make hypot 1
						// - draw the circle first, since that's meant to show
						//   foreshortening and this will negate that.
						linespecial(
							ctx,
							...coor,
							coor[0] + pole[0]*length,
							coor[1] + pole[1]*length,
							center
						);
					}
					else {
						//console.log(view + " " + "xyz"[i1]);
						circledraw(ctx, ...coor, 2, false);
						//console.log(i1 + ": " + pole);
					};
				}
				loop.end();
				ctx.strokeStyle = styletemp;
			};
			function partimage(part, view) {
				if(view === "front" || view === "right") {
					console.log("this should only be run with 0-3 view numbers.");
					return;
				}
				const _view = perspectived ? view : view%2 ? "right" : "front";
				let image = (
					strokecache
					&&
					strokecache.hasOwnProperty(part.name)
					&&
					strokecache[part.name].hasOwnProperty(view)
					?
					strokecache[part.name][view]
					:
					part[(perspectived ? "perspective_" : "image_") + _view]
				);
				// use the strokecache, if possible.
				if(!perspectived && view >= 2) {
					const w = AAX.l_dim(image.length, part.image_oddness(_view))[0];
					image = Raster.xmirror(image, w);
				}
				return image;
			}
			function onesilhouette(partname, view, multiple) {
			// returns the _2dPoly for the given part, with an
			// offset applied.
			// - multiple: Raster._2dPoly argument. remember, this makes it an
			//   array of shapes instead of just one.
				let loop = new Loop("AAX.draw onesilhouette");
				let part = pose[partname];
				if(view === "front" || view === "right") {
					console.log("this should only be run with 0-3 view numbers.");
					return;
				}
				const _view = perspectived ? view : view%2 ? "right" : "front";
				let shape = partimage(part, view);
				shape = Raster._2dPoly(shape, part.dim(_view, shape.length), multiple);
				let node = aa.getnode(view, partname);
				node = [
					node.x - view*ds.cell.w,
					node.y,
				];
				// reverse view offset
				for(let i1 = 0; i1 < shape.length; i1++) {
				// add offset so it's relative to the canvas instead of relative
				// to the node
					loop.tick(1);
					if(multiple) {
						for(let i2 = 0; i2 < shape[i1].length; i2++) {
							loop.tick(2);
							shape[i1][i2][0] += node[0];
							shape[i1][i2][1] += node[1];
						}
						loop.end();
					}
					else {
						shape[i1][0] += node[0];
						shape[i1][1] += node[1];
					}
				}
				loop.end();
				return shape;
			}
			function drawpart(part, view, filltype, x, y) {
			// draws a part onto the canvas coordinates specified.
			// - perspectived: whether to use the perspectived images or not. it
			//   will also add the perspective coordinates to x/y.
			// - filltype:
			//   - falsy: all pixels are drawn
			//   - "fill only": only the fill color is drawn
			//   - "no fill": fill is not drawn
			//   =
			//   - those last two are used if ds.parts === "overlap"
				let i1 = 0;
				let loop = new Loop("AAX.draw drawpart", 10000);
				if(((x ?? null) === null) || ((y ?? null) === null)) {
					let temp = coortocanvas(part.abscoor, view, true);
					x = temp[0];
					y = temp[1];
					if(perspectived) {
						let coor = part["perspective_coor_" + view];
						x += coor[0];
						y += coor[1];
					};
				}
				const _view = perspectived ? view : view%2 ? "right" : "front";
				// number if perspectived, string if not
				let image = partimage(part, view);
				let oddness = part.image_oddness(_view);
				let temp = AAX.l_size(image.length, oddness);
				if(temp === null) {
					console.log({name: part.name, view, image, image_oddness: part.image_oddness(_view)});
				};
				temp = aa.rect(temp, oddness);
				const w = temp.w;
				const h = temp.h;
				x += temp.x;
				y += temp.y;
				// it should start at the top-left corner, not the center
				if(x%1 || y%1) {
					console.log(part.name + " view " + view + ": the x and y for the image drawing are not integers (" + x + ", " + y + ")");
				};
				//
				image = AAX.sq_raster.fill(image, w);
				//console.log(part.name + " " + view);
				//console.log(image);
				//console.log(image);
				let palette = {
					1: part.color1,
					2: part.color2,
					fill: color.part_interior,
				};
				if(w*h !== image.length) {
					console.log(part.name + " image length does not match the w*h. it's probably that changeoddness or changedimensions isn't being run when it should.");
				};
				for(i1 = 0; i1 < image.length; i1++) {
					loop.tick(1);
					if(
						image[i1]
						&&
						(
							!filltype
							||
							(filltype === "fill only" && image[i1] === "fill")
							||
							(filltype === "no fill" && image[i1] !== "fill")
						)
					) {
						let _x = i1%w;
						let _y = Math.floor(i1/w);
						ctx.fillStyle = palette[image[i1]];
						ctx.fillRect(x + _x, y + _y, 1, 1);
					};
				}
				loop.end();
			};
			for(view = 0; view < numofcells; view++) {
				loop.tick("view");
				ctx.putImageData(imagedata[view], 0, 0);
				nodes[view] = [];
				let _nodes = nodes[view];
				// used in the clickable interface. objects of x, y, name, and a
				// reference to their parent's node, sorted by z order.
				const stems = {};
				// an object of the node coordinates for the standpoint children
				for(i1 in pose) {
					loop.tick(1);
					if(pose.hasOwnProperty(i1)) {
						let coor = coortocanvas(pose[i1].abscoor, view, true, true);
						// no null, view offset
						if(perspectived) {
							let _coor = pose[i1]["perspective_coor_" + view];
							coor[0] += _coor[0];
							coor[1] += _coor[1];
						};
						_nodes[_nodes.length] = {
							x: coor[0],
							y: coor[1],
							z: ds.screen_z(abs[i1], view, perspectived),
							name: i1,
						};
						if(pose[i1].parent === "standpoint") {
							stems[i1] = structuredClone(coor);
						};
					}
				}
				loop.end();
				_nodes.sort(function(a, b) {
					let temp = a.z - b.z;
					return (
						roundspecial(temp)
						?
						temp
						:
						(
							Math.hypot(
								b.x - stems[ AAX.getstem(pose, b.name) ][0],
								b.y - stems[ AAX.getstem(pose, b.name) ][1]
							)
							-
							Math.hypot(
								a.x - stems[ AAX.getstem(pose, a.name) ][0],
								a.y - stems[ AAX.getstem(pose, a.name) ][1]
							)
						)
					);
					// if they're the same, prioritize nodes that are closer to
					// the standpoint child. (this sounds neurotic, but
					// otherwise the layering near the pelvis is l_hip, pelvis,
					// r_hip or something like that.)
				});
				// now it's an array of the order to draw parts in, taking into
				// account view number and xz/yz rotation.
				for(i1 = 0; i1 < _nodes.length; i1++) {
					loop.tick(1);
					let parent = pose[ _nodes[i1].name ].parent;
					if(parent === "standpoint") {
						_nodes[i1].parent = parent;
					}
					else {
						for(i2 = 0; i2 < _nodes.length; i2++) {
							loop.tick(2);
							if(_nodes[i2].name === parent) {
								_nodes[i1].parent = _nodes[i2];
								i2 += _nodes.length;
							}
						}
						loop.end();
						if(!_nodes[i1].hasOwnProperty("parent")) {
							console.log("this shouldn't happen");
						};
					}
				}
				loop.end();
				// create .parent, a reference to the node for the parent.
				if(ds.silhouette !== "off" && strokecache === null) {
				// silhouette can be kind of intensive, so i don't want it to
				// draw per frame.
					let groups = [];
					// - [group numbers]
					//   - [subgroup names]
					//     - _2dPoly.getdatas
					for(i1 = 0; i1 < _nodes.length; i1++) {
						loop.tick(1);
						let part = pose[ _nodes[i1].name ];
						const sl_center = coortocanvas([0, 0, 0], view, true);
						if(visible(part, "silhouette")) {
							let groupnum = ds.silhouette === "overlap" ? part.silhouette[0] : 0;
							let subgroup = ds.silhouette === "overlap" ? part.silhouette[1] : "";
							groups[groupnum] ??= {};
							groups[groupnum][subgroup] ??= [];
							let group = groups[groupnum][subgroup];
							let conn = part.connection;
							let image = null;
							if(!AAX.valid.connection.includes(conn.type)) {
								console.log("this shouldn't happen");
								conn = {
									type: "generation",
									value: [1, 0],
								};
							}
							if(conn.type === "generation") {
								let list = part.silhouettelist;
								image = [];
								for(let i2 = 0; i2 < list.length; i2++) {
									loop.tick(2);
									image = image.concat(onesilhouette(list[i2], view));
								}
								loop.end();
								image = _2dPoly.getdata(_2dPoly.convexed(image), true, sl_center);
								// merge into one _2dPoly, and get the getdata
								// from that.
							}
							else if(conn.type === "capsule") {
								image = onesilhouette(part.name, view, true);
								let parent = part.parent;
								if(parent !== "standpoint") {
								// add capsule
									let start = [
										_nodes[i1].x - view*ds.cell.w,
										_nodes[i1].y
									];
									let end = aa.getnode(view, parent);
									end = [
										end.x - view*ds.cell.w,
										end.y
									];
									// start and end of the capsule
									capsule = [];
									const fineness = ds.fineness ? ds.fineness : 32;
									for(i2 = 0; i2 < ds.fineness; i2++) {
										loop.tick(2);
										let temp = 2*Math.PI*i2/ds.fineness;
										temp = [
											Math.cos(temp)*conn.value/2,
											Math.sin(temp)*conn.value/2
										];
										// halve it, because it's a diameter
										capsule[capsule.length] = [
											start[0] + temp[0],
											start[1] + temp[1]
										];
										capsule[capsule.length] = [
											end[0] + temp[0],
											end[1] + temp[1]
										];
									}
									loop.end();
									// this doesn't follow 0 fineness. i'd
									// like to change that soon, but it's
									// not like you're supposed to see the
									// ends of the capsule anyway...
									image[image.length] = _2dPoly.convexed(capsule);
									// get rid of interior points and make
									// sure it's ordered right
								};
								for(i2 = 0; i2 < image.length; i2++) {
									loop.tick(2);
									image[i2] = _2dPoly.getdata(image[i2], true, sl_center);
								}
								loop.end();
								image = _2dPoly.mergedata(image);
								// it's an array of _2dPolys. use getdata on
								// each one and merge them. (preserves concave
								// features.)
							}
							group[group.length] = image;
						}
					}
					loop.end();
					let sum = [];
					// gonna combine all silhouette getdatas here
					for(i1 = 0; i1 < groups.length; i1++) {
						loop.tick(1);
						groups[i1] ??= {};
						// fill empty group slots
						for(i2 in groups[i1]) {
							loop.tick(2);
							if(groups[i1].hasOwnProperty(i2)) {
							// for each subgroup, merge them into one getdata
								groups[i1][i2] = _2dPoly.mergedata(groups[i1][i2]);
								sum[sum.length] = structuredClone(groups[i1][i2]);
							}
						}
						loop.end();
					}
					loop.end();
					// now each groups index is the .within array and .rect for
					// that silhouette group.
					if(sum.length) {
					// if everything's hidden or there's no parts, skip it all.
						sum = _2dPoly.mergedata(sum);
						// all of them combined. this will be an array of values
						// like:
						// - number: silhouette group/color index
						// - null: empty
						// - "fill": silhouette_fill
						const rect = sum.rect;
						const within = sum.within;
						for(i1 = 0; i1 < within.length; i1++) {
							loop.tick(1);
							within[i1] = within[i1] ? "fill" : null;
						};
						loop.end();
						for(i1 = groups.length - 1; i1 >= 0; i1--) {
						// iterate backwards, so that higher number groups are
						// layered under.
						loop.tick(1);
							for(i2 in groups[i1]) {
								loop.tick(2);
								if(groups[i1].hasOwnProperty(i2)) {
								// for every subgroup, add the outlines to the
								// sum silhouette.
									let _rect = groups[i1][i2].rect;
									let outline = Raster.outline(groups[i1][i2].within, _rect.w);
									for(i3 = 0; i3 < outline.length; i3++) {
										loop.tick(3);
										if(outline[i3]) {
										// if it's part of the outline...
											let x = _rect.x + (i3%_rect.w);
											let y = _rect.y + Math.floor(i3/_rect.w);
											x -= rect.x;
											y -= rect.y;
											// relative to the main rectangle
											if(
												x >= 0 && x < rect.w
												&&
												y >= 0 && y < rect.h
											) {
												let index = rect.w*y + x;
												if(within[index] === null) {
													console.log("this shouldn't happen");
												}
												else {
													// set it as the outline color for this
													// group
													within[index] = i1;
												}
											}
											else {
												console.log("this shouldn't happen");
											};
										}
									}
									loop.end();
								}
							}
							loop.end();
						}
						loop.end();
						for(i1 = 0; i1 < within.length; i1++) {
							loop.tick(1);
							if(within[i1] !== null) {
								ctx.fillStyle = (
									within[i1] === "fill" ? color.silhouette_fill :
									(within[i1] >= 0 && within[i1] < color.silhouette.length) ? color.silhouette[ within[i1] ] :
									"gray"
								);
								ctx.fillRect(
									rect.x + (i1%rect.w),
									rect.y + Math.floor(i1/rect.w),
									1,
									1
								);
							}
						}
						loop.end();
					}
				};
				for(i1 = 0; i1 < _nodes.length; i1++) {
					loop.tick(1);
					if(poles.hasOwnProperty(_nodes[i1].name)) {
						drawpoles(
							poles[_nodes[i1].name],
							[_nodes[i1].x - view*ds.cell.w, _nodes[i1].y],
							view,
							Quat.axis_magnitude(pose[ _nodes[i1].name ].orient).axis
						);
					}
				}
				loop.end();
				if(ds.parts === "overlap") {
					for(i1 = 0; i1 < _nodes.length; i1++) {
						loop.tick(1);
						let part = pose[ _nodes[i1].name ];
						if(visible(part, "parts")) {
							drawpart(part, view, "fill only", _nodes[i1].x - view*ds.cell.w, _nodes[i1].y);
							// drawpart can fill in the coordinates on its own, but
							// waste not want not.
						}
					}
					loop.end();
				};
				if(ds.parts !== "off") {
				// draw parts
					for(i1 = 0; i1 < _nodes.length; i1++) {
						loop.tick(1);
						let part = pose[ _nodes[i1].name ];
						if(visible(part, "parts")) {
							drawpart(part, view, (ds.parts === "overlap" ? "no fill" : null), _nodes[i1].x - view*ds.cell.w, _nodes[i1].y);
						}
					}
					loop.end();
				};
				if(ds.skeleton) {
				// draw skeleton
					ctx.strokeStyle = color.skeleton;
					for(i1 = 0; i1 < _nodes.length; i1++) {
						loop.tick(1);
						let part = pose[ _nodes[i1].name ];
						if(visible(part, "skeleton")) {
							aa.nodeline(ctx,
								_nodes[i1].parent.x - view*ds.cell.w,
								_nodes[i1].parent.y,
								_nodes[i1].x - view*ds.cell.w,
								_nodes[i1].y,
								view,
							);
						}
					}
					loop.end();
				};
				if(ds.perspective) {
				// draw perspective
					ctx.strokeStyle = color.perspective;
					for(i1 = 0; i1 < _nodes.length; i1++) {
						loop.tick(1);
						let part = pose[ _nodes[i1].name ];
						if(visible(part, "perspective")) {
							const rotated_coor = coortocanvas(AAX.camerarotations(part.abscoor, null, ds.xz, ds.yz, "same floats"), view, true, false);
							// rotated unperspectived coordinates. (it should
							// start here so that the lines point to the
							// vanishing point.)
							//const rect = aa.noderect(...rotated_coor);
							//ctx.strokeRect(rect.x - .5, rect.y - .5, rect.w + 1, rect.h + 1);
							// testing code. the rotated coordinates don't
							// actually display anywhere.
							let perspectived_coor = coortocanvas(part.abscoor, view, true, false);
							let temp = part["perspective_coor_" + view];
							perspectived_coor[0] += temp[0];
							perspectived_coor[1] += temp[1];
							aa.nodeline(ctx,
								...rotated_coor,
								...perspectived_coor,
								view
							);
						}
					}
					loop.end();
				};
				if(ds.nodes) {
				// draw nodes
					ctx.fillStyle = color.nodes;
					for(i1 = 0; i1 < _nodes.length; i1++) {
						loop.tick(1);
						let part = pose[ _nodes[i1].name ];
						if(visible(part, "nodes")) {
						// draw nodes even if the part is hidden
							const rect = aa.noderect(_nodes[i1].x, _nodes[i1].y);
							//ctx.fillRect(_nodes[i1].x - view*ds.cell.w + rect.x, _nodes[i1].y + rect.y, rect.w, rect.h);
							ctx.fillRect(rect.x - view*ds.cell.w, rect.y, rect.w, rect.h);
						}
					}
					loop.end();
				};
				if(!objectisempty(rotatecoor)) {
				// the code in here only happens for rotatecoor.
					let fulcrum = null;
					// screen coordinates of the fulcrum's node
					for(i1 = 0; i1 < _nodes.length; i1++) {
						loop.tick(1);
						if(_nodes[i1].name === fulcrum_name) {
							fulcrum = [_nodes[i1].x - view*ds.cell.w, _nodes[i1].y];
							// negate the view offset (that was
							// added earlier, for the clickable
							// interface's sake.)
						}
					}
					loop.end();
					if(fulcrum === null) {
						console.log("this shouldn't happen");
					};
					let _rotatecoor = {};
					// object for the coortocanvas-ed coordinates.
					ctx.strokeStyle = color.interface[0];
					for(i1 in rotatecoor) {
						loop.tick(1);
						if(rotatecoor.hasOwnProperty(i1)) {
							_rotatecoor[i1] = coortocanvas(rotatecoor[i1], view, true, false);
							let parent = pose[i1].parent;
							if(parent === fulcrum_name) {
							// probably the fulcrum. that isn't included in the
							// rotatecoor object because it doesn't move.
								parent = fulcrum;
							}
							else if(rotatecoor.hasOwnProperty(parent)) {
								if(!_rotatecoor.hasOwnProperty(parent)) {
								// it should be in getdesc order, so parents should
								// be put in _rotatecoor before their children.
									console.log("this shouldn't happen");
								};
								parent = _rotatecoor[parent];
							}
							else {
								console.log("this shouldn't happen");
							};
							//console.log("===" + i1 + "===");
							//console.log(parent);
							//console.log(_rotatecoor[i1]);
							aa.nodeline(ctx,
								...parent,
								..._rotatecoor[i1],
								view
							);
						}
					}
					loop.end();
					// draw lines
					fulcrum = aa.noderect(...fulcrum);
					ctx.fillStyle = color.interface[0];
					ctx.fillRect(fulcrum.x - 2, fulcrum.y - 2, fulcrum.w + 4, fulcrum.h + 4);
					for(i1 in _rotatecoor) {
						loop.tick(1);
						if(_rotatecoor.hasOwnProperty(i1)) {
							_rotatecoor[i1] = aa.noderect(_rotatecoor[i1][0], _rotatecoor[i1][1]);
							ctx.fillRect(_rotatecoor[i1].x - 1, _rotatecoor[i1].y - 1, _rotatecoor[i1].w + 2, _rotatecoor[i1].h + 2);
						}
					}
					loop.end();
					// draw node outlines
					ctx.fillStyle = color.interface[1];
					ctx.fillRect(fulcrum.x, fulcrum.y, fulcrum.w, fulcrum.h);
					for(i1 in _rotatecoor) {
						loop.tick(1);
						if(_rotatecoor.hasOwnProperty(i1)) {
							ctx.fillRect(_rotatecoor[i1].x, _rotatecoor[i1].y, _rotatecoor[i1].w, _rotatecoor[i1].h);
						}
					}
					loop.end();
					// draw node interiors
				}
				//
				imagedata[view] = ctx.getImageData(0, 0, ds.cell.w, ds.cell.h);
			}
			loop.end();
			ctx.canvas.width = numofcells*ds.cell.w;
			ctx.clearRect(0, 0, numofcells*ds.cell.w, ds.cell.h);
			for(view = 0; view < numofcells; view++) {
				loop.tick("view");
				ctx.putImageData(imagedata[view], view*ds.cell.w, 0);
			}
			loop.end();
			//console.log("AAX.draw took " + (new Date().valueOf() - time)/1000 + " seconds.");
		},
		save: function() {
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let loop = new Loop("aa.save");
			let obj = {
				version: aa.version,
				// doesn't do anything, but it's useful information.
				anim_index: aa.anim_index,
				bodytext: aa.bodytext,
				drawsettings: structuredClone(aa.drawsettings),
				color: structuredClone(aa.color),
				states_limit: aa.states_limit,
				states_truncator: aa.states_truncator,
				// you can't save settings/preferences on a web tool, so i'd
				// like to get as close as i can.
			};
			// then, integer properties are animations.
			delete obj.drawsettings.viewer;
			// this is a getter.
			for(i1 = 0; i1 < aa.anims.length; i1++) {
				loop.tick(1);
				let ref = aa.anims[i1];
				obj[i1] = {name: ref.name};
				ref = ref.states[ref.state_index];
				for(i2 in ref) {
					if(ref.hasOwnProperty(i2)) {
					// copy every aspect of the state
						obj[i1][i2] = structuredClone(ref[i2]);
					}
				}
				// keep only the name and the current state.
				// - make sure the name is the first property
				ref = ref.poseobjs;
				for(i2 = 0; i2 < ref.length; i2++) {
				// for every frame,
					for(i3 in ref[i2]) {
						if(ref[i2].hasOwnProperty(i3)) {
						// every part,
							delete obj[i1].poseobjs[i2][i3].cache;
							// delete cache.
						}
					}
				}
			};
			loop.end();
			let blob = new Blob([ objtotext(obj) ], {type: "text/plain"});
			// it should be text, so that it's easy to read manually.
			let url = URL.createObjectURL(blob);
			let downloader = document.createElement("a");
			downloader.href = url;
			//
			let date = new Date();
			date = [
				date.getFullYear(),
				date.getMonth() + 1,
				date.getDate()
			].join("-").split("-");
			for(i1 = 1; i1 < 3; i1++) {
				loop.tick(1);
				date[i1] = "0".repeat(2 - date[i1].length) + date[i1];
			}
			loop.end();
			date = date.join("-");
			let filename = aa.control.projectname + ".txt";
			//browser.downloads.download({url: url, filename: filename});
			//URL.revokeObjectURL(url);
			// - this is what mdn says to use, but it doesn't work on android.
			//   so why do they recommend it.
			downloader.download = filename;
			downloader.click();
		},
		load: function() {
		// what happens when the load button is clicked. it asks for a file,
		// then runs readfile on it.
			let input = document.createElement("input");
			input.type = "file";
			input.accept = ".txt";
			input.oninput = function() {
				aa.readfile(input.files[0]);
			};
			input.click();
		},
		readfile: function(file) {
		// run by load and the drag-and-drop event listener.
			if(file) {
				let temp = file.name.lastIndexOf(".");
				aa.control.projectname = temp === -1 ? file.name : file.name.slice(0, temp);
				let reader = new FileReader();
				reader.onload = function() {
					file = texttoobj(reader.result);
					let loop = new Loop("aa.readfile reader.onload");
					if(file) {
						let i1 = 0;
						let i2 = 0;
						let i3 = 0;
						let body = AAX.Body.new(file.bodytext);
						if(typeof body === "object") {
						// errors from invalid input
							aa.bodytext = file.bodytext;
							aa.body = body;
						}
						else {
							alert("invalid bodytext: " + body);
						};
						aa.anims = [];
						for(i1 = 0; file.hasOwnProperty(i1); i1++) {
							aa.anims[i1] = aa.newanim();
							let ref = aa.anims[i1];
							ref.name = file[i1].name;
							ref.states = [structuredClone(file[i1])];
							delete ref.states[0].name;
							ref.state_index = 0;
							ref = ref.states[0].poseobjs;
							for(i2 = 0; i2 < ref.length; i2++) {
								for(i3 in ref[i2]) {
									if(ref[i2].hasOwnProperty(i3)) {
										ref[i2][i3].cache = structuredClone(AAX.cache_init);
									}
								}
							}
							// restore cache
						}
						aa.anim_index = file.anim_index;
						for(i1 in aa.drawsettings) {
							loop.tick(1);
							if(file.drawsettings.hasOwnProperty(i1)) {
								aa.drawsettings[i1] = structuredClone(file.drawsettings[i1]);
							};
						}
						loop.end();
						for(i1 in aa.color) {
							loop.tick(1);
							if(file.color.hasOwnProperty(i1)) {
								aa.color[i1] = structuredClone(file.color[i1]);
							};
						}
						// you have to copy these property by property. if you
						// use structuredClone outright, it won't be the AAX
						// DrawSettings/Color class anymore.
						let temp = file.states_limit ?? null;
						if(Number.isInteger(temp) && temp >= 1) {
							aa.states_limit = temp;
						};
						temp = file.states_truncator ?? null;
						if(Number.isInteger(temp) && temp >= 0) {
							aa.states_truncator = temp;
						};
						loop.end();
						aa.refresh();
					}
				};
				reader.readAsText(file);
			}
			else {
				console.log("this shouldn't happen");
			};
		},
	};
	aa.initialize();
	document.write(`</div>`);
	document.write(`<div name="hider" id="hider_fighting_game_tester">`);
	let fg = {
	// fighting game testy thing.
		initialize: function() {
			let i1 = 0;
			let i2 = 0;
			this.p2 = structuredClone(this.p1);
			for(i1 = 1; i1 <= 2; i1++) {
				let ref = this["p" + i1];
				ref.x = this.visual.stage_w/2 + (i1 === 2 ? 1 : -1)*this.visual.w/4;
				Object.defineProperty(ref, "air", {
					get() {
						return this.y < 0;
					}
				});
				ref.held = structuredClone(ref.keys);
				for(i2 in ref.held) {
					if(ref.held.hasOwnProperty(i2)) {
						if(i1 === 2) {
							ref.keys[i2] = "";
							// not sure where to put p2 controls. i use a
							// laptop.
						};
						ref.held[i2] = false;
					}
				}
			};
			this.p1.char = this.char.unnamed;
			this.p2.char = this.char.unnamed;
			let html = [
				`<label>move list`,
				`<textarea id="fg_movelist" rows="12" cols="48"></textarea></label>`,
				`<button id="fg_applymovelist">apply</button>`,
				`<canvas id="fg_canvas"></canvas>`,
				`<div id="fg_display"></div>`
			].join(`<br>`);
			document.write(html);
			let array = [
				"movelist",
				"display",
				"canvas"
			];
			for(i1 = 0; i1 < array.length; i1++) {
				let ref = document.getElementById("fg_" + array[i1]);
				if(array[i1] === "canvas") {
					ref.width = this.visual.w;
					ref.height = this.visual.h;
					this.ctx = ref.getContext("2d");
				}
				else {
					this[ array[i1] ] = ref;
				};
				ref.onclick = function() { changefocus("fg") };
			}
			document.getElementById("fg_applymovelist").onclick = function() {
				changefocus("fg");
				fg.applymovelist();
			};
			this.movelist = document.getElementById("fg_movelist");
			this.display = document.getElementById("fg_display");
			this.movelist.value = [
				`qcf p: hadoken`,
				`z p: shoryuken`,
				`qcb k: tatsu`,
				`hcf p: special hadoken`,
				`f p: forward punch`,
				`f pk: grab`,
				`d d s: invite hell`
			].join(String.fromCharCode(10));
			this.applymovelist();
			fg.process(0);
		},
		movelist: null,
		display: null,
		ctx: null,
		visual: {
			w: 256,
			h: 192,
			stage_w: 512,
			color: "white",
			floor_color: "green",
			floor_level: 1/4,
			// 0 to 1, from the bottom of the screen to the top
			p1: "red",
			p2: "blue",
			player_size: 8,
			// visualized as circles for now
		},
		fps: 24,
		normals: {
			punch: {
				short: "p",
			},
			kick: {
				short: "k",
			},
			slash: {
				short: "s",
			},
		},
		char: {
		// stores all data that would be stored under the character rather
		// than the player. (ex: your defense is based on the defense ryu
		// has, right?)
			unnamed: {
			// there's only one character, though.
				specials: {},
				// structure:
				// - input: array of directions
				// - button: if they follow the directions and press this button, the
				//   special is executed.
				//   - this can be an array or string. arrays mean the player can use
				//     any index.
				// - ground, air: booleans for where it can be executed
				mass: 1,
				jump_velocity: -256,
				jumps: 3,
				// number of times you can jump
				f_walk: 128,
				b_walk: 64,
				// walk speeds (the fancy physics stuff isn't used here.)
				p: {
					duration: 1000,
				},
				k: {
					duration: 1000,
				},
				s: {
					duration: 1000,
				},
			},
		},
		p1: {
		// data that changes as the player moves and does things.
			x: null,
			y: 0,
			// [0, 0] is the horizontal center of the stage, on the ground.
			speed: [0, 0],
			// x velocity, y velocity
			direction: "",
			// direction being inputted. empty string means neutral, ie no
			// directions.
			specials: {},
			// an object of numbers for where they are in the specials. (-1
			// means they've inputted no steps, 0 means they're on the first
			// step, etc.)
			jumps: 0,
			// number of jumps since you landed.
			//last_direction_input: 0,
			// measured in new Date().valueOf()
			commitment: null,
			// object storing data for the non-cancellable action they're in the
			// middle of.
			// - name: name of the normal/special/etc
			// - type: "normal", "special", etc
			// - time: Date.valueOf() for when they performed it
			// - duration: how many milliseconds it'll last
			keys: {
				u: "w",
				l: "a",
				d: "s",
				r: "d",
				punch: "k",
				kick: "o",
				slash: "p",
			},
			held: null,
			// booleans for each key
			char: null,
			// reference to character data
		},
		p2: null,
		shorthand: {
			qcf: ["d", "df", "f"],
			qcb: ["d", "db", "b"],
			hcf: ["b", "db", "d", "df", "f"],
			hcb: ["f", "df", "d", "db", "b"],
			z: ["f", "d", "df"],
			bz: ["b", "d", "db"],
		},
		//direction_buffer: 1000/16,
		// for non-adjacent input combinations, (ex: f to d, d to d) the player
		// can spend this many ms in neutral between the inputs.
		physics: {
			gravity: 640,
			// measured in pixels per second per second
			// - 64 pixels = ~2 meters, let's say
			// - 32 pixels per meter
			// - 32*9.81 = ~320
			friction: 128,
			// the number of pixels per second per second it should detract from
			// a vector moving horizontally across the ground.
		},
		interval: null,
		game: {
		// stores temporary data that changes during the game and isn't tied to
		// either player (like the timer or whatever)
			left_player: "p1",
			// "p1", "", or "p2"
			// - "" means they're equal.
		},
		process: function(delta) {
		// various things executed per frame.
			let i0 = 0;
			let i1 = 0;
			let i2 = 0;
			let old_lp = fg.game.left_player;
			for(i0 = 1; i0 <= 2; i0++) {
			// gravity, speed
				let obj = fg["p" + i0];
				const old_air = obj.y < 0;
				obj.x += delta*obj.speed[0];
				obj.y += delta*obj.speed[1];
				if(!obj.direction.includes("d") && (obj.direction.includes("b") || obj.direction.includes("f"))) {
					obj.x += delta*(obj.direction.includes("b") ? -1 : 1)*fg.forward_sign(obj)*obj.char[obj.direction.slice(-1) + "_walk"];
				};
				if(obj.y < 0) {
				// gravity
					obj.speed[1] += delta*fg.physics.gravity;
				};
				if(obj.speed[0]) {
				// friction against the floor
					let sign = Math.sign(obj.speed[0]);
					obj.speed[0] -= (
						Math.sign(obj.speed[0])
						*
						delta
						*
						(obj.speed[0]/Math.hypot(...obj.speed))
						*
						fg.physics.friction
					);
					// you'd think the possible divide by zero would be okay
					// since it requires a Math.sign of zero, but 0*Infinity is
					// NaN, not zero.
					if(Math.sign(obj.speed[0]) !== sign) {
						obj.speed[0] = 0;
					};
				}
				obj.x = Math.min(Math.max(0, obj.x), fg.visual.stage_w);
				obj.y = Math.min(obj.y, 0);
				// don't pass through the floor
				if(old_air !== obj.y < 0) {
					fg.groundair_reset(obj);
				}
			}
			if(!fg.p1.commitment) {
				fg.display.innerHTML = "(" + fg.stance(fg.p1) + ")";
			}
			fg.game.left_player = ["p1", "", "p2"][Math.sign(fg.p1.x - fg.p2.x) + 1];
			if(fg.game.left_player !== old_lp && fg.game.left_player) {
			// reverse b/f directions.
			// - don't do anything if they only became equal
				for(i0 = 1; i0 <= 2; i0++) {
					let obj = fg["p" + i0];
					obj.direction = (
						obj.direction.includes("b") ? obj.direction.replace("b", "f") :
						obj.direction.includes("f") ? obj.direction.replace("f", "b") :
						obj.direction
					);
					if(obj.direction.includes("b") || obj.direction.includes("f")) {
						fg.advancespecials(obj);
						// so that specials get reset to zero if this
						// happens
					};
				}
			}
			let ctx = fg.ctx;
			let ref = fg.visual;
			ctx.fillStyle = ref.color;
			ctx.clearRect(0, 0, ref.w, ref.h);
			ctx.fillRect(0, 0, ref.w, ref.h);
			let floor_y = Math.ceil(ref.h*(1 - ref.floor_level));
			// canvas y to start the floor rectangle at.
			ctx.fillStyle = ref.floor_color;
			ctx.fillRect(0, floor_y, ref.w, ref.h - floor_y);
			let scroll = [
				(fg.p1.x + fg.p2.x)/2,
				-floor_y + ref.h/2
			];
			scroll = [
				Math.trunc(scroll[0] - ref.stage_w/2) + ref.stage_w/2,
				Math.ceil(
					fg.p1.y < -floor_y || fg.p2.y < -floor_y
					?
					(scroll[1] + Math.min(fg.p1.y, fg.p2.y))/2
					:
					scroll[1]
				)
			];
			// this is the absolute coordinates of the center of the screen.
			let toscreen = (x, y) => [
				x - scroll[0] + ref.w/2,
				y - scroll[1] + ref.h/2
			];
			// - translate coordinates by subtracting this and adding the halved
			//   halved dimensions
			ctx.strokeStyle = "gray";
			circledraw(ctx, ...toscreen(ref.stage_w/2, 0), ref.player_size);
			ctx.strokeStyle = ref.p1;
			circledraw(ctx, ...toscreen(fg.p1.x, fg.p1.y), ref.player_size/2);
			ctx.strokeStyle = ref.p2;
			circledraw(ctx, ...toscreen(fg.p2.x, fg.p2.y), ref.player_size/2);
		},
		groundair_reset: function(player) {
		// run when the player jumps or lands. resets all specials that no
		// longer apply to -1.
			let i1 = 0;
			player ??= fg.p1;
			let air = fg.stance(player) === "a";
			if(!air) {
				player.jumps = 0;
			};
			for(i1 in player.specials) {
				if(player.specials.hasOwnProperty(i1) && !player.char.specials[i1][air ? "air" : "ground"]) {
					player.specials[i1] = -1;
				};
			}
		},
		isdirection: (string) => (
			[1, 2].includes(string.length)
			&&
			(
				"ud".includes(string[0])
				||
				"bf".includes(string[string.length - 1])
			)
		),
		applymovelist: function(char) {
			let i0 = 0;
			let i1 = 0;
			char ??= "unnamed";
			fg.char[char].specials = this.interpret(fg.movelist.value);
			for(i0 = 0; i0 < 2; i0++) {
				let ref = fg[i0 ? "p2" : "p1"];
				ref.specials = {};
				if(ref.char === fg.char[char]) {
					for(i1 in ref.char.specials) {
						if(ref.char.specials.hasOwnProperty(i1)) {
							ref.specials[i1] = -1;
						};
					}
				}
			}
		},
		interpret: function(text) {
			let i1 = 0;
			let i2 = 0;
			let list = {};
			text = text.split(String.fromCharCode(10));
			for(i1 = 0; i1 < text.length; i1++) {
				let line = text[i1];
				let temp = line.indexOf(":");
				if(temp !== -1) {
					let input = line.slice(0, temp).trim().split(" ");
					let name = line.slice(temp + 1).trim();
					let ground = true;
					let air = false;
					if(input.length < 1) {
					}
					else if(input[0] === "(a)") {
						ground = false;
						air = true;
						input = input.slice(1);
					}
					else if(input[0] === "(ga)") {
						air = true;
						input = input.slice(1);
					};
					if(input.length >= 1 && name) {
						let button = input[input.length - 1];
						button = button.split("/");
						let bool = [];
						for(i2 = 0; i2 < button.length; i2++) {
							bool[i2] = false;
						}
						for(i2 in fg.normals) {
							if(fg.normals.hasOwnProperty(i2) && button.includes(fg.normals[i2].short)) {
								bool[ button.indexOf(fg.normals[i2].short) ] = true;
							}
						}
						// make sure all buttons are real buttons
						if(button.length === 1) {
							button = button[0];
						};
						list[name] = {
							input: [],
							button: structuredClone(button),
							ground,
							air,
							duration: 1000,
						};
						let ref = list[name];
						for(i2 = 0; i2 < input.length - 1; i2++) {
							if(fg.isdirection(input[i2])) {
								ref.input[ref.input.length] = input[i2];
							}
							else if(fg.shorthand.hasOwnProperty(input[i2])) {
								ref.input = ref.input.concat(fg.shorthand[ input[i2] ]);
							};
						}
					}
				}
			}
			return list;
		},
		adjacent: (d1, d2) => d1.includes(d2) || d2.includes(d1),
		directioninput: function(player) {
			player ??= fg.p1;
			let ref = player;
			const direction = ref.direction;
			//
			if(ref.commitment) {
				return;
			};
			if(direction.startsWith("u") && (ref.y >= 0 || ref.jumps < ref.char.jumps)) {
			// jump
				if(ref.y >= 0) {
					ref.jumps = 0;
				}
				ref.jumps++;
				ref.speed[1] = ref.char.jump_velocity;
			};
			fg.advancespecials(ref);
		},
		advancespecials: function(player) {
		// progresses or resets all specials.
			let i1 = 0;
			let i2 = 0;
			player ??= fg.p1;
			let ref = player;
			const direction = ref.direction;
			let air = fg.stance(player) === "a";
			//
			for(i1 in ref.specials) {
				if(ref.specials.hasOwnProperty(i1)) {
					if(
						ref.char.specials[i1].ground !== !air
						||
						ref.char.specials[i1].air !== air
					) {
					// make sure it stays at -1 if the ground/air doesn't match.
						ref.specials[i1] = -1;
					}
					else {
						let input = ref.char.specials[i1].input;
						// array of directions
						let step = ref.specials[i1];
						// which index the player is on
						if(
							step > input.length - 1
							||
							step < -1
						) {
							console.log("this shouldn't happen");
							ref.specials[i1] = -1;
							step = ref.specials[i1];
						};
						if(
							step !== input.length - 1
							&&
							input[step + 1] === direction
						) {
							ref.specials[i1]++;
							//console.log(i1 + ": " + ref.specials[i1]);
						};
					};
				}
			}
		},
		buttoninput: function(button, player) {
		// executes a special or normal, resets all special input chains to the
		// beginning
		// - button shouldn't be in short form.
			let i1 = 0;
			let i2 = 0;
			let normal = button;
			button = fg.normals[normal].short;
			player ??= fg.p1;
			let ref = player;
			if(ref.commitment) {
				return;
			};
			let special = null;
			// name of the special they end up performing
			let special_length = -1;
			// number of inputs to the special (this needs to be saved so that
			// if multiple specials apply, the one with a longer input will be
			// used)
			for(i1 in ref.specials) {
				if(ref.specials.hasOwnProperty(i1)) {
					let input = ref.char.specials[i1].input;
					// array of directions
					let step = ref.specials[i1];
					// which index the player is on
					if(
						step === input.length - 1
						&&
						(
							Array.isArray(ref.char.specials[i1].button)
							?
							ref.char.specials[i1].button.includes(button)
							:
							ref.char.specials[i1].button === button
						)
						&&
						input.length > special_length
						&&
						ref.direction === input[input.length - 1]
					) {
					// if it's at the end of the input, the button is right, and
					// it's the longest applicable special so far, set that as
					// the action.
						special = i1;
						special_length = input.length;
					};
					ref.specials[i1] = -1;
					// set all of them to -1 to start their input chain over.
				}
			}
			ref.commitment = (
				special
				?
				{
					name: special,
					// which non-cancellable action they're in the middle of
					type: "special",
					// whether it's
					time: new Date().valueOf(),
					duration: ref.char.specials[special].duration,
				}
				:
				{
					name: normal,
					type: "normal",
					time: new Date().valueOf(),
					duration: ref.char[button].duration,
				}
			);
			fg.display.innerHTML = "(" + fg.stance(ref) + ") " + ref.commitment.name;
			setTimeout(function() {
				ref.commitment = null;
			}, ref.commitment.duration);
		},
		stance: (player) => (
			player.y < 0 ? "a" :
			player.direction.startsWith("d") ? "c" :
			"s"
		),
		forward_sign: (player) => (
			player === fg.p1 ? (
				fg.game.left_player === "p2"
				?
				-1
				:
				1
			)
			:
			player === fg.p2 ? (
				fg.game.left_player === "p2"
				?
				1
				:
				-1
			)
			:
			null
		),
		keyevent: function(e, up) {
			let i0 = 0;
			let i1 = 0;
			let key = keyinterpreter(e.key);
			for(i0 = 1; i0 <= 2; i0++) {
				let ref = fg["p" + i0];
				for(i1 in ref.keys) {
					if(ref.keys.hasOwnProperty(i1) && ref.keys[i1] === key) {
						ref.held[i1] = !up;
						if(["u", "l", "d", "r"].includes(i1)) {
							let direction = "u".repeat(ref.held.u) + "d".repeat(ref.held.d) + "l".repeat(ref.held.l) + "r".repeat(ref.held.r);
							direction = direction.replace("ud", "").replace("lr", "");
							direction = (
								fg.forward_sign(ref) === -1
								?
								direction.replace("r", "b").replace("l", "f")
								:
								direction.replace("l", "b").replace("r", "f")
							);
							if(direction !== ref.direction) {
								ref.direction = direction;
								fg.directioninput(ref);
							};
						}
						else if(fg.normals.hasOwnProperty(i1)) {
							fg.buttoninput(i1, ref);
						};
					};
				}
			}
		},
		keydown: function(e) {
			fg.keyevent(e, false);
		},
		keyup: function(e) {
			fg.keyevent(e, true);
		},
	};
	fg.initialize();
	document.write(`</div>`);
	document.write(`<div name="hider" id="hider_sprite_arranger"></div>`);
	let sa = {
		tools: ["move", "swap", "paint"],
		// modes for what happens when you click the main canvas. i'm not
		// bothering with canvas uis, it's gonna be html
		buttons: ["import", "clear", "redimension", "change_block_increment", "change_move_increment", "change_background", "change_checker"],
		control: {
			//tool
			//increments
			// - these will be getter/setters tied to the html ui
			selection: {
				x: 0,
				y: 0,
				w: 1,
				h: 1,
			},
			input: [0, 0],
			// where the user last clicked the input, measured in sa.blocks
			clicktype: null,
			strokedata: null,
		},
		block: 8,
		// 8 means it'll use 8x8 pieces of the image.
		move: 4,
		// 4 means you can only move things to coordinates divisible by 4. (the
		// button that changes this only allows numbers that divide evenly into
		// block.)
		background: "purple",
		// null means it'll be transparent if a block is empty. make this a
		// color, and it'll be that color.
		checker: "#0000ff0f",
		// half the background tiles will have this color placed on them too.
		input: null,
		// inputted image. also used to check if it's started yet.
		data: [],
		// data for where you're placing blocks from the input.
		// - x indexes
		//   - y indexes
		//     - objects (or null, if there's nothing here.)
		//       - offset (two-number array for its pixel offset relative to the
		//         top-left corner.)
		//       - input (two-number array for which block it's referencing,
		//         from the input data.)
		// =
		// - the x/y indexes count by sa.blocks, not sa.moves. a block counts as
		//   being in that coordinate if its top-left corner is somewhere in
		//   there. (the offsets are always positive.)
		// - the input stuff is also counting by sa.blocks. not pixels.
		data_w: 64,
		data_h: 8,
		div: null,
		ctx: {
			input: null,
			main: null,
		},
		clean_image: null,
		initdata: function() {
			let i1 = 0;
			let i2 = 0;
			sa.data = [];
			for(i1 = 0; i1 < sa.data_w; i1++) {
				sa.data[i1] = [];
				for(i2 = 0; i2 < sa.data_h; i2++) {
					sa.data[i1][i2] = null;
				}
			}
		},
		initialize: function() {
			let i1 = 0;
			let i2 = 0;
			sa.div = document.getElementById("hider_sprite_arranger");
			let html = ``;
			html += `something for ungarbling sprite image data. i'm not sure if the popular sprite-ripping tools suck or if i'm using them wrong. so many repetitive mouse movements.`;
			html += `<br><label>image input: <input type="file" id="sa_fileinput"></label>`;
			for(i1 in sa.ctx) {
				if(sa.ctx.hasOwnProperty(i1)) {
					html += `<br><canvas id="sa_` + i1 + `"></canvas>`;
				}
			}
			html += `<br><div id="sa_coordisplay"></div>`;
			html += `<br><label>tool: <select id="sa_tool">`;
			for(i1 = 0; i1 < sa.tools.length; i1++) {
				html += `<option value="` + sa.tools[i1] + `"` + ` selected`.repeat(i1 === 0) + `>` + sa.tools[i1] + `</option>`;
			}
			html += `</select></label>`;
			html += `<br><label>import increments: <input type="text" id="sa_increments"></label>`;
			for(i1 = 0; i1 < sa.buttons.length; i1++) {
				html += `<br><button id="sa_button_` + sa.buttons[i1] + `">` + sa.buttons[i1].replaceAll("_", " ") + `</button>`;
			}
			sa.div.innerHTML = html;
			for(i1 in sa.ctx) {
				if(sa.ctx.hasOwnProperty(i1)) {
					let canvas = document.getElementById("sa_" + i1);
					canvas.style["image-rendering"] = "crisp-edges";
					canvas.style["touch-action"] = "none";
					canvas.hidden = true;
					sa.ctx[i1] = canvas.getContext("2d");
				}
			}
			sa.ctx.input.canvas.onpointerdown = function(e) {
				let click = sa.block_coor(...clickxy(e, "sa"));
				sa.control.input = [click.x, click.y];
				sa.refresh();
			};
			sa.ctx.main.canvas.onpointerdown = sa.mousedown;
			sa.ctx.main.canvas.onpointermove = sa.mousemove;
			sa.ctx.main.canvas.onpointerup = sa.mouseup;
			Object.defineProperty(sa.control, "tool", {
				get() {
					return document.getElementById("sa_tool").value;
				},
				set(value) {
					if(sa.tools.includes(value)) {
						document.getElementById("sa_tool").value = value;
					};
				},
			});
			Object.defineProperty(sa.control, "increments", {
				get() {
					let i1 = 0;
					let input = document.getElementById("sa_increments").value.split(",");
					for(i1 = 0; i1 < input.length; i1++) {
						input[i1] = Number(input[i1]);
						if(!Number.isInteger(input[i1]) || input[i1] <= 0) {
							input.splice(i1, 1);
							i1--;
						}
					}
					if(input.length) {
						document.getElementById("sa_increments").value = input.join(",");
					}
					else {
						input = [1, 1];
					};
					if(input.length%2) {
						input[input.length] = 1;
					};
					return input;
				},
				set(value) {
					if(Array.isArray(value)) {
						document.getElementById("sa_increments").value = value.join();
					};
				},
			});
			document.getElementById("sa_button_import").onpointerdown = function() {
				let i1 = 0;
				let coor = sa.rect_start(sa.control.selection);
				let positions = sa.incrementer(sa.control.increments);
				let inputdim = [Math.floor(sa.input.width/sa.block), Math.floor(sa.input.height/sa.block)];
				let start = inputdim[0]*sa.control.input[1] + sa.control.input[0];
				let end = Math.min(start + positions.length, inputdim[0]*inputdim[1]);
				// start and end of the data being imported, converted to single
				// numbers
				for(i1 = start; i1 < end; i1++) {
					let pos = [
						coor[0] + positions[i1 - start][0],
						coor[1] + positions[i1 - start][1]
					];
					if(
						pos[0] >= 0 && pos[0] < sa.data_w
						&&
						pos[1] >= 0 && pos[1] < sa.data_h
					) {
						sa.data[ pos[0] ][ pos[1] ] = {
							offset: [0, 0],
							input: [
								i1%inputdim[0],
								Math.floor(i1/inputdim[0])
							],
						};
						sa.clear_overlap(...pos);
					}
				}
				let temp = Math.min(end, inputdim[0]*inputdim[1] - 1);
				sa.control.input = [
					temp%inputdim[0],
					Math.floor(temp/inputdim[0])
				];
				sa.refresh();
			};
			document.getElementById("sa_button_clear").onpointerdown = function() {
				sa.rect_execute(sa.control.selection, function(x, y, outside) {
					sa.data[x][y] = null;
				});
				sa.refresh();
			};
			document.getElementById("sa_button_redimension").onpointerdown = function() {
				let i1 = 0;
				let i2 = 0;
				let input = prompt("enter new canvas dimensions. (measured in blocks, and separated by a comma.)");
				if(input && input.includes(",")) {
					input = input.split(",");
					input = [Number(input[0]), Number(input[1])];
					if(
						Number.isInteger(input[0]) && input[0] > 0
						&&
						Number.isInteger(input[1]) && input[1] > 0
					) {
						let old = [sa.data_w, sa.data_h];
						sa.data_w = input[0];
						sa.data_h = input[1];
						for(i1 = 0; i1 < old[0]; i1++) {
							if(old[1] > input[1]) {
							// decrease in height
								sa.data[i1] = sa.data[i1].slice(0, input[1]);
							}
							else if(old[1] < input[1]) {
							// increase in height
								for(i2 = old[1]; i2 < input[1]; i2++) {
									sa.data[i1][i2] = null;
								}
							}
						}
						if(old[0] > input[0]) {
						// decrease in width
							sa.data = sa.data.slice(0, input[0]);
						}
						else if(old[0] < input[0]) {
						// increase in width
							for(i1 = old[0]; i1 < input[0]; i1++) {
								sa.data[i1] = [];
								for(i2 = 0; i2 < input[1]; i2++) {
									sa.data[i1][i2] = null;
								}
							}
						}
						sa.control.selection = {
							x: 0,
							y: 0,
							w: 1,
							h: 1,
						};
						sa.control.input = [0, 0];
						sa.refresh();
					};
				}
			};
			function inc_change(move) {
				let input = Number(prompt("enter a new " + (move ? "placement" : "block") + " increment." + (move ? " it must divide evenly into the block increment." : "") + String.fromCharCode(10).repeat(2) + "this will wipe the canvas."));
				if(input && Number.isInteger(input) && input > 0 && (!move || sa.block%input === 0)) {
					sa[move ? "move" : "block"] = input;
					sa.initdata();
					sa.control.selection = {
						x: 0,
						y: 0,
						w: 1,
						h: 1,
					};
					sa.control.input = [0, 0];
					sa.refresh();
				}
			}
			document.getElementById("sa_button_change_block_increment").onpointerdown = function(){inc_change(false)};
			document.getElementById("sa_button_change_move_increment").onpointerdown = function(){inc_change(true)};
			function color_change(checker) {
				let color = prompt(
					checker
					?
					"enter a color for the checker pattern. (it can be a tint, or an opaque color. it'll be placed on half of the background tiles, to show the grid.)"
					:
					"enter a background color."
				);
				if(color !== null) {
					sa[checker ? "checker" : "background"] = color ? color : null;
					sa.refresh();
				}
			};
			document.getElementById("sa_button_change_background").onpointerdown = function() {color_change(false)};
			document.getElementById("sa_button_change_checker").onpointerdown = function() {color_change(true)};
			document.getElementById("sa_fileinput").oninput = function() {
				sa.readfile(document.getElementById("sa_fileinput").files[0]);
			};
		},
		readfile: function(file) {
		// run by load and the drag-and-drop event listener.
			let reader = new FileReader();
			reader.onload = function() {
				sa.input = structuredClone(reader.result);
				sa.start();
			};
			reader.readAsDataURL(file);
		},
		start: function() {
		// plays when the image is loaded, starts everything.
			let i1 = 0;
			let i2 = 0;
			for(i1 in sa.ctx) {
				if(sa.ctx.hasOwnProperty(i1)) {
					document.getElementById("sa_" + i1).hidden = false;
				}
			}
			let image = document.createElement("img");
			let ctx = sa.ctx.input;
			let canvas = sa.ctx.input.canvas;
			// image urls, ImageDatas, image elements, canvas elements, and
			// canvas contexts. god bless javascript. this is so dumb.
			image.src = sa.input;
			canvas.width = image.width;
			canvas.height = image.height;
			ctx.drawImage(image, 0, 0);
			//console.log([canvas.width, canvas.height]);
			sa.input = ctx.getImageData(0, 0, canvas.width, canvas.height);
			sa.control.input = [0, 0];
			sa.initdata();
			sa.refresh();
		},
		make_rect: function(x1, y1, x2, y2) {
			let rect = {
				x: x1,
				y: y1,
				w: x2 - x1,
				h: y2 - y1,
			};
			if(rect.w < 0) {
				rect.w--;
				rect.x++;
			}
			else {
				rect.w++;
			};
			if(rect.h < 0) {
				rect.h--;
				rect.y++;
			}
			else {
				rect.h++;
			};
			return rect;
		},
		select_rect: function(ctx, rect) {
		// draws a rectangle to indicate selection.
		// - x, y, w, and h should be measured in sa.block.
			let temp = [
				sa.block*rect.x + .5,
				sa.block*rect.y + .5,
				sa.block*rect.w,
				sa.block*rect.h
			];
			ctx.strokeStyle = "black";
			ctx.strokeRect(...temp);
			ctx.strokeStyle = "white";
			temp[0]--;
			temp[1]--;
			ctx.strokeRect(...temp);
		},
		rect_start: (rect) => [
			rect.x - (rect.w < 0),
			rect.y - (rect.h < 0)
		],
		in_rect: (rect, x, y) => (
			x >= Math.min(rect.x, rect.x + rect.w)
			&&
			x < Math.max(rect.x, rect.x + rect.w)
			&&
			y >= Math.min(rect.y, rect.y + rect.h)
			&&
			y < Math.max(rect.y, rect.y + rect.h)
		),
		rect_execute: function(rect, code) {
		// executes a (x, y, outside) function for every block in a rectangle.
		// - outside is a boolean for whether it's the edge of the rectangle.
			let i1 = 0;
			let i2 = 0;
			let x = Math.min(rect.x, rect.x + rect.w);
			let y = Math.min(rect.y, rect.y + rect.h);
			let w = Math.max(rect.x, rect.x + rect.w) - x;
			let h = Math.max(rect.y, rect.y + rect.h) - y;
			for(i1 = 0; i1 < rect.w; i1++) {
				for(i2 = 0; i2 < rect.h; i2++) {
					code(
						rect.x + i1,
						rect.y + i2,
						i1 === 0 || i1 === rect.w - 1 || i2 === 0 || i2 === rect.h - 1
					);
				}
			}
		},
		block_coor: function(x, y, detect) {
		// converts canvas coordinates to block coordinates
		// - detect: if true, it'll return which tile you clicked, or null if
		//   there's nothing in that spot.
		//   - that sounds like exactly the same thing, and it almost is
		//   - but depending on a tile's offset property, it can reach into the
		//     the blocks below and to the right.
			let obj = {
				x: Math.floor(x/sa.block),
				y: Math.floor(y/sa.block),
			};
			obj.offset = [
				Math.floor((x - obj.x*sa.block)/sa.move)*sa.move,
				Math.floor((y - obj.y*sa.block)/sa.move)*sa.move
			];
			if(detect) {
				let i1 = 0;
				let i2 = 0;
				for(i1 = 0; i1 < 2; i1++) {
				// this row, then the one above
					for(i2 = 0; i2 < 2; i2++) {
					// this column, then the one to the left
						let index = [obj.x - i2, obj.y - i1];
						//console.log(index)
						if(index[0] >= 0 && index[0] < sa.data_w && index[1] >= 0 && index[1] < sa.data_h) {
							let ref = sa.data[index[0]][index[1]];
							if(
								ref
								&&
								ref.offset[0] - i2 <= obj.offset[0]
								&&
								ref.offset[1] - i1 <= obj.offset[1]
							) {
							// the subtraction is because a click on the very
							// left edge counts, but not the right edge.
							// technically that's not inside the rectangle.
								return index;
							};
						}
					}
				}
				return null;
				// null if there's no block there.
			};
			return obj;
		},
		clear_overlap: function(x, y) {
		// deletes any blocks that are overlapping this one.
			let i1 = 0;
			let i2 = 0;
			let main = sa.data[x][y];
			if(!main) {
				return;
			};
			for(i1 = -1; i1 <= 1; i1++) {
				for(i2 = -1; i2 <= 1; i2++) {
				// check all eight neighbors
					let index = [x + i2, y + i1];
					if(
						index[0] >= 0 && index[0] < sa.data_w
						&&
						index[1] >= 0 && index[1] < sa.data_h
						&&
						(i1 || i2)
					) {
						let ref = sa.data[index[0]][index[1]];
						if(
							ref
							&&
							Math.abs((i2*sa.block + ref.offset[0]) - main.offset[0]) < sa.block
							&&
							Math.abs((i1*sa.block + ref.offset[1]) - main.offset[1]) < sa.block
						) {
						// if their top-left corner is less than sa.block away
						// from this one in either axis, delete it.
							sa.data[index[0]][index[1]] = null;
						};
					}
				}
			}
		},
		incrementer: function(array) {
		// runs through the increments and runs a list of x/y indexes.
			let i1 = 0;
			let i2 = 0;
			let place = [];
			let total = 1;
			for(i1 = 0; i1 < array.length; i1++) {
				place[i1] = 0;
				total *= array[i1];
			}
			function tickup(index) {
				place[index]++;
				if(place[index] >= array[index]) {
					place[index] = 0;
					if(index < place.length - 1) {
						tickup(index + 1);
					};
				}
			}
			let positions = [];
			for(i1 = 0; i1 < total; i1++) {
				let x_mult = 1;
				let y_mult = 1;
				let x = 0;
				let y = 0;
				for(i2 = 0; i2 < place.length; i2++) {
					if(i2%2) {
						y += y_mult*place[i2];
						y_mult *= array[i2];
					}
					else {
						x += x_mult*place[i2];
						x_mult *= array[i2];
					}
				}
				positions[positions.length] = [x, y];
				// for every number of a given place, multiply it by previous
				// maximums in that axis. (ex: for a [1, 2, 3, 2], a 1 in [3]
				// would mean a 2 y offset, since the previous y number was
				// another 2.)
				tickup(0);
			}
			return positions;
		},
		refresh: function() {
			let i1 = 0;
			let i2 = 0;
			sa.ctx.input.putImageData(sa.input, 0, 0);
			const ctx = sa.ctx.main;
			const input = sa.ctx.input;
			const dim = [
				sa.data_w*sa.block,
				sa.data_h*sa.block
			];
			ctx.canvas.width = dim[0];
			ctx.canvas.height = dim[1];
			ctx.clearRect(0, 0, ...dim);
			if(sa.background) {
				ctx.fillStyle = sa.background;
				ctx.fillRect(0, 0, ...dim);
			};
			if(sa.checker) {
				ctx.fillStyle = sa.checker;
				for(i1 = 0; i1 < sa.data_w; i1++) {
					for(i2 = 0; i2 < sa.data_h; i2++) {
						if(i1%2 === i2%2) {
							ctx.fillRect(sa.block*i1, sa.block*i2, sa.block, sa.block);
						};
					}
				}
			}
			for(i1 = 0; i1 < sa.data_w; i1++) {
				for(i2 = 0; i2 < sa.data_h; i2++) {
					let ref = sa.data[i1][i2];
					if(ref) {
						let temp = input.getImageData(
							sa.block*ref.input[0],
							sa.block*ref.input[1],
							sa.block, sa.block
						);
						ctx.putImageData(
							temp,
							sa.block*i1 + ref.offset[0],
							sa.block*i2 + ref.offset[1]
						);
					};
				}
			}
			sa.clean_image = ctx.getImageData(0, 0, ...dim);
			sa.select_rect(sa.ctx.input, {x: sa.control.input[0], y: sa.control.input[1], w: 1, h: 1});
			sa.select_rect(ctx, sa.control.selection);
		},
		paint: function(x, y) {
			sa.data[x][y] = {
				offset: [0, 0],
				input: structuredClone(sa.control.input),
			};
			sa.clear_overlap(x, y);
		},
		mousedown: function(e) {
			let i1 = 0;
			let i2 = 0;
			let click = clickxy(e, "sa");
			let block = sa.block_coor(...click, true);
			click = sa.block_coor(...click);
			let tool = sa.control.tool;
			let selection = sa.control.selection;
			sa.control.clicktype = "main";
			sa.control.strokedata = null;
			if(block && tool !== "move") {
				sa.control.selection = {
					x: block[0],
					y: block[1],
					w: 1,
					h: 1,
				};
				//sa.control.input = structuredClone(sa.data[click.x][click.y].input);
			};
			if(tool === "move") {
				sa.control.strokedata = {
					click,
					in_rect: sa.in_rect(selection, ...(block ?? [click.x, click.y])),
				};
			}
			else if(tool === "swap") {
				sa.control.strokedata = block ?? [click.x, click.y];
			}
			else if(tool === "paint") {
				sa.paint(click.x, click.y);
			};
			sa.refresh();
		},
		mousemove: function(e, finish) {
			let i1 = 0;
			let i2 = 0;
			let click = clickxy(e);
			let block = sa.block_coor(...click, true);
			click = sa.block_coor(...click);
			document.getElementById("sa_coordisplay").innerHTML = [
				"x: " + click.x + ":" + click.offset[0],
				"y: " + click.y + ":" + click.offset[1]
			].join("<br>");
			if(sa.control.clicktype !== "main") {
				return;
			}
			let tool = sa.control.tool;
			let selection = sa.control.selection;
			let stroke = sa.control.strokedata;
			let skip_refresh = false;
			let ctx = sa.ctx.main;
			ctx.putImageData(sa.clean_image, 0, 0);
			if(tool === "move") {
				if(stroke.in_rect) {
				// move
					let _data = structuredClone(sa.data);
					let _selection = structuredClone(selection);
					let diff = [
						(sa.block*click.x + click.offset[0]) - (sa.block*stroke.click.x + stroke.click.offset[0]),
						(sa.block*click.y + click.offset[1]) - (sa.block*stroke.click.y + stroke.click.offset[1])
					];
					if(stroke.in_rect || stroke.block) {
						diff = [
							[Math.trunc(diff[0]/sa.block), diff[0]%sa.block],
							[Math.trunc(diff[1]/sa.block), diff[1]%sa.block],
						];
						// number of blocks to move, number of pixels
						let func = function(x, y, outside, select) {
							let block = structuredClone(sa.data[x][y]);
							if(!block) {
								return;
							}
							sa.data[x][y] = null;
							let temp = [
								block.offset[0] + diff[0][1],
								block.offset[1] + diff[1][1]
							];
							block.offset[0] = posmod(temp[0], sa.block);
							block.offset[1] = posmod(temp[1], sa.block);
							let _x = x + diff[0][0] + Math.round((temp[0] - block.offset[0])/sa.block);
							let _y = y + diff[1][0] + Math.round((temp[1] - block.offset[1])/sa.block);
							if(_x < 0 || _x >= sa.data_w || _y < 0 || _y >= sa.data_h) {
								return;
							};
							sa.data[_x][_y] = structuredClone(block);
							if(outside) {
								sa.clear_overlap(_x, _y);
							};
							if(select) {
								sa.control.selection = {
									x: _x,
									y: _y,
									w: 1,
									h: 1,
								};
							}
						};
						if(stroke.in_rect) {
							sa.rect_execute(selection, func);
							selection.x += diff[0][0];
							selection.y += diff[1][0];
							selection.x = Math.min(sa.data_w, Math.max(selection.x, 0));
							selection.w = Math.min(sa.data_w, Math.max(selection.x + selection.w, 0)) - selection.x;
							selection.y = Math.min(sa.data_h, Math.max(selection.y, 0));
							selection.h = Math.min(sa.data_h, Math.max(selection.y + selection.h, 0)) - selection.y;
							// move the selection to match, but keep it inside
						}
						else {
							func(...stroke.block, true, true);
						};
						if(!finish) {
						// display changes, but restore the old version
							sa.refresh();
							skip_refresh = true;
							sa.data = structuredClone(_data);
							sa.control.selection = structuredClone(_selection);
						}
					}
				}
				else {
				// select
					let rect = sa.make_rect(stroke.click.x, stroke.click.y, click.x, click.y);
					if(finish) {
						sa.control.selection = structuredClone(rect);
					}
					else {
						sa.select_rect(ctx, rect);
					};
				}
			}
			else if(tool === "swap" && finish) {
			// swap the blocks at the beginning and end of the stroke
				let start = stroke;
				let _start = sa.data[ start[0] ][ start[1] ];
				let end = block ?? [click.x, click.y];
				let _end = sa.data[ end[0] ][ end[1] ];
				if(!_start && !_end) {
				}
				else if(!_start) {
					sa.data[ start[0] ][ start[1] ] = {
						offset: [0, 0],
						input: structuredClone(_end.input),
					};
					sa.data[ end[0] ][ end[1] ] = null;
				}
				else if(!_end) {
					sa.data[ end[0] ][ end[1] ] = {
						offset: [0, 0],
						input: structuredClone(_start.input),
					};
					sa.data[ start[0] ][ start[1] ] = null;
				}
				else {
					let temp = structuredClone(_start.input);
					_start.input = structuredClone(_end.input);
					_end.input = structuredClone(temp);
				};
				sa.control.selection = {
					x: end[0],
					y: end[1],
					w: 1,
					h: 1,
				};
			}
			else if(tool === "paint") {
				sa.paint(click.x, click.y);
				sa.refresh();
				skip_refresh = true;
			};
			if(finish) {
				if(!skip_refresh) {
					sa.refresh();
				};
				sa.control.clicktype = null;
			};
		},
		mouseup: function(e) {
			sa.mousemove(e, true);
		},
	};
	sa.initialize();
	//
	let palette = {
		colortypes: ["a", "b", "c", "skin", "outline", "wildcard"],
		ctx: null,
		initialize: function() {
			let i1 = 0;
			let html = [];
			for(i1 = 0; i1 < 3; i1++) {
				html[i1] = `<input type="color" id="palette_` + "abc"[i1] + `">`;
			}
			html = [
				`interactive tool for the rules i make character palettes with.
				<ul>
					<li>
					three base colors
					</li>
					<li>
					skin color
					</li>
					<li>
					dark color for outlines
					</li>
					<li>
					squarings of all of those, for lighting
					</li>
					<li>
					multiplications of the base colors, for variety
					</li>
					<li>
					white for lighting and eye whites
					</li>
					<li>
					transparency
					</li>
					<li>
					extra color for anything not covered by all that. (black,
					iris colors, visual effects)
					</li>
				</ul>`,
				`<label>` + html.join(` `) + ` base colors</label>`
			];
			for(i1 = 0; i1 < palette.colortypes.length; i1++) {
				let type = palette.colortypes[i1];
				if(type.length !== 1 || !"abc".includes(type)) {
					html[html.length] = `<label><input type="color" id="palette_` + type + `"> ` + type + `</label>`;
				}
			}
			html[html.length] = `<button id="palette_randomize">randomize</button>`;
			html[html.length] = `<canvas id="palette_canvas" width=32 height=32></canvas>`;
			html = `<div name="hider" id="hider_palette_tester">\n` + html.join(`<br>`) + `\n</div>`;
			document.write(html);
			for(i1 = 0; i1 < palette.colortypes.length; i1++) {
				document.getElementById("palette_" + palette.colortypes[i1]).onchange = palette.refresh;
			}
			document.getElementById("palette_randomize").onclick = palette.randomize;
			document.getElementById("palette_canvas").style["image-rendering"] = "crisp-edges";
			palette.ctx = document.getElementById("palette_canvas").getContext("2d");
			document.getElementById("palette_skin").value = "#6f9f9f";
			palette.randomize();
			// initialize the value, refresh
		},
		randomize: function() {
			let convert = (color) => Color.rgb(palette.ctx, color, true);
			let temp = Color.random(3);
			for(i1 = 0; i1 < 3; i1++) {
				document.getElementById("palette_" + "abc"[i1]).value = convert(temp[i1]);
			}
			document.getElementById("palette_outline").value = convert(Color.random(null, true));
			document.getElementById("palette_wildcard").value = convert(Color.random());
			palette.refresh();
		},
		refresh: function() {
			let ctx = palette.ctx;
			let dim = [ctx.canvas.width, ctx.canvas.height];
			let colors = [];
			for(i1 = 0; i1 < palette.colortypes.length; i1++) {
				colors[i1] = document.getElementById("palette_" + palette.colortypes[i1]).value;
			};
			colors = Color.palette(ctx, ...colors);
			ctx.clearRect(0, 0, dim[0], dim[1]);
			const w = 4;
			const h = Math.ceil(colors.length/w);
			dim[0] /= w;
			dim[1] /= h;
			for(let i1 = 0; i1 < colors.length; i1++) {
				ctx.fillStyle = colors[i1];
				ctx.fillRect(dim[0]*(i1%w), dim[1]*Math.floor(i1/w), dim[0], dim[1]);
			}
		},
	};
	palette.initialize();
	//
	document.write(`<div name="hider" id="hider_interactive_animation"></div>`);
	class Intanisy {
	// "interactive animation system"
		constructor() {
			let temp = {
				w: 256,
				h: 256,
				color: "white",
				div: null,
				ctx: null,
			};
			for(let i1 in temp) {
				if(temp.hasOwnProperty(i1)) {
					this[i1] = structuredClone(temp[i1]);
				};
			}
		}
		initialize(div) {
			this.div.innerHTML = `<canvas width=` + this.w + ` height=` + this.h + `></canvas>`;
			let canvas = div.querySelector("canvas");
			canvas.style["image-rendering"] = "crisp-edges";
			canvas.style["touch-action"] = "none";
			this.ctx = canvas.getContext("2d");
			canvas.onpointerdown = this.mousedown;
			canvas.onpointermove = this.mousemove;
			canvas.onpointerup = this.mouseup;
		}
		mousedown(e) {
			let click = clickxy(e);
		}
		mousemove(e) {
			let click = clickxy(e);
		}
		mouseup(e) {
			let click = clickxy(e);
		}
	}
	let ias = new Intanisy(document.getElementById("hider_intanisy"));
	//
	document.write(`<div name="hider" id="hider_background_maker"></div>`);
	let bgm = {
		draw: {
			ctx: null,
			ctx_ui: null,
			ui: {},
			ui_color: ["orange", "white", "#ffdfef"],
			valid: {
				tool: ["pen", "eraser", "colorpick"],
			},
			control: {
				_tool: 0,
				// get tool
				// set tool
				color_pen: "black",
				color_eraser: "white",
			},
			initialize: function() {
				let i1 = 0;
				let i2 = 0;
				let control = this.control;
				let valid = this.valid;
				Object.defineProperty(control, "tool", {
					get() {
						return valid.tool[ control._tool ];
					},
					set(value) {
						value = valid.tool.indexOf(value);
						if(value !== -1) {
							control._tool = value;
						};
					},
				})
				let html = [
					`<canvas id="bgm_draw" width=256 height=256></canvas>`,
					`<canvas id="bgm_draw_ui" width=256 height=256></canvas>`
				];
				document.getElementById("hider_background_maker").innerHTML = html.join("\n");
				const array = ["down", "move", "up"];
				for(i1 = 0; i1 < 2; i1++) {
					let canvas = document.getElementById(i1 ? "bgm_draw_ui" : "bgm_draw");
					canvas.style["image-rendering"] = "crisp-edges";
					// no antialiasing
					canvas.style["touch-action"] = "none";
					// this keeps it from sliding around when you're using a phone.
					this[i1 ? "ctx_ui" : "ctx"] = canvas.getContext("2d");
					this[i1 ? "ctx_ui" : "ctx"].font = "6px 'thick 4x4'";
					for(i2 = 0; i2 < array.length; i2++) {
						let type = array[i2];
						let name = (i1 ? "ui_" : "") + "mouse" + type;
						if(name in this) {
							canvas["onpointer" + type] = this[name];
						};
					}
				}
				let _this = this;
				this.ctx_ui.canvas.onpointerdown = function(e) {
					let click = clickxy(e, "bgm");
					let button = Rect.inside_multi(_this.ui, ...click);
					if(button) {
						_this.ui_action(button);
					}
				};
				this.ui = Rect.ui([
					{
						prefix: "tool",
						first: {
							suffix: this.valid.tool,
							w: 8, h: 2,
						},
						heading: 1,
					},
					{
						prefix: "color",
						first: {
							suffix: ["pen", "eraser"],
							w: 4, h: 2, horizontal: true,
						},
						heading: 1,
					},
					{
						prefix: "misc",
						first: {
							suffix: ["canvas_w", "canvas_h"],
							w: 4, h: 2,
						},
						heading: 1,
					}
				]);
				let ui_block = 8;
				for(i1 in this.ui) {
					if(this.ui.hasOwnProperty(i1)) {
						this.ui[i1].x *= ui_block;
						this.ui[i1].y *= ui_block;
						this.ui[i1].w *= ui_block;
						this.ui[i1].h *= ui_block;
					}
				}
				this.ui_refresh();
			},
			ui_refresh: function() {
				let i1 = 0;
				let i2 = 0;
				let ctx = this.ctx_ui;
				let outlines = {};
				let dim = [0, 0];
				for(i1 in this.ui) {
					if(this.ui.hasOwnProperty(i1)) {
						dim = [
							Math.max(dim[0], Rect.r(this.ui[i1])),
							Math.max(dim[1], Rect.d(this.ui[i1]))
						];
					}
				};
				ctx.canvas.width = dim[0] + 1;
				ctx.canvas.height = dim[1] + 1;
				ctx.clearRect(0, 0, ...dim);
				ctx.font = "6px 'thick 4x4'";
				ctx.textBaseline = "middle";
				for(i1 in this.ui) {
					if(this.ui.hasOwnProperty(i1)) {
						let prefix = PreSuf.get(i1);
						let suffix = prefix[1];
						prefix = prefix[0];
						let rect = this.ui[i1];
						let selected = Number(
							(prefix === "tool" && this.control.tool === suffix)
						);
						let color = structuredClone(this.ui_color);
						ctx.strokeStyle = color[ posmod(- selected, color.length) ];
						if(suffix !== "heading") {
							ctx.fillStyle = color[ posmod(1 - selected, color.length) ];
							if(prefix === "color") {
								ctx.fillStyle = this.control[i1];
							}
							ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
							outlines[i1] = ctx.strokeStyle;
						}
						buttontext(
							null,
							// settings
							ctx, rect,
							(
								suffix === "heading" ? prefix :
								(prefix === "misc" && suffix === "canvas_w") ? ["canvas", "width"] :
								(prefix === "misc" && suffix === "canvas_h") ? ["canvas", "height"] :
								suffix
							),
							// text
							null,
							(
								suffix === "heading"
								||
								prefix === "color"
								||
								prefix === "misc"
							)
						);
					}
				}
				for(i1 in outlines) {
					if(outlines.hasOwnProperty(i1)) {
						ctx.strokeStyle = outlines[i1];
						let rect = this.ui[i1];
						ctx.strokeRect(rect.x + .5, rect.y + .5, rect.w, rect.h);
					}
				}
			},
			ui_action: function(button) {
				let prefix = PreSuf.get(button);
				let suffix = prefix[1];
				prefix = prefix[0];
				if(prefix === "tool") {
					this.control.tool = suffix;
				}
				else if(prefix === "color") {
					let color = prompt("enter a new " + suffix + " color.");
					if(color) {
						this.control[button] = color;
					};
				}
				else if(prefix === "misc") {
					if(suffix === "canvas_w" || suffix === "canvas_h") {
						let dim = suffix === "canvas_w" ? "width" : "height";
						let num = Number(prompt("enter a new " + dim + " for the drawing area."));
						if(Number.isInteger(num) && num > 0) {
							let _ctx = this.ctx;
							let imagetemp = _ctx.getImageData(0, 0, _ctx.canvas.width, _ctx.canvas.height);
							_ctx.canvas[dim] = num;
							_ctx.clearRect(0, 0, _ctx.canvas.width, _ctx.canvas.height);
							let filltemp = _ctx.fillStyle;
							_ctx.fillStyle = this.control.color_eraser;
							_ctx.fillRect(0, 0, _ctx.canvas.width, _ctx.canvas.height);
							_ctx.fillStyle = filltemp;
							_ctx.putImageData(imagetemp, 0, 0);
						};
					}
				};
				this.ui_refresh();
			},
		},
		initialize: function() {
			this.draw.initialize();
		}
	};
	bgm.initialize();
	//
	document.write(`<div name="hider" id="hider_facial_proportions_tool"></div>`);
	let fpt = {
	// lets you edit and visualize facial proportions by dragging markers along
	// axes.
	// - marker structure:
	//   - [part name]
	//     - x/y/z
	//       - parent: which other part its coordinates are relative to. (null
	//         means it isn't relative to anything, it starts at 0.)
	//       - start: the start coordinate of this part minus the end of the
	//         parent part. (or the start of the parent part, if it had no end.)
	//       - end: the coordinate of the end of this part, minus the start of
	//         this part.
	//       - dim: the distance from the center/start of the part to its edges.
	//         this is special in some ways.
	//         - first, a duplicate handle will be made. there will be a start +
	//           dim handle and a start - dim handle. both can be moved to scale
	//           the part.
	//         - second, if a parenting string ends with + or -, parts can be
	//           made relative to one of these edges. for example, nose.z's
	//           parent is cranium+. it will be positioned relative to the front
	//           edge of the cranium.
	//       - [any other string]: another reference point.
	//         - for example, the start of the nose is the top of the bridge,
	//           and the end of the nose is the bottom. this is true in all
	//           axes.
	//         - so the front or side points will be nose.front and nose.side.
	// cranium, jaw, nose, eye, brow, mouth, ears
		markers: {
			cranium: {
				x: {
					// the cranium can't be moved in the x axis, because it
					// doesn't mix well with the x/dim handle duplicates. it
					// isn't impossible or anything, but there's no reason to
					// move the cranium in the x axis anyway. (unlike the y or z
					// axis where you might move it to make room for the jaw or
					// nose, all x features are symmetrical.)
					dim: 16,
				},
				y: {
					start: 0,
					dim: 14,
				},
				z: {
					start: 0,
					dim: 16,
				},
			},
			jaw: {
				parent: "cranium",
				x: {
					dim: 12,
				},
				y: {
					parent: "cranium+",
					start: 14,
					end: -6,
				},
				z: {
					parent: "cranium+",
					start: -2,
					end: -22,
				},
			},
			ear: {
				parent: "cranium",
				x: {
					parent: "cranium+",
					start: -2,
					end: 4,
					skew: 3/2,
				},
				y: {
					parent: "cranium+",
					start: -6,
					dim: 6,
					middle: 1,
				},
				z: {
					start: 0,
					end: -7,
					middle: -5,
					skew: -1,
				},
			},
			nose: {
				parent: "cranium",
				x: {
					start: 2,
					side: 2,
					front: 0,
					end: 0,
				},
				y: {
					start: 2,
					side: 7,
					front: 6,
					end: 10,
				},
				z: {
					parent: "cranium+",
					start: 0,
					side: -2,
					front: 2,
					end: 0,
				},
			},
			mouth: {
				parent: "cranium",
				x: {
					dim: 9,
				},
				y: {
					parent: "nose",
					start: 5,
					end: 1,
				},
				z: {
					parent: "cranium+",
					start: -1,
					end: -9,
				},
			},
			brow: {
				parent: "eye",
				x: {
					start: -4,
					bend: 4,
					end: 9,
				},
				y: {
					start: -7,
					bend: -1,//-8/2,
					end: 1,//11/2,
				},
				z: {
					start: 4,
					bend: -3,
					end: -9,
				},
			},
			eye: {
				parent: "cranium",
				x: {
					start: 8,
					dim: 4,
					//corner: 0,
				},
				y: {
					start: 6,
					dim: 4,
					upper: -3,
					lower: 3,
				},
				z: {
					start: 8,
					dim: 4,
					//corner: 0,
				},
			},
		},
		handles: [],
		// an array of objects storing information related to the draggable
		// markers.
		// - x, y (of the center of the marker)
		// - prefix
		// - axis (the axis it represents, that is.)
		// - suffix
		settings: {
			cell_w: 64,
			cell_h: 64,
			barwidth: 8,
			fineness: 32,
			handleleeway: 2,
			disablelids: true,
		},
		/*
		color: {
			bg: "white",
			skin: "#6f9f9f",
			main: "#3f7f6f",
			nose: "cornflowerblue",
			eye: "red",
			brow: "brown",
			mouth: "cornflowerblue",
		},
		//*/
		color: {
			bg: "white",
			skin: "#6f9f9f",
			main: "#578f87",
			ear: "#3f7f6f",
			cranium: "#3f7f6f",
			jaw: "#3f7f6f",
			brow: "#5b674f",
			eye: "red",
		},
		control: {
			handle_index: -1,
			get handle() {
				return fpt.handles[fpt.control.handle_index] ?? null;
			},
			downclick: null,
			// coordinates of the mousedown
		},
		states: null,
		// a States object, for undo/redo
		ctx: null,
		element: (name) => document.getElementById(tohtmlid("fpt " + name)),
		initialize: function() {
			if(fpt.settings.disablelids) {
				delete fpt.markers.eye.y.upper;
				delete fpt.markers.eye.y.lower;
			}
			fpt.scale(2);
			fpt.markers.nose.z.end--;
			fpt.markers.mouth.z.start--;
			let html = [
				`<canvas id="fpt_canvas"></canvas>`,
				addhtml("fpt", "button", "undo") + ` ` + addhtml("fpt", "button", "redo"),
				[
					addhtml("fpt", "input", "cell w", `type="number" style="width: 4em" step=2 value=` + fpt.settings.cell_w, null, "width"),
					addhtml("fpt", "input", "cell h", `type="number" style="width: 4em" step=2 value=` + fpt.settings.cell_h, null, "height"),
					addhtml("fpt", "button", "apply dimensions", null, "apply")
				].join(" "),
				[
					addhtml("fpt", "input", "scale", `style="width: 2em" value=2`),
					addhtml("fpt", "button", "multiply"),
					addhtml("fpt", "button", "divide")
				].join(" "),
				addhtml("fpt", "textarea", "data", null, null, "data text"),
				addhtml("fpt", "button", "apply data", null, null, "apply data changes")
			].join(`\n<br>`);
			document.getElementById("hider_facial_proportions_tool").innerHTML = html;
			let canvas = document.getElementById("fpt_canvas");
			fpt.ctx = canvas.getContext("2d");
			canvas.style["image-rendering"] = "crisp-edges";
			canvas.style["touch-action"] = "none";
			canvas.onpointerdown = fpt.mousedown;
			canvas.onpointermove = fpt.mousemove;
			canvas.onpointerup = fpt.mouseup;
			fpt.refresh("states");
			// no new state, since the States constructor will make one
			// automatically.
			fpt.states = new States(fpt, 32, (tool) => structuredClone(tool.markers), function(tool, state) {
				tool.markers = structuredClone(state);
				tool.refresh("states");
			});
			fpt.element("undo").onclick = function() { fpt.states.undo() };
			fpt.element("redo").onclick = function() { fpt.states.redo() };
			fpt.element("apply dimensions").onclick = function() {
				let w = Number(fpt.element("cell w").value);
				let h = Number(fpt.element("cell h").value);
				w = Number.isInteger(w) && w > 1 ? w : fpt.settings.cell_w;
				h = Number.isInteger(h) && h > 1 ? h : fpt.settings.cell_h;
				w = Math.floor(w/2)*2;
				h = Math.floor(h/2)*2;
				fpt.settings.cell_w = w;
				fpt.settings.cell_h = h;
				fpt.refresh(["states", "datatext"]);
			};
			fpt.element("multiply").onclick = function() {
				let scale = Math.abs(Number(fpt.element("scale").value));
				if(scale) {
					fpt.scale(scale);
					fpt.refresh();
				};
			};
			fpt.element("divide").onclick = function() {
				let scale = Math.abs(Number(fpt.element("scale").value));
				if(scale) {
					fpt.scale(1/scale);
					fpt.refresh();
				};
			};
			fpt.element("data").cols = 36;
			fpt.element("apply data").onclick = function() {
			// NOTE: the logic that unabsolutes coordinates won't work quite
			// right if the data is missing coordinates, like if it's missing
			// a part's start...
			// - i didn't fix that because there's no particular reason to
			//   expect that to happen. of course it'd glitch if you screw with
			//   the text. are you stupid?
			// - if a fix is ever needed, you could do that by iterating through
			//   the current state of fpt.markers and filling the missing values
			//   with fpt.abscoor.
				let data = texttoobj(fpt.element("data").value);
				if(data) {
					for(let i1 in data) {
						for(let i2 = 0; i2 < 3; i2++) {
							let axis = "xyz"[i2];
							let _data = data[i1][axis];
							let ref = fpt.markers[i1][axis];
							let parentend = (ref.parent ?? fpt.markers[i1].parent) ?? "";
							if(parentend) {
							// figure out the coordinates of the end of the
							// parent, since that'll be necessary no matter
							// what, at least to figure out the start's relative
							// coordinate.
								let sign = parentend.endsWith("-") ? -1 : parentend.endsWith("+") ? 1 : 0;
								let parent = data[ sign ? parentend.slice(0, -1) : parentend ][axis];
								parentend = "start" in parent ? parent["end" in parent ? "end" : "start"] : 0;
								parentend += sign*(parent.dim ?? 0);
								// parent start/end abscoor plus sign*dim
							}
							else {
								parentend = 0;
							};
							let parentcoor = parentend;
							if("start" in _data) {
							// if the part has a start, set it as the
							// abscoor minus parentend.
								parentcoor = _data.start;
								ref.start = parentcoor - parentend;
							};
							for(let i3 in _data) {
								if(_data.hasOwnProperty(i3) && i3 !== "parent" && i3 !== "start") {
									ref[i3] = _data[i3] - (i3 !== "dim")*parentcoor;
								}
							}
						}
					}
					fpt.refresh("states");
				}
				/*
				abscoor: function(prefix, axis, suffix) {
					let num = fpt.markers[prefix][axis][suffix];
					return (
						suffix === "dim" ? num :
						fpt.parentcoor(prefix, axis) + (suffix === "start" ? 0 : num)
					);
				},
				//*/
			};
			element = fpt.element
			//addhtml("fpt", "textarea", "data", "cols=32", null, "data text"),
			//addhtml("fpt", "button", "apply data")
		},
		scale: function(scale) {
			for(let i1 in fpt.markers) {
				for(let i2 = 0; i2 < 3; i2++) {
					let axis = "xyz"[i2];
					let ref = fpt.markers[i1][axis];
					for(let i3 in ref) {
						if(ref.hasOwnProperty(i3) && i3 !== "parent") {
							ref[i3] *= scale;
							ref[i3] = Math.trunc(ref[i3]);
						}
					}
				}
			}
			fpt.settings.cell_w *= scale;
			fpt.settings.cell_h *= scale;
		},
		parentcoor: function(prefix, axis) {
		// returns the absolute coordinate all markers of this prefix/axis start
		// from.
			let ref = fpt.markers[prefix];
			let num = ref[axis].start ?? 0;
			let parent = (ref[axis].parent ?? ref.parent) ?? "";
			let sign = parent.endsWith("-") ? -1 : parent.endsWith("+") ? 1 : 0;
			if(sign) {
				parent = parent.slice(0, -1);
			};
			if(parent) {
				let ref = fpt.markers[parent][axis];
				if("start" in ref) {
					num += fpt.abscoor(parent, axis, ("end" in ref ? "end" : "start"));
				};
				if("dim" in ref) {
					num += sign*Math.abs(ref.dim);
				};
			};
			return num;
		},
		abscoor: (prefix, axis, suffix) => (
			(suffix !== "dim")*fpt.parentcoor(prefix, axis) + (suffix !== "start")*fpt.markers[prefix][axis][suffix]
		),
		refresh: function(skip) {
		// - skip: an array of things to skip.
		//   - "handlechange": new handles will be drawn, but fpt.handles will
		//     not be redefined.
		//   - "states": it will not create a new state.
		//   - "datatext": it will not rewrite the data textarea.
			let i0 = 0;
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			skip = Array.isArray(skip) ? skip : typeof skip === "string" ? [skip] : [];
			for(i1 = 0; i1 < skip.length; i1++) {
				if(!["handlechange", "states", "datatext"].includes(skip[i1])) {
					console.log("unknown skip item: " + skip[i1]);
				};
			}
			//
			let x = {};
			let y = {};
			let z = {};
			let numofbars = 0;
			for(i1 in fpt.markers) {
				if(fpt.markers.hasOwnProperty(i1)) {
					numofbars++;
					for(i2 = 0; i2 < 3; i2++) {
						let axis = "xyz"[i2];
						let axis_obj = i2 === 0 ? x : i2 === 1 ? y : i2 === 2 ? z : null;
						if(fpt.markers[i1].hasOwnProperty(axis)) {
							let ref = fpt.markers[i1][axis];
							for(i3 in ref) {
								if(ref.hasOwnProperty(i3) && i3 !== "parent") {
									axis_obj[i1] ??= {};
									axis_obj[i1][i3] = fpt.abscoor(i1, axis, i3);
								}
							}
						}
					}
				}
			}
			//
			let jawcurve = [];
			let mouthcurve = [];
			let temp = Math.ceil(fpt.settings.fineness/4);
			for(i1 = 0; i1 <= temp; i1++) {
				let angle = 2*Math.PI*(1/8 + i1/(temp*4));
				let point = [Math.cos(angle), Math.sin(angle)];
				point[0] /= Math.SQRT1_2;
				point[1] -= Math.SQRT1_2;
				point[1] /= 1 - Math.SQRT1_2;
				// move and stretch it so it goes from -1 to 1 x and 0 to 1
				// y
				jawcurve.push([
					point[0]*x.jaw.dim,
					// -1 to 1 => -dim to dim
					y.jaw.end + point[1]*(y.jaw.start - y.jaw.end),
					z.jaw.end + point[1]*(z.jaw.start - z.jaw.end)
					// 0 to 1 => end to start
				]);
				mouthcurve.push([
					point[0]*x.mouth.dim,
					// -1 to 1 => -dim to dim
					y.mouth.end + point[1]*(y.mouth.start - y.mouth.end),
					z.mouth.end + point[1]*(z.mouth.start - z.mouth.end)
					// 0 to 1 => end to start
				]);
			}
			let ear = null;
			let box = {
				x: x.ear.start,
				y: y.ear.start - y.ear.dim,
				z: z.ear.start,
				w: x.ear.end - x.ear.start,
				h: 2*y.ear.dim,
				d: z.ear.end - z.ear.start,
			};
			if(box.w && box.h && box.d) {
				ear = [
					{x: x.ear.skew, y: box.y, z: z.ear.skew},
					// upper circle
					{x: box.x, y: box.y + box.h, z: box.z},
					// lower circle
				];
				ear[0].xr = box.w/2;
				ear[0].yr = (y.ear.middle - box.y)/2;
				ear[0].zr = box.d/2;
				ear[0].x += ear[0].xr;
				ear[0].y += ear[0].yr;
				ear[0].z += ear[0].zr;
				let temp = (z.ear.middle - box.z)/(box.d*2);
				ear[1].xr = temp*box.w;
				ear[1].yr = temp*Math.hypot(box.w, box.d);
				ear[1].zr = temp*box.d;
				ear[1].x += ear[1].xr;
				ear[1].y -= ear[1].yr;
				ear[1].z += ear[1].zr;
			};
			let eye = fpt.settings.disablelids ? null : {};
			for(i1 = 0; i1 < 2 && eye; i1++) {
				let temp = i1 ? "lower" : "upper";
				let num = (y.eye[temp] - y.eye.start)/y.eye.dim;
				if(num < -1 || num > 1) {
					eye = null;
				}
				else {
					eye[temp] = posmod(0*Math.PI/2 + Math.asin(num), 2*Math.PI);
				}
			}
			if(eye) {
				eye = {
					range: posmod(eye.lower - eye.upper, 2*Math.PI),
					yz: eye.upper,
				};
				/*
				eye.xz = (z.eye.corner - z.eye.start)/z.eye.dim;
				eye.xz = (
					eye.xz <= -1 ? Math.PI/2 :
					eye.xz <= 1 ? -Math.PI/2 :
					Math.asin(num)
				);
				//*/
			}
			//
			let ctx = fpt.ctx;
			let cell = [fpt.settings.cell_w, fpt.settings.cell_h];
			ctx.canvas.width = cell[0];
			ctx.canvas.height = cell[1];
			let images = [null, null];
			function colorchange(name) {
				//console.log(name);
				ctx.fillStyle = fpt.color[name] ?? fpt.color.main;
				ctx.strokeStyle = fpt.color[name] ?? fpt.color.main;
			};
			for(i0 = 0; i0 < 2; i0++) {
				//console.log("===\n" + (i0 ? "right" : "front") + "\n===");
				ctx.clearRect(0, 0, ...cell);
				ctx.fillStyle = fpt.color.bg;
				ctx.fillRect(0, 0, ...cell);
				ctx.translate(cell[0]/2, cell[1]/2);
				//
				if(ear) {
					colorchange("ear");
					//*
					let points = [];
					for(i1 = 0; i1 < 2; i1++) {
						let ref = ear[i1];
						let rect = [
							Math.abs(ref[i0 ? "zr" : "xr"]),
							Math.abs(ref.yr)
						];
						rect = Rect.new(
							ref[i0 ? "z" : "x"] - rect[0],
							ref.y - rect[1],
							2*rect[0] + 1,
							2*rect[1] + 1
						);
						let image = Raster.outline(Raster.fullellipse(rect.w, rect.h), rect.w);
						//console.log(Raster.totext(image, rect.w));
						for(i2 = 0; i2 < image.length; i2++) {
							if(image[i2]) {
								points.push(Raster.indextocoord(i2, rect));
							}
						}
					}
					points = _2dPoly.convexed(points);
					if(!i0) {
						_2dPoly.draw(ctx, points, "stroke");
					};
					for(i1 = 0; i1 < points.length; i1++) {
						points[i1][0] *= -1;
					};
					_2dPoly.draw(ctx, points, "stroke");
					//*/
					/*
					if(i0) {
						circledraw(ctx, -ear.core1.z, ear.core1.y, [ear.core1.zr, ear.core1.yr]);
						circledraw(ctx, -ear.core2.z, ear.core2.y, [ear.core2.zr, ear.core2.yr]);
					}
					else {
						circledraw(ctx, ear.core1.x, ear.core1.y, [ear.core1.xr, ear.core1.yr]);
						circledraw(ctx, -ear.core1.x, ear.core1.y, [ear.core1.xr, ear.core1.yr]);
						circledraw(ctx, ear.core2.x, ear.core2.y, [ear.core2.xr, ear.core2.yr]);
						circledraw(ctx, -ear.core2.x, ear.core2.y, [ear.core2.xr, ear.core2.yr]);
					};
					//*/
				}
				//
				colorchange("cranium");
				let head = [];
				for(i1 = 0; i1 < fpt.settings.fineness; i1++) {
					let angle = 2*Math.PI*i1/fpt.settings.fineness;
					head.push([
						(i0 ? -z.cranium.start : 0) + (i0 ? z : x).cranium.dim*Math.cos(angle),
						y.cranium.start + y.cranium.dim*Math.sin(angle)
					]);
				}
				//_2dPoly.draw(ctx, head, "stroke");
				//head = [];
				for(i1 = 0; i1 < jawcurve.length; i1++) {
					head.push([
						(i0 ? -jawcurve[i1][2] : jawcurve[i1][0]),
						jawcurve[i1][1]
					]);
				}
				//_2dPoly.draw(ctx, head, "stroke", null, null, "skiplaststroke");
				head = _2dPoly.convexed(head);
				ctx.fillStyle = fpt.color.skin;
				_2dPoly.draw(ctx, head, "stroke");
				//
				colorchange("nose");
				for(i1 = 0; i1 < (i0 ? 1 : 2); i1++) {
					let obj = (i0 ? z : x);
					let points = [
						[obj.nose.start, y.nose.start],
						[obj.nose.side, y.nose.side],
						[obj.nose.front, y.nose.front],
						[obj.nose.end, y.nose.end]
					];
					if(i0 || i1) {
						for(i2 = 0; i2 < points.length; i2++) {
							points[i2][0] *= -1;
						}
					};
					let center = [0, points[2][1]];
					// use front as the sl center
					for(i2 = 0; i2 < points.length; i2++) {
						for(i3 = i2 + 1; i3 < points.length; i3++) {
						// round robin all four nose points
							if(i2 === 0 && i3 === 3) {
							// except start to end.
							}
							else {
								linespecial(ctx, ...points[i2], ...points[i3], center);
							}
						}
						if(!i0 && !i1 && i2 !== 0 && i2 !== 1 && points[i2][0]) {
						// connect to symmetrical counterpart (except for the
						// start/side point)
							linespecial(ctx, points[i2][0], points[i2][1], -points[i2][0], points[i2][1], center);
						};
					}
				}
				//
				colorchange("eye");
				if(eye) {
					let dim = [
						Math.abs((i0 ? z : x).eye.dim),
						Math.abs(y.eye.dim)
					];
					let rect = Rect.new(
						-dim[0],
						-dim[1],
						2*dim[0] + 1,
						2*dim[1] + 1
					);
					let image = Raster.fullellipse(rect.w, rect.h);
					for(i1 = 0; i1 < image.length; i1++) {
						if(image[i1]) {
							let coor = Raster.indextocoord(i1, rect);
							let hypot = Math.hypot(...coor);
							if(hypot) {
								coor = Points.multiply(coor, Math.max(0, hypot - .5)/hypot);
							}
							// avoids the thing where only the peaks of the
							// curves meet the conditions. like how you have to
							// add .5 to the radius when drawing a circle.
							coor[0] /= dim[0];
							coor[1] /= dim[1];
							coor[2] = Math.sqrt(1 - coor[0]**2 - coor[1]**2);
							// x2 + y2 + z2 = 1
							coor = revolve(-i0*Math.PI/2, coor, null, "xz");
							//let angle = posmod(get2dangle(coor[1], coor[2], true) - eye.yz, 2*Math.PI);
							coor = revolve(-eye.yz, coor, null, "yz");
							let angle = posmod(get2dangle(coor[1], coor[2], true), 2*Math.PI);
							image[i1] = angle < eye.range;
						};
					}
					image = Raster.outline(image, rect.w);
					for(i1 = 0; i1 < image.length; i1++) {
						if(image[i1]) {
							let coor = Raster.indextocoord(i1, rect);
							coor[0] += (i0 ? z : x).eye.start;
							coor[1] += y.eye.start;
							if(!i0) {
								ctx.fillRect(coor[0], coor[1], 1, 1);
							}
							ctx.fillRect(-coor[0], coor[1], 1, 1);
						}
					}
				}
				else if(i0) {
					circledraw(ctx, -z.eye.start, y.eye.start, [z.eye.dim, y.eye.dim]);
				}
				else {
					circledraw(ctx, x.eye.start, y.eye.start, [x.eye.dim, y.eye.dim]);
					circledraw(ctx, -x.eye.start, y.eye.start, [x.eye.dim, y.eye.dim]);
				};
				//
				colorchange("brow");
				for(i1 = 0; i1 < (i0 ? 1 : 2); i1++) {
					//console.log("===");
					let obj = (i0 ? z : x);
					let _obj = (i0 ? x : z);
					let start = [
						obj.brow.start,
						y.brow.start,
						_obj.brow.start
					];
					let bend = [
						obj.brow.bend,
						y.brow.bend,
						_obj.brow.bend
					];
					let end = [
						obj.brow.end,
						y.brow.end,
						_obj.brow.end
					];
					if(i0 || i1) {
						start[0] *= -1;
						bend[0] *= -1;
						end[0] *= -1;
					};
					if(i0) {
						start[2] = Math.abs(start[2]);
						bend[2] = Math.abs(bend[2]);
						end[2] = Math.abs(end[2]);
					};
					// front: [x, y, z], [-x, y, z]
					// right: [-z, y, abs(x)]
					let basis = Basis.new();
					let _bend = Points.subtract(bend, start);
					let _end = Points.subtract(end, start);
					if(Points.zero(_bend) || Points.zero(_end) || Points.parallel(_bend, _end)) {
					// a straight line
						//console.log(_bend);
						//console.log(_end);
						linespecial(ctx, start[0], start[1], bend[0], bend[1]);
						linespecial(ctx, bend[0], bend[1], end[0], end[1]);
					}
					else {
						basis[2] = Points.cross(_bend, _end);
						basis[2] = Points.invert(basis[2]);
						// z axis is something perpendicular to the plane all three
						// points are on (the opposite angle is equally valid. the
						// uninverted cross doesn't work how the math below expects,
						// so use the inverted version.)
						basis[0] = structuredClone(_bend);
						// x axis is the start to bend angle
						basis[1] = Points.cross(basis[0], basis[2]);
						// y axis is whatever is perpendicular to those two
						basis = [
							Points.normalized(basis[0]),
							Points.normalized(basis[1]),
							Points.normalized(basis[2])
						];
						//console.log(basis);
						let _basis = Basis.invert(basis);
						_bend = Basis.apply(_basis, _bend);
						_end = Basis.apply(_basis, _end);
						_bend = _bend.slice(0, 2);
						_end = _end.slice(0, 2);
						// applying the inverted basis should make bend have
						// positive x, zero y, and zero z, and end should be
						// down-right of that.
						let temp = get2dangle(...Points.subtract(_end, _bend));
						// we need the position of a circle that will have both
						// _bend and _end on it, and tangent the origin to _bend
						// line so that the circular arc flows seamlessly into
						// it.
						// - that means it has to be directly below _bend, and
						//   it has to be equally far from _bend and _end.
						// - that forms an isosceles triangle.
						// - point A is bend, B is end, C is the circle.
						// - known angles: none
						// - known sides: AB
						let r = Math.hypot(...Points.subtract(_end, _bend));
						// side AB
						if(temp >= Math.PI) {
							console.log("this shouldn't happen");
							// the basis should be designed so _end is never
							// below _bend.
						}
						else if(temp > Math.PI/2) {
							temp = Math.PI - temp;
						};
						if(temp === Math.PI/2) {
						// perfect right angles require one of those weird
						// exceptions. math is a pain in the ass.
							r /= 2;
						}
						else {
							temp = Math.PI/2 - temp;
							// - angle A = 90 - [angle between A to B and the x axis]
							// - angle B is the same
							// - angle C is 180 - (angle A + angle B)
							// - law of sine: BC/sin(A) = AC/sin(B) = etc
							// - r/Math.sin(temp) = AB/Math.sin(Math.PI - 2*temp)
							r = Math.sin(temp)*r/Math.sin(Math.PI - 2*temp);
							// that logic is designed for acute angles only, but
							// obtuse is mostly the same. draw a diagram or
							// something. everything just gets flipped x ways.
						};
						let circ = [_bend[0], _bend[1] + r];
						let angle = get2dangle(_end[0] - circ[0], _end[1] - circ[1]);
						angle = posmod(angle - 3*Math.PI/2, 2*Math.PI);
						temp = Math.ceil(fpt.settings.fineness*angle/(2*Math.PI));
						let prev = [bend[0], bend[1]];
						linespecial(ctx, start[0], start[1], bend[0], bend[1]);
						for(i2 = 1; i2 < temp; i2++) {
							let _angle = posmod(3*Math.PI/2 + angle*i2/temp, 2*Math.PI);
							let point = Points.add(circ, Points.multiply([Math.cos(_angle), Math.sin(_angle)], r));
							point = Points.add(start, Basis.apply(basis, [...point, 0]));
							linespecial(ctx, ...prev, point[0], point[1]);
							prev = [point[0], point[1]];
						}
						linespecial(ctx, ...prev, end[0], end[1]);
					}
				}
				//
				colorchange("mouth");
				let temp = [];
				for(i1 = 0; i1 < mouthcurve.length; i1++) {
					temp.push([
						(i0 ? -mouthcurve[i1][2] : mouthcurve[i1][0]),
						mouthcurve[i1][1]
					]);
				}
				_2dPoly.draw(ctx, temp, "stroke", null, null, "skiplaststroke");
				// nose, ear
				//
				ctx.translate(-cell[0]/2, -cell[1]/2);
				images[i0] = ctx.getImageData(0, 0, ...cell);
			}
			let barsize = fpt.settings.barwidth*numofbars + 1;
			let w = 2*cell[0] + barsize;
			let h = cell[1] + barsize;
			ctx.canvas.width = w;
			ctx.canvas.height = h;
			ctx.clearRect(0, 0, w, h);
			ctx.fillStyle = "black";
			ctx.fillRect(0, 0, w, h);
			ctx.putImageData(images[0], 0, 0);
			ctx.putImageData(images[1], w - cell[0], 0);
			//
			let handles = null;
			if(skip.includes("handlechange")) {
				handles = [];
			}
			else {
				fpt.handles = [];
				handles = fpt.handles;
			};
			for(i0 = 0; i0 < 3; i0++) {
				let obj = i0 === 0 ? x : i0 === 1 ? y : i0 === 2 ? z : null;
				let axis1 = i0 === 1 ? 1 : 0;
				// long axis
				let axis2 = posmod(axis1 + 1, 2);
				// short axis
				let start = (
					i0 === 0 ? [0, cell[1]] :
					i0 === 1 ? [cell[0], 0] :
					i0 === 2 ? [cell[0] + barsize, cell[1]] :
					null
				);
				start[axis1] += cell[axis1]/2;
				start[axis2] += Math.floor(fpt.settings.barwidth/2);
				// this way, markers start from the center
				let bar = numofbars - 1;
				for(i1 in obj) {
					if(obj.hasOwnProperty(i1)) {
						//ctx.fillStyle = "white";
						colorchange(i1);
						let line = Rect.new(...start, 1, 1);
						line["xy"[axis1]] -= cell[axis1]/2;
						line["xy"[axis2]] += fpt.settings.barwidth*bar;
						line["wh"[axis1]] = cell[axis1];
						ctx.fillRect(line.x, line.y, line.w, line.h);
						for(i2 in obj[i1]) {
							if(obj[i1].hasOwnProperty(i2)) {
								let num = (i0 === 2 ? -1 : 1)*obj[i1][i2];
								if(i2 === "dim") {
									let parent = (i0 === 2 ? -1 : 1)*fpt.parentcoor(i1, "xyz"[i0]);
									num = (
										i0 === 0 ?
										[
											-parent - num,
											-parent + num,
											parent - num,
											parent + num
										]
										:
										[
											parent - num,
											parent + num
										]
									);
								}
								else {
									num = i0 === 0 ? [-num, num] : [num];
								};
								// x markers get symmetrical duplicates, and dim
								// markers get symmetrical duplicates. there can
								// be one, two, or four numbers.
								for(i3 = 0; i3 < num.length; i3++) {
									let position = structuredClone(start);
									position[axis1] += num[i3];
									position[axis2] += fpt.settings.barwidth*bar;
									handles.push({
										x: position[0], y: position[1],
										prefix: i1,
										axis: "xyz"[i0],
										suffix: i2,
										invert: !(num.length%2) && !(i3%2),
									});
									if(num[i3] >= -cell[axis1]/2 && num[i3] < cell[axis1]/2) {
										let dim = fpt.settings.barwidth - (i2 === "start" || i2 === "end" || i2 === "dim" ? 1 : 3);
										let line = Rect.new(...position, 1, 1);
										line["wh"[axis2]] = dim;
										line["xy"[axis2]] -= Math.floor(dim/2);
										ctx.fillRect(line.x, line.y, line.w, line.h);
										//let temp = ctx.fillStyle;
										//ctx.fillStyle = "white";
										//ctx.fillRect(...position, 1, 1);
										//ctx.fillStyle = temp;
									};
								}
							}
						}
						bar--;
					}
				}
			}
			//
			if(!skip.includes("states")) {
			// save a state
				fpt.states.save();
			};
			if(!skip.includes("datatext")) {
			// rewrite the data text
				let obj = {};
				for(i0 = 0; i0 < 3; i0++) {
				// for every axis...
				// - in case of future changes to the parenting structure, i'd
				//   like it to save absolute coordinates.
				// - but unlike the x/y/z objects, i want it the order to be
				//   prefix, axis, suffix. easier to understand.
					let _obj = i0 === 0 ? x : i0 === 1 ? y : i0 === 2 ? z : null;
					let axis = "xyz"[i0];
					for(i1 in _obj) {
						if(_obj.hasOwnProperty(i1)) {
						// for every prefix...
							obj[i1] ??= {};
							obj[i1][axis] = {};
							for(i2 in _obj[i1]) {
								if(_obj[i1].hasOwnProperty(i2) && i2 !== "parent") {
								// for every suffix...
									obj[i1][axis][i2] = _obj[i1][i2];
									// copy the absolute coordinate.
								}
							}
						}
					}
				}
				let text = objtotext(obj);
				fpt.element("data").value = text;
				fpt.element("data").rows = text.split("\n").length;
			};
		},
		mousedown: function(e) {
			let click = clickxy(e, "fpt");
			let index = -1;
			let dist = fpt.settings.handleleeway + 1;
			//console.log("=");
			for(let i1 = 0; i1 < fpt.handles.length; i1++) {
				let handle = fpt.handles[i1];
				let axis1 = Number(handle.axis === "y");
				let axis2 = posmod(axis1 + 1, 2);
				// long axis, short axis
				let diff1 = Math.abs(Math.floor(click[axis1]) - handle["xy"[axis1]]);
				let diff2 = click[axis2] - handle["xy"[axis2]];
				if(
					diff1 <= fpt.settings.handleleeway
					&&
					diff2 >= -(fpt.settings.barwidth/2 - 1) && diff2 < fpt.settings.barwidth/2
					&&
					(diff1 < dist || (diff1 === dist && fpt.handles[index].suffix === "start"))
				) {
					//console.log([handle.prefix, handle.axis, handle.suffix].join("."));
					//console.log(diff1);
					//console.log(diff2);
					//console.log("-");
					index = i1;
					dist = diff1;
				};
			}
			if(index !== -1) {
				fpt.control.handle_index = index;
				fpt.control.downclick = structuredClone(click);
				let handle = fpt.control.handle;
				//console.log([handle.prefix, handle.axis, handle.suffix].join("."));
			};
		},
		mousemove: function(e, finish) {
			let handle = fpt.control.handle;
			if(!fpt.control.downclick || !handle) {
				return;
			};
			let click = clickxy(e, "fpt");
			let min = null;
			let max = null;
			if(handle.axis === "x") {
				min = 0;
				max = fpt.settings.cell_w;
			}
			else if(handle.axis === "y") {
				min = 0;
				max = fpt.settings.cell_h;
			}
			else if(handle.axis === "z") {
				max = fpt.ctx.canvas.width;
				min = max - fpt.settings.cell_w;
			};
			let axis1 = Number(handle.axis === "y");
			let move = click[axis1];
			if(move < min || move >= max) {
			// return if out of range
				//console.log("oopes");
				return;
			}
			move = Math.trunc(move - fpt.control.downclick[axis1]);
			if(handle.axis === "z") {
				move *= -1;
			};
			if(handle.invert) {
				move *= -1;
			};
			let ref = fpt.markers[ handle.prefix ][ handle.axis ];
			let before = ref[ handle.suffix ];
			let after = before + move;
			if(handle.suffix === "dim") {
				after = Math.abs(after);
			};
			ref[ handle.suffix ] = after;
			fpt.refresh(finish ? [] : ["handlechange", "states", "datatext"]);
			if(finish) {
				fpt.control.handle_index = -1;
				fpt.control.downclick = null;
				//console.log(fpt.handles);
			}
			else {
				ref[ handle.suffix ] = before;
			}
		},
		mouseup: function(e) {
			fpt.mousemove(e, true);
		},
	};
	fpt.initialize();
	//
	/*
	//*/
	//
	let tips = {
		"drawing app": [
			"the smear and spray brushes can be used to make a different texture if you tap repeatedly instead of making full strokes.",
			"there's two separate brush sizes, pen, and paint/eraser. for brushes like smear and spray, the range dots can appear in is as wide as the paint/eraser size, while the dots themselves are the pen size.",
			"WASD cycles through subtools, E switches tools, R and F change size.",
			"try combining dithers, that's always fun. (pythagorean has some interesting combinations.)",
			"if you change tools/subtools with a right click or while holding shift, you'll select the inverted version.",
			"inverses of pens are alternative versions. for example, the smear brush will create a more dense smear.",
			"inverses of paints are inversions of the dither pattern. that's why there's no dithers that cover more than 50% of pixels.",
			"inverses of erasers are... well i don't really make erasers, so.",
			"there's other menu actions that can be modified with this, too. for size up/down, it'll modify the other size. (paint size if you're using a pen, pen size if you're using paint/eraser) for color changes, it'll change the other color.",
			"pens sometimes incorporate the size of the paint/eraser. for example, spray/smear will distribute points around an area of that size, but pen size will determine how big the dots are.",
			"sunset pen - this draws ellipses that are as tall as the pen size and as wide as the paint size, with the ellipses at the end of the stroke being a little smaller.",
			"stroke pen - this draws a line as wide as the paint size in the erase color, with a pen-size outline around it in the draw color.",
			"if you have any cool pen or dither ideas, let me know. i'll credit you in here, i guess.",
			"when using the palette changing button, if one of your colors has no specified index, it'll use whatever index comes after the last one it used. (or zero, if it's the first color you inputted.)"
		],
		"sprite arranger": [
			"the most useful thing here is the import increment system. it's sorta hard to explain, but each pair of numbers is a grid arrangement. 1, 2, 3, 2 will import 1x2x3x2 blocks at once, and paste them as 1x2 pieces in a 3x2 formation. if you can figure out the right pattern, it'll save tons of time."
		],
	};
	//tips[tips.length] = `for any color change setting, use <a href="developer.mozilla.org/en-US/docs/Web/CSS/CSS_colors/Applying_color">this</a> as an overview of what formats you can use. basically: #rrggbb, #rrggbbaa, rgb(r, g, b), rgba(r, g, b, a), hsl(h, s, l), hsla(h, s, l, a), some others, and there's also a few named colors like "black", "white", "cornflowerblue", etc.`;
	//tips[tips.length] = `armature artist: `
	//tips[tips.length] = ``
	// making sure there's commas between each one is a pain so fuck it
	let tipsindex = -1;
	let hider_id_to_name = (id) => id.split("_").slice(1).join(" ");
	let hider_section = () => hider_id_to_name(document.getElementById("hider_select").value);
	function hider_init() {
		let i1 = 0;
		let divs = document.getElementsByName("hider");
		let html = ``;
		for(i1 = 0; i1 < divs.length; i1++) {
			divs[i1].hidden = true;
			let name = hider_id_to_name(divs[i1].id);
			if(!["face tool", "fighting game tester", "interactive animation"].includes(name)) {
				html += `<option value="` + divs[i1].id + `"` + (name === "armature artist" ? ` selected` : ``) + `>` + name + `</option>`;
			};
		}
		let ref = document.getElementById("hider_select");
		ref.innerHTML = html;
		ref.onchange = function() {
			let i1 = 0;
			let choice = document.getElementById("hider_select").value;
			let divs = document.getElementsByName("hider");
			for(i1 = 0; i1 < divs.length; i1++) {
				divs[i1].hidden = divs[i1].id !== choice;
			};
			let temp = hider_section();
			tipsindex = (
				tips.hasOwnProperty(temp) && tips[temp].length
				?
				Math.floor(Math.random()*tips[temp].length) - 1
				:
				-1
			);
			document.getElementById("tipsbutton").onclick();
		}
		ref.onchange();
	};
	document.write("<br>".repeat(2) + "<button id='tipsbutton'>tips</button><br><div id='tipstext'></div>");
	document.getElementById("tipsbutton").onclick = function() {
		let tipstext = document.getElementById("tipstext");
		let name = hider_section();
		if(tips.hasOwnProperty(name) && tips[name].length) {
			let array = tips[name];
			tipsindex++;
			if(tipsindex < 0 || tipsindex >= array.length) {
				tipsindex = 0;
			};
			tipstext.innerHTML = array[tipsindex];
		}
		else {
			tipstext.innerHTML = "&#160;";
		};
	};
	hider_init();
	//
	//
	//
	</script>
	</body>
</html>
