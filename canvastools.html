<!DOCTYPE html>
<html lang="en">
	<script src="script/barky_main.js"></script>
	<script src="script/site.js"></script>
	<script src="script/barky_strings.js"></script>
	<script src="script/barky_graphics.js"></script>
	<script>
		document.write(head);
		//document.write(header);
		document.write(nav + "\n<br>");
		document.querySelector("title").innerHTML = "canvas tools";
	</script>
	<head>
		<style>
			body {
				background: #fffae3;
				color: black;
			}
		</style>
	</head>
	<body>
	<script>
	function hsvtorgb(h, s, v, returncolor) {
	// returncolor: if true, it'll return an "rgb(x, y, z)" string instead of an
	// array of rgb values
	// - seems to work.
		let maxvalue = Math.round(255*v/100);
		let minvalue = Math.round(maxvalue*(1 - s/100));
		let color1 = Math.floor(((h + 60)%360)/120);
		// the r/g/b that has the highest value
		// the turning points for which is color1 should be the secondary
		// colors: yellow, cyan, and magenta
		// - 300 to 60 = red
		// - 60 to 180 = green
		// - 180 to 300 = blue
		let color2 = (color1 + (h%120 < 60 ? 1 : 2))%3;
		// the r/g/b that has the second highest value
		let secondary = Math.abs((h + 60)%120 - 120/2) * 1/(.5*120);
		// the fraction of the way color2 is between the highest and lowest
		// - i need to properly figure out the math for scaling a triangle wave
		//   to a particular wavelength/height sometime, this is always hard to
		//   wrap my head around
		// - or i could just do it right now... apparently. what the hell, the
		//   last time i tried this i couldn't figure it out at all.
		//   - Math.abs(x%w - w/2) * h/(.5*w)
		let rgb = [minvalue, minvalue, minvalue];
		rgb[color1] = maxvalue;
		rgb[color2] = Math.round(minvalue + secondary*(maxvalue - minvalue));
		/*
		console.log("minvalue: " + minvalue);
		console.log("maxvalue: " + maxvalue);
		console.log("color1: " + color1);
		console.log("color2: " + color2);
		console.log("secondary: " + secondary);
		//*/
		if(returncolor) {
			return "rgb(" + rgb.join(", ") + ")";
		}
		else {
			return rgb;
		};
		// value
		// 0: red		rg	0	01 <
		// 30: orange	rg	50	01 <
		// 60: yellow	gr	100	10
		// 90: lime		gr	50	10
		// 120: green	gb	0	12 <
		// 150: mint	gb	50	12 <
		// 180: cyan	bg	100	21
		// 210: azure	bg	50	21
		// 240: blue	br	0	20 <
		// 270: purple	br	50	20 <
		// 300: magenta	rb	100	02
		// 330: viored	rb	50	02
		// color2 is color1 + 2, or + 1 if h%120 < 60
	}
	function colormath(ctx, color0, color1, place) {
		let i1 = 0;
		place = Math.max(0, Math.min(place, 1));
		if(typeof color0 === "string") {
			color0 = Color.rgb(ctx, color0);
		}
		if(typeof color1 === "string") {
			color1 = Color.rgb(ctx, color1);
		}
		if((color0.length === 4) !== (color1.length === 4)) {
			color0[3] ??= 255;
			color1[3] ??= 255;
		};
		let newcolor = [];
		for(i1 = 0; i1 < color0.length; i1++) {
			newcolor[i1] = color1[i1]*place + color0[i1]*(1 - place);
			if(i1 === 3) {
				newcolor[i1] /= 255;
			};
		}
		return "rgb" + (newcolor.length === 3 ? "a" : "") + "(" + newcolor.join() + ")";
	};
	function gethsv(color, ctx) {
	// ctx is used to convert the color if it isn't in hexadecimal format. (for
	// whatever reason, there is no built-in function for this.)
		let rgb = Color.rgb(ctx, color).slice(0, 3);
		let sorted = structuredClone(rgb);
		sorted.sort((a, b) => a - b);
		let v = 100*sorted[2]/255;
		let s = (
			sorted[2] === 0
			// zero value means saturation can't be calculated without divide by
			// zero errors
			?
			0
			:
			100*(1 - sorted[0]/sorted[2])
		);
		if(sorted[0] === sorted[1]) {
		// primary color or neutral
			if(sorted[1] === sorted[2] || sorted[2] === rgb[0]) {
			// neutral or red
				return [0, s, v];
			}
			else if(sorted[2] === rgb[1]) {
			// green
				return [120, s, v];
			}
			else if(sorted[2] === rgb[2]) {
			// blue
				return [240, s, v];
			}
		}
		else if(sorted[1] === sorted[2]) {
		// secondary color
			if(sorted[2] === rgb[0] && sorted[2] === rgb[1]) {
			// yellow
				return [60, s, v];
			}
			else if(sorted[2] === rgb[1] && sorted[2] === rgb[2]) {
			// cyan
				return [180, s, v];
			}
			else if(sorted[2] === rgb[2] && sorted[2] === rgb[0]) {
			// magenta
				return [300, s, v];
			}
		}
		else {
			let i1 = 0;
			let primary = null;
			let secondary = null;
			for(i1 = 0; i1 < 3; i1++) {
				if(sorted[2] === rgb[i1]) {
					primary = i1;
				};
				if(sorted[1] === rgb[i1]) {
					secondary = i1;
				};
			}
			let sign = [null, 1, -1][posmod(secondary - primary, 3)];
			let ratio = (sorted[1] - sorted[0])/(sorted[2] - sorted[0]);
			// lower means it's closer to the primary hue, higher means it's
			// closer to the secondary hue
			let h = posmod(120*primary + 60*sign*ratio, 360);
			return [h, s, v];
		};
	}
	function colorgradient(colorA, colorB, value) {
	// 0 is colorA, 1 is colorB. both have to be in hexadecimal form
		if(value <= 0) {
			return colorA;
		}
		else if(value >= 1) {
			return colorA;
		}
		else {
			let newcolor = [
				(1 - value)*parseInt(colorA.slice(1, 3), 16) + value*parseInt(colorB.slice(1, 3), 16),
				(1 - value)*parseInt(colorA.slice(3, 5), 16) + value*parseInt(colorB.slice(3, 5), 16),
				(1 - value)*parseInt(colorA.slice(5, 7), 16) + value*parseInt(colorB.slice(5, 7), 16)
			];
			newcolor = [
				Math.min(Math.max(0, Math.floor(newcolor[0])), 255),
				Math.min(Math.max(0, Math.floor(newcolor[1])), 255),
				Math.min(Math.max(0, Math.floor(newcolor[2])), 255)
			];
			return "rgb(" + newcolor.join(",") + ")";
		}
	}
	class Shape2d {
	// this is more than just a way of defining a spline, it's also a way of
	// defining a shape that's a mix of splines, straight lines, and
	// quarter/eighth curves.
	// - fyi this used to be called "Spline" but i changed it before changing it
	//   becomes a pain in the ass. i'm pretty sure i got all references to it,
	//   but maybe i missed something in my notes or comments somewhere...
	//   - i searched "spline" to replace it, so i'm confident i got all the
	//     ones that matter. but still.
	// - TODO
	//   - give draw a "slice" parameter
	//   - make it possible to draw any kind of circular or elliptical arc
	//     - use that to make it possible to rotate the shape.
	//       - gather all non-elbow coordinates and indexes, run revolve on
	//         them, replace the numbers, and add a "rotate" parameter that
	//         everything responds to
		constructor(points, close, fineness) {
		// - points: an array of objects. the structure is:
		//   - x, y: coordinates
		//   - elbow: object property defining the connection from this point to
		//     the next. a spline, quarter-curve, or eighth-curve. NOTE if there
		//     is no elbow property, the connection will be straight.
		//     - if the elbow does not have a fineness property, the fineness
		//       parameter will be used. if that is absent, it will have a
		//       fineness of 16.
		//     - if it's "in" or "out", it's a quarter-circle.
		//       - if it's out and the line connecting the points has a
		//         negative slope, (visually, i mean... ignore that +y is
		//         down and -y is up in programming) it's a line that
		//         curves up then left
		//       - out and positive, left then down
		//       - in and negative, down then right
		//       - in and positive, right then up
		//     - if it's "u", "d", "l", or "r", it's an eighth curve
		//       - the letter indicates which cardinal direction it's
		//         mostly pointing towards. for a positive slope, "r"
		//         would mean right then up/right, "u" would mean up then
		//         up/right
		//   - the structure of Shape2d is exactly the same, except for:
		//     - path: all of the points a drawing of this shape should connect,
		//       in one big list.
		//       - it's an array of coordinate arrays. it's unstructured.
		//       - it's a getter, so make sure to copy it to a temp if you're
		//         gonna be referencing it a lot.
		//     - close: a boolean storing whether to connect the first and last
		//       point.
		//     - fineness: number used when a point does not have a fineness
		//       number of its own
		//     - rotation: object
		//       - angle: amount that get path rotates things by, measured in
		//         radians
		//       - x, y: fulcrum that get path rotates things by
		//   =
		//   - simplified:
		//     - x, y
		//     - elbow:
		//       - straight line if absent
		//       - x, y (spline)
		//       - fineness
		//       - direction (in/out: quarter curve, u/r/d/l: eighth curve)
		//     - and the properties the constructor adds are path, close, fineness
		// - alternatively, points can be an array or arrays. in that case,
		//   every other point will be treated as an elbow, and if a [2] number
		//   exists, that will be used as a fineness number.
		// - close: boolean. if true, the last point will be connected to the
		//   first.
		// - fineness: this will be saved into the object and used whenever for
		//   the number of lines per spline or curve if the elbow does not
		//   specify.
			if(noargumentscheck([points, close, fineness])) {
			// create an empty object that another object's contents can be
			// pasted into
				return;
			}
			let i1 = 0;
			let i2 = 0;
			if(!fineness) {
				fineness = points.hasOwnProperty("fineness") ? points.fineness : 16;
			};
			if((close ?? null) === null) {
				close = points.hasOwnProperty("close") ? points.close : false;
			};
			let inputtype = "";
			let length = Array.isArray(points) ? points.length : objarraylength(points);
			for(i1 = 0; i1 < length; i1++) {
				if(typeof points[i1] === "object") {
					if(Array.isArray(points[i1])) {
						if(!inputtype) {
							inputtype = "array";
						}
						else if(inputtype !== "array") {
							console.log("invalid input, points is a mix of arrays and objects");
							return;
						};
					}
					else {
						if(!inputtype) {
							inputtype = "object";
						}
						else if(inputtype !== "object") {
							console.log("invalid input, points is a mix of arrays and objects");
							return;
						};
					}
				}
				else {
					console.log("invalid input, at least one point isn't an array or object");
					return;
				};
			}
			let _points = {};
			if(inputtype === "array") {
				for (i1 = 0; i1 < length; i1 += 2) {
					_points[i1] = {
						x: points[i1][0],
						y: points[i1][1],
					};
					if(i1 + 1 < length) {
						_points[i1].elbow = {
							x: points[i1 + 1][0],
							y: points[i1 + 1][1],
						}
						if(points[i1 + 1][2] || points[i1 + 1][2] === 0) {
							_points[i1].elbow.fineness = points[i1][2];
						};
					};
				}
			}
			else if(inputtype === "object") {
				_points = structuredClone(points);
			}
			else if(compareobject(points, [])) {
				this.fineness = fineness;
				this.closed = !!closed;
				this.rotate = {
					angle: 0,
					x: 0,
					y: 0,
				};
				return;
			}
			else {
				console.log("invalid input, couldn't figure out if points are arrays or objects.");
				return;
			};
			if(Array.isArray(_points)) {
				_points = structuredClone(arraytoobject(_points))
			};
			_points.fineness = fineness;
			_points.closed = close;
			_points.rotate = {
				angle: 0,
				x: 0,
				y: 0,
			}
			for (i1 in _points) {
				this[i1] = structuredClone(_points[i1]);
			};
			//this = structuredClone(_points);
			//return _points;
			//
			// all properly formatted now.
			// - it's an object of objects
			// - fineness and elbow are present and defined
			// - closed is there
			// yes, that's all. path is a getter, meaning running it makes it
			// calculate where all the points should be.
		}
		get path() {
		// this should go without saying but, don't run this more than you have
		// to. save it to a temp or something.
			let i1 = 0;
			let i2 = 0;
			let path = [];
			//
			let prev = null;
			let next = null;
			//let intersections = [];
			let arraylength = objarraylength(this);
			let temp = [];
			let fineness = 0;
			const eighthdim = [1 - Math.cos(2*Math.PI/8), Math.sin(2*Math.PI/8)];
			// dimensions of an arc from 0 to 45
			for (i1 = 0; i1 < arraylength; i1++) {
				path[path.length] = [this[i1].x, this[i1].y];
				if(this.closed) {
					prev = structuredClone(this[posmod(i1, arraylength)]);
					next = structuredClone(this[posmod(i1 + 1, arraylength)]);
				}
				else {
					prev = structuredClone(this[i1]);
					next = structuredClone(this[i1 + 1]);
				};
				prev ??= null;
				next ??= null;
				// right now it's prev/next point, singular...
				if(
					!this[i1].hasOwnProperty("elbow")
					||
					(
						prev !== null
						&&
						next !== null
						&&
						this[i1].elbow.hasOwnProperty("direction")
						&&
						(
							Math.abs(next.x - prev.x) === 0
							||
							Math.abs(next.y - prev.y) === 0
						)
					)
					||
					(
						i1 === arraylength - 1
						&&
						!this.closed
					)
				) {
				// skip all the elbow code.
				// - if it's a quarter or eighth curve and either coordinate
				//   distance is zero, it'll screw up the logic, and it'll just
				//   make a straight line anyway.
				// - if it's not closed and this is the last point, there's no
				//   next point to connect to.
				}
				else {
					fineness = (this[i1].elbow.hasOwnProperty("fineness") ? this[i1].elbow.fineness : this.fineness);
					// use the overall fineness if none exists for this point.
					if(this[i1].elbow.hasOwnProperty("x") && this[i1].elbow.hasOwnProperty("y")) {
					// spline
					// - there are a lot of ways things can go tits up with a
					//   spline, because of the mathematical limits of
					//   fourpointintersect.
					//   - if the elbow falls on the same line as the previous
					//     and next point, lines will count as parallel
					//   - if the previous and next point are on the same
					//     coordinates, same thing.
					//   - if the elbow is directly on one or both, you get
					//     the point error.
					//   - however, in all of those cases, it still needs to
					//     draw something. picture a spline's angle narrowing
					//     and narrowing until it closes. it doesn't make
					//     sense for it to draw a line from prev to the
					//     elbow to the next, and it doesn't make sense
					//     for it to skip the elbow either. my aim is to use
					//     the Shape2d class in an interactive gui, and either
					//     of those would make it look glitchy and awful.
					//     oh fuck it, for now i'm just gonna use
					//     Math.SQRT1_2. that's close enough. i don't feel
					//     like figuring out what different fineness levels
					//     should translate to. fuck you
					//     - TODO
						temp = [structuredClone(prev), structuredClone(next)];
						prev = [];
						// equidistant points from the previous point to the
						// elbow (including the previous point, but not the
						// elbow)
						next = [];
						// equidistant points from the elbow to the next
						// point
						let intersections = [];
						temp[2] = fourpointintersect(temp[0].x, temp[0].y, this[i1].elbow.x, this[i1].elbow.y, this[i1].elbow.x, this[i1].elbow.y, temp[1].x, temp[1].y, true);
						//
						if(temp[2] === "point") {
							// don't add anything. the elbow is either on the
							// previous point, the next point, or both.
						}
						else if(temp[2] === "parallel") {
							if(temp[0].x === temp[1].x && temp[0].y === temp[1].y) {
								// if the previous and next point are on the same
								// coordinates.
								let temp2 = [
								temp[0].x*Math.SQRT1_2 + this[i1].elbow.x*(1 - Math.SQRT1_2),
								temp[0].y*Math.SQRT1_2 + this[i1].elbow.y*(1 - Math.SQRT1_2)
								];
								path[path.length] = structuredClone(temp2);
								// technically this should change a little
								// bit based on fineness but. fuck yuou
							}
							else {
								// the elbow falls on the same line as the previous
								// and next point
								let temp2 = null;
								if(Math.hypot(temp[1].x - this[i1].elbow.x, temp[1].y - this[i1].elbow.y) < Math.hypot(temp[0].x - this[i1].elbow.x, temp[0].y - this[i1].elbow.y)) {
									temp2 = [temp[1].x, temp[1].y];
								}
								else {
									temp2 = [temp[0].x, temp[0].y];
								};
								// use whichever point is closer.
								temp2 = [
								temp2[0]*Math.SQRT1_2 + this[i1].elbow.x*(1 - Math.SQRT1_2),
								temp2[1]*Math.SQRT1_2 + this[i1].elbow.y*(1 - Math.SQRT1_2)
								];
								path[path.length] = structuredClone(temp2);
							};
						}
						else {
							for (i2 = 0; i2 < fineness; i2++) {
								prev[i2] = [
								temp[0].x*(fineness - i2) + this[i1].elbow.x*i2,
								temp[0].y*(fineness - i2) + this[i1].elbow.y*i2
								];
								prev[i2][0] /= fineness;
								prev[i2][1] /= fineness;
								//
								next[i2] = [
								this[i1].elbow.x*(fineness - (i2 + 1)) + temp[1].x*(i2 + 1),
								this[i1].elbow.y*(fineness - (i2 + 1)) + temp[1].y*(i2 + 1),
								];
								next[i2][0] /= fineness;
								next[i2][1] /= fineness;
								if(i2 > 0) {
									intersections[i2 - 1] = fourpointintersect(
										prev[i2][0], prev[i2][1],
										next[i2][0], next[i2][1],
										prev[i2 - 1][0], prev[i2 - 1][1],
										next[i2 - 1][0], next[i2 - 1][1]
									);
								};
							}
							path = path.concat(intersections);
						};
					}
					else if(this[i1].elbow.hasOwnProperty("direction")) {
						let center = [null, null];
						let radii = [null, null];
						let arcstart = null;
						let ccw = false;
						// this stores which angle the previous point is
						// and which the next point is.
						// - ccw stands for counterclockwise
						if(["in", "out"].includes(this[i1].elbow.direction)) {
						// quarter
							radii = [Math.abs(next.x - prev.x), Math.abs(next.y - prev.y)];
							let relation = [Math.sign(next.x - prev.x), Math.sign(next.y - prev.y)];
							if(![-1, 1].includes(relation[0]) || ![-1, 1].includes(relation[1])) {
								console.log("this shouldn't happen");
							};
							relation = "u d"[(relation[1] + 1)] + "l r"[(relation[0] + 1)];
							let section = ["dl", "ul", "ur", "dr"].indexOf(relation);
							// if you're confused by the order here, relation is
							// where the next point is, but section is which
							// quarter of the circle you're using.
							let invert = invertboolean(this[i1].elbow.direction === "in", section < 2);
							// invert is whether, if this was a quarter on a
							// full ellipse, the in/out would make it concave
							// instead.
							if(invert) {
								section = (section + 2)%4;
							}
							center = invertboolean(section%2 === 0, invert) ? [next.x, prev.y] : [prev.x, next.y];
							for(i2 = (invert ? fineness - 1 : 1); 0 < i2 && i2 < fineness; i2 += (invert ? -1 : 1)) {
								let angle = (section + i2/fineness)%4;
								angle = 2*Math.PI*angle/4;
								let temp = [
									Math.cos(angle),
									Math.sin(angle)
								];
								path[path.length] = [
									center[0] + radii[0]*temp[0],
									center[1] + radii[1]*temp[1]
								];
							};
						}
						else if(["u", "d", "l", "r"].includes(this[i1].elbow.direction)) {
						// eighth
							radii = [];
							center = [];
							if(this[i1].elbow.direction === "u" || this[i1].elbow.direction === "d") {
								// y is the longer dimension, at least in the
								// eighthdim version
								radii[0] = Math.abs(next.x - prev.x)/eighthdim[0];
								//if eighthdim[0] = xdist/radius
								// eighthdim[0]*xradius = xdist
								// xradius = xdist/eighthdim[0]
								radii[1] = radii[0]*Math.abs(next.y - prev.y)*eighthdim[0]/(Math.abs(next.x - prev.x)*eighthdim[1]);
								//if yradius/xradius = (ydist/xdist)/(eighthdim[1]/eighthdim[0])
								// yradius = xradius*(ydist/xdist)/(eighthdim[1]/eighthdim[0])
								// simplified, that's
								// yradius = xradius*ydist*eighthdim[0]/(xdist*eighthdim[1])
							}
							else if(this[i1].elbow.direction === "l" || this[i1].elbow.direction === "r") {
								// remember, eighthdim[0] is the shorter dimension, so that should be y
								radii[1] = Math.abs(next.y - prev.y)/eighthdim[0];
								//if eighthdim[0] = ydist/radius
								// eighthdim[0]*yradius = ydist
								// yradius = ydist/eighthdim[0]
								radii[0] = radii[1]*Math.abs(next.x - prev.x)*eighthdim[0]/(Math.abs(next.y - prev.y)*eighthdim[1]);
								//if yradius/xradius = (ydist/xdist)/(eighthdim[0]/eighthdim[1])
								// xradius/yradius = (eighthdim[0]/eighthdim[1])/(ydist/xdist)
								// xradius = yradius*(eighthdim[0]/eighthdim[1])/(ydist/xdist)
								// simplified, that's
								// xradius = yradius*xdist*eighthdim[0]/(ydist*eighthdim[1])
							}
							else {
								console.log("this shouldn't happen");
							};
							let clockplace = [];
							const directions = ["u", "r", "d", "l"];
							clockplace[0] = directions.indexOf(this[i1].elbow.direction);
							clockplace[0] = (4 + 2*clockplace[0])%8;
							// 4 6 0 2
							clockplace[1] = (clockplace[0] + 3)%8;
							// 7 1 3 5
							let relation = [Math.sign(next.x - prev.x), Math.sign(next.y - prev.y)];
							switch (relation[0]) {
								case -1:
								relation[0] = "l";
								break;
								case 1:
								relation[0] = "r";
								break;
								default:
								console.log("this shouldn't happen");
								break;
							};
							switch (relation[1]) {
								case -1:
								relation[1] = "u";
								break;
								case 1:
								relation[1] = "d";
								break;
								default:
								console.log("this shouldn't happen");
								break;
							};
							relation = relation[1] + relation[0];
							ccw = relation.includes( directions[( directions.indexOf(this[i1].elbow.direction) + 3 )%directions.length] );
							if(invertboolean(relation.includes(directions[( directions.indexOf(this[i1].elbow.direction) + 2 )%directions.length]), ccw)) {
								clockplace = clockplace[1];
								// go with the choice clockwise of the
								// three-sector gap
							}
							else {
								clockplace = clockplace[0];
								// go with the choice counterclockwise of the
								// three-sector gap
							};
							arcstart = (clockplace + (ccw ? 1 : 0))%8;
							center = structuredClone(invertboolean(clockplace%2 === 1, ccw) ? next : prev);
							// choose the previous or next point this way
							clockplace = (clockplace + 1)%8;
							clockplace = Math.floor(clockplace/2);
							// clockplace has served its purpose
							switch (clockplace) {
								case 0:
								center = [center.x - radii[0], center.y];
								//console.log("subtract x");
								break;
								case 1:
								center = [center.x, center.y - radii[1]];
								//console.log("subtract y");
								break;
								case 2:
								center = [center.x + radii[0], center.y];
								//console.log("add x");
								break;
								case 3:
								center = [center.x, center.y + radii[1]];
								//console.log("add y");
								break;
								default:
								console.log("this shouldn't happen");
								break;
							};
							let angle = 0;
							//console.log(JSON.stringify({relation,arcstart,ccw,center,radii}));
							for(i2 = 1; i2 < fineness; i2++) {
								angle = 2*Math.PI*(arcstart + (ccw ? -1 : 1)*i2/fineness)/8;
								path[path.length] = [
								center[0] + radii[0]*Math.cos(angle),
								center[1] + radii[1]*Math.sin(angle)
								];
							};
							// the shit i put up with, i swear to god.
							// - this may be squeaky clean but good god was
							//   it a pain in the ass. i had to take out
							//   scratch paper and navigate stupid mental
							//   pretzel knots for literally two hours
							//   - "clockplace" comes from me drawing a
							//     circle, dividing it into eighths, and
							//     writing which relation/direction
							//     combination should be associated with
							//     which (treating the area outside the
							//     sector as counterclockwise)
							// - it probably could've taken less time if i
							//   just copied down all the data that helped
							//   me figure out to conditionals for each of
							//   the 16 possible relation/direction
							//   combinations
							// - but that'd be prone to mistakes and any
							//   mistake would be utter hell to identify and
							//   fix
							// - i'm gonna rewrite the quarter section
							//   around this
							//
							// this doesn't work yet, but it's almost there, i
							// think.
							// - might have to revisit the diagrams that i wrote
							//   on paper, like a caveman
							// -
						}
						else {
							console.log("invalid .direction.");
						};
					}
					else {
						console.log("invalid elbow point.");
					};
				};
			} // i1
			if(this.rotate.angle) {
				for(i1 = 0; i1 < path.length; i1++) {
					path[i1][2] = 0;
					path[i1] = revolve(this.rotate.angle, path[i1], [this.rotate.x, this.rotate.y, 0], "xy");
					path[i1] = [path[i1][0], path[i1][1]];
				}
			};
			return path;
		}
		draw(ctx, x, y, weight, fill, path) {
		// path: if specified, it'll use this instead. good for keeping it from
		// calculating path too many times.
			if(!path) {
				path = structuredClone(this.path);
			};
			// define this before because if i use this.path directly, it might
			// be running through that whole function every time it's brought up
			_2dPoly.draw(ctx, path, (fill ? "fill" : "stroke"), weight, [x, y], (this.closed ? false : "skiplaststroke"));
		}
		pathfraction(fraction) {
		// 0 is the beginning of the path, 1 is the end. (or beginning
		// again, if it's closed.) returns the x and y of that point.
			let i1 = 0;
			let i2 = 0;
			let path = structuredClone(this.path);
			if(this.closed) {
				fraction = posmod(fraction, 1);
			}
			else {
				fraction = Math.max(0, fraction);
				fraction = Math.min(1, fraction);
			};
			if(fraction === 0) {
				return path[0];
			}
			else if(fraction === 1) {
				return path[path.length - 1];
			};
			let dist = [];
			let total = 0;
			for (i1 = 0; i1 < path.length - 1; i1++) {
				dist[i1] = Math.hypot(path[i1 + 1][0] - path[i1][0], path[i1 + 1][1] - path[i1][1]);
				total += dist[i1];
			}
			if(this.closed) {
				dist[path.length - 1] = Math.hypot(path[0][0] - path[path.length - 1][0], path[0][1] - path[path.length - 1][1]);
				total += dist[path.length - 1];
			};
			fraction *= total;
			for (i1 = 0; i1 < dist.length; i1++) {
				if(fraction >= dist[i1]) {
					fraction -= dist[i1];
				}
				else {
					fraction /= dist[i1];
					return [
						fraction*path[(i1 + 1)%dist.length][0] + (1 - fraction)*path[i1][0],
						fraction*path[(i1 + 1)%dist.length][1] + (1 - fraction)*path[i1][1]
					];
				};
			}
		}
		get length() {
			let i1 = 0;
			let path = structuredClone(this.path);
			let total = 0;
			for (i1 = 0; i1 < path.length - 1; i1++) {
				total += Math.hypot(path[i1 + 1][0] - path[i1][0], path[i1 + 1][1] - path[i1][1]);
			}
			if(this.closed) {
				total += Math.hypot(path[0][0] - path[path.length - 1][0], path[0][1] - path[path.length - 1][1]);
			};
			return total;
		}
		tangent(relativeto, inorout) {
		// returns a slice of the .path between the two points that the
		// relativeto point tangents.
		// - relativeto: coordinates of the point you're tangenting to
		//   - obviously, it will not work properly if this is inside the path. my best
		//     guess of what would happen is that unless inorout is in, it will draw
		//     nothing except maybe a single side in the opposite direction of the
		//     closest path point, and if it's out it will draw everything except that
			let i1 = 0;
			let i2 = 0;
			relativeto ??= [0, 0];
			//increment ??= 1;
			inorout ??= "out";
			let path = structuredClone(this.path);
			let length = this.length;
			let offset = [];
			let closestindex = null;
			let closestdist = null;
			let temp = 0;
			for (i1 = 0; i1 < path.length; i1++) {
				temp = Math.hypot(path[i1][0] - relativeto[0], path[i1][1] - relativeto[1]);
				if(closestindex === null || temp > closestdist) {
					closestindex = i1;
					closestdist = temp;
				};
				/*
				if(increment && (this.closed || i1 === path.length - 1)) {
					offset[i1] = (i1 === 0 ? 0 : offset[i1 - 1]) + Math.hypot(path[(i1 + 1)%path.length][0] - path[i1][0], path[(i1 + 1)%path.length][1] - path[i1][1]);
					offset[i1] %= increment;
				};
				//*/
			}
			// offset 0 is the length from point 0 of the path to point 1. offset 1 is
			// point 0 to 2, 3 is point 0 to 3. etcetera
			// - they're remaindered by increment too
			// - why? because it bothers me for all the increment checks to start right
			//   at the relevant point, when if i actually ran a pathfraction thing for
			//   each position, it'd start at point 0.
			let closestrelangle = get2dangle(path[closestindex][0] - relativeto[0], path[closestindex][1] - relativeto[1], true);
			// this is the angle the closest path point has relative to the relativeto
			// point, it'll be used later...
			let lowestangle = null;
			let startindex = null;
			let highestangle = null;
			let endindex = null;
			for (i1 = 0; i1 < path.length; i1++) {
				temp = get2dangle(path[i1][0] - relativeto[0], path[i1][1] - relativeto[1], true);
				temp = posmod(temp, 2*Math.PI) - Math.PI;
				// now it should be an angle number between -1/2 a circumference and 1/2
				// a circumference
				if(startindex === null || temp < lowestangle) {
					startindex = i1;
					lowestangle = temp;
				};
				if(endindex === null || temp > highestangle) {
					endindex = i1;
					highestangle = temp;
				};
			}
			startindex = [startindex, endindex];
			endindex = Math.max(...startindex);
			startindex = Math.min(...startindex);
			// startindex and end index are the most clockwise and counterclockwise
			// indexes.
			//
			// insideavg
			// outsideavg
			let innerrecord = null;
			let outerrecord = null;
			// that is, record for furthest from the relativeto point.
			temp = 0;
			for (i1 = 0; i1 < path.length; i1++) {
				temp = Math.hypot(path[i1][0] - relativeto[0], path[i1][1] - relativeto[1]);
				if(i1 > startindex && i1 < endindex) {
					if(innerrecord === null || temp > innerrecord) {
						innerrecord = temp;
					};
				};
				if(i1 < startindex || i1 > endindex) {
					if(outerrecord === null || temp > outerrecord) {
						outerrecord = temp;
					};
				};
			}
			temp = [
				(path[startindex][0] + path[endindex][0])/2,
				(path[startindex][1] + path[endindex][1])/2
			];
			temp = Math.hypot(temp[0] - relativeto[0], temp[1] - relativeto[1]);
			innerrecord ??= temp;
			outerrecord ??= temp;
			// if there were no points between them, use the halfway point
			// -
			// innerrecord and outerrecord are the records for highest distance
			// from the relativeto, for the points between the start and end
			// index and outside them, respectively. NOTE this is NOT the points
			// that are on the inside and outside! this is just something very
			// stupid i have to do to find that.
			temp = invertboolean(inorout === "in", innerrecord > outerrecord);
			// a boolean for if i should retain the indexes between instead of the
			// indexes outside.
			// - if the average between distance is greater than the average outside
			//   distance, then the groups don't represent in and out points
			//   respectively, but the opposites of those.
			if(temp) {
				path = path.slice(startindex, endindex + 1);
			}
			else {
				path = path.slice(endindex).concat(path.slice(0, startindex + 1));
			};
			return path;
		}
		modcoordinates(operations) {
		/*
		modcoordinates({
			multiply: ,
			add: ,
			math: "floor",
		})
		//*/
		// runs an applyoperations on the shape2d and also inverts directions
		// and shit properly.
			let i1 = 0;
			let i2 = 0;
			let arraylength = objarraylength(this);
			let olddiff = [];
			// stores the positivity/negativity of the coordinate differences
			// from point to point.
			// - point 0 stores whether point 1 is higher or lower, to the left
			//   or the right.
			// - then i'll do another loop after applyoperations is done, so i
			//   can check which distances have been inverted.
			// - i need to do all this convoluted bullshit for it to invert
			//   quarter/eighth curves properly.
			// if the x difference from the previous point has been inverted,
			// invert the previous elbow.
			for (i1 = 0; i1 < arraylength - 1; i1++) {
				olddiff[i1] = [
					Math.sign(this[i1 + 1].x - this[i1].x),
					Math.sign(this[i1 + 1].y - this[i1].y)
				];
			}
			if(this.closed) {
				olddiff[arraylength - 1] = [
					Math.sign(this[0].x - this[arraylength - 1].x),
					Math.sign(this[0].y - this[arraylength - 1].y)
				];
			}
			for (i1 = 0; i1 < arraylength; i1++) {
				this[i1].x = applyoperations(this[i1].x, operations, 0);
				this[i1].y = applyoperations(this[i1].y, operations, 1);
				if(this[i1].hasOwnProperty("elbow")) {
					if(this[i1].elbow.hasOwnProperty("x")) {
						this[i1].elbow.x = applyoperations(this[i1].elbow.x, operations, 0);
					};
					if(this[i1].elbow.hasOwnProperty("y")) {
						this[i1].elbow.y = applyoperations(this[i1].elbow.y, operations, 1);
					};
				};
			}
			let newdiff = [];
			// this is just one point, because i don't need anything more.
			let temp = "";
			function invertdirection(direction, axis) {
				let temp = [];
				function arraycycle(array, item, shiftby) {
				// might make this universal too.
				// - especially since it's super useful in arrays for circular
				//   things. it's always a pain in the ass to connect the last
				//   point to the first.
					if(array.includes(item)) {
						return array[ posmod(array.indexOf(item) + shiftby, array.length) ];
					}
					else {
						return item;
					};
				}
				temp = ["l", "r"];
				if(axis.includes("x") && temp.includes(direction)) {
					direction = arraycycle(temp, direction, 1);
				};
				temp = ["u", "d"];
				if(axis.includes("y") && temp.includes(direction)) {
					direction = arraycycle(temp, direction, 1);
				};
				temp = ["in", "out"];
				if(axis.includes("y") && temp.includes(direction)) {
					direction = arraycycle(temp, direction, 1);
				};
				return direction;
			};
			for (i1 = 0; i1 < arraylength + (this.closed ? 0 : -1); i1++) {
				if(this[i1].hasOwnProperty("elbow") && this[i1].elbow.hasOwnProperty("direction")) {
					if(i1 === arraylength - 1) {
						newdiff = [
							Math.sign(this[0].x - this[i1].x),
							Math.sign(this[0].y - this[i1].y)
						];
					}
					else {
						newdiff = [
							Math.sign(this[i1 + 1].x - this[i1].x),
							Math.sign(this[i1 + 1].y - this[i1].y)
						];
					};
					temp = "";
					if([-1, 1].includes(newdiff[0]) && newdiff[0] === -1*olddiff[i1][0]) {
						temp += "x";
					};
					if([-1, 1].includes(newdiff[1]) && newdiff[1] === -1*olddiff[i1][1]) {
						temp += "y";
					};
					this[i1].elbow.direction = invertdirection(this[i1].elbow.direction, temp);
				}
			}
		}
		newpoint(index) {
		// places a new point after the index specified.
		// - if the index is the last point index and it isn't a closed shape,
		//   this will be an extension, a duplicate of the connection between
		//   the last two points.
		// - if not, it'll be a subdivision of the connection between this point
		//   and the next.
			let i1 = 0;
			let i2 = 0;
			let arraylength = objarraylength(this);
			if(!index) {
				index = arraylength - 1;
			}
			if(!Number.isInteger(index) || index >= arraylength) {
				console.log("invalid index");
			};
			function objsplice(object, index, deletenumber, insert) {
			// object version of array.splice. this is gonna be balls and ass to
			// test, won't it
				let i1 = 0;
				let i2 = 0;
				let shiftby = -(deletenumber ?? 0) + (insert || insert === 0 ? 1 : 0);
				// now it means, "how many places to shift the indexes after by"
				let arraylength = objarraylength(object);
				if(shiftby > 0) {
					for (i1 = arraylength - 1; i1 >= index; i1++) {
						object[i1 + shiftby] = structuredClone(object[i1]);
					}
				}
				else if(shiftby < 0) {
					for (i1 = index; i1 < arraylength; i1++) {
						object[i1] = structuredClone(object[i1 - shiftby]);
					}
					for(i1 = arraylength; i1 - arraylength < -shiftby; i1++) {
						delete object[i1];
					}
				}
				if(insert || insert === 0) {
					object[index] = structuredClone(insert);
				};
			}
			objsplice(this, index + 1, 0, {});
			extend = index === arraylength - 1 && !this.closed;
			arraylength = objarraylength(this);
			if(arraylength === 2) {
				console.log("newpoint shouldn't be used if there's only one point so far.");
				this[index + 1] = {
					x: this[index].x + 10,
					y: this[index].y + 10,
				};
				if(this[index].hasOwnProperty("elbow")) {
					this[index + 1].elbow = structuredClone(this[index].elbow);
				}
				return;
			};
			let nextindex = (index + 2)%arraylength;
			if(extend) {
				this[index + 1].x = this[index].x + (this[index].x - this[index - 1].x);
				this[index + 1].y = this[index].y + (this[index].y - this[index - 1].y);
			}
			else {
				this[index + 1].x = (this[index].x + this[nextindex].x)/2;
				this[index + 1].y = (this[index].y + this[nextindex].y)/2;
			}
			if(this[index].hasOwnProperty("elbow")) {
				this[index + 1].elbow = structuredClone(this[index].elbow);
				if(this[index].elbow.hasOwnProperty("x") && this[index].elbow.hasOwnProperty("y")) {
					this[index + 1].elbow.x = this[index + 1].x + (this[index].elbow.x - this[index].x)/(extend ? 1 : 2);
					this[index + 1].elbow.y = this[index + 1].y + (this[index].elbow.y - this[index].y)/(extend ? 1 : 2);
				}
			}
		}
		//Shape2d.build(type, dimensions, fineness, points, offset, etc)
		static build(type, dimensions, fineness, points, offset, etc) {
		// an alternate constructor, similar to build3dshape. instead of using
		// coordinates, you specify a type of shape.
		// - type:
		//   - "circle": makes an ellipsoid using quarter-curves.
		//   - "rect":
		//   - "regular": makes a regular polygon, the number of sides matching
		//     the fineness number.
		//   - "star": makes a star with as many points as the fineness number.
		//     (or 5, by default.)
		//     - if etc contains a number property called "constant", it will
		//       use that to determine where the armpits are instead of where
		//       lines intersect. 0 is at the center, 1 is at the same distance
		//       as the points.
		// - dimensions: one number, or an array of a width and height.
		// - points: used for star and regular, determines how many points or
		//   sides, respectively
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			if(["ellipse", "ellipsoid", "circ"].includes(type)) {
				type = "circle";
			};
			if(["box", "square", "rectangle"].includes(type)) {
				type = "rect";
			};
			if(["polygon"].includes(type)) {
				type = "regular";
			};
			//if([""].includes(type)) {
			//	type = "";
			//};
			let w = 1;
			let h = 1;
			if(typeof dimensions === "number") {
				w = dimensions;
				h = dimensions;
			}
			else if(Array.isArray(dimensions) && dimensions.length >= 2) {
				w = dimensions[0];
				h = dimensions[1];
			}
			else {
				console.log("invalid dimensions.");
			};
			if(!points) {
				points = 5;
			};
			if(!Array.isArray(offset) || offset.length < 2) {
				offset = [0, 0];
			};
			let shape = [];
			switch (type) {
				case "circle":
					for (i1 = 0; i1 < 4; i1++) {
						shape[i1] = {
							x: [ w/2,    0, -w/2,    0][i1],
							y: [   0,  h/2,    0, -h/2][i1],
							elbow: {
								direction: ["in", "in", "out", "out"][i1],
							},
						};
					}
				break;
				case "rect":
					for (i1 = 0; i1 < 4; i1++) {
						shape[i1] = {
							x: [ w/2, -w/2, -w/2,  w/2][i1],
							y: [ h/2,  h/2, -h/2, -h/2][i1],
						};
					}
				break;
				case "regular":
					for (i1 = 0; i1 < points; i1++) {
						shape[i1] = {
							x: Math.cos(2*Math.PI*i1/points)*w/2,
							y: Math.sin(2*Math.PI*i1/points)*h/2,
						};
					}
				break;
				case "star":
					if(etc && etc.hasOwnProperty("constant") && typeof etc.constant === "number") {
						for (i1 = 0; i1 < points; i1++) {
							shape[2*i1] = {
								x: Math.cos(2*Math.PI*i1/points)*w/2,
								y: Math.sin(2*Math.PI*i1/points)*h/2,
							};
							shape[2*i1 + 1] = {
								x: Math.cos(2*Math.PI*(i1 + .5)/points)*etc.constant*w/2,
								y: Math.sin(2*Math.PI*(i1 + .5)/points)*etc.constant*h/2,
							};
						}
					}
					else {
						let pits = [];
						for (i1 = 0; i1 < points; i1++) {
							shape[i1] = {
								x: Math.cos(2*Math.PI*i1/points)*w/2,
								y: Math.sin(2*Math.PI*i1/points)*h/2,
							};
						}
						let places = [];
						places[0] = Math.ceil(points/2) - 1;
						places[1] = points + 1 - places[0];
						// this should work for 5, 6, 7, 8.
						for (i1 = 0; i1 < points; i1++) {
							pits[i1] = fourpointintersect(
								shape[i1].x,
								shape[i1].y,
								shape[(i1 + places[0])%points].x,
								shape[(i1 + places[0])%points].y,
								shape[(i1 + 1)%points].x,
								shape[(i1 + 1)%points].y,
								shape[(i1 + places[1])%points].x,
								shape[(i1 + places[1])%points].y,
							true);
							pits[i1] = {
								x: pits[i1][0],
								y: pits[i1][1],
							};
						}
						for (i1 = 0; i1 < points; i1++) {
							shape.splice(2*i1 + 1, 0, structuredClone(pits[i1]));
						};
					};
				break;
				default:
					console.log("invalid type.");
				break;
			};
			for (i1 = 0; i1 < shape.length; i1++) {
				shape[i1].x += offset[0];
				shape[i1].y += offset[1];
				if(shape[i1].hasOwnProperty("elbow") && shape[i1].elbow.hasOwnProperty("x") && shape[i1].elbow.hasOwnProperty("y")) {
					shape[i1].elbow.x += offset[0];
					shape[i1].elbow.y += offset[1];
				}
			}
			return new Shape2d(shape, true, fineness);
		}
	};
	function savectxsettings(ctx) {
	// returns an object with all the simple data of a ctx, so it can be
	// restored later.
	// - fillStyle, strokeStyle, font, etc.
		let i1 = "";
		let ctxsettings = {};
		for (i1 in ctx) {
			if (["string", "number", "boolean", "bigint"].includes(typeof ctx[i1]) || Array.isArray(ctx[i1])) {
				ctxsettings[i1] = structuredClone(ctx[i1]);
			}
		}
		return ctxsettings;
	}
	function restorectxsettings(ctx, ctxsettings) {
		let i1 = "";
		for (i1 in ctxsettings) {
			if (["string", "number", "boolean", "bigint"].includes(typeof ctxsettings[i1]) || Array.isArray(ctxsettings[i1])) {
				ctx[i1] = structuredClone(ctxsettings[i1]);
			}
		}
	}
	function easingplacement(value1, value2, time, easeinorout, easingtype, overshoot/*[distance, time, easeinorout, easingtype]*/) {
	// returns the coordinates the specified movement should produce.
	// - time: expressed as a fraction or decimal (for example, if a
	//   movement begins on frame 6 and ends on frame 8, on frame 7 you
	//   should enter 1/2)
	// - easing type:
	//   - "linear"
	//   - "circ"
	//     - or circular, or circle
	//   - "sine"
	//     - or sin
	// - in or out: ease "in", ease "out", ease "in/out", or ease "out/in"
	// - overshoot: an array with distance, time, easeinorout, and
	//   easingtype, in that order
	//   - this only applies to the retraction motion
	//   - overshoot distance (written as a fraction of the original
	//     distance) (this is multiplicative. if you want it to go an extra
	//     20%, write 1.2, not .2.)
	//   - at what point in the animation it should transition from the
	//     overshoot to the retraction (written as a fraction, like time)
	//   - the easeinorout to use
	//   - the easingtype to use
	// - defaults:
	//   - linear easing
	//   - ease in
	//   - overshoot
	//     - an inversion of the easeinorout (in if it was out, out if it
	//       was in. if there was nothing, it's out)
	//     - the same easingtype
	// - maybe i should just convert this into a "time to position"
	//   converter? it'd be more versatile that way... which makes it easier
	//   to do things like animate with a third axis.
	//   - eh, i should just limit it to one axis. the thing is, since this
	//     returns an array, and the coordinates are usually used as
	//     parameters for something else, i usually have to type
	//     "easingplacement(parameters)[0], easingplacement(parameters)[1]".
	//     that's super tedious. also redundant. (not that i'm at risk of
	//     running out of ram or whatever here, but still.)
	//   - point is, i already have to type it twice, so...
	//   - done.
	// - you can make the two values can be arrays, which makes it return an
	//   array between the two.
	//   - as in you can type 2d or 3d coordinates and it'll find whatever
	//     position between them, since it's tedious to copy this function twice
	//     or three times
		if(Array.isArray(value1) && Array.isArray(value2) && value1.length===value2.length) {
			ep_array = [];
			for(ep_i1 = 0; ep_i1 < value1.length; ep_i1++) {
				ep_array[ep_i1] = easingplacement(value1[ep_i1], value2[ep_i1], time, easeinorout, easingtype, overshoot);
			};
			return ep_array;
			// TODO not sure this is sompatible with overshoot considering that
			// modifies parameters
		};
		if(overshoot) {
			time /= overshoot[1];
			// modify the time so that the overshoot part of the animation
			// will be at 1 if the user inputs the overshoot time
			if(time > 1) {
			// if the overshoot is already done, modify the parameters to
			// work for the retraction
				time -= 1;
				time /= 1 - overshoot[1];
				// modify the time to be a fraction of the time remaining for retraction
				if(overshoot[2]) {
					easeinorout = overshoot[2];
				}
				else {
					if(easeinorout==="in") {
						easeinorout = "out";
					}
					else if(easeinorout==="out") {
						easeinorout = "in";
					}
					else {
						easeinorout = "out";
						// default to out for the retraction, to match how
						// it normally defaults to in
					};
					// reverse the in/out
				};
				if(overshoot[3]) {
					easingtype = overshoot[3];
				};
				// if they didn't specify an easing type for the retraction,
				// use the same thing again
				value1 += (value2 - value1)*overshoot[0];
				// make the coordinates of the overshoot the new starting
				// coordinates
			};
		};
		if(time <= 0) {
			return value1;
		}
		else if(time >= 1) {
			return value2;
		};
		if(easingtype==="circular" || easingtype==="circle") {
			easingtype = "circ";
		}
		else if(easingtype==="sin") {
			easingtype = "sine";
		}
		else if(!easingtype) {
			easingtype==="linear";
		};
		if(!easeinorout) {
			easeinorout==="in";
		};
		if(easingtype==="linear") {
			return value1 + time*(value2 - value1);
		};
		if(easeinorout==="in/out" || easeinorout==="out/in") {
			if(time===.5) {
				return (value1+value2)/2;
			}
			else if(time < .5) {
				value2 = (value1+value2)/2;
				if(easeinorout==="in/out") {
					easeinorout = "in";
				}
				else if(easeinorout==="out/in") {
					easeinorout = "out";
				}
				else {
					console.log("something went wrong");
					return;
				};
				time *= 2;
			}
			else if(time > .5) {
				value1 = (value1+value2)/2;
				if(easeinorout==="in/out") {
					easeinorout = "out";
				}
				else if(easeinorout==="out/in") {
					easeinorout = "in";
				}
				else {
					console.log("something went wrong");
					return;
				};
				time -= .5;
				time *= 2;
			}
			else {
				console.log("something went wrong");
				return;
			};
		};
		if(easingtype==="circ") {
			if(easeinorout==="in") {
				return value1 + (value2 - value1)*(1 - Math.cos(Math.asin(time)));
			}
			else if(easeinorout==="out") {
				return value1 + (value2 - value1)*Math.cos(Math.asin(time - 1));
			}
			else {
				console.log("something went wrong");
				return;
			};
		}
		else if(easingtype==="sine") {
			if(easeinorout==="in") {
				return value1 + (value2 - value1)*(1 + Math.sin((time - 1) * Math.PI/2));
			}
			else if(easeinorout==="out") {
				return value1 + (value2 - value1)*Math.sin(time * Math.PI/2);
			}
			else {
				console.log("something went wrong");
				return;
			};
		};
	}
	let Physics = {
		shove: (time, init_speed, decel) => (
		// calculates the time-to-distance factor of an object whose only
		// propulsion is a sudden shove, with nothing pushing it after the fact.
		// - decel: to be specific, this is friction, wind resistance, something
		//   like that; it stops when the object stops. force/mass =
		//   acceleration, so change it accordingly for objects of different
		//   mass.
			time*decel >= init_speed
			?
			// enough time has passed to decelerate to a stop
			(init_speed**2)/(2*decel)
			//(init_speed/decel)*(init_speed/2)
			:
			(init_speed - decel*time/2)*time
		),
		addvectors: function(vector1, vector2) {
		// let vector = Physics.addvectors([magnitude1, angle1], [magnitude2, angle2]);
		// input two arrays of magnitude and angle, it'll add them together to
		// create the combined vector.
			let newvect = [
				Math.cos(vector1[1])*vector1[0] + Math.cos(vector2[1])*vector2[0],
				Math.sin(vector1[1])*vector1[0] + Math.sin(vector2[1])*vector2[0]
			];
			newvect = [
				Math.hypot(...newvect),
				get2dangle(...newvect, true)
			];
			console.log("addvectors: " + (newvect[1] === null ? [0, vector1[1]] : newvect));
			return (
				typeof newvect[1] === "string"
				?
				[0, vector1[1]]
				// it was [0, 0] or something before conversion.
				// - don't change the angle, since that's like the direction
				//   it's facing. it hasn't changed to vector2's direction until
				//   vector2 makes the magnitude more than zero.
				// - at least, that's how i think it should be. decelerating to
				//   a stop doesn't make you flip directions, right?
				:
				newvect
			);
		},
	}
	if(0===0) {
	// specific movement functions.
		function screwmovement(x1, y1, x2, y2, time, r, numofcycles, xy_angle, z_angle) {
		// - x1, y1, x2, y2, time: same as easingplacement
		// - r: radius of the circle
		// - numofcycles: number of circular motions it goes through before
		//   it ends
		// - xy_angle: the number of clockwise degrees to rotate the circle
		//   by (starting from the angle perpendicular to the line from the
		//   beginning to the end)

		};
		//ctx2.fillStyle = "#000000";
		//if(currframe%8 === 0 || currframe%8 >= 4) {
		//	circledraw(ctx2, easingplacement(8, 56, (4 - Math.abs(currframe%8 - 4))/4, "in/out", "sine"), easingplacement(8, 56, currframe/numofframes, "in", "sine"), 3);
		//};
		//easingplacement(8, 56, (4 - Math.abs(currframe%8 - 4))/4, "in/out", "sine"), easingplacement(8, 56, currframe/numofframes, "in", "sine")
		function _3dstar(x, y, z, r, fraction, rotation, starconstant, linearguments/*[context, antialiasing, viewer]*/) {
		// though this counts as a _3d function, this is only in a very
		// loose sense. if there's no valid z value, it'll just draw
		// normally.
		// - fraction: fraction of the star's perimeter to place the point
		//   at, going clockwise from the top.
		// - rotation: rotation offset for the star, works the same as
		//   fraction
		// - starconstant: this is the distance from a star's center to one
		//   of its armpits, divided by the radius. optional.
		// - linearguments: if there's something here, it will draw a star
		//   instead of giving coordinates. it's an array with:
		//   - context
		//   - antialiasing boolean
		//   - viewer
		// - TODO
		//   - make it so the number of points can be specified? (only odd
		//     numbers, probably)
		//   - add a setting that makes it draw/place a pentagram instead?
		//     - this would be pretty useful for fancy movement patterns
		//   - add a setting to use splines?
			if(!starconstant && starconstant!==0) {
				//console.log(Math.hypot(fourpointintersect(circlepoints(0, 0, 1, 0/5)[0], circlepoints(0, 0, 1, 0/5)[1], circlepoints(0, 0, 1, 2/5)[0], circlepoints(0, 0, 1, 2/5)[1], circlepoints(0, 0, 1, 4/5)[0], circlepoints(0, 0, 1, 4/5)[1], circlepoints(0, 0, 1, 1/5)[0], circlepoints(0, 0, 1, 1/5)[1])[0], fourpointintersect(circlepoints(0, 0, 1, 0/5)[0], circlepoints(0, 0, 1, 0/5)[1], circlepoints(0, 0, 1, 2/5)[0], circlepoints(0, 0, 1, 2/5)[1], circlepoints(0, 0, 1, 4/5)[0], circlepoints(0, 0, 1, 4/5)[1], circlepoints(0, 0, 1, 1/5)[0], circlepoints(0, 0, 1, 1/5)[1])[1]));
				starconstant = 0.3819660112501051;
				// . i think there's better ways
				// to calculate this but i don't give a shit
				// -
				// the reason i want it to be modular is it greatly
				// impacts how the star feels. if you look at like, i
				// dunno. stickers kindergarten teachers give out.
				// chances are this value is much higher.
			}
			let starpointx = [];
			let starpointy = [];
			let starpitx = [];
			let starpity = [];
			for(star_i1=0; star_i1 < 5; star_i1++){
				starpointx[star_i1] = circlepoints(x, y, r, star_i1/5 + (rotation ? rotation : 0))[0];
				starpointy[star_i1] = circlepoints(x, y, r, star_i1/5 + (rotation ? rotation : 0))[1];
				starpitx[star_i1] = circlepoints(x, y, r*starconstant, (star_i1 + .5)/5 + (rotation ? rotation : 0))[0];
				starpity[star_i1] = circlepoints(x, y, r*starconstant, (star_i1 + .5)/5 + (rotation ? rotation : 0))[1];
				//ctx2.fillText(star_i1, starpointx[star_i1], starpointy[star_i1]);
				//ctx2.fillText(star_i1, starpitx[star_i1], starpity[star_i1]);
				//circledraw(ctx2, starpointx[star_i1], starpointy[star_i1], 2, true);
				//circledraw(ctx2, starpitx[star_i1], starpity[star_i1], 2, true);
			}
			//linearguments[context, antialiasing, viewer]
			//nonaaline(context, x1, y1, x2, y2)
			//_3dline(viewer, context, x1, y1, z1, x2, y2, z2, antialiasing)
			if(linearguments) {
				if(z || z===0) {
					for(star_i1=0; star_i1 < 5; star_i1++){
						_3dline(linearguments[2], linearguments[0], starpointx[star_i1], starpointy[star_i1], z, starpitx[star_i1], starpity[star_i1], z, linearguments[1]);
						_3dline(linearguments[2], linearguments[0], starpitx[star_i1], starpity[star_i1], z, starpointx[(star_i1 + 1)%5], starpointy[(star_i1 + 1)%5], z, linearguments[1]);
					}
				}
				else {
					for(star_i1=0; star_i1 < 5; star_i1++){
						if(linearguments[1]) {
							linearguments[0].beginPath();
							linearguments[0].moveTo(starpointx[star_i1], starpointy[star_i1]);
							linearguments[0].lineTo(starpitx[star_i1], starpity[star_i1]);
							linearguments[0].lineTo(starpointx[(star_i1 + 1)%5], starpointy[(star_i1 + 1)%5]);
							linearguments[0].stroke();
							linearguments[0].closePath();
						}
						else {
							//nonaaline(context, x1, y1, x2, y2)
							nonaaline(linearguments[0], starpointx[star_i1], starpointy[star_i1], starpitx[star_i1], starpity[star_i1]);
							nonaaline(linearguments[0], starpitx[star_i1], starpity[star_i1], starpointx[(star_i1 + 1)%5], starpointy[(star_i1 + 1)%5]);
						};
					}
				};
			}
			else {
				fraction %= 1;
				fraction += 1;
				fraction %= 1;
				// just in case.
				let starx1 = (fraction%(1/5) < 1/10 ? starpointx[Math.floor(fraction/(1/5))] : starpitx[Math.floor(fraction/(1/5))]);
				let starx2 = (fraction%(1/5) < 1/10 ? starpitx[Math.floor(fraction/(1/5))] : starpointx[(Math.floor(fraction/(1/5)) + 1)%5]);
				// either going from the point to the pit or the pit to the next point
				let stary1 = (fraction%(1/5) < 1/10 ? starpointy[Math.floor(fraction/(1/5))] : starpity[Math.floor(fraction/(1/5))]);
				let stary2 = (fraction%(1/5) < 1/10 ? starpity[Math.floor(fraction/(1/5))] : starpointy[(Math.floor(fraction/(1/5)) + 1)%5]);
				fraction %= .1;
				fraction *= 10;
				return [starx1 + fraction*(starx2 - starx1), stary1 + fraction*(stary2 - stary1)];
			};
		}
	};
	var viewer = {
		x: 0,
		y: 0,
		z: 0,
		ratio: 1,
		offset: {
			x: 0,
			y: 0,
			z: 0,
			//x: (document.getElementById("xoffset").value ? document.getElementById("xoffset").value : 0),
			//y: (document.getElementById("yoffset").value ? document.getElementById("yoffset").value : 0),
			//z: (document.getElementById("zoffset").value ? document.getElementById("zoffset").value : 0),
		},
	};
	// - "ratio": ratio of pixels/degrees, how many pixels there should be
	//   per degree;
	// - offset: don't modify that directly, it's annoying to scroll back
	//   and forth and easy to forget.
	//   - do not make perspectiveconvert use this. this is for _3d
	//     functions to use. (the chain is _3d functions,
	//     perspectiveconvert, functions that actually draw stuff on the
	//     canvas. but if there's something like, say, the line you're
	//     drawing reaching behind the viewer, the _3d function has to know
	//     that, and it only can if the offsets are already applied by that
	//     point.)
	// NOTE: the z should be the most variable thing. that's the distance
	// it's zoomed out, the distance objects will be at 0 z position.
	function perspectiveconvert(viewer, x, y, z) {
	// converts coordinates from x/y/z space to screen coordinates
	// - notes
	//   - the size of an object is relative to what the angle is from our
	//     eyes to the edges of it.
	//   - so if i establish a "default distance" (when z === 0) in pixels,
	//     and a vanishing point where the angles are measured from, i could
	//     figure out where the edges should be. (for simplicity's sake, i'm
	//     probably just gonna assume the object is flat.)
	//   - or another way to put it is that i'm deciding the x, y, and z
	//     position of the camera.
	//     - nah, the viewer's eye. camera sounds so impersonal.
	// - surprise motherfucker, this DOES work (it was my line-drawing
	//   function that didn't. really.)
	// - TODO z needs an offset of some kind, because it's supposed to be
	//   that 0 z is where everything is onscreen, but that's not true at
	//   all.
	//   - well, i tried. it's in the junkpile file, because it didn't work.
		return viewer ? Viewer.fromobj(viewer).convert(x, y, z) : [x, y, z];
	}
	function screeninverse(viewer, x, y, z, plane) {
		return viewer ? Viewer.fromobj(viewer).inverse(x, y, z, plane) : plane.planepoint(x, y, "z");
	}
	function z_to_size(viewer, z) {
	// creates size scalers based on a z coordinate and a hypothetical sphere
	// that lines up with the vanishing point and has the z specified.
	// - ie it figures out what angles the left and right edge would have
	//   relative to the viewer, then converts the degrees to pixels with .ratio
		return Viewer.fromobj(viewer).z_size(z);
	};
	function central_z(viewer) {
	// returns the viewer.z to use for a sphere to be sized the same at
		return Viewer.fromobj(viewer).central_z;
	};
	function lightlevel(viewer, point, angle, alpha) {
	// returns an array of r, g, and b, calculating how much each lamp adds to
	// it.
	// - angle: the angle of the triangle the point is on, the direction it
	//   faces. use tridirection.
	// - alpha: a number from 0 to 1 for how opaque the surface is, so it can
	//   tell how much light can seep through if the lamp's light should fall on
	//   the other side of the triangle the point is on. (that is, if the
	//   Angle.compare between the angle and the angle from the point to the
	//   lamp is over 90) generally, you should use the alpha of the triangle's
	//   color.
	// - this should be multiplied by the point's color, then added to it. at
	//   least, that's how the default shader works.
	//   - red = red*(1 + lightlevel[0]);
		alpha ??= 1;
		let lightlevel = (typeof viewer.baselightlevel === "number" ? viewer.baselightlevel : 0);
		// the lightlevel should start at a negative number. when light is 0,
		// the color should be what it is in the texture, but the texture
		// assumes there's light.
		lightlevel = [
			lightlevel,
			lightlevel,
			lightlevel
		];
		// one for r, g, and b
		function addlight(lamp) {
		// adds to the lightlevel, taking into account one lamp's properties.
		// have to make this an inner function because otherwise i have to
		// violate DRY to make the stuff in the loop happen for singular lamps.
		// - lamp: a lamp object
			let addend = [
				lamp.x - point[0],
				lamp.y - point[1],
				lamp.z - point[2]
			];
			let dist = Math.hypot(...addend);
			if(dist === 0) {
			// if it's right at the lamp, the angle doesn't matter. (it'd be
			// invalid too.)
				addend = 1;
			}
			else {
				addend = Angle.get(...addend);
				addend = Math.abs(Math.cos(Angle.compare(angle, addend)));
				// it's 1 if angle and the angle to the lamp are parallel, 0 if
				// they're perpendicular.
				addend *= (addend >= Math.PI/2 ? 1 - alpha : 1);
				// the light is coming from the other side of the face, so
				// multiply by 1 - alpha
			};
			addend *= (typeof lamp.brightness === "number" ? lamp.brightness : 1)/(dist**2);
			// multiply by brightness, divide by surface area (since the number
			// of rays per whatever is directly tied to that.)
			// - technically surface area is 4*pi*dist**2, but there's no point
			//   dividing by a constant since the only point of this is
			//   accurately lowering/raising the brightness by distance
			if(lamp.hasOwnProperty("color")) {
				lightlevel[0] += addend*lamp.color[0]/255;
				lightlevel[1] += addend*lamp.color[1]/255;
				lightlevel[2] += addend*lamp.color[2]/255;
			}
			else {
				lightlevel[0] += addend;
				lightlevel[1] += addend;
				lightlevel[2] += addend;
			};
		}
		if(viewer.lamp.hasOwnProperty("single") && viewer.lamp.single) {
			addlight(lamp);
		}
		else {
			let i1 = 0;
			for (i1 in viewer.lamp) {
				if (viewer.lamp.hasOwnProperty(i1)) {
					addlight(lamp);
				};
			}
		};
		return lightlevel;
	};
	function _3dline(viewer, context, x1, y1, z1, x2, y2, z2, weight, antialiasing) {
	// draws a line in 3d space.
	// - weight does not have any effect if antialiasing is used.
	// - TODO
	//   - make it so weight changes based on the distance from the camera.
	//   - make it so this just does _3dlineexecute with circledraw
		if(viewer.offset.x) {
			x1 += viewer.offset.x;
			x2 += viewer.offset.x;
		};
		if(viewer.offset.y) {
			y1 += viewer.offset.y;
			y2 += viewer.offset.y;
		};
		if(viewer.offset.z) {
			z1 += viewer.offset.z;
			z2 += viewer.offset.z;
		};
		// apply offsets
		if(viewer.z - z1 < 0 && viewer.z - z2 < 0) {
		// if the line is behind the viewer, don't even draw it.
		}
		else {
			if(viewer.z - z1 >= 0 && viewer.z - z2 < 0) {
			// if it ends behind the viewer, cut it off.
				x2 = x1 + (x2 - x1)*(z1 - viewer.z)/(z2 - z1);
				y2 = y1 + (y2 - y1)*(z1 - viewer.z)/(z2 - z1);
				// the new z2 will be viewer.z, so you can find the x and y
				// coordinates by multiplying the x/y distance by the fraction
				// of the z distance that's still retained by this change.
				z2 = viewer.z;
			}
			else if(viewer.z - z1 < 0 && viewer.z - z2 >= 0) {
			// if it starts behind the viewer, cut it off.
				x1 = x1 + (x2 - x1)*(z1 - viewer.z)/(z2 - z1);
				y1 = y1 + (y2 - y1)*(z1 - viewer.z)/(z2 - z1);
				z1 = viewer.z;
			};
			// TODO both are untested.
			if(antialiasing) {
				context.beginPath();
				context.moveTo(perspectiveconvert(viewer, x1, y1, z1)[0], perspectiveconvert(viewer, x1, y1, z1)[1]);
				context.lineTo(perspectiveconvert(viewer, x2, y2, z2)[0], perspectiveconvert(viewer, x2, y2, z2)[1]);
				context.stroke();
				context.closePath();
			}
			else {
				nonaaline(context, perspectiveconvert(viewer, x1, y1, z1)[0], perspectiveconvert(viewer, x1, y1, z1)[1], perspectiveconvert(viewer, x2, y2, z2)[0], perspectiveconvert(viewer, x2, y2, z2)[1], weight);
			};
		};
	}
	function _3dcircle(viewer, context, x, y, z, r, fill) {
		if(viewer.hasOwnProperty("offset")) {
			if(viewer.offset.x) {
				x += viewer.offset.x;
			};
			if(viewer.offset.y) {
				y += viewer.offset.y;
			};
			if(viewer.offset.z) {
				z += viewer.offset.z;
			};
		}
		// apply offsets
		if(viewer.z - z < 0) {
		// if it's behind the viewer, don't bother
			return;
		};
		circledraw(context, perspectiveconvert(viewer, x, y, z)[0], perspectiveconvert(viewer, x, y, z)[1], r, fill);
	}
	function _3dpoly(viewer, context, shape, offset, weight, invert, outline, etc) {
	// - shape: an object with this structure:
	//   - .points: array of coordinate arrays
	//   - .faces: array of objects
	//     - .faces[facenumber].indexes: point indexes to connect to form a
	//       face
	//     - .faces[facenumber].fill: fill color change
	//       - "default" refers to whatever the fill/stroke style was at the
	//         time of running _3dpoly.
	//     - .faces[facenumber].stroke: stroke color change
	//     - .faces[facenumber].center: changes to the point the faces
	//       face away from (an array of x/y/z coordinates, or a string
	//       saying "default" which sets it back to the average of all
	//       points)
	//     - .faces[facenumber].hide: an array of .faces[facenumber].indexes
	//       indexes indicating lines that shouldn't be drawn
	//   - .colors: array of colors for .fill and .stroke to use. (they can
	//     use the normal formats, but numbers will be converted to
	//     whatever's in here.)
	//   - the face is broken up into triangles by connecting the first
	//     point to all other points.
	// - offset: applied to all coordinates when drawing.
	// - weight: line weight passed to _3dline
	// - invert: if this is true, the side of each triangle that's one-sided
	//   will be inverted.
	//   - useful for drawing a room interior or something like that.
	//   - or you could run it uninverted and inverted to make all faces
	//     double-sided (useful for shapes that aren't closed)
	// - outline: an array with a color and a width. this is added to the
	//   outside of the 3d shape.
	//   - if there's no color, it'll use whatever the current strokeStyle
	//     is. (or you can use "stroke", but. why bother.)
	//   - if there's no number, it'll use a weight of 1.
	//   - if you use "default" as the color, it'll use whatever the
	//     strokeStyle was at the time of running _3dpoly. (as in, it will
	//     NOT be affected by .stroke properties in the faces that change
	//     it.)
	//   - this is not at all guaranteed to work with the below etc
	//     commands.
	// - etc: a series of special commands.
	//   - "wireframe": no fill will be done, and stroke will always be done
	//     regardless of which direction the triangle faces.
	//   - "tri": all triangles' strokes will be drawn.
	//   - "lineless": stroke will not be drawn.
	//   - "lock stroke color": this is mainly meant to be used internally.
	//     it prevents stroke color from being changed by the shape's
	//     .stroke properties.
	//   =
	//   - NOTE: if wireframe, tri, or lock stroke mode are removed for any reason,
	//     outline will not work.
	//   - you can use multiple of these by making them an array.
	// =
	// - NOTE: if something has gone wrong, there's a good chance of it
	//   being the shape, not _3dpoly. doublecheck both.
		// - TODO
		//   - finish
		//     - outline
		//   - test
		//     - lineless
		//     - tri
		//   - same cutoff things _3dline has
		//   - fix the issue with cube faces not being drawn right
		//   - lighting system
		//     - this is super duper important, because. it's kinda hard to
		//       make things look 3d when every face blends into each other.
		//     - figure out how to translate these elements into how much
		//       the surface should be lit
		//       - the angle the plane faces
		//       - the angle from the center of a triangle to the light
		//         source
		//     - add a "lamp" object, which works like viewer
		//     - add these parameters to _3dpoly
		//       - fill/stroke light color
		//       - fill/stroke dark color
		//       - some way of controlling how light *everything* is, and/or
		//         how much lighting varies
		//         - ideally this should be a parameter of shapes, too. so
		//           a face can be shinier?
		//         - eh, that's probably an oversimplification. i don't know
		//           a lot about lighting. but still.
		//       - a number for how many colors are actually displayed
		//     - make it so it can interpret arrays in .stroke or .fill as
		//       light/dark colors
		//       - if there's one color, that's displayed no matter what. if
		//         there's two, it's interpreted as the dark and normal
		//         color
		//   - outline does not interpret input that's just a color
		//     correctly.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		if(Array.isArray(offset) && offset.length >= 3) {
		// did you know that typeof doesn't work on arrays? i didn't.
			let logerror = false;
			let oldoffset = structuredClone(offset);
			for(i1 = 0; i1 < 3; i1++) {
				if(typeof offset[i1] !== "number" || isNaN(offset[i1])) {
				// if it's invalid, use 0
					logerror = true;
					offset[i1] = 0;
				};
			}
			if(logerror) {
				console.log("invalid coordinates: " + oldoffset);
			};
		}
		else {
			offset = [0, 0, 0];
		};
		let styletemp = [context.fillStyle, context.strokeStyle, context.strokeStyle];
		// [2] is for storing the stroke style when it switches to outline
		if(!etc) {
		// prevents undefined errors
			etc = "";
		};
		if(outline) {
			let outlinecolor = "stroke";
			let outlineweight = 1;
			if(Array.isArray(outline) && outline.length === 2 && typeof outline[0] === "string" && typeof outline[1] === "number") {
				outlinecolor = outline[0];
				outlineweight = outline[1];
			}
			else if(typeof outline === "string") {
				outlinecolor = outline;
			}
			else if(typeof outline === "number") {
				outlineweight = outline;
			};
			// the outline is partially covered up by the line weight
			// though, so...
			// - since the outline and normal lines are centered in the same
			//   place, it'd be (outline - weight)/2 = actual outline
			outlineweight *= 2;
			if(typeof weight === "number") {
				outlineweight += weight;
			}
			else if(Array.isArray(weight)) {
				outlineweight = [outlineweight + weight[0], outlineweight + weight[1]];
			}
			else {
				outlineweight += 1;
			};
			outlineweight -= 1;
			if(outlinecolor === "stroke") {
				context.strokeStyle = styletemp[1];
				_3dpoly(viewer, context, shape, offset, outlineweight, invert, false, ["wireframe", "tri"]);
			}
			else {
				if(outlinecolor === "default") {
					context.strokeStyle = styletemp[1];
				};
				_3dpoly(viewer, context, shape, offset, outlineweight, invert, false, ["wireframe", "tri", "lock stroke color"]);
			};
			// recurse this bitch. i'm a goddamn time wizard.
		};
		let points = structuredClone(shape.points);
		let center = [0, 0, 0];
		// the point that faces should face away from.
		for(i1 = 0; i1 < points.length; i1++){
			for(i2 = 0; i2 < 3; i2++){
				points[i1][i2] += offset[i2];
				center[i2] += points[i1][i2];
			}
		}
		for(i1 = 0; i1 < 3; i1++){
			center[i1] /= points.length;
		}
		let defaultcenter = structuredClone(center);
		// apply offset, define the default center
		let faces = structuredClone(shape.faces);
		for (b3s_i1 = 0; b3s_i1 < faces.length; b3s_i1++) {
			if(faces[b3s_i1].hasOwnProperty("center")) {
				faces[b3s_i1].center[0] += offset[0];
				faces[b3s_i1].center[1] += offset[1];
				faces[b3s_i1].center[2] += offset[2];
			}
		};
		// apply offset to centers described here, too
		let colors = structuredClone(shape.colors);
		let pointstemp = [];
		let currangle = [];
		let centerangle = [];
		let angletemp = [];
		if(!faces[0].center) {
			faces[0].center = "default";
		};
		if(!faces[0].fill && faces[0].fill !== 0) {
			faces[0].fill = "default";
		};
		if(!faces[0].stroke && faces[0].stroke !== 0) {
			faces[0].stroke = "default";
		};
		for(i1 = 1; i1 < faces.length; i1++){
		// runs for every face, applies changes to center and colors.
		// - it's sorta hard to explain, but the way changes used to be
		//   effected doesn't work if the faces get sorted first.
			if(!faces[i1].center) {
				faces[i1].center = structuredClone(faces[i1 - 1].center);
			};
			if(!faces[i1].fill && faces[0].fill !== 0) {
				faces[i1].fill = faces[i1 - 1].fill;
			};
			if(!faces[i1].stroke && faces[0].stroke !== 0) {
				faces[i1].stroke = faces[i1 - 1].stroke;
			};
		}
		function _3dpolysort(a, b) {
			let i1 = 0;
			let a_zaverage = 0;
			let b_zaverage = 0;
			for(i1 = 0; i1 < a.indexes.length; i1++){
				a_zaverage += points[a.indexes[i1]][2];
			}
			a_zaverage /= a.indexes.length;
			for(i1 = 0; i1 < b.indexes.length; i1++){
				b_zaverage += points[b.indexes[i1]][2];
			}
			b_zaverage /= b.indexes.length;
			return a_zaverage - b_zaverage;
		};
		faces.sort(_3dpolysort);
		// sorts it by whatever the average z position of their points is
		//console.log(currframe);
		//console.log(faces);
		for(i1 = 0; i1 < faces.length; i1++){
		// runs for every face
			if(!faces[i1].center) {
				console.log("face " + i1 + " has no defined center. _3dpoly is supposed to fill that automatically, something went wrong.");
			}
			else {
				if(faces[i1].center === "default") {
					center = structuredClone(defaultcenter);
				}
				else if(Array.isArray(faces[i1].center)) {
					center = structuredClone(faces[i1].center);
				};
			};
			if(!faces[i1].fill && faces[0].fill !== 0) {
				console.log("face " + i1 + " has no defined fill color. _3dpoly is supposed to fill that automatically, something went wrong.");
			}
			else {
				if(faces[i1].fill === "default") {
					context.fillStyle = styletemp[0];
				}
				else if(typeof faces[i1].fill === "number" && colors[faces[i1].fill]) {
				// .colors index
					context.fillStyle = colors[faces[i1].fill];
				}
				else if(typeof faces[i1].fill === "string") {
					context.fillStyle = faces[i1].fill;
				};
			};
			if(!faces[i1].stroke && faces[0].stroke !== 0) {
				console.log("face " + i1 + " has no defined stroke color. _3dpoly is supposed to fill that automatically, something went wrong.");
			}
			else {
				if(etc.includes("lock stroke color")) {
				}
				else if(faces[i1].stroke === "default") {
					context.strokeStyle = styletemp[1];
				}
				else if(typeof faces[i1].stroke === "number" && colors[faces[i1].stroke]) {
				// .colors index
					context.strokeStyle = colors[faces[i1].stroke];
				}
				else if(typeof faces[i1].stroke === "string") {
					context.strokeStyle = faces[i1].stroke;
				};
			};
			// trigger center/color changes
			for(i2 = 1; i2 < faces[i1].indexes.length - 1; i2++){
			// run for every index except the first and last. defines a
			// triangle, figures out the angle it faces, and draws the fill
			// part.
				pointstemp = [];
				pointstemp[0] = points[faces[i1].indexes[i2]];
				pointstemp[1] = points[faces[i1].indexes[i2 + 1]];
				pointstemp[2] = points[faces[i1].indexes[0]];
				// break the face up into triangles by connecting every side
				// to the first point
				currangle = Plane.frompoints(pointstemp).line().angle;
				currangle = Angle.correct(currangle);
				pointstemp[3] = [];
				pointstemp[3][0] = (pointstemp[0][0] + pointstemp[1][0] + pointstemp[2][0])/3;
				pointstemp[3][1] = (pointstemp[0][1] + pointstemp[1][1] + pointstemp[2][1])/3;
				pointstemp[3][2] = (pointstemp[0][2] + pointstemp[1][2] + pointstemp[2][2])/3;
				// average of all three points
				//_3dcircle(viewer, context, center[0], center[1], center[2], 5, true);
				centerangle = Angle.get(
					center[0] - pointstemp[3][0],
					center[1] - pointstemp[3][1],
					center[2] - pointstemp[3][2]
				);
				centerangle = Angle.correct(centerangle);
				// angle to the shape's center
				//if(i1 === 5 && ((currframe >= 1 && currframe <= 3) || (currframe >= 15 && currframe <= 21) || (currframe >= 69 && currframe <= 71))) {
				//	console.log("frame " + currframe + " before drawing");
				//	console.log(faces[i1].name + " face, tri " + i2);
				//	console.log("currangle:");
				//	console.log((360*currangle[0]/(2*Math.PI)) + ", " + 360*currangle[1]/(2*Math.PI));
				//	console.log("Angle.compare:");
				//	console.log(360*Angle.compare(currangle, centerangle)/(2*Math.PI));
				//};
				if(Angle.compare(currangle, centerangle) < Math.PI/2) {
				// if it's less than one hemisphere away, (ie the face angle
				// is facing toward the center) invert the face angle.
					currangle[0] += Math.PI;
					currangle[0] %= 2*Math.PI;
					currangle[1] *= -1;
					//if(i1 === 5 && ((currframe >= 1 && currframe <= 3) || (currframe >= 15 && currframe <= 21) || (currframe >= 69 && currframe <= 71))) {
					//	console.log("angle inverted");
					//};
				};
				/*
				_3dline(viewer, context,
					pointstemp[3][0],
					pointstemp[3][1],
					pointstemp[3][2],
					pointstemp[3][0] + framew*Angle.numbers(currangle)[0],
					pointstemp[3][1] + framew*Angle.numbers(currangle)[1],
					pointstemp[3][2] + framew*Angle.numbers(currangle)[2]
				);
				context.strokeStyle = "red";
				_3dline(viewer, context,
					pointstemp[3][0],
					pointstemp[3][1],
					pointstemp[3][2],
					pointstemp[3][0] + framew*Angle.numbers(centerangle)[0],
					pointstemp[3][1] + framew*Angle.numbers(centerangle)[1],
					pointstemp[3][2] + framew*Angle.numbers(centerangle)[2]
				);

				context.strokeStyle = "lime";
				_3dline(viewer, context,
					pointstemp[3][0],
					pointstemp[3][1],
					pointstemp[3][2],
					pointstemp[3][0] + (framew/2),
					pointstemp[3][1],
					pointstemp[3][2]
				);
				_3dline(viewer, context,
					pointstemp[3][0],
					pointstemp[3][1],
					pointstemp[3][2],
					pointstemp[3][0] + (framew/2)*Math.cos(Angle.compare(currangle, centerangle)),
					pointstemp[3][1] + (framew/2)*Math.sin(Angle.compare(currangle, centerangle)),
					pointstemp[3][2]
				);
				context.strokeStyle = "white";
				*/
				angletemp[i2] = structuredClone(currangle);
				/*
				_3dline(viewer, ctx2,
					pointstemp[3][0],
					pointstemp[3][1],
					pointstemp[3][2],
					pointstemp[3][0] + framew*Angle.numbers(currangle)[0],
					pointstemp[3][1] + framew*Angle.numbers(currangle)[1],
					pointstemp[3][2] + framew*Angle.numbers(currangle)[2]
				);
				*/
				if(currangle[1] === 0) {
				// if the z angle is 0, do not draw it if the angle between
				// the xy and the angle to the viewer x/y is obtuse.
					centerangle = get2dangle(viewer.x - (viewer.offset.x + pointstemp[3][0]), viewer.y - (viewer.offset.y + pointstemp[3][1]));
					if(
						(viewer.x - (viewer.offset.x + pointstemp[3][0]) === 0 && viewer.y - (viewer.offset.y + pointstemp[3][1]) === 0)
						||
						compare2dangle(currangle[0], centerangle) <= Math.PI/2
					) {
					// if it was right on top of the viewer (and therefore
					// there was no valid angle to begin with) or if the
					// is acute/right, draw it
					// - it bothers me to not catch the former sooner, but
					//   i'd rather not violate DRY
					}
					else {
						angletemp[i2][1] = "hide";
						// replaces the z angle with a string saying to hide
						// it. the line drawing logic can use this so it
						// doesn't have to figure this shit out again
					};
				};
				for(i3 = 0; i3 < 3; i3++) {
					pointstemp[i3] = perspectiveconvert(viewer, pointstemp[i3][0] + viewer.offset.x, pointstemp[i3][1] + viewer.offset.y, pointstemp[i3][2] + viewer.offset.z);
					// convert to x/y, add viewer offset since
					// _2dPoly.draw isn't a _3d function
				}
				pointstemp.splice(3, 1);
				// remove the center point
				if(
					!etc.includes("wireframe")
					&&
					(
						(!invert && currangle[1] >= 0 && currangle[1] !== "hide")
						||
						(invert && (currangle[1] < 0 || currangle[1] === "hide"))
					)
				) {
					_2dPoly.draw(context, pointstemp);
				};
				//if(i1 === 5 && ((currframe >= 1 && currframe <= 3) || (currframe >= 15 && currframe <= 21) || (currframe >= 69 && currframe <= 71))) {
				// troubleshooting thing
				//	console.log("frame " + currframe + " after drawing");
				//	console.log("pointstemp:");
				//	console.log(pointstemp);
				//	console.log("currangle:");
				//	console.log((360*currangle[0]/(2*Math.PI)) + ", " + 360*currangle[1]/(2*Math.PI));
				//};
				if(etc === "tri" || etc.includes("tri")) {
				// if it's tri mode, draw all triangles
					_2dPoly.draw(context, pointstemp, "stroke", weight);
				};
				// the big problem i hit my head against for so long was
				// that the center wasn't in the right place. i forgot to
				// apply offsets to it.
				// -
				// TODO there's still problems.
				// - problems with rendering cubes, mostly.
				// - if a cube is rotating in the xz axis like what i'm
				//   having it do, it should only display two faces at a
				//   time.
				// - and naturally, it should also display both triangles of
				//   those faces.
				// - instead, quite a lot of frames render it improperly.
				// - after fixing a few things and hiding the front face, i
				//   can see that the second-frontmost face and the face
				//   opposite of that are guaranteed to render properly, the
				//   frontmost face only sometimes renders properly, and
				//   everything else is guaranteed to not render properly.
				// - the front face draws improperly if it's at 15 to 21 /
				//   72 or 69 to 3 / 72.
				//   - in other words, 5 to 7 / 24 or 23 to 1 / 24...
				//   - except for 0, but that could be caused by some
				//     exception in logic. like compare2dangle or whatever.
				// - surprisingly, even though i turned back on the z angle
				//   === 0 logic, it isn't any less busted when i turn it
				//   off.
				// -
				// - i would love to just fuck off and do the rest of the
				//   body model shit now that spheroids work, but those are
				//   a little glitchy too when a face faces a certain angle.
				//   (only one face at a time, but still.)
				// - i ran it while forcing it to only show the top and
				//   bottom face, where i learned that which triangle is
				//   present changes when the center crosses the halfway
				//   point
				//   - in other words, the top triangle is always the one
				//     whose center is on the left side of the screen, and
				//     the bottom's center is always on the right.
				//   - after testing in different offsets, it seems bottom
				//     triangles will only display if their centers are
				//     below and to the right of the viewer, while top
				//     triangles only display if they're above and to the
				//     left
				//   - commenting out the === 0 fixes it. i thought that
				//     *didn't* make it more busted?
				//     - well, it should mostly affect the top and bottom
				//       since those are the only faces that always have a 0
				//       z angle... (i'm testing this with a cube that
				//       rotates in the xz axis)
				//   - considering these patterns and how the 0 z hiding
				//     logic revolves around the angle to the viewer... this
				//     is either a logic error or a flaw in get2dangle.
				//     - it's the latter. goddamn inverse tan. forgot to
				//       invert it if x is negative.
				//     - nope, it's both.
				// -
				// - it was a flaw in compare2dangle. you correct reflex angles
				//   by subtracting them from a circumference, not subtracting
				//   half a circumference from them. stoopid
				// - still not there yet though. the logic that inverts face
				//   angles is flawed.
				//   - part of the problem is that it doesn't effect .center
				//     changes correctly. using _3dcircle to show where it is
				//     shows it is not where it should be
				//   - that's not all though, there's problems with cubes too
			}
			angletemp[0] = angletemp[1];
			angletemp[angletemp.length] = structuredClone(angletemp[angletemp.length - 1]);
			// angletemp stores the angles of the faces each point's line
			// is part of.
			for(i2 = 0; i2 < faces[i1].indexes.length; i2++){
			// runs for every index, draws the lines of the face.
				if(
					(!faces[i1].hide || !faces[i1].hide.includes(i2))
					// if hide does not specify it should be hidden
					&&
					(
						(!invert && angletemp[i2][1] >= 0 && angletemp[i2][1] !== "hide")
						||
						(invert && (angletemp[i2][1] < 0 || angletemp[i2][1] === "hide"))
						||
						etc.includes("wireframe")
					)
					// and the z angle and invert or wireframe mode
					// indicates it should be drawn
					&&
					!etc.includes("lineless")
					// and it isn't lineless mode
				) {
				// if it hasn't been hidden and the triangle for it isn't
				// facing away from the camera, draw it
					_3dline(viewer, context,
						points[faces[i1].indexes[i2]][0],
						points[faces[i1].indexes[i2]][1],
						points[faces[i1].indexes[i2]][2],
						points[faces[i1].indexes[((i2 + 1)%faces[i1].indexes.length)]][0],
						points[faces[i1].indexes[((i2 + 1)%faces[i1].indexes.length)]][1],
						points[faces[i1].indexes[((i2 + 1)%faces[i1].indexes.length)]][2],
					weight);
				};
			}
		}
		context.fillStyle = styletemp[0];
		context.strokeStyle = styletemp[1];
		// what are all the steps to drawing a face.
		// - use structuredClone on .points and .faces
		// - for loop for every face
		//   - enact changes if .stroke, .fill, or .center is there
		//   - for loop for every index (or most indexes. the number of
		//     triangles is the number of points minus 2.)
		//     - find the angle using findplane
		//     - if the average of the three points plus the sin cosine
		//       whatever the hell of the 3d angle (the magic geometry math
		//       that says "this is how much x/y/z distance moving ___ pixels
		//       in this angle would have") is further from the center point
		//       than the average *minus* the sin cosine whatever the hell,
		//       invert the angle.
		//     - if the z angle is less than 0, don't draw it.
		//     - also save the angle for future reference. make it 1-indexed
		//       though. you'll see why later
		//   - for loop for every line
		//     - if it's in .hiddenlines, don't draw it.
		//     - but also don't draw it if there's no triangle with it that
		//       isn't hidden.
		//       - if it's line 0, check index 1. if it's line
		//         (.length - 1), check index (.length - 2).
	}
	function build3dshape(type, dimensions, fineness, offset) {
	// creates an array to be passed onto _3dpoly.
	// - type: a string specifying which kind of shape to build.
	//   - "sphere"
	//     - alternative names: spheroid, ball (none of these shapes are
	//       locked to a 1:1:1 ratio.)
	//     - it can probably be used to make an octahedron if fineness is 4.
	//       TODO
	//   - "cube"
	//     - alternative names: box
	//   - "cone"
	//     - alternative names: pyramid
	//   - "cylinder"
	//     - alternative names: prism
	//   - "disc" (makes circles or regular polygons, parallel to the xy
	//     plane)
	//     - alternative names: circle, polygon
	//   - "square" (makes squares, parallel to the xy plane)
	//     - alternative names: rectangle, rect
	//   - "stairs" (they face the camera. fineness is how many steps it's
	//     divided into)
	// - dimensions: a single value, or an array. if only one value is
	//   specified, it'll be used for all three. if two values are
	//   specified, d will be whichever is smaller.
	// - fineness: used for shapes like sphere and cone. adjusts how many
	//   sides a circle is made of.
	// - offset: by default, 0, 0, 0 will be the center of the shape.
	// - there are no parameters for rotating it. just use revolve.
	//   - TODO eh, maybe i should do this anyway
	// - remember, the structure of the shape object is:
	//   - .points: array of coordinate arrays
	//   - .faces: array of objects
	//     - .faces[facenumber].indexes: point indexes to connect to form a
	//       face
	//     - .faces[facenumber].fill: fill color change
	//       - "default" refers to whatever the fill/stroke style was at the
	//         time of running _3dpoly.
	//     - .faces[facenumber].stroke: stroke color change
	//     - .faces[facenumber].center: changes to the point the faces
	//       face away from (an array of x/y/z coordinates, or a string
	//       saying "default" which sets it back to the average of all
	//       points)
	//     - .faces[facenumber].hide: an array of .faces[facenumber].indexes
	//       indexes indicating lines that shouldn't be drawn
	//   - .colors: array of colors for .fill and .stroke to use. (they can
	//     use the normal formats, but numbers will be converted to
	//     whatever's in here.)
	//   - the face is broken up into triangles by connecting the first
	//     point to all other points.
		var shape = {};
		shape.points = [];
		shape.faces = [];
		shape.colors = [];
		var b3s_temp = 0;
		if(!Array.isArray(offset) || offset.length !== 3) {
			offset = [0, 0, 0];
		};
		if(typeof dimensions === "number") {
			var w = dimensions;
			var h = dimensions;
			var d = dimensions;
		}
		else if(Array.isArray(dimensions)) {
			var w = dimensions[0];
			if(dimensions.length >= 2) {
				var h = dimensions[1];
			};
			if(dimensions.length >= 3) {
				var d = dimensions[2];
			};
			if(!h && h !== 0) {
				var h = w;
			};
			if(!d && d !== 0) {
				var d = Math.min(w, h);
			};
		}
		else {
			console.log("build3dshape ran with invalid dimensions.");
			return [[offset[0], offset[1], offset[2]]];
		};
		if(type==="spheroid" || type==="ball") {
			type = "sphere";
		};
		if(type==="box") {
			type = "cube";
		};
		if(type==="pyramid") {
			type = "cone";
		};
		if(type==="prism") {
			type = "cylinder";
		};
		if(type==="circle" || type==="polygon") {
			type = "disc";
		};
		if(type==="rectangle" || type==="rect") {
			type = "square";
		};
		if(type==="sphere") {
			fineness = 4*Math.floor(fineness/4);
			if(fineness === 0) {
				fineness = 4;
			};
			shape.points = [];
			shape.points[0] = [0, -h/2, 0];
			b3s_temp = [];
			for (b3s_i1 = 1; b3s_i1 < fineness/2; b3s_i1++) {
			// each iteration is a new ring of points.
				b3s_temp[0] = shape.points.length;
				b3s_temp[1] = Math.cos(2*Math.PI*(.25 + b3s_i1/fineness))*w/2;
				// width modifier
				b3s_temp[2] = Math.cos(2*Math.PI*(.25 + b3s_i1/fineness))*d/2;
				// depth modifier
				b3s_temp[3] = -Math.sin(2*Math.PI*(.25 + b3s_i1/fineness))*h/2;
				// height of ring
				// [4] is like [0] but for faces
				for (b3s_i2 = 0; b3s_i2 < fineness; b3s_i2++) {
					shape.points[b3s_temp[0] + b3s_i2] = [Math.cos(2*Math.PI*b3s_i2/fineness)*b3s_temp[1], b3s_temp[3], Math.sin(2*Math.PI*b3s_i2/fineness)*b3s_temp[2]];
				}
				// define the points
				if(b3s_i1===1) {
				// make the top of the sphere, which is like a cone
					shape.faces[0] = {
						indexes: [0, 1, 2],
						center: [0, 0, 0],
						hide: [0, 1, 2],
					};
					for (b3s_i2 = 2; b3s_i2 <= fineness; b3s_i2++) {
						shape.faces[b3s_i2 - 1] = {
							indexes: [0, b3s_i2, (b3s_i2)%fineness + 1],
							hide: [0, 1, 2],
						};
					}
				}
				else {
					b3s_temp[4] = shape.faces.length;
					b3s_temp[5] = shape.points.length - (2*fineness);
					// the index of the first point of the second to last
					// ring
					for (b3s_i2 = 0; b3s_i2 < fineness; b3s_i2++) {
						if((Math.floor(8*(b3s_i1 + .5)/fineness)%2 === 0 && b3s_i1 <= fineness/4) || (Math.floor(8*(b3s_i1 + .5)/fineness)%2 === 1 && b3s_i1 > fineness/4)) {
						//               (circumference fraction)
						// (convert to whole number under 8   )
						// if it's an odd number 1/8 fraction and above the
						// equator or an even number fraction and below the
						// equator
							shape.faces[b3s_temp[4] + b3s_i2] = {
								indexes: [b3s_temp[5] + b3s_i2,  b3s_temp[5] + (b3s_i2 + 1)%fineness, b3s_temp[5] + (b3s_i2 + 1)%fineness + fineness, b3s_temp[5] + b3s_i2 + fineness],
								hide: [0, 1, 2, 3],
								// up cw, down cw, down ccw, up ccw
							};
							//console.log([b3s_i2, shape.faces[b3s_temp[4] + b3s_i2].indexes[1] - (fineness*(b3s_i1 - 2)), shape.faces[b3s_temp[4] + b3s_i2].indexes[2] - (fineness*(b3s_i1 - 1))])
						}
						else if((Math.floor(8*(b3s_i1 + .5)/fineness)%2 === 0 && b3s_i1 > fineness/4) || (Math.floor(8*(b3s_i1 + .5)/fineness)%2 === 1 && b3s_i1 <= fineness/4)) {
						// inverse of that
							shape.faces[b3s_temp[4] + b3s_i2] = {
								indexes: [b3s_temp[5] + b3s_i2 + fineness,  b3s_temp[5] + (b3s_i2 + 1)%fineness + fineness, b3s_temp[5] + (b3s_i2 + 1)%fineness, b3s_temp[5] + b3s_i2],
								hide: [0, 1, 2, 3],
								// down cw, up cw, up ccw, down ccw
							};
							//console.log([b3s_i2, shape.faces[b3s_temp[4] + b3s_i2].indexes[2] - (fineness*(b3s_i1 - 2)), shape.faces[b3s_temp[4] + b3s_i2].indexes[1] - (fineness*(b3s_i1 - 1))])
						}
						else {
							console.log("something went wrong with build3dshape sphere.");
						};
					}
					// the pattern of diagonals should be: ([] represents a
					// 1/4 mark)
					// [] [] [] [] []
					// /\\/\\/\\/\\/\
					// or
					// []  []  []  []  []
					// /\\//\\//\\//\\//\
					// the flow chart of which point to start with goes like
					// this:
					// - is the square within a odd number eighth of the
					//   circumference, or an even number? (if it's centered
					//   on a 1/8 mark due to being divisible by 4 but not
					//   8, round up. or down. whatever, as long as it's
					//   consistent)
					// - odd
					//   - start at the point that's earlier in the
					//     rotation, and outer
					//   - above the equator
					//     - up cw, down cw, down ccw, up ccw
					//   - below the equator
					//     - down cw, up cw, up ccw, down ccw
					// - even
					//   - start at the point that's earlier in the
					//     rotation, and inner
					//   - above the equator
					//     - down cw, up cw, up ccw, down ccw
					//   - below the equator
					//     - up cw, down cw, down ccw, up ccw
					if(b3s_i1===(fineness/2 - 1)) {
					// make the bottom, which is also like a cone
						b3s_temp[5] = shape.points.length - fineness;
						// the index of the first point of the last ring
						b3s_temp[4] = shape.faces.length;
						shape.points[shape.points.length] = [0, h/2, 0];
						for (b3s_i2 = 0; b3s_i2 < fineness; b3s_i2++) {
							shape.faces[b3s_temp[4] + b3s_i2] = {
								indexes: [shape.points.length - 1, b3s_temp[5] + b3s_i2, b3s_temp[5] + (b3s_i2 + 1)%fineness],
								hide: [0, 1, 2],
							};
						}
					};
				};
			}
			// TODO
			// - edit build3dshape and _3dpoly so that points and faces
			//   can be categorized.
			//   - like for this sphere here, i can put all the faces of one
			//     ring into a single array.
			//   - this actually wouldn't be too hard, i'd just have to
			//     rewrite build3dshape and have 3dpoly use .flat on the shape
			//     and face arrays.
			//   - wait no, .indexes doesn't support that kind of complexity.
			//     i'd have to make a format for that, and make it so _3dpoly
			//     can convert that into normal numbers...
			//   - it should also be an object instead of an array, since
			//     the whole point is to make it easier to keep track of all
			//     the points and stuff...
			//   - revolve needs to be able to process it too... shit.
			// - define each triangle of the ends as a separate face
		}
		else if(type==="cube") {
			shape.points = [
				[-w/2, -h/2, -d/2],
				// left top back
				[-w/2, -h/2, d/2],
				// left top front
				[-w/2, h/2, -d/2],
				// left bottom back
				[-w/2, h/2, d/2],
				// left bottom front
				[w/2, -h/2, -d/2],
				// right top back
				[w/2, -h/2, d/2],
				// right top front
				[w/2, h/2, -d/2],
				// right bottom back
				[w/2, h/2, d/2],
				// right bottom front
			];
			shape.faces[0] = {
				indexes: [0, 1, 3, 2],
				center: [0, 0, 0],
				name: "left",
			};
			// left
			shape.faces[1] = {
				indexes: [0, 1, 5, 4],
				name: "top",
			};
			// top
			shape.faces[2] = {
				indexes: [0, 2, 6, 4],
				name: "back",
			};
			// back
			shape.faces[3] = {
				indexes: [4, 5, 7, 6],
				name: "right",
			};
			// right
			shape.faces[4] = {
				indexes: [2, 3, 7, 6],
				name: "bottom",
			};
			// bottom
			shape.faces[5] = {
				indexes: [1, 3, 7, 5],
				name: "front",
			};
			// front
			// TODO remove names
		}
		else if(type==="cone") {
			shape.points = [];
			shape.points[0] = [0, -h/2, 0];
			for (b3s_i1 = 0; b3s_i1 < fineness; b3s_i1++) {
				shape.points[1 + b3s_i1] = [Math.cos(2*Math.PI*b3s_i1/fineness)*w/2, h/2, Math.sin(2*Math.PI*b3s_i1/fineness)*d/2];
			}
			shape.points[shape.points.length] = [0, h/2, 0];
			shape.faces = [];
			shape.faces[0] = {
				indexes: [],
				center: [0, 0, 0],
				hide: [0, fineness + 1],
			};
			for (b3s_i1 = 0; b3s_i1 <= fineness; b3s_i1++) {
				shape.faces[0].indexes[b3s_i1] = b3s_i1;
			}
			shape.faces[0].indexes[shape.faces[0].indexes.length] = 1;
			shape.faces[1] = structuredClone(shape.faces[0]);
			shape.faces[1].indexes[0] = shape.points.length - 1;
		}
		else if(type==="cylinder") {
			shape.points = [];
			shape.points[0] = [0, -h/2, 0];
			for (b3s_i1 = 0; b3s_i1 < fineness; b3s_i1++) {
				shape.points[1 + b3s_i1] = [Math.cos(2*Math.PI*b3s_i1/fineness)*w/2, -h/2, Math.sin(2*Math.PI*b3s_i1/fineness)*d/2];
				shape.points[1 + fineness + 1 + b3s_i1] = [Math.cos(2*Math.PI*b3s_i1/fineness)*w/2, h/2, Math.sin(2*Math.PI*b3s_i1/fineness)*d/2];
			}
			shape.points[fineness + 1] = [0, h/2, 0];
			shape.faces = [];
			shape.faces[0] = {
				indexes: [],
				center: [0, 0, 0],
				hide: [0, fineness + 1],
			};
			for (b3s_i1 = 0; b3s_i1 <= fineness; b3s_i1++) {
				shape.faces[0].indexes[b3s_i1] = b3s_i1;
			}
			shape.faces[0].indexes[shape.faces[0].indexes.length] = 1;
			// complete the circle
			for (b3s_i1 = 1; b3s_i1 <= fineness; b3s_i1++) {
				shape.faces[b3s_i1] = {
					indexes: [b3s_i1, b3s_i1 + fineness + 1, (b3s_i1%fineness) + 1 + fineness + 1, (b3s_i1%fineness) + 1],
					hide: [0, 2],
				};
			}
			b3s_temp = shape.faces.length;
			shape.faces[b3s_temp] = structuredClone(shape.faces[0]);
			delete shape.faces[b3s_temp].center;
			for (b3s_i1 = 0; b3s_i1 < shape.faces[b3s_temp].indexes.length; b3s_i1++) {
				shape.faces[b3s_temp].indexes[b3s_i1] += fineness + 1;
			}
		}
		else if(type==="disc") {
			shape.points = [];
			shape.points[0] = [0, 0, 0];
			for (b3s_i1 = 0; b3s_i1 < fineness; b3s_i1++) {
				shape.points[1 + b3s_i1] = [Math.cos(2*Math.PI*b3s_i1/fineness)*w/2, Math.sin(2*Math.PI*b3s_i1/fineness)*h/2, 0];
			}
			// no sense having duplicate points, so don't complete a full
			// circuit.
			shape.faces = [];
			shape.faces[0] = {
				indexes: [],
				center: [0, 0, -d/2],
				hide: [0, fineness + 1],
			};
			for (b3s_i1 = 0; b3s_i1 <= fineness; b3s_i1++) {
				shape.faces[0].indexes[b3s_i1] = b3s_i1;
			}
			shape.faces[0].indexes[shape.faces[0].indexes.length] = 1;
			// the above for loop goes from the center to all the outer
			// points, but it needs to return to the first outer point in
			// order to form a circle.
			shape.faces[1] = structuredClone(shape.faces[0]);
			shape.faces[1].center[2] *= -1;
			// draw it twice so it's double-sided
		}
		else if(type==="square") {
			shape.points = [
				[-w/2, -h/2, 0],
				// top left
				[w/2, -h/2, 0],
				// top right
				[w/2, h/2, 0],
				// bottom right
				[-w/2, h/2, 0]
				// bottom left
			];
			shape.faces = [];
			shape.faces[0] = {
				indexes: [0, 1, 2, 3],
				center: [0, 0, -d/2],
			};
			shape.faces[1] = structuredClone(shape.faces[0]);
			shape.faces[1].center[2] *= -1;
			// draw it twice so it's double-sided
		}
		else if(type==="stairs") {
			shape.points = [];
			shape.faces = [];
			for(b3s_i1=0; b3s_i1 <= fineness*2; b3s_i1++) {
				shape.points[b3s_i1*2] = [
					-w/2,
					h/2 - h*Math.floor((b3s_i1 + 1)/2)/fineness,
					d/2 - d*Math.floor(b3s_i1/2)/fineness
				];
				shape.points[b3s_i1*2 + 1] = structuredClone(shape.points[b3s_i1*2]);
				shape.points[b3s_i1*2 + 1][0] *= -1;
			};
			// lower points, then higher points
			for(b3s_i1=0; b3s_i1 < fineness*2; b3s_i1++) {
				shape.faces[b3s_i1] = {
					indexes: [b3s_i1*2 + 0, b3s_i1*2 + 1, b3s_i1*2 + 3, b3s_i1*2 + 2],
				};
			};
			shape.faces[0].center = [0, -h/2, d/2];
		};
		// - remember, the structure of the shape object is:
		//   - .points: array of coordinate arrays
		//   - .faces: array of objects
		//     - .faces[facenumber].indexes: point indexes to connect to form a
		//       face
		//     - .faces[facenumber].fill: fill color change
		//       - "default" refers to whatever the fill/stroke style was at the
		//         time of running _3dpoly.
		//     - .faces[facenumber].stroke: stroke color change
		//     - .faces[facenumber].center: changes to the point the faces
		//       face away from (an array of x/y/z coordinates, or a string
		//       saying "default" which sets it back to the average of all
		//       points)
		//     - .faces[facenumber].hide: an array of .faces[facenumber].indexes
		//       indexes indicating lines that shouldn't be drawn
		//   - .colors: array of colors for .fill and .stroke to use. (they can
		//     use the normal formats, but numbers will be converted to
		//     whatever's in here.)
		//   - the face is broken up into triangles by connecting the first
		//     point to all other points.
		for (b3s_i1 = 0; b3s_i1 < shape.points.length; b3s_i1++) {
			shape.points[b3s_i1][0] = Math.round(shape.points[b3s_i1][0]*(10**13))/(10**13) + offset[0];
			shape.points[b3s_i1][1] = Math.round(shape.points[b3s_i1][1]*(10**13))/(10**13) + offset[1];
			shape.points[b3s_i1][2] = Math.round(shape.points[b3s_i1][2]*(10**13))/(10**13) + offset[2];
			// because of the hell that is radians, operations like
			// Math.cos(2*Math.PI*3/4) run long stupid decimals when they
			// should really just give whole numbers. so. this rounds it to
			// the nearest .00000000000001 and also applies offset.
			// - seriously, how the hell are radians standard... this is
			//   like the one instance where i think the us customary system
			//   *isn't* the stupid one
			//   - i think maybe they use this because it makes more sense
			//     in scientific settings? like in physics equations, you
			//     gotta use shit like meters, meters per second, newtons,
			//     etc because all the measurement systems have to be
			//     compatible with each other. but this is still dumb 90% of
			//     the time
		};
		for (b3s_i1 = 0; b3s_i1 < shape.faces.length; b3s_i1++) {
			if(b3s_i1===0 && !shape.faces[b3s_i1].hasOwnProperty("center")) {
				shape.faces[b3s_i1].center = offset;
			}
			else if(shape.faces[b3s_i1].hasOwnProperty("center")) {
				shape.faces[b3s_i1].center[0] = Math.round(shape.faces[b3s_i1].center[0]*(10**13))/(10**13) + offset[0];
				shape.faces[b3s_i1].center[1] = Math.round(shape.faces[b3s_i1].center[1]*(10**13))/(10**13) + offset[1];
				shape.faces[b3s_i1].center[2] = Math.round(shape.faces[b3s_i1].center[2]*(10**13))/(10**13) + offset[2];
			}
		};
		// apply offset
		shape.colors = [];
		// TODO
		// - add modifying features
		//   - multiplying their distance from the edges of the box by a
		//     cosine or whatever (do it to a sphere, and it'll look like a
		//     rounded cube)
		//   - split into two parts using a plane
		return shape;
	}
	function polyjoin(shapes) {
	// returns a combination of all the 3d shapes provided.
	// - shapes should be an array.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		let sumshape = structuredClone(shapes[0]);
		if(!sumshape.hasOwnProperty("colors")) {
			sumshape.colors = [];
		};
		let tempshape = "";
		for(i1 = 1; i1 < shapes.length; i1++) {
			tempshape = structuredClone(shapes[i1]);
			if(tempshape.faces.length > 0) {
				if(!tempshape.faces[0].hasOwnProperty("center")) {
					// if the center isn't specified, it's supposed to be the average of
					// all points, but that won't be in the same place once it's
					// combined with the other shapes
					tempshape.faces[0].center = [0, 0, 0];
					for(i2 = 0; i2 < tempshape.points.length; i2++) {
						tempshape.faces[0].center[0] += tempshape.points[i2][0];
						tempshape.faces[0].center[1] += tempshape.points[i2][1];
						tempshape.faces[0].center[2] += tempshape.points[i2][2];
					}
					tempshape.faces[0].center[0] /= tempshape.points.length;
					tempshape.faces[0].center[1] /= tempshape.points.length;
					tempshape.faces[0].center[2] /= tempshape.points.length;
				};
				if(!tempshape.faces[0].hasOwnProperty("fill")) {
					// if fill isn't specified, it should be reset to the default color
					tempshape.faces[0].fill = "default";
				};
				if(!tempshape.faces[0].hasOwnProperty("stroke")) {
					// if fill isn't specified, it should be reset to the default color
					tempshape.faces[0].stroke = "default";
				};
			};
			for(i2 = 0; i2 < tempshape.faces.length; i2++) {
				for(i3 = 0; i3 < tempshape.faces[i2].indexes.length; i3++) {
					tempshape.faces[i2].indexes[i3] += sumshape.points.length;
				}
				// add the number of points sumshape has to every
				// .faces[x].indexes so it doesn't lead to the wrong points
				if(tempshape.faces[i2].hasOwnProperty("fill") && typeof tempshape.faces[i2].fill === "number") {
					tempshape.faces[i2].fill += sumshape.colors.length;
				};
				if(tempshape.faces[i2].hasOwnProperty("stroke") && typeof tempshape.faces[i2].stroke === "number") {
					tempshape.faces[i2].stroke += sumshape.colors.length;
				};
				// do the same thing for .colors indexes
			}
			sumshape.points = sumshape.points.concat(tempshape.points);
			sumshape.faces = sumshape.faces.concat(tempshape.faces);
			if(tempshape.hasOwnProperty("colors")) {
				sumshape.colors = sumshape.colors.concat(tempshape.colors);
			};
			// merge the points, faces, and colors arrays into sumshape
		}
		return sumshape;
	}
	function polysubdivide(shape, fineness) {
	// returns a version of the shape that has every face broken up into more
	// faces, so you can apply distortion and stuff like that.
	// - fineness: how many segments each edge is broken up into. the square of
	//   this is how many triangles each triangle becomes.
	// - notes for how this works:
	//   - it makes each triangle a separate face
	//   - it splices in duplicates of the faces, fineness^2 - 1 of them
	//   - fancy math time, change the points for each one so they're fragments
	//   - 'imma be real with you, it'll get to be kind of a clusterfuck. the
	//     however, any nonessential properties of a face will be shared by all
	//     the faces it's broken up into, so if you have a "name" property, it
	//     should point you to all the faces that face was made into.
	//     - also all the faces will have adjacent indexes. if the factor is 2,
	//       face 5 will be made into face 12 to 15.
	//       - that's assuming they're all triangles though. you're probably
	//         gonna have to do a little work to get the right index.
	//       - and points do not have the same luxury. new points are tacked
	//         onto the end of the array.
		var newshape = structuredClone(shape);
		var psd_temp = null;
		for(psd_i1=0; psd_i1 < newshape.faces.length; psd_i1++) {
		// runs for every face, breaks it up into triangles
			psd_temp = [];
			logtext = "";
			for(psd_i2=2; psd_i2 < newshape.faces[psd_i1].indexes.length - 1; psd_i2++) {
			// - skip the first triangle, that'll be done by the conditional at
			//   the end since all the others have to reference it
				psd_temp[psd_temp.length] = structuredClone(newshape.faces[psd_i1]);
				psd_temp[psd_temp.length - 1].indexes = [newshape.faces[psd_i1].indexes[0], newshape.faces[psd_i1].indexes[psd_i2], newshape.faces[psd_i1].indexes[psd_i2 + 1]];
				delete psd_temp[psd_temp.length - 1].fill;
				delete psd_temp[psd_temp.length - 1].stroke;
				delete psd_temp[psd_temp.length - 1].center;
				// redundant, the first side should enact all these changes
				if(newshape.faces[psd_i1].hasOwnProperty("hide") && newshape.faces[psd_i1].hide.includes(psd_i2)) {
					psd_temp[psd_temp.length - 1].hide = [0, 1, 2];
				}
				else {
					psd_temp[psd_temp.length - 1].hide = [0, 2];
				};
				// side 1 should be the outer side, so that's the only one that
				// could've been visible before.
				if(psd_i2===newshape.faces[psd_i1].indexes.length - 2) {
					newshape.faces[psd_i1].indexes = newshape.faces[psd_i1].indexes.slice(0, 3);
					// trim it down to the first three indexes
					if(newshape.faces[psd_i1].hasOwnProperty("hide")) {
						for(psd_i3=0; psd_i3 < newshape.faces[psd_i1].hide.length; psd_i3++) {
							if(newshape.faces[psd_i1].hide[psd_i3] >= 2) {
								// remove .hide items that are too high (2 is too high,
								// since that used to refer to an outside line)
								newshape.faces[psd_i1].hide.splice(psd_i3, 1);
								psd_i3--;
							};
						};
						newshape.faces[psd_i1].hide[newshape.faces[psd_i1].hide.length] = 2;
						// that's an inside line now, so get rid of it
					}
					else {
						newshape.faces[psd_i1].hide = [];
						newshape.faces[psd_i1].hide[0] = 2;
					};
				};
			}
			//for(psd_i2 = 0; psd_i2 < psd_temp.length; psd_i2++) {
			for(psd_i2 = psd_temp.length - 1; psd_i2 >= 0; psd_i2--) {
				newshape.faces.splice(psd_i1 + 1, 0, structuredClone(psd_temp[psd_i2]));
			}
			psd_i1 += psd_temp.length;
			// splice in psd_temp, add the length to psd_i1 so it skips them
			// - go backwards so it's in order
		}

		var subdivides = [];
		psd_temp = [];
		for(psd_i1=0; psd_i1 < newshape.faces.length; psd_i1++) {
		// runs for all of the new triangle faces
			// find all the right points, make them into new points and add
			// their indexes to an array
			// -
			subdivides = [];
			// structure is:
			// - steps from point 0 to point 1
			//   - steps from that point to the side between 1 and 2 (which also
			//     means the higher the "x", the few "y"s there are)
			subdivides[0] = [];
			subdivides[0][0] = newshape.faces[psd_i1].indexes[0];
			subdivides[0][fineness] = newshape.faces[psd_i1].indexes[2];
			subdivides[fineness] = [];
			subdivides[fineness][0] = newshape.faces[psd_i1].indexes[1];
			psd_temp = [];
			psd_temp[0] = structuredClone(newshape.points[ newshape.faces[psd_i1].indexes[0] ]);
			// the starting point for the creation of any new point.
			psd_temp[1] = structuredClone(newshape.points[ newshape.faces[psd_i1].indexes[1] ]);
			psd_temp[2] = structuredClone(newshape.points[ newshape.faces[psd_i1].indexes[2] ]);
			// arrays of the distances to move in order to move up one "x" or
			// "y". or they will be, anyway.
			for(psd_i2=0; psd_i2 < 3; psd_i2++) {
				psd_temp[1][psd_i2] -= psd_temp[0][psd_i2];
				psd_temp[1][psd_i2] /= fineness;
				psd_temp[2][psd_i2] -= psd_temp[0][psd_i2];
				psd_temp[2][psd_i2] /= fineness;
			};
			for(psd_i2=0; psd_i2 < fineness; psd_i2++) {
			// make one "x" row (skipping the last since that's only one point)
				if(psd_i2 !== 0) {
					subdivides[psd_i2] = [];
				};
				for(psd_i3=0; psd_i3 <= Math.min(fineness - psd_i2, fineness - 1); psd_i3++) {
				// make one "y" item
				// - don't go to full fineness since [0][fineness] is already
				//   filled
					if(psd_i2===0 && psd_i3===0) {
						psd_i3++;
					};
					psd_temp[3] = structuredClone(psd_temp[0]);
					// stores the coordinates for the new point
					for(psd_i4=0; psd_i4 < 3; psd_i4++) {
						psd_temp[3][psd_i4] += psd_i2*psd_temp[1][psd_i4];
						// move x-wise
						psd_temp[3][psd_i4] += psd_i3*psd_temp[2][psd_i4];
						// move y-wise
					}
					// - with each "x", move side 0/fineness, with every "y"
					//   move side 2/fineness
					newshape.points[newshape.points.length] = structuredClone(psd_temp[3]);
					subdivides[psd_i2][psd_i3] = newshape.points.length - 1;
					// create the point, record the index
				}
			}
			// subdivides array is now filled
			psd_temp = [];
			for(psd_i2=1; psd_i2 < fineness**2; psd_i2++) {
				psd_temp[0] = structuredClone(newshape.faces[psd_i1]);
				psd_temp[2] = psd_i2;
				for(psd_i3=0; psd_temp[2] >= 2*fineness - 1 - 2*psd_i3; psd_i3++) {
					psd_temp[2] -= 2*fineness - 1 - 2*psd_i3;
				}
				psd_temp[1] = psd_temp[2];
				psd_temp[2] = psd_i3;
				// this is the "x" and "y" coordinates of the subtriangle.
				// finding the right corners is another thing entirely though,
				// since some of them are inverted
				delete psd_temp[0].fill;
				delete psd_temp[0].stroke;
				delete psd_temp[0].center;
				psd_temp[0].indexes = [];
				psd_temp[0].indexes[0] = subdivides[ Math.round(psd_temp[1]/2) ][ psd_temp[2] ];
				psd_temp[0].hide = [];
				if(psd_temp[1]%2===1) {
				// if it's an inverted triangle
					psd_temp[0].indexes[1] = subdivides[ Math.round(psd_temp[1]/2) ][ psd_temp[2] + 1 ];
					psd_temp[0].indexes[2] = subdivides[ Math.round(psd_temp[1]/2) - 1 ][ psd_temp[2] + 1 ];
					psd_temp[0].hide = [0, 1, 2];
				}
				else {
					psd_temp[0].indexes[1] = subdivides[ Math.round(psd_temp[1]/2) + 1 ][ psd_temp[2] ];
					psd_temp[0].indexes[2] = subdivides[ Math.round(psd_temp[1]/2) ][ psd_temp[2] + 1 ];
					if(psd_temp[2] !== 0 || newshape.faces[psd_i1].hide.includes(0)) {
					// if it isn't part of what used to be the 0 side, or the first
					// triangle hides that side, hide it
						psd_temp[0].hide[ psd_temp[0].hide.length ] = 0;
					};
					if(psd_temp[1] !== 2*(fineness - 1 - psd_temp[2]) || newshape.faces[psd_i1].hide.includes(1)) {
						psd_temp[0].hide[ psd_temp[0].hide.length ] = 1;
					};
					if(psd_temp[1] !== 0 || newshape.faces[psd_i1].hide.includes(2)) {
						psd_temp[0].hide[ psd_temp[0].hide.length ] = 2;
					};
				};
				newshape.faces.splice(psd_i1 + psd_i2, 0, structuredClone(psd_temp[0]));
			}
			newshape.faces[psd_i1].indexes = [
				subdivides[0][0],
				subdivides[1][0],
				subdivides[0][1]
			];
			newshape.faces[psd_i1].hide[newshape.faces[psd_i1].hide.length] = 1;
			// this should be an inner side
			psd_i1 += fineness**2 - 1;
			// skip all the faces it just made
		}
		return newshape;
	}
	function polyrandomize(shape, range, condensefactor) {
	// randomizes the positions of every point to be moved in a random 3d angle
	// somewhere between 0 and the range provided.
	// - condensefactor: uses randexponent to make it more likely for it to move
	//   less, yet still have the range as a maximum
		let i1 = 0;
		let i2 = 0;
		let anglenum = [];
		let randnum = 0;
		if(!condensefactor) {
			condensefactor = 1;
		};
		for(i1 = 0; i1 < shape.points.length; i1++) {
			anglenum = [Math.random()*2*Math.PI, Math.random()*Math.PI - Math.PI/2];
			// random 3d angle
			anglenum = Angle.numbers(anglenum);
			// convert to 3d equivalent of cos/sin
			randnum = randexponent(condensefactor, true);
			for(i2 = 0; i2 < 3; i2++) {
				shape.points[i1][i2] += anglenum[i2]*randnum*range;
			}
		}
	}
	class Poly {
	// - (changes that can be set by .init or any faces)
	//   - .fill, .stroke
	//   - .center: the point that faces are assumed to face away from. (they
	//     are single-sided.) starts as an average of all points.
	//   - .invert_toggle: switches things so faces face towards the center, or
	//     switches back.
	//     - the reason it's a toggle is because the whole point is that what's
	//       visible becomes invisible and vice versa. wouldn't work well
	//       otherwise.
	//   - .outline
	//     - .color
	//     - .width
	//     =
	//     - starts as always being whatever the stroke currently is.
	//   - .reset (if this boolean is on, it resets everything back to how the
	//     main .init had it, just like exiting/entering a face group.)
	//   - .texture_name (changes which property of .texture to use for a
	//     texture)
	//   - .shader
	//     - .lightmod
	//     - .colormod
	//   =
	//   - enter "default" for any of these and it will reset to how it is
	//     *before* .init. for example, .fill and .stroke start as whatever the
	//     canvas styles were before running Poly.draw.
	//     - for things like shader, it will delete itself.
	// - .points: an array of coordinate arrays.
	// - .faces: an object of objects that store information for a single face.
	//   - .[integer] properties: these represent the individual points.
	//     - .index: which .points this is
	//     - .hide: whether to hide the line from this to the next point
	//     - .texture: texture 2d coordinates
	//   - (changes that can also be set by .init)
	//   - .circular
	//   - .double_sided: makes it so the face will be drawn regardless of which
	//     direction it faces.
	//   =
	//   - property names starting with an underscore are assumed to be
	//     categories. these will also reset any changes and go back to however
	//     things were as of the main .init property.
	//     - .init: these groups can have .inits of their own. they are applied
	//       in addition to the main .init, they do not replace it.
	//     =
	//     - you can nest these.
	//   - triangles are formed by connecting every consecutive pair to the
	//     first point.
	//     - if circular is on, it will also form a triangle with the first,
	//       last, and second. (this doesn't apply to the faces that come after,
	//       it's turned on per face. use it for circles, regular polygons,
	//       etc.)
	//   - don't create a property called "_settingsindex", or "_average".
	//     Poly.draw uses those.
	//     - Poly.draw doesn't modify the shape, and presumably you wouldn't be
	//       counting on it to react to your custom properties so it's not like
	//       it matters that it'll overwrite them.
	//     - so i'm not gonna say anything like "don't name anything this
	//       because it'll fuck up everything". i'm just too paranoid to not
	//       take note of a Forbidden Name for future properties
	// - .texture
	//   - for the sake of Poly.join and all that, this can be an object. or at
	//     least, it should be possible for it to be an object.
	//   - by default, it's assumed .texture is itself an ImageData and you
	//     should use that.
	// - .init
	//   - applies the changes faces can apply, but at the beginning. (for
	//     example, make .fill "orange" and the shape will be orange. you could
	//     do the same thing by editing the first face, but that can get messy)
	// - .staticsettings: static as in they're similar to the face/.init changes
	//   but can't be changed by those.
	//   - .orient: an angle for Poly.draw to use in revolve(), with [0, 0, 0]
	//     as the fulcrum. (this is done before offset is applied.)
	//     - read the comments at the beginning of revolve for information on
	//       what angles are allowed and how they work.
	//   - .offset: coordinates added to every point and center in Poly.draw.
	//   - .double_sided: does the same thing as making every face double-sided.
		constructor(makestructure) {
			if(makestructure) {
				this.points = [];
				this.faces = {};
				this.texture = null;
				this.init = {};
				this.staticsettings = {};
			};
		}
		static build(type, dimensions, fineness, offset, texture) {
		// the successor to build3dshape, which is so old i used var. ew.
		// - type:
		//   - "sphere"
		//     - this is like a latitude/longitude. horizontal rings of
		//       quadrangle faces.
		//   - "cube"
		//   - "cone"
		//     - the circular side is at the bottom, the point is at the top.
		//   - "cylinder"
		//     - the circular sides are at the top and bottom.
		//   - "disc" (circles or regular polygons, parallel to the xy plane)
		//     - alternative names: circle, polygon
		//   - "square" (makes squares, parallel to the xy plane)
		//     - alternative names: rectangle, rect
		//   - "stairs" (they face the camera. fineness is how many steps it's
		//     divided into.)
		//   =
		//   - despite names like "sphere" and "cube", none of these shapes are
		//     locked to a 1:1:1 ratio.
		//   - the "altnames" variable in this function shows other allowed
		//     names like "box" instead of cube.
		// - dimensions:
		//   - an array of width, height, depth
		//   - if it's only one number or an array of one number, it'll use that
		//     for every dimension
		//   - if it's two numbers, they'll be used as width and height, and
		//     depth will be whatever is smaller
		//   - by default, it's 1.
		//   - remember, for spheres and stuff you have to input diameter, not
		//     radius.
		// - fineness:
		//   - this is pretty much "how many sides a circle has".
		//   - ie, a cylinder with 5 fineness will be a pentagonal prism.
		//   - for spheres, it needs to be an even number. it will be ticked up
		//     if it isn't.
		// - offset: an array of three coordinates that it adds to each point at
		//   the end.
		//   - it does NOT use .staticsettings. i recommend using that instead
		//     because it's much easier to edit.
		// - texture: an object for specifying things about the texture
		//   coordinates.
		//   - texture coordinates are, roughly, scaled as what the dimensions
		//     of the shape should be.
		//   - .scalable: boolean for whether it should create it as if it's a
		//     1:1:1 shape. (the highest dimension is used.)
		//     - this is ideal for a shape whose dimensions might change, but
		//       the default is better for a more consistent pixel size.
		//   - .no_infinites: coordinates are not multiplied by pi or square
		//     roots or anything like that. instead it uses an approximate.
		//     - those are more accurate or whatever, but they also guarantee
		//       every coordinate is an infinite decimal and that can look weird
		//       and asymmetrical.
		//     - this does not avoid infinites caused by simple division,
		//       however. like, if you make a sphere with 6 fineness, every cell
		//       will be the diameter divided by 6, so there will be infinite
		//       decimals.
		//     - it will use 3 in place of pi.
		//   - note that Poly.build does not create a texture image, which means
		//     you don't have to worry about deleting texture coordinates if you
		//     don't want texturing.
		//     - Poly.draw only runs texturing if the points have texture
		//       coordinates and the texture isn't null.
		//     - but if you wanna omit it to make sure the object isn't bigger
		//       than it has to be, use an "omit" string.
		//   - .type: used in certain shapes. a string specifying a different
		//     way of assigning coordinates.
		//   - how the textures are mapped:
		//     - NOTE: generally, xz angle correlates to x position on the
		//       texture image, but this is inverted. angles close to 360 are on
		//       the left, angles close to 0 are on the right.
		//       - this is because 0 xz is the right, 90 xz is the front, 180 is
		//         left, 270 is the back... if you look at one face of a sphere,
		//         the left side is the one with *more* xz angle, not less.
		//     - NOTE: for circular features, it generally uses a fraction of a
		//       circumference rather than the actual side length.
		//     - sphere:
		//       - if .type === "square": a square grid where x is xz angle and
		//         y is which ring of faces it is. except for the top and
		//         bottom, which are isosceles triangles.
		//     - cylinder:
		//       - the top as a circle, the bottom right next to it, and the
		//         sides on the bottom.
		//       - if .type === "teeth": the top and bottom are two interlocked
		//         rows of triangles. (the leftmost tooth is part of the top.)
		//     - cube: a sideways T.
		//       - front, right, back, left, and top and bottom above and below
		//         the front side.
		//     - cone TODO
		//     - disc, square: these are just 2d versions of the shapes,
		//       positioned whatever way will guarantee the leftmost/upmost
		//       point at 0 x/y
		//     - stairs
		//   - .symmetry property
		//     - there's no rule against using the same part of a texture for
		//       multiple faces. it's actually pretty common since it means the
		//       texture can be smaller.
		//     - this property is an object that lets you specify which faces
		//       should be duplicates. it works differently for each shape
		//       though.
		//     =
		//     - multiple
		//       - radial: faces that are all part of the same circle share
		//         textures.
		//         - if this is a number, instead there will be multiple
		//           textures that it alternates between. (if it's 3 and this is
		//           used on a shape with 9 fineness, faces that are at position
		//           0, 3, and 6 will use the first texture, 1, 4, and 7 will
		//           use the second, etc)
		//         =
		//         - sphere
		//         - cone
		//         - cylinder
		//         - disc
		//     - sphere
		//       - vertical: there's only a single square texture for every
		//         column of faces. (the top and bottom will use the midpoint of
		//         the top/bottom edge of this square to form an isosceles
		//         triangle.)
		//         - like radial symmetry, you can specify how many faces to
		//           alternate between.
		//     - cube
		//       - x, y, z: the two sides of whatever specified axis match each
		//         other.
		//         - specifically, the coordinates are oriented so that every
		//           pixel directly matches the opposite side... but this also
		//           means that if you have an F on the top side, it'll be
		//           mirrored on the bottom side.
		//     - cone
		//     - cylinder
		//       - bases: same as cube's axis symmetries, but only for the top
		//         and bottom.
		//     - disc, square
		//       - other: the back side matches the front. NOTE this works
		//         differently than the others, it alters the actual shape. only
		//         one face is made, which is double-sided. (as opposed to
		//         duplicates that face opposite directions.)
		//     - stairs
		//       - sides
		//         - works like cube's symmetries.
		//       - tops: the tops of each step match. (you can specify how many
		//         rectangles to alternate between, like radial symmetry.)
		//       - fronts: same thing for the front of each step
		//       - topandfront: tops and fronts use the same set of rectangles
		// - log an example of the shape you're about to make if you want to
		//   know how the faces are structured.
		// - don't forget to add these, because this sure doesn't
		//   - .init
		//     - .fill, .stroke
		//     - if you're combining this with something
		//       - .reset
		//       - .center (it sets this as [0, 0, 0] or whatever offset is)
		//       - .texture_name
		//     - .shader (absent, which means )
		//       - .lightmod
		//       - .colormod
		//   - .staticsettings
		//     - .orient
		//     - .offset (the offset parameter is added to the points manually
		//       instead of using this, because that makes more sense when
		//       combining shapes)
		//     - .double_sided
		//   - .texture
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let altnames = {
				sphere: ["spheroid", "ball"],
				cube: ["box"],
				cone: ["pyramid"],
				cylinder: ["prism"],
				disc: ["circle", "polygon"],
				square: ["rectangle", "rect"],
				stairs: ["steps"],
			};
			if(typeof type !== "string") {
			// if they used false or something to skip it, use sphere
				type = "sphere";
			}
			else if(!altnames.hasOwnProperty(type)) {
			// if it's not one of the "correct" names, search the alternate
			// names, and use sphere if nothing matches
				let temp = false;
				for (i1 in altnames) {
					if (altnames.hasOwnProperty(i1) && altnames[i1].includes(type)) {
						type = i1;
						temp = true;
					}
				}
				if(!temp) {
					console.log("invalid shape type: " + type);
					type = "sphere";
				}
			};
			let w = null;
			let h = null;
			let d = null;
			if(typeof dimensions === "number") {
				w = dimensions;
				h = dimensions;
				d = dimensions;
			}
			if(typeof dimensions === "object") {
				let temp = [
					dimensions.hasOwnProperty(0) && typeof dimensions[0] === "number",
					dimensions.hasOwnProperty(1) && typeof dimensions[1] === "number",
					dimensions.hasOwnProperty(2) && typeof dimensions[2] === "number"
				];
				if(temp[0]) {
					if(!temp[1] && !temp[2]) {
					// one number
						w = dimensions[0];
						h = dimensions[0];
						d = dimensions[0];
					}
					else if(temp[1] && !temp[2]) {
					// two numbers
						w = dimensions[0];
						h = dimensions[1];
						d = Math.min(dimensions[0], dimensions[1]);
					}
					else if(temp[1] && temp[2]) {
					// three
						w = dimensions[0];
						h = dimensions[1];
						d = dimensions[2];
					};
				};
			}
			else if(typeof dimensions === "number") {
				w = dimensions;
				h = dimensions;
				d = dimensions;
			};
			w ??= 1;
			h ??= 1;
			d ??= 1;
			if(typeof fineness !== "number" || fineness <= 0) {
				fineness = 16;
			};
			if(type === "sphere") {
				fineness = 2*Math.ceil(fineness/2);
			}
			else {
				fineness = Math.floor(fineness);
			};
			if(!Array.isArray(offset)) {
				offset = [0, 0, 0];
			};
			let poly = new Poly(true);
			function convertfaces(facesobj) {
				function facefromindexes(array) {
				// takes an array of .points indexes and converts it into a proper
				// face.
					let i1 = 0;
					let obj = {};
					for (i1 = 0; i1 < array.length; i1++) {
						obj[i1] = {
							index: array[i1],
						};
					}
					return obj;
				}
				let i1 = 0;
				for (i1 in facesobj) {
					if (facesobj.hasOwnProperty(i1)) {
						if(i1.startsWith("_")) {
						// face category
							convertfaces(facesobj[i1]);
						}
						else if(i1 !== "init") {
						// face
							facesobj[i1] = facefromindexes(facesobj[i1]);
						};
					}
				}
			}
			function addring(pointsarray, position, radius, axis) {
			// adds a ring of points along the xy, xz, or yz axis.
			// - DRY and all that.
			// - position can be a three coordinate array or just a single
			//   number. if it's a single number, it's assumed to be on whatever
			//   axis the circle is perpendicular to.
				let i1 = 0;
				radius = typeof radius === "number" ? radius : 1;
				axis = ["xy", "xz", "yz"].includes(axis) ? axis : "xz";
				let axes = {
					pos: ["yz", "xz", "xy"].indexOf(axis),
					// axis to use the specified position for
				};
				axes.cos = "xyz".indexOf(axis.charAt(0));
				axes.sin = "xyz".indexOf(axis.charAt(1));
				if(!Array.isArray(position)) {
					let temp = position;
					position = [0, 0, 0];
					if(typeof temp === "number") {
						position[axes.pos] = temp;
					};
				};
				for (i1 = 0; i1 < fineness; i1++) {
					pointsarray[pointsarray.length] = structuredClone(position);
					pointsarray[pointsarray.length - 1][axes.cos] += radius*Math.cos(2*Math.PI*i1/fineness);
					pointsarray[pointsarray.length - 1][axes.sin] += radius*Math.sin(2*Math.PI*i1/fineness);
				}
			}
			function discindexes(center, ringstart) {
			// returns an array of indexes that can form a circle, the point of
			// a cone, the cap of a sphere, etc.
			// - it's an array so it won't screw up convertfaces.
			// - NOTE don't forget to add .circular after it's converted.
				let i1 = 0;
				let array = [center];
				for (i1 = 0; i1 < fineness; i1++) {
					array[array.length] = ringstart + i1;
				}
				return array;
			}
			// NOTE for the initial construction, point positions will stay
			// between -1 and 1. it's multiplied by the dimensions divided by 2,
			// later...
			// NOTE the pattern for creating rectangular faces is top-left,
			// top-right, bottom-right, bottom-left. for circular faces, it's in
			// order of angle
			// - actually, just look at the cube logic. basically, that's my
			//   order for the front side, and the other sides i just rotate the
			//   cube xz/yz in my head to make that side the front and do the
			//   same thing.
			if(type === "sphere") {
				// yyysphere
				let ring = {
					num: -1,
					// this starts at -1 because the first "ring" is the top of
					// the sphere, which can't create a ring of faces.
					y: null,
					r: null,
					start: 0,
					ref: null,
				};
				for (i1 = -1; i1 < fineness/2; i1++) {
				// makes a ring of points, then a ring of faces with the
				// previous ring.
					let angle = (-1/4 + (i1 + 1)/fineness)*2*Math.PI;
					ring.y = Math.sin(angle);
					ring.r = Math.abs(Math.cos(angle));
					ring.start = poly.points.length;
					// index this ring starts at
					ring.cap = false;
					if(i1 !== -1) {
						poly.faces["_" + i1] = {};
						ring.ref = poly.faces["_" + i1];
					};
					if([-1, fineness/2 - 1].includes(i1)) {
					// if the newest ring is the very top or the very bottom of
					// the sphere, only make one point
						poly.points[poly.points.length] = [0, Math.sign(angle), 0];
					}
					else {
						addring(poly.points, ring.y, ring.r, "xz");
					};
					// make the points
					if(i1 !== -1) {
						for (i2 = 0; i2 < fineness; i2++) {
						// connect the previous set of points to the new set of
						// points
						// - can't do this for the top, because there is no
						//   previous set of points.
							ring.ref[i2] = [
								ring.start + (i2 + 1)%fineness - fineness,
								ring.start + i2 - fineness,
								ring.start + i2,
								ring.start + (i2 + 1)%fineness
							];
							// needs to go in a c motion, so next meridian
							// to this meridian to this meridian to next
							// meridian. subtract fineness from the first
							// two to put them in the previous ring.
							if(i1 === 0) {
							// top of sphere
								ring.ref[i2].splice(0, 2, ring.start - 1);
							}
							else if(i1 === fineness/2 - 1) {
							// bottom of sphere
								ring.ref[i2].splice(2, 2, ring.start);
							}
						}
					}
					// make the faces
					ring.num++
				}
				// make the second cap/point
				convertfaces(poly.faces);
				for (i1 in poly.faces) {
					if (poly.faces.hasOwnProperty(i1)) {
					// run for every ring
						for (i2 in poly.faces[i1]) {
							if (poly.faces[i1].hasOwnProperty(i2)) {
							// run for every face
								for (i3 in poly.faces[i1][i2]) {
									if (poly.faces[i1][i2].hasOwnProperty(i3) && !isNaN(Number(i3))) {
									// run for every point
										poly.faces[i1][i2][i3].hide = true;
										// hide all edges.
									}
								}
							}
						}
					}
				}
				// i have no idea if this will work. it'll probably won't, at
				// first. this logic is hard.
			}
			else if(type === "cube") {
				for (i1 = 0; i1 < 8; i1++) {
					poly.points[i1] = [
						i1%8 < 4 ? -1 : 1,
						i1%4 < 2 ? -1 : 1,
						i1%2 < 1 ? -1 : 1
					];
				};
				// 0 000 left  top    back
				// 1 001 left  top    front
				// 2 010 left  bottom back
				// 3 011 left  bottom front
				// 4 100 right top    back
				// 5 101 right top    front
				// 6 110 right bottom back
				// 7 111 right bottom front
				poly.faces = {
					left	: [0, 1, 3, 2],
					right	: [5, 4, 6, 7],
					top		: [0, 4, 5, 1],
					bottom	: [3, 7, 6, 2],
					back	: [0, 4, 6, 2],
					front	: [1, 5, 7, 3],
				};
				convertfaces(poly.faces);
			}
			else if(type === "cone") {
				poly.points[poly.points.length] = [0, -1, 0];
				addring(poly.points, 1, 1, "xz");
				poly.points[poly.points.length] = [0, 1, 0];
				poly.faces.top = discindexes(0, 1);
				poly.faces.base = discindexes(1 + fineness, 1);
				convertfaces(poly.faces);
				poly.faces.top.circular = true;
				poly.faces.base.circular = true;
			}
			else if(type === "cylinder") {
				poly.points[poly.points.length] = [0, -1, 0];
				addring(poly.points, -1, 1, "xz");
				poly.points[poly.points.length] = [0, 1, 0];
				addring(poly.points, 1, 1, "xz");
				poly.faces.top = discindexes(0, 1);
				for (i1 = 0; i1 < fineness; i1++) {
					poly.faces[i1] = [
						1 + i1,
						1 + (i1 + 1)%fineness,
					];
					poly.faces[i1][2] = (1 + fineness) + poly.faces[i1][1];
					poly.faces[i1][3] = (1 + fineness) + poly.faces[i1][0];
				}
				poly.faces.bottom = discindexes(1 + fineness, 1 + fineness + 1);
				convertfaces(poly.faces);
				poly.faces.top.circular = true;
				poly.faces.bottom.circular = true;
				for (i1 = 0; i1 < fineness; i1++) {
					poly.faces[i1][1].hide = true;
					poly.faces[i1][3].hide = true;
				}
			}
			else if(["disc", "square"].includes(type)) {
				if(type === "disc") {
					poly.points[poly.points.length] = [0, 0, 0];
					addring(poly.points, 0, 1, "xy");
					poly.faces.front = discindexes(0, 1);
					poly.faces.back = discindexes(0, 1);
				}
				else if(type === "square") {
					for (i1 = 0; i1 < 4; i1++) {
						poly.points[i1] = [
							i1%4 < 2 ? -1 : 1,
							i1%2 < 1 ? -1 : 1,
							0
						];
					};
					// 0 00 left  top
					// 1 01 left  bottom
					// 2 10 right top
					// 3 11 right bottom
					poly.faces = {
						front: [0, 1, 3, 2],
						back: [0, 1, 3, 2],
					};
				}
				convertfaces(poly.faces);
				poly.faces.front.circular = true;
				poly.faces.back.circular = true;
				poly.faces.front.center = [0, 0, -1];
				poly.faces.back.center = [0, 0, 1];
			}
			else if(type === "stairs") {
				poly.points = [
					[-1, 1, -1],
					// bottom left back
					[1, 1, -1]
					// bottom right back
				];
				// bottom back corners
				poly.faces = {
					left: [0],
					right: [1],
					_tops: {},
					_fronts: {},
				}
				let temp1 = null;
				let temp2 = "";
				for (i1 = 0; i1 <= fineness; i1++) {
				// create four points for each step. (plus the two points on the
				// bottom. those aren't part of the top of any step.)
					temp1 = [
						-1,
						-1 + 2*i1/fineness,
						-1 + 2*i1/fineness
					];
					// the left back point of a stair's top
					poly.points[poly.points.length] = structuredClone(temp1);
					poly.points[poly.points.length] = structuredClone(temp1);
					poly.points[poly.points.length - 1][0] *= -1;
					// invert x to make right back point
					temp2 = poly.points.length - 1;
					poly.faces.left[poly.faces.left.length] = temp2 - 1;
					poly.faces.right[poly.faces.right.length] = temp2;
					// add to left/right sides
					if(i1 === 0) {
					// create back side
						poly.faces.back = [temp2 - 1, temp2, 0, 1];
						// top left back, top right back, bottom right back, bottom left back
					}
					else {
					// create the front face of a step using the front two
					// points from the last step.
						poly.faces._fronts[i1 - 1] = [temp2 - 3, temp2 - 2, temp2, temp2 - 1];
					};
					if(i1 === fineness) {
					// create bottom side
						poly.faces.bottom = [temp2 - 1, temp2, 1, 0];
						// bottom left front, bottom right front, bottom right back, bottom left back
					}
					else {
					// create the front two points.
						poly.points[poly.points.length] = structuredClone(temp1);
						poly.points[poly.points.length - 1][2] += 2*1/fineness;
						// add one step's worth of z
						poly.points[poly.points.length] = structuredClone(poly.points[poly.points.length - 1]);
						poly.points[poly.points.length - 1][0] *= -1;
						// copy and invert x
						temp2 = poly.points.length - 1;
						poly.faces.left[poly.faces.left.length] = temp2 - 1;
						poly.faces.right[poly.faces.right.length] = temp2;
						poly.faces._tops[i1] = [temp2 - 3, temp2 - 2, temp2, temp2 - 1];
						// add to left/right sides, create the top of a step
						// using all four points made this iteration.
					};
				}
				convertfaces(poly.faces);
			};
			// end of basic construction
			function finalcoordinates(point) {
				return [
					offset[0] + point[0]*w/2,
					offset[1] + point[1]*h/2,
					offset[2] + point[2]*d/2
					// halved because the initial construction places them between
					// -1 and 1 (ie they're 2 wide)
				];
			}
			for (i1 = 0; i1 < poly.points.length; i1++) {
				poly.points[i1] = finalcoordinates(poly.points[i1]);
			}
			let settings = Poly.allfaces(poly.faces, true);
			for (i1 = 0; i1 < settings.length; i1++) {
				if(settings[i1].hasOwnProperty("center")) {
					settings[i1].center = finalcoordinates(settings[i1].center);
				};
			}
			poly.init = {
				center: structuredClone(offset),
			};
			return poly;
		}
		static facetris(face) {
		// returns an array of all the triangles in a face.
		// - these are all arrays with three numbers, all of which are indexes
		//   for which point of the face they are. (that's not to be confused
		//   with indexes of .point.)
			let array = [];
			let facelength = objarraylength(face);
			let circular = !!face.circular && facelength > 3;
			let i1 = 0;
			for (i1 = 0; i1 < facelength; i1++) {
				if (i1 !== 0 && (circular || i1 !== facelength - 1)) {
					array[array.length] = [0, i1, (i1 + 1)%facelength];
				}
			}
			return array;
		}
		static tristroke(face, tri) {
		// returns an array of three booleans for which edges of a triangle
		// should be drawn.
		// - tri should be an array of three indexes, like what facetris
		//   returns.
			let numofpoints = objarraylength(face);
			let _return = [];
			let i1 = 0;
			for (i1 = 0; i1 < 3; i1++) {
				let pointA = tri[i1];
				let pointB = tri[(i1 + 1)%3];
				_return[i1] = false;
				if(!!face[pointA].hide) {
				// hide hides lines. end of story.
				}
				else if(pointA === numofpoints - 1) {
				// the normal flow is:
				// - tris: [0, 1, 2], [0, 2, 3]
				// - lines: 0 to 1 to 2 to 3 to 0
				// circular is like:
				// - tris: [0, 1, 2], [0, 2, 3], [0, 3, 1]
				// - lines: 1 to 2 to 3 to 1
					_return[i1] = pointB === (!!face.circular ? 1 : 0);
				}
				else {
					_return[i1] = (
						pointB - pointA === 1
						&&
						(
							!face.circular
							||
							pointA !== 0
						)
					);
				};
			}
			return _return;
		}
		// yyydraw
		draw(viewer, ctx, offset, orient, weight, etc) {
		// - offset: applied to all coordinates when drawing.
		// - orient: an angle to use with revolve(). [0, 0, 0] is the center of
		//   rotation. (this is done before offset is applied.)
		// - weight: line weight passed to _3dline
		// - etc: a series of special commands.
		//   - "wireframe": no fill will be done, and stroke will always be done
		//     regardless of which direction the triangle faces.
		//   - "tri": all triangles' strokes will be drawn.
		//   - "lineless": stroke will not be drawn.
		//   - "double-sided": faces will be drawn regardless of their
		//     direction.
		//   =
		//   - you can use multiple of these by making them an array.
		// =
		// - NOTE: if something has gone wrong, there's a good chance of it
		//   being the shape, not Poly.draw. doublecheck both.
			console.log(this);
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let _default = {
				fill: ctx.fillStyle,
				stroke: ctx.strokeStyle,
				center: [0, 0, 0],// this is changed to the average of all points, later
				invert: false,
				texture_name: null,
			};
			// - (changes that can be set by .init or any faces)
			//   - .fill, .stroke
			//   - .center
			//   - .invert_toggle
			//   - .outline
			//     - .color
			//     - .width
			//   - .reset
			//   - .texture_name
			//   - .shader
			//     - .lightmod
			//     - .colormod
			etc = (typeof etc === "string" || Array.isArray(etc) ? etc : []);
			// if it's nullish, it'll turn up errors
			let _this = structuredClone(this);
			let _offset = offset ? structuredClone(offset) : [];
			for (i1 = 0; i1 < 3; i1++) {
				_offset[i1] = typeof _offset[i1] === "number" && !isNaN(_offset[i1]) ? _offset[i1] : 0;
				if(!!_this.staticsettings && !!_this.staticsettings.offset) {
					_offset[i1] += _this.staticsettings.offset[i1];
				};
			}
			if(_this.staticsettings.orient) {
				_this.points = revolve(_this.staticsettings.orient, _this.points);
			};
			if(orient) {
				_this.points = revolve(orient, _this.points);
			};
			for (i1 = 0; i1 < _this.points.length; i1++) {
				_this.points[i1][0] += _offset[0];
				_this.points[i1][1] += _offset[1];
				_this.points[i1][2] += _offset[2];
				_default.center[0] += _this.points[i1][0];
				_default.center[1] += _this.points[i1][1];
				_default.center[2] += _this.points[i1][2];
			};
			_default.center[0] /= _this.points.length;
			_default.center[1] /= _this.points.length;
			_default.center[2] /= _this.points.length;
			let settings = structuredClone(_default);
			function reset() {
			// sets settings back to whatever it was right after the main .init.
				settings = structuredClone(_default);
				applychanges(_this.init);
			};
			let possiblechanges = [
				"reset",
				"fill",
				"stroke",
				"center",
				"invert_toggle",
				"outline",
				"texture_name",
				"shader"
			];
			function applychanges(object) {
			// applies the changes stored in a .init or face to settings.
			// - object: the .init or face
				let i1 = 0;
				let i2 = 0;
				let change = "";
				for (i1 = 0; i1 < possiblechanges.length; i1++) {
					change = possiblechanges[i1];
					if(object.hasOwnProperty(change)) {
						if(object[change] === "default") {
							if(_default.hasOwnProperty(change)) {
								settings[change] = structuredClone(_default[change]);
							}
							else {
								delete settings[change];
							}
						}
						else if(change === "reset") {
							reset();
						}
						else if(["fill", "stroke", "center", "texture_name"].includes(change)) {
							settings[change] = structuredClone(object[change]);
						}
						else if(change === "invert_toggle") {
							settings.invert = !settings.invert;
						}
						else if(change === "outline") {
							if(!settings.outline) {
								settings.outline = {
									color: settings.stroke,
									// this makes it use whatever the stroke currently
									// is.
									width: false,
								};
							};
							if(!!object.outline.color) {
								settings.outline.color = (
									object.outline.color === "default"
									?
									_default.stroke
									:
									object.outline.color
								);
							};
							if(object.outline.hasOwnProperty("width")) {
								settings.outline.width = object.outline.width;
							};
						}
						else if(change === "shader") {
							if(!settings.shader) {
								settings.shader = {
									lightmod: null,
									colormod: null,
								};
							};
							let temp = ["lightmod", "colormod"];
							for (i2 = 0; i2 < temp.length; i2++) {
								if(object.shader.hasOwnProperty(temp[i2])) {
									settings.shader[temp[i2]] = structuredClone(object.shader[temp[i2]]);
								};
							}
						};
					}
				}
			};
			applychanges(_this.init);
			let facesettings = [];
			// an array of the different settings different faces have. every time it
			// applies a change from .inits or faces, it will add a new object to this
			// array.
			facesettings[0] = structuredClone(settings);
			let faces = [];
			// this is an array of faces in a "workable" form. what that means is:
			// - all of the faces are in one linear array, instead of being in
			//   categories. (it has to be in one array for it to be sorted by z.)
			// - all data related to changes is gone.
			// - there's the ._settingsindex property, which tells it which facesettings
			//   to use, and the ._average property which stores the average coordinates
			//   of all points.
			function haschanges(object) {
				let i1 = 0;
				for (i1 = 0; i1 < possiblechanges.length; i1++) {
					if(object.hasOwnProperty(possiblechanges[i1])) {
						return true;
					}
				}
				return false;
			}
			function deletechanges(object) {
				let i1 = 0;
				for (i1 = 0; i1 < possiblechanges.length; i1++) {
					if(object.hasOwnProperty(possiblechanges[i1])) {
						delete object[possiblechanges[i1]];
					}
				}
			}
			// - _this: this should be "this", (the shape inputted into
			//   Poly.draw, which functions should not edit) not "_this" (the
			//   copy Poly.draw makes to get around not being allowed to edit
			//   this)
			//   - used in methods.
			function makeworkable(facesobj, keychain) {
			// converts faces to a workable form and adds them to the faces array. this
			// should be applied to a whole object of faces, because it recurses for
			// face groups.
			// - keychain: used in recursion
				let i1 = 0;
				let i2 = 0;
				if(keychain === undefined) {
					keychain = [];
				};
				for (i1 in facesobj) {
					if (facesobj.hasOwnProperty(i1)) {
						if(i1.startsWith("_")) {
						// face group
							let settingstemp = structuredClone(settings);
							reset();
							keychain[keychain.length] = i1;
							let categoryref = _this.faces;
							for (i2 = 0; i2 < keychain.length; i2++) {
								categoryref = categoryref[keychain[i2]];
								if(categoryref.hasOwnProperty("init")) {
									applychanges(categoryref.init);
								};
							}
							// apply the changes stored in the whole lineage of
							// categories
							facesettings[facesettings.length] = structuredClone(settings);
							makeworkable(facesobj[i1], keychain);
							settings = structuredClone(settingstemp);
							// go back to whatever it was back before this category, so
							// that the faces after it aren't affected by what i just
							// did.
							keychain = [];
							// the keychain won't apply to faces after this
							// category, so get rid of that too.
						}
						else if(i1 !== "init") {
						// face
							let booltemp = haschanges(facesobj[i1]);
							if(booltemp) {
							// has changes to apply and save
								applychanges(facesobj[i1]);
								facesettings[facesettings.length] = structuredClone(settings);
							};
							faces[faces.length] = structuredClone(facesobj[i1]);
							if(booltemp) {
								deletechanges(faces[faces.length - 1]);
							};
							faces[faces.length - 1]._settingsindex = facesettings.length - 1;
						};
					};
				}
			}
			makeworkable(_this.faces);
			// - make a settings array.
			// - run through every face
			// - every time there's a change, apply it to the temporary settings
			//   variable, and add a structured clone as a new index.
			// - save this index for each face.
			for (i1 = 0; i1 < facesettings.length; i1++) {
				if(facesettings[i1].hasOwnProperty("center")) {
				// apply offset to center changes
					if(_this.staticsettings.orient) {
						facesettings[i1].center = revolve(_this.staticsettings.orient, facesettings[i1].center);
					};
					if(orient) {
						facesettings[i1].center = revolve(orient, facesettings[i1].center);
					};
					facesettings[i1].center[0] += _offset[0];
					facesettings[i1].center[1] += _offset[1];
					facesettings[i1].center[2] += _offset[2];
				}
			}
			function facecoord(face, point) {
			// returns the coordinates of a specified face point.
				return structuredClone(_this.points[face[point].index]);
			};
			function tridirection(tri, center, invert) {
			// returns the angle for which direction the triangle faces.
			// - tri should be three coordinates.
			// - center must be specified, yes. technically it could maybe figure
			//   this out on its own but that'd be slower for where i'm using this
			//   function.
				let angle = Plane.frompoints(tri).line().angle;
				let anglenum = Angle.numbers(angle);
				let average = [
					(tri[0][0] + tri[1][0] + tri[2][0])/3,
					(tri[0][1] + tri[1][1] + tri[2][1])/3,
					(tri[0][2] + tri[1][2] + tri[2][2])/3,
				];
				let plusdist = Math.hypot(
					average[0] + anglenum[0] - center[0],
					average[1] + anglenum[1] - center[1],
					average[2] + anglenum[2] - center[2]
				);
				let minusdist = Math.hypot(
					average[0] - anglenum[0] - center[0],
					average[1] - anglenum[1] - center[1],
					average[2] - anglenum[2] - center[2]
				);
				return (invertboolean(plusdist < minusdist, invert) ? Angle.invert(angle) : angle);
				// invert the angle if it points towards the center instead of away.
				// (switch it around if invert is on.)
			};
			// functions i'll need for calculating position and direction
			for (i1 = 0; i1 < faces.length; i1++) {
			// calculate and add ._average
				faces[i1]._average = [0, 0, 0];
				let numofpoints = objarraylength(faces[i1]);
				//let highestz = null;
				for (i2 = 0; i2 < numofpoints; i2++) {
					//let temp = this.points[faces[i1][i2].index];
					let temp = facecoord(faces[i1], i2);
					faces[i1]._average[0] += temp[0];
					faces[i1]._average[1] += temp[1];
					faces[i1]._average[2] += temp[2];
					//if(temp[2] > highestz || highestz === null) {
						//highestz = temp[2];
					//}
				}
				faces[i1]._average[0] /= numofpoints;
				faces[i1]._average[1] /= numofpoints;
				faces[i1]._average[2] /= numofpoints;
				// i don't wanna do all of this in the sorting function because
				// then it'll be done on every comparison...
				//faces[i1]._highestz = highestz;
			}
			function zsort(a, b) {
				return a._average[2] - b._average[2];
				//return a._highestz - b._highestz;
			};
			faces.sort(zsort);
			// sorts it by whatever the average z position of their points is
			for (i1 = 0; i1 < faces.length; i1++) {
			// draw each face, finally
				let _settings = facesettings[ faces[i1]._settingsindex ];
				// underscored so it's distinct from the temporary settings object i
				// used to make facesettings.
				ctx.fillStyle = _settings.fill;
				ctx.strokeStyle = _settings.stroke;
				// apply color changes. these are the only _settings properties where
				// they have to be applied to a specific object rather than the code
				// referencing _settings...
				//console.log(_settings.center.toString());
				let f = faces[i1];
				// for easy reference
				let facetris = Poly.facetris(f);
				//
				// check for errors in facesettings
				// draw triangles
				// draw outline
				for (i2 = 0; i2 < facetris.length; i2++) {
				// each item of facetris is an array of the numbers for three points of
				// the face.
				// - it's best to leave the triangulation to a separate function, for
				//   the sake of DRY and to make it easier to change how it works...
					facetris[i2] = {
						0: facecoord(f, facetris[i2][0]),
						1: facecoord(f, facetris[i2][1]),
						2: facecoord(f, facetris[i2][2]),
						indexes: structuredClone(facetris[i2]),
					};
					let temp = [false, false, false];
					for (i3 = 0; i3 < this.points.length; i3++) {
						if(compareobject(this.points[i1], facetris[i2][0])) {
							temp[0] = true;
						}
						if(compareobject(this.points[i1], facetris[i2][1])) {
							temp[1] = true;
						}
						if(compareobject(this.points[i1], facetris[i2][2])) {
							temp[2] = true;
						}
					}
					facetris[i2]._average = [
						(facetris[i2][0][0] + facetris[i2][1][0] + facetris[i2][2][0])/3,
						(facetris[i2][0][1] + facetris[i2][1][1] + facetris[i2][2][1])/3,
						(facetris[i2][0][2] + facetris[i2][1][2] + facetris[i2][2][2])/3
					];
				};
				facetris.sort(zsort);
				for (i2 = 0; i2 < facetris.length; i2++) {
					let tri = facetris[i2];
					let strokes = etc.includes("tri") ? [true, true, true] : Poly.tristroke(f, tri.indexes);
					// an array of which sides of the triangles are drawn. (tri
					// mode makes it so all of them are)
					if(!!_settings.outline) {
					// draw the outline before the rest of the shape
					// - all legs are drawn
						ctx.strokeStyle = _settings.outline.color;
						for (i3 = 0; i3 < tri.length; i3++) {
							let temp = _settings.outline.weight;
							_3dline(viewer, ctx,
								tri[i3][0],
								tri[i3][1],
								tri[i3][2],
								tri[(i3 + 1)%3][0],
								tri[(i3 + 1)%3][1],
								tri[(i3 + 1)%3][2],
							temp);
						};
						ctx.strokeStyle = _settings.stroke;
						// restore the strokeStyle since i had to change it
					};
					//logspecial({face: i1, tri: i2, point0: tri[0], point1: tri[1], point2: tri[2], indexes: tri.indexes}, false, true);
					let angle = tridirection([tri[0], tri[1], tri[2]], _settings.center, _settings.invert);
					let hide = angle[1] < 0;
					// if it's facing away from the camera...
					if(angle[1] === 0) {
					// if it's perpendicular to the camera...
					// - do not draw it if the xy of the angle and the xy to the
					//   vanishing point are more than 90 degrees apart.
						let centerangle = get2dangle(
							viewer.x - (viewer.offset.x + tri._average[0]),
							viewer.y - (viewer.offset.y + tri._average[1]),
							true
						);
						hide = centerangle !== null && compare2dangle(angle[0], centerangle) > Math.PI/2;
						// if it's obtuse, hide it. don't hide it if it's right on top
						// of viewer
					};
					//hide = invertboolean(hide, _settings.invert);
					// if invert is on it should reverse whatever it was
					// - nope, this is redundant. tridirection already factors
					//   in invert.
					let double_sided = etc.includes("double-sided") || !!this.staticsettings.double_sided || !!f.double_sided;
					if(double_sided) {
						hide = false;
					};
					// double-sided draws it regardless of direction
					let tri2d = [];
					for(i3 = 0; i3 < 3; i3++) {
						tri2d[i3] = perspectiveconvert(
							viewer,
							tri[i3][0] + viewer.offset.x,
							tri[i3][1] + viewer.offset.y,
							tri[i3][2] + viewer.offset.z
						).slice(0, 2);
					}
					// convert to screen coordinates.
					// - add viewer offset since _2dPoly.draw isn't a _3d function
					// - also converts it to an array, which removes .indexes and
					//   ._average
					if(
						!etc.includes("wireframe")
						&&
						!hide
					) {
					// draw the fill
						let texture = typeof _settings.texture_name === "string" ? this.texture[ _settings.texture_name ] : this.texture;
						// this.texture can be an imagedata or a container of
						// other imagedatas, so
						if (
							!f[ tri.indexes[0] ].hasOwnProperty("texture")
							||
							!f[ tri.indexes[1] ].hasOwnProperty("texture")
							||
							!f[ tri.indexes[2] ].hasOwnProperty("texture")
						) {
						// and skip texturing if some of the points have no
						// coordinates.
							texture = null;
						};
						let shader = _settings.hasOwnProperty("shader") ? _settings.shader : null;
						let shaderangle = null;
						if(_settings.shader && double_sided && Angle.numbers(angle)[2] < 0) {
						// the shader needs whatever angle is facing the camera.
						// when it's single-sided you don't gotta worry about
						// that since hide will cover that, but if it's
						// double-sided, it might have to be inverted.
							shaderangle = Angle.invert(angle);
						}
						else {
							shaderangle = angle;
						};
						let lightmod = shader && shader.hasOwnProperty("lightmod") ? shader.lightmod : null;
						let colormodtype = null;
						if(!shader) {
						}
						else if(!shader.hasOwnProperty("colormod")) {
							colormodtype = "default";
						}
						else if(shader.colormod.hasOwnProperty("type")) {
							colormodtype = shader.colormod.type;
						}
						else {
							console.log("shader .colormods must have a specified type.");
							colormodtype = "default";
						};
						let defaultrgba = [
							parseInt(ctx.fillStyle.slice(1, 3), 16),
							parseInt(ctx.fillStyle.slice(3, 5), 16),
							parseInt(ctx.fillStyle.slice(5, 7), 16)
						];
						if(ctx.fillStyle.length === 9) {
						// alpha
							defaultrgba[3] = parseInt(ctx.fillStyle.slice(7, 9), 16);
						}
						else {
							defaultrgba[3] = 255;
						};
						if(texture || shader) {
						// run the pixel-by-pixel logic only if there's
						// texturing or pixel-by-pixel lighting.
							let planetemp = Plane.frompoints([tri[0], tri[1], tri[2]]);
							// used in screeninverse
							_2dPoly.execute(tri2d, true, function(x, y) {
								let coor = screeninverse(viewer, x, y, false, planetemp);
								// get the 3d coordinate this pixel represents
								let color = structuredClone(defaultrgba);
								if(texture) {
									color = tricoordinates(tri, coor);
									// convert to triangle coordinates
									color = tricoordinates([
										f[ tri.indexes[0] ].texture,
										f[ tri.indexes[1] ].texture,
										f[ tri.indexes[2] ].texture
									], color, true);
									// convert triangle coordinates to 2d
									// coordinates on the texture image
									color = 4*(texture.width*posmod(color[1], texture.height) + posmod(color[0], texture.width));
									// ImageData is an array of rgba values from the
									// left pixels to right, top to bottom. this is
									// the index to start from.
									color = texture.data.slice(coor, coor + 4);
								};
								if(shader) {
									let light = lightlevel(viewer, coor, angle, color[3]/255);
									// an array of modifiers for r, g, and b
									let i1 = 0;
									for (i1 = 0; i1 < 3; i1++) {
										if(lightmod) {
											light[i1] = applyoperations(light[i1], lightmod, i1);
										};
										if(colormodtype === "default") {
											color[i1] = color[i1]*(1 + light[i1]);
										}
										else if(colormodtype === "alt_palette") {
											//
										};
										color[i1] = Math.max(0, Math.min(Math.floor(color[i1]), 255));
										// apply flooring, minimum and maximum.
									}
								};
								ctx.fillStyle = "rgba(" + color.join(", ") + ")";
								ctx.fillRect(x, y, 1, 1);
							});
						}
						else {
							_2dPoly.draw(ctx, tri2d);
						};
					};
					if((!hide || etc.includes("wireframe")) && strokes.includes(true) && !etc.includes("lineless")) {
					// draw the stroke
					// - unless if this face is hidden
					// - or all strokes are hidden (by the points' .hides or by
					//   them not being an edge of the face)
					// - or it's lineless mode
					// - (invert is irrelevant because that was already applied
					//   to hide.)
						for (i3 = 0; i3 < tri2d.length; i3++) {
							if(strokes[i3]) {
								nonaaline(ctx,
									tri2d[i3][0],
									tri2d[i3][1],
									tri2d[(i3 + 1)%3][0],
									tri2d[(i3 + 1)%3][1],
								weight);
							};
						}
					};
				};// end of triangles loop
			};// end of faces loop
			ctx.fillStyle = _default.fill;
			ctx.strokeStyle = _default.stroke;
			// restore styles
		}
		static allfaces(facesobj, includeinits, array) {
		// returns an array of references to all faces in order, sifting through
		// all the categories and crap
		// - array: this is used in recursion (i dunno if Array.concat would
		//   retain references and i don't wanna risk it) but there's no harm in
		//   using it anyway. put in an array, and it'll add these references to
		//   the end.
		//   - if an array is given, it edits that. if not, it returns a new
		//     one.
		// - includeinits: what it sounds like. it'll add .inits if it sees
		//   them.
		//   - however, it can't check the init of the poly itself, so if you
		//     want that, input that as includeinits and it'll add that to the
		//     array.
			let i1 = 0;
			let i2 = 0;
			let arraygiven = typeof array === "object" && Array.isArray(array);
			if(!arraygiven) {
				array = [];
			}
			if(includeinits && typeof includeinits === "object") {
				array[array.length] = includeinits;
			};
			for (i1 in facesobj) {
				if (facesobj.hasOwnProperty(i1)) {
					if(i1.startsWith("_")) {
					// face group
						if(includeinits && facesobj.hasOwnProperty("init")) {
							array[array.length] = facesobj.init;
						};
						Poly.allfaces(facesobj[i1], false, array);
					}
					else if(i1 !== "init") {
					// face
						array[array.length] = facesobj[i1];
					};
				};
			}
			if(!arraygiven) {
				return array;
			}
		}
		static shrinkwrap(points) {
		// creates a Poly that resembles what _2dPoly.convexed would create.
		// - NOTE unfinished.
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let i4 = 0;
			if(points.length < 4) {
				let poly = new Poly(true);
				poly.points = structuredClone(points);
				poly.faces[0] = {};
				for(i1 = 0; i1 < points.length; i1++) {
					poly.faces[0][i1] = {index: i1};
				}
				return poly;
			}
			let center = [0, 0, 0];
			for(i1 = 0; i1 < points.length; i1++) {
				for(i2 = 0; i2 < 3; i2++) {
					center[i2] += points[i1][i2];
				}
			}
			for(i1 = 0; i1 < 3; i1++) {
				center[i1] /= points.length;
			};
			let distancefrom = (start, end) => Math.hypot(
				end[0] - start[0],
				end[1] - start[1],
				end[2] - start[2]
			);
			function distanceorder(start, highestfirst) {
			// returns an array of points indexes, sorted by distance from the
			// given point.
				let i1 = 0;
				let i2 = 0;
				let order = [];
				for(i1 = 0; i1 < points.length; i1++) {
					order[i1] = {index: i1, dist: distancefrom(start, Math.hypot(
						points[i1][0] - start[0],
						points[i1][1] - start[1],
						points[i1][2] - start[2]
					))};
				}
				order.sort(
					highestfirst
					?
					((a, b) => b.dist - a.dist)
					:
					((a, b) => a.dist - b.dist)
				);
				for(i1 = 0; i1 < order.length; i1++) {
					order[i1] = order[i1].index;
				}
				return order;
			}
			let order = distanceorder(center, true);
			// sort by highest distance first (triple round-robining is super
			// dangerous, i need to maximize the chances that the first faces it
			// tries are on the outside.)
			let tri = [];
			// array of three-index arrays representing triangle faces.
			let unclosed = {};
			// object storing data for edges that are only used by one tri, not
			// two. structure:
			// - [tri indexes, only present for tris that still have unclosed
			//   sides]
			//   - 0, 1, and 2 booleans (true means it's unclosed. side 0 is
			//     from 0 to 1, 1 is 1 to 2, etc)
			function addtri(newtri) {
				let i1 = 0;
				let i2 = 0;
				let _unclosed = {0: true, 1: true, 2: true};
				// it will add this to unclosed, for the new tri.
				let side = (index1, index2) => posmod(index1 + 1, 3) === index2 ? index1 : posmod(index2 + 1, 3) === index1 ? index2 : null;
				for(i1 in unclosed) {
					if(unclosed.hasOwnProperty(i1)) {
					// check for tris that share a side
						let same = [
							[0, tri[i1].indexOf(newtri[0])],
							[1, tri[i1].indexOf(newtri[1])],
							[2, tri[i1].indexOf(newtri[2])]
						];
						for(i2 = 0; i2 < same.length; i2++) {
							if(same[i2][1] === -1) {
								same.splice(i2, 1);
								i2--;
							};
						}
						// same is now an array of [newtri index, tri[i1] index]
						// matches
						if(same.length === 3) {
						// perfectly matches an existing tri, so it's
						// unnecessary. (this will only be caught if that tri
						// was unclosed, but i don't know how this would happen
						// anyway.)
							return;
						}
						else if(same.length === 2) {
							same = [
								side(same[0][0], same[1][0]),
								side(same[0][1], same[1][1])
							];
							// [newtri side index, tri[i1] side index]
							unclosed[i1][ same[1] ] = false;
							_unclosed[ same[0] ] = false;
							if(!unclosed[i1][0] && !unclosed[i1][1] && !unclosed[i1][2]) {
							// the tri isn't unclosed anymore
								delete unclosed[i1];
							};
							if(!_unclosed[0] && !_unclosed[1] && !_unclosed[2]) {
							// there's no more unclosed tris to find
								tri[tri.length] = structuredClone(newtri);
								return;
							};
						}
					}
				}
				tri[tri.length] = structuredClone(newtri);
				unclosed[ tri.length - 1 ] = structuredClone(_unclosed);
				// add to tri and unclosed
			}
			for(i1 = 0; i1 < order.length && !tri.length; i1++) {
			// find one tri on the outside.
				let _order = distanceorder(points[ order[i1] ]);
				// sort by closest first (otherwise it'll take way too long on
				// sphere-like shapes.)
				let order_slice = order.slice(0, i1);
				for(i2 = 0; i2 < _order.length && !tri.length; i2++) {
					if(!order_slice.includes(_order[i2])) {
					// if it went through this point in the i1 loop, that means
					// it tried every single combination with this one.
						for(i3 = i2 + 1; i3 < _order.length && !tri.length; i3++) {
							if(!order_slice.includes(_order[i3])) {
								let newtri = [
									order[i1],
									_order[i2],
									_order[i3]
								];
								let plane = Plane.frompoints([
									points[ newtri[0] ],
									points[ newtri[1] ],
									points[ newtri[2] ]
								]);
								let sign = null;
								for(i4 = 0; i4 < points.length; i4++) {
									let _sign = Math.sign(roundspecial(plane.pointtotal(points[i4])));
									if(_sign && !sign) {
									// set the first non-zero sign as the one to
									// expect
										sign = _sign;
									};
									if(_sign !== sign) {
										newtri = null;
										i4 += points.length;
									}
								};
								if(newtri) {
								// all other points are on the same side of this
								// tri, therefore it's on the outside.
									addtri(newtri);
								};
							}
						}
					}
				}
			}
			// - avoid invalid Plane.frompoints (all of them being on the same
			//   line)
			// - iterate through unclosed, find an outside tri for every
			//   unclosed side and quit when unclosed is empty.
			//   - do it how i found the first tri?
			//   - or do it how _2dPoly.convexed does? (get the plane of the
			//     tri, picture it rotating around the unclosed side, find the
			//     point that'd collide with it first.)
			//     - this is probably better, but how do i rotate a plane, and
			//       in which direction...
			// - create Poly from it and return that.
		}
		// TODO
		// - finish tricoordinates
		// - Poly.draw
		//   - calculate the outline weight to use based on the stroke weight and
		//     whether a stroke will be drawn for this leg
		//   - make a strokeweight property
		//   - write alternate shader.colormod modes
		//     - alt_palette
		//     - others
		// - method rewrites
		//   - build
		//     - write texturing logic
		//     - fix problems associated with disc/square and cones, rewrite
		//       construction logic accordingly
		//     - test and fix sphere
		//   - join
		//   - subdivide
		//     - make sure it creates a face category for each divided face.
		//       (unless the factor is 1 and it started as a triangle.)
		//     - make it possible to use on a single face
		//   - randomize
	}
	function _3dlineexecute(viewer, context, x1, y1, z1, x2, y2, z2, weight, increment, code, codeis3d) {
	/*
	function _2d_3le_code(context, x, y, weight)
	function _3d_3le_code(viewer, context, x, y, z, weight)
	*/
	// executes a function at regularly spaced positions along a line in 3d
	// space.
	// - code is a function with the parameters context, x, y, weight.
	//   - or, if codeis3d is true, viewer, context, x, y, z, weight.
	//   - "weight" is misleading. what it means is pretty much "a number
	//     that's bigger the closer it is to the camera, can be adjusted in
	//     the given function, and may change over the course of the line."
	//     - it doesn't change with z in a perfect way though. it checks
	//       what the perspectiveconvert-ed x position of x + weight/2, y, z
	//       minus the perspectiveconvert-ed x position x - weight/2, y, z
	//       would be.
	//     - that's equivalent to checking the width of a flat disc that's
	//       facing the camera, rather than the radius of a sphere. TODO.
	// - just like _3dline, weight can be an array of two numbers, representing
	//   the value at the beginning and end
	// - codeis3d: boolean. if this is used, the code will be expected to have a
	//   viewer parameter before all the others.
	// - increment: what the 3d distance between executions should be. by
	//   default it is 1.
	// - remember, don't be afraid to write a small function that does whatever
	//   you want it to. the same is true for every function that runs code, in
	//   my opinion.
	// - TODO. this might not work yet.
	// - TODO add a parameter that makes it break lines up to properly show
	//   perspective?
	//   - like if you filmed a cube with a fisheye lens, the edges are straight
	//     but they'd look curved.
	//   - this just connects two 3d-to-screen coordinates with one line, so it
	//     doesn't show that.
	//   - i guess make a Line with the two points, and find intersections with
	//     xy, xz, and yz planes
	//     - like check where it meets the "y === 0" plane, then the "y === 2"
	//       plane, and so on
		if(!codeis3d) {
			if(viewer.offset.x) {
				x1 += viewer.offset.x;
				x2 += viewer.offset.x;
			};
			if(viewer.offset.y) {
				y1 += viewer.offset.y;
				y2 += viewer.offset.y;
			};
			if(viewer.offset.z) {
				z1 += viewer.offset.z;
				z2 += viewer.offset.z;
			};
		};
		// TODO apply cutoff
		let angle = Angle.get(x2 - x1, y2 - y1, z2 - z1);
		let xinc = Angle.numbers(angle);
		let yinc = xinc[1];
		let zinc = xinc[2];
		xinc = xinc[0];
		let fulldist = Math.hypot(x2 - x1, y2 - y1, z2 - z1);
		// - code is a function with the parameters context, x, y, weight.
		//   - or, if codeis3d is true, viewer, context, x, y, z, weight.
		let distcovered = 0;
		let weighttemp = 0;
		let x = x1;
		let y = y1;
		let z = z1;
		if(Array.isArray(weight) && weight.length >= 2) {
		}
		else if(typeof weight === "number") {
			weighttemp = "x";
		}
		else {
			weighttemp = "x";
			weight = 0;
		};
		// if there's no array, always use weight proper
		if(!x && x !== 0) {
			return;
		};
		if(!y && y !== 0) {
			return;
		};
		if(!z && z !== 0) {
			return;
		};
		for(; distcovered <= fulldist ;) {
			if(Array.isArray(weight) && weight.length >= 2) {
				weighttemp = weight[0] + (weight[1] - weight[0])*distcovered/fulldist;
			}
			else {
				weighttemp = Math.abs(perspectiveconvert(viewer, x + weight/2, y, z)[0] - perspectiveconvert(viewer, x - weight/2, y, z)[0]);
			};
			if(codeis3d) {
				code(viewer, context, x, y, z, weighttemp);
			}
			else {
				code(context, perspectiveconvert(viewer, x, y, z)[0], perspectiveconvert(viewer, x, y, z)[1], weighttemp);
			};
			x += xinc;
			y += yinc;
			z += zinc;
			distcovered += increment;
		}
	}
	CanvasRenderingContext2D.prototype.lineexecute = function(x1, y1, x2, y2, weight, code, omitstart) {
	/*
	ctx.lineexecute(x1, y1, x2, y2, weight, function(ctx, x, y, weight) {
		//
	}, omitstart);
	*/
	// executes a function at every pixel in the line between the two points.
	// - code is a function with the parameters context, x, y, weight.
	//   - "weight" is misleading. what it means is pretty much "a number
	//     that's bigger the closer it is to the camera, can be adjusted in
	//     the given function, and may change over the course of the line."
	// - weight can be an array of two numbers, representing the value at the
	//   beginning and end
	// - omitstart: boolean. if true, the code will not execute for the starting
	//   pixel. (this is a fairly specific need, but it's useful for chaining
	//   multiple line executes together seamlessly.)
	//   - note that it will not omit it if the end and beginning happen to be
	//     at the same place.
	// - TODO: make an increment parameter that makes it execute at even
	//   positions instead of pixels (that way there isn't a difference in
	//   density between cardinal and diagonal)
	//   - make sure the coordinates are still floored
		let i1 = 0;
		omitstart = !!omitstart;
		if(weight) {
			x1 = .5*Math.round(x1/.5);
			y1 = .5*Math.round(y1/.5);
			x2 = .5*Math.round(x2/.5);
			y2 = .5*Math.round(y2/.5);
			if(Array.isArray(weight)) {
			// makes sure they're centered on the center or top left corner of
			// the pixel coordinates given
				if((.5*Math.round(weight[0]/.5))%2===1) {
					x1 += .5;
					y1 += .5;
				};
				if((.5*Math.round(weight[1]/.5))%2===1) {
					x2 += .5;
					y2 += .5;
				};
			}
			else if(weight%2===1) {
				x1 += .5;
				y1 += .5;
				x2 += .5;
				y2 += .5;
			};
		}
		else {
			x1 = Math.round(x1);
			y1 = Math.round(y1);
			x2 = Math.round(x2);
			y2 = Math.round(y2);
			weight = 1;
		};
		if(!Number.isInteger(2*x1) || !Number.isInteger(2*y1) || !Number.isInteger(2*x2) || !Number.isInteger(2*y2)) {
			console.log("invalid coordinates. (" + [x1, y1, x2, y2].join() + ")");
			return;
		};
		let getwt = (value) => (Array.isArray(weight) ? Math.round(weight[0] + value*(weight[1] - weight[0])) : weight);
		const start = [x1, y1];
		const end = [x2, y2];
		let coor = [(end[0] - start[0]), (end[1] - start[1])];
		const axis1 = Number(Math.abs(coor[1]) > Math.abs(coor[0]));
		// the wider axis is the one it iterates across.
		const axis2 = (axis1 + 1)%2;
		const sign1 = Math.sign(coor[axis1]);
		const diff1 = Math.abs(coor[axis1]);
		const sign2 = Math.sign(coor[axis2]);
		const diff2 = Math.abs(coor[axis2]);
		coor = [start[0], start[1]];
		// coordinate of the pixel to run code on. loops change it, iteration by
		// iteration
		if(x1 === x2 && y1 === y2) {
			code(this, x1, y1, (
				weight
				?
				(Array.isArray(weight) ? Math.max(...weight) : weight)
				:
				1
			));
		}
		else if(x1 === x2 || y1 === y2) {
		// unsloped line, or both coordinates are the same. to avoid divide by
		// zero errors.
			for(i1 = Number(omitstart); i1 <= diff1; i1++) {
				coor[axis1] = start[axis1] + sign1*i1;
				code(this, ...coor, getwt(i1/diff1));
			}
		}
		else {
			let line = get2dline(x1, y1, x2, y2, true);
			// it fills the first pixel whose line[0]*x + line[1]*y + offset is
			// between 0 and 1.
			function getcoor(knowncoor) {
			// axis1 is the known axis, the one the coordinate comes from. axis2
			// is the unknown axis.
				// 0 = x*line.x + ?*line.y + offset
				// 0 = knowncoor*line[axis1] + ?*line[axis2] + line[2]
				// ? = -(knowncoor*line[axis1] + line[2])/line[axis2]
				let num = -((knowncoor + .5)*line[axis1] + line[2])/line[axis2];
				//let num = (.5 - (knowncoor + .5)*line[axis1] - line[2])/line[axis2];
				//return num;
				//return Math.round(num - .5);
				return Math.floor(num);
				//return Math[ ["floor", "round", "ceil"][-sign2 + 1] ](num - .5);
			}
			if(line[0] === 0 || line[1] === 0) {
				console.log("this shouldn't happen");
				return;
			}
			if(sign2 === 0) {
				console.log("this shouldn't happen");
				/*
				console.log("Math.sign(end[axis2] - start[axis2])");
				console.log("Math.sign(end[" + axis2 + "] - start[" + axis2 + "])");
				console.log("Math.sign(" + end[axis2] + " - " + start[axis2] + ")");
				console.log("Math.sign(" + (end[axis2] - start[axis2]) + ")");
				//*/
				//console.log("xy"[axis1] + "xy"[axis2] + ": " + [x1, x2, y1, y2].join());
				return;
			}
			for (i1 = Number(omitstart); i1 <= diff1; i1++) {
				coor[axis1] = start[axis1] + i1*sign1;
				coor[axis2] = getcoor(coor[axis1]);
				code(this, ...coor, getwt(i1/diff1));
			}
		};
	}
	function nonaaline(context, x1, y1, x2, y2, weight) {
	// draws a line that isn't antialiased.
	// - uses strokeStyle
	// - weight can be a single value or an array with the starting weight and
	//   ending weight
	//   - NOTE it does not just pass the array onto circledraw, so if you're
	//     trying to make a line with an elliptical particle, it won't work.
	//     it'll do this instead.
	// - TODO add a gradient line thing?
	//   - make it possible to specify color, and if it's an array, same deal as
	//     weight
	//   - it draws a dot in the first color, then a dot in the second color
	//     over it, with the opacity depending on where in the line it is
	// - TODO keep it from making misshapen ends
	//   - probably caused by an x coordinate that's closer to a .5 number, and
	//     a y coordinate that's closer to a .0 number. see circledraw for
	//     details.
		let styletemp = context.fillStyle;
		context.fillStyle = context.strokeStyle;
		function naal_circ(context, x, y, weight) {
			circledraw(context, Math.floor(x) + .5, Math.floor(y) + .5, weight/2, true);
		}
		context.lineexecute(x1, y1, x2, y2, weight, naal_circ);
		context.fillStyle = styletemp;
	}
	function circlepoints(x, y, r, fraction) {
	// runs the coordinates of the point you specify, measured in entire
	// circles and starting clockwise from the top.
	// - so if fraction is 0, it'll return the point one radius directly above
	//   the circle's center.
	// - if that format sounds dumb it probably is, but it's because this is
	//   going to be used the most for placing several objects in a circle. for
	//   example, drawing a star.
		return [x + r*Math.cos(2*Math.PI*-(fraction-.25)), y - r*Math.sin(2*Math.PI*-(fraction-.25))];
	}
	function limitlessrand(chance, modifier, multiply, initialvalue) {
	// moved to reusables
	// =
	// - if multiply is true, it'll multiply the initial value by modifier. if
	//   not, it'll add modifier.
	// - if modifier is an array of two numbers, it'll pick a random number
	//   between them. if the third item of the array is "int", it'll only pick
	//   integers.
		let i1 = 0;
		let i2 = 0;
		let lr_return = typeof initialvalue === "number" && !isNaN(initialvalue) ? initialvalue : (multiply ? 1 : 0);
		modifier = typeof modifier === "number" && !isNaN(modifier) ? modifier : (multiply ? 2 : 1);
		let lr_mod = 0;
		for (i1 = Math.random(); i1 < chance; i1 = Math.random()) {
			if(Array.isArray(modifier) && modifier.length===2) {
				lr_mod = modifier[0] + Math.random()*(modifier[1] - modifier[0]);
			}
			else if(Array.isArray(modifier) && modifier.length===3 && modifier[2]==="int") {
				lr_mod = modifier[0] + Math.floor(Math.random()*(1 + modifier[1] - modifier[0]));
			}
			else if((!isNaN(Number(modifier)) && Number(modifier) !== 0) || modifier === 0) {
			// if it's a valid number
				lr_mod = modifier;
			}
			else {
				console.log("invalid modifier.");
				return;
			};
			if(multiply) {
				lr_return *= lr_mod;
			}
			else {
				lr_return += lr_mod;
			};
		}
		return lr_return;
	}
	function get3rddist(d1, d2, dtotal) {
	// moved to reusables
		//d1**2 + d2**2 + d3**2 = dtotal**2
		if(dtotal**2 - (d1**2 + d2**2) < 0) {
			console.log("invalid get3rddist operation: d1 (" + d1 + ") and d2 (" + d2 + ") are bigger than what dtotal (" + dtotal + ") can allow for.")
			return 0;
		}
		else {
			return Math.sqrt(dtotal**2 - (d1**2 + d2**2));
		};
	}
	function raysegmentintersect(x1, y1, angle, x2a, y2a, x2b, y2b) {
	// - x1, y1, angle: parameters for the ray (a ray is a line that
	//   only travels one direction, if you didn't remember inane math
	//   trivia from fourth grade)
	// - x2a, y2a, x3a, y3a: parameters for the line segment
	// - returns either coordinates for the intersection, or a false
	//   boolean
		let adist = Math.hypot(x2a - x1, y2a - y1);
		let bdist = Math.hypot(x2a - x1, y2a - y1);
		if((x1===x2a && y1===y2a) && (x1===x2b && y1===y2b)) {
			return [x1, y1];
		}
		if(
			(
				angle >= Math.min(Math.acos((x2a - x1)/adist), Math.acos((x2b - x1)/bdist))
				&&
				angle <= Math.max(Math.acos((x2a - x1)/adist), Math.acos((x2b - x1)/bdist))
			)
			||
			(
				angle >= Math.min(Math.asin((y2a - y1)/adist), Math.asin((y2b - y1)/bdist))
				&&
				angle <= Math.max(Math.asin((y2a - y1)/adist), Math.asin((y2b - y1)/bdist))
			)
		) {
		// if angle is between the angle to point 2a and the angle to
		// point 2b,
			let segangle = 0;
			for(rsi_i1 = 0; rsi_i1 < 4; rsi_i1++) {
				if((rsi_i1%2)===0) {
					segangle = Math.hypot(x2b - x2a, y2b - y2a);
					if(rsi_i1 < 2) {
						segangle = Math.acos((x2b - x2a)/segangle);
					}
					else {
						segangle = Math.asin((y2b - y2a)/segangle);
					};
					for(; segangle < 0 ;) {
						segangle += 2*Math.PI;
					}
					for(; segangle >= 2*Math.PI ;) {
						segangle -= 2*Math.PI;
					}
				};
				if((rsi_i1%2)===1) {
					segangle += Math.PI;
					segangle %= 2*Math.PI;
				}
				if(segangle === angle) {
					if(adist <= bdist) {
						return [x2a, y2a];
					}
					else if(bdist <= adist) {
						return [x2b, y2b];
					};
				};
			}
			return fourpointintersect(x1, y1, x1 + Math.cos(angle), y1 + Math.sin(angle), x2a, y2a, x2b, y2b);
		}
		else {
			return false;
		};
	}
	function compare2dangle(angle1, angle2) {
		let returnangle = posmod(
			posmod(Math.max(angle1, angle2), 2*Math.PI) - posmod(Math.min(angle1, angle2), 2*Math.PI),
		2*Math.PI);
		if(returnangle > Math.PI) {
			returnangle = 2*Math.PI - returnangle;
		};
		return returnangle;
	}
	class Operations {
	// this really only exists to make it easy to verify that something's an
	// operations object. (otherwise, you'd have to check every property and
	// make sure the name starts with one of the allowed words.)
		constructor(value) {
			if(noargumentscheck([value])) {
			// create an empty object that another object's contents can be
			// pasted into
				return;
			}
			let i1 = 0;
			for (i1 in value) {
				if (value.hasOwnProperty(i1)) {
					this[i1] = structuredClone(value[i1]);
				}
			}
		}
		useless(isangle) {
		// returns a boolean for whether the operations is just composed of
		// arithmetic that barely changes the number at all because it just
		// multiplies it by 1.000000000000000000001 or something
		// - isangle: also declares 2 pi minus .0000000000000001 or w/e useless
			let i1 = "";
			let op = "";
			for (i1 in this) {
				if (this.hasOwnProperty(i1)) {
					op = (i1.includes("_") ? i1.slice(0, i1.indexOf("_")) : i1);
					if(
						["add", "subtract"].includes(op)
						&&
						(
							Math.abs(this[i1]) < .0000000001
							||
							(
								isangle
								&&
								Math.abs(this[i1] - 2*Math.PI) < .0000000001
							)
						)
					) {
					// if it's adding/subtracting 0 or a number infinitesimally close to 0
					}
					else if(["multiply", "divide"].includes(op) && Math.abs(1 - this[i1]) < .0000000001) {
					// if it's multiplying/dividing 1 or a number infinitesimally close to 1
					}
					else {
						return false;
					};
				}
			}
			return true;
		}
	}
	function applyoperations(number, operations, place) {
	// applies the operations in the operations object to the given number and
	// returns the new version.
	// - add, subtract, multiply, divide, remainder, exponent, math.
	// - the first five are pretty obvious. they are either arrays of multiple
	//   numbers, or one number applied regardless of the place value entered.
	//   - place is the index to use if it's an array. for example, if you
	//     wanted to add a 5 x and -10 y offset to coordinates, you would have
	//     an add: [5, -10] property, and use 0 as the place number when using
	//     this on an x coordinate.
	// - math is different. math is a string representing a function of the
	//   Math object. usually floor, ceil, round.
	// - this was created so i could easily adjust coordinates to be
	//   absolute, apply a multiplier, and floor it.
	// - add an underscore after a property name to add a number or whatever
	//   while still recognizing the operation (for example, you can't have
	//   multiply, add, multiply because that'd mean two properties are the
	//   same. but if it was multiply_1, add, multiply_2, it'd be fine.)
		let i1 = "";
		let temp = "";
		let operand = 0;
		for (i1 in operations) {
			if (operations.hasOwnProperty(i1)) {
				if(i1.includes("_")) {
					temp = i1.slice(0, i1.indexOf("_"));
				}
				else {
					temp = i1;
				};
				if(Array.isArray(operations[i1]) && operations[i1].length > place) {
					if(
						typeof operations[i1][place] === "number"
						||
						(
							typeof operations[i1][place] === "string"
							&&
							(
								temp === "add"
								||
								temp === "math"
							)
						)
					) {
						operand = operations[i1][place];
					}
					else {
						operand = NaN;
					}
				}
				else if(
					typeof operations[i1] === "number"
					||
					(
						typeof operations[i1] === "string"
						&&
						(
							temp === "add"
							||
							temp === "math"
						)
					)
				) {
					operand = operations[i1];
				}
				else {
					operand = NaN;
				}
				switch (temp) {
					case "set":
					number = operand;
					break;
					case "add":
					number += operand;
					break;
					case "subtract":
					number -= operand;
					break;
					case "multiply":
					number *= operand;
					break;
					case "divide":
					number /= operand;
					break;
					case "remainder":
					number %= operand;
					break;
					case "exponent":
					number = number**operand;
					break;
					case "math":
					if(Math.hasOwnProperty(operand) && typeof Math[operand] === "function") {
						number = Math[operand](number);
					}
					else {
						number = NaN;
					}
					break;
					default:
					console.log("invalid operation.");
					break;
				}
			};
		}
		return number;
	}
	function newoperationname(operations, newoperation) {
	// for use with a applyoperations input. checks every
	// "[operation name]_[number]" property so that the new property will be one
	// that isn't used yet and is higher than whatever the highest number is,
	// then it returns that property name
		let i1 = 0;
		let currentuses = [];
		for (i1 in operations) {
			if (operations.hasOwnProperty(i1) && i1.slice(0, i1.indexOf("_")) === newoperation) {
				currentuses[currentuses.length] = i1;
			};
		}
		if(currentuses.length === 0) {
			return newoperation;
		}
		else {
			let highestnum = 1;
			let temp = "";
			for(i1 = 0; i1 < currentuses.length; i1++) {
				temp = currentuses[i1].slice(newoperation.length + 1);
				if(temp && !isNaN(Number(temp)) && Number(temp) > highestnum) {
					highestnum = Math.ceil(Number(temp));
					// the ceil is in case i use decimal points or something...
					// can't just add 1 to that, that'll make it confusing
				};
			}
			return newoperation + "_" + (highestnum + 1);
		}
	}
	function inverseoperations(input) {
	// returns a version of the given operations object where it's in reverse
	// order and all operations are inverses of what they were.
	// - applying these should reverse the changes of the original and revert a
	//   number to what it was before.
	// - there are limits, however.
	//   - a lot of Math operations cannot be reversed.
	//   - *, /, or ** by 0 cannot be reversed
	//   - even-number exponents for negative numbers will make them positive,
	//     so running an inverse operation on it will not return it to what it
	//     was.
		let i1 = 0;
		let i2 = 0;
		let inverse = {};
		let keys = Object.keys(input);
		let types = ["set", "add", "subtract", "multiply", "divide", "remainder", "exponent", "math"];
		let op = "";
		let temp = "";
		for (i1 = 0; i1 < keys.length; i1++) {
			op = "";
			for (i2 = 0; i2 < types.length; i2++) {
				if(keys[i1].slice(0, types[i2].length) === types[i2]) {
					op = types[i2];
					i2 += types.length;
				};
			}
			if(!op) {
				console.log("invalid operation.");
				return;
			};
			if(op === "math") {
				temp = ["cos", "sin", "tan", "cosh", "sinh", "tanh"];
				// the other math methods with only one argument are:
				// - reversible
				//   - cbrt
				//   - sqrt
				// - irreversible
				//   - abs
				//   - ceil
				//   - floor
				//   - round
				//   - sign
				//   - trunc
				//   - clz32
				//   - fround
				// - probably reversible but i'd have to make special arguments
				//   and i'm not doing that
				//   - exp
				//   - expm1
				// - don't feel like figuring this shit out right now
				//   - log
				//   - log10
				//   - log1p
				//   - log2
				// 2 arguments:
				//   - atan2
				//   - hypot
				//   - max
				//   - min
				//   - pow (exponent does the same thing though)
				// - i do not give a shit about whatever this is,
				//   - imul
				// =
				// - oh who gives a shit. the math property string already takes
				//   the place of the operand.
				op = input[keys[i1]];
				if(temp.includes(op)) {
					inverse[keys[i1]] = "a" + op;
					// cos to acos
				}
				else if(op === "sqrt") {
					inverse[newoperationname(input, "exponent")] = 2;
				}
				else if(op === "cbrt") {
					inverse[newoperationname(input, "exponent")] = 3;
				}
				else if(op.charAt(0) === "a" && temp.includes(op.slice(1))) {
					inverse[keys[i1]] = op.slice(1);
					// acos to cos
				}
				else if(["floor", "ceil", "round", "fround", "trunc", "abs", "sign", "clz32", "fround"].includes(op)) {
					console.log("Math." + op + " operations are irreversible.");
				}
				else if(["exp", "expm1", "log", "log10", "log1p", "log2"].includes(op)) {
					console.log("Math." + op + " operations are probably reversible maybe, but i don't really feel like figuring it out right now.");
				}
				else if(!Math[i1] || typeof Math[i1] !== "function" || Math[i1].length !== 1) {
					console.log("this Math function either doesn't exist, isn't a function, or has more than one argument. you aren't supposed to use those to begin with.");
				}
				else {
					console.log("this shouldn't happen");
				};
			}
			else if(["set", "remainder"].includes(op)) {
				console.log(op + " operations are irreversible.");
			}
			else {
				if(["add", "subtract"].includes(op)) {
					temp = "negative";
				}
				else if(["multiply", "divide", "exponent"].includes(op)) {
					temp = "reciprocate";
				}
				else {
					console.log("this shouldn't happen");
				};
				let inputvalue = 0;
				// temp
				for (i2 = 0; i2 < (Array.isArray(input[keys[i1]]) ? input[keys[i1]].length : 1); i2++) {
					if(Array.isArray(input[keys[i1]])) {
						if(i2 === 0) {
							inverse[keys[i1]] = [];
						}
						inputvalue = input[keys[i1]][i2];
					}
					else {
						inputvalue = input[keys[i1]];
					};
					if(typeof inputvalue === "number") {
						switch (temp) {
							case "negative":
								if(Array.isArray(input[keys[i1]])) {
									inverse[keys[i1]][i2] = -1*inputvalue;
								}
								else {
									inverse[keys[i1]] = -1*inputvalue;
								};
							break;
							case "reciprocate":
								if(inputvalue === 0) {
									console.log(op + " operations with 0 are irreversible.");
								}
								else {
									if(Array.isArray(input[keys[i1]])) {
										inverse[keys[i1]][i2] = 1/inputvalue;
									}
									else {
										inverse[keys[i1]] = 1/inputvalue;
									};
								};
							break;
							default:
								console.log("this shouldn't happen");
							break;
						};
					}
					else if(typeof inputvalue === "string") {
						console.log("string concatenation is technically reversible but only kind of and also it's a pain in the ass");
					}
					else {
						console.log("this shouldn't happen");
					};
				}
			}
		}
		return inverse;
	}
	function isoperations(object) {
		let i1 = 0;
		let op = "";
		if(typeof object !== "object" || Object.keys(object).length <= 0) {
			return false;
		};
		for (i1 in object) {
			if (object.hasOwnProperty(i1)) {
				op = i1.includes("_") ? i1.slice(0, i1.indexOf("_")) : i1;
				if(!["set", "add", "subtract", "multiply", "divide", "remainder", "exponent", "math"].includes(op)) {
					return false;
				}
			}
		}
		return true;
	}
	function isrevolutions(object) {
		let i1 = 0;
		let op = "";
		if(typeof object !== "object" || Object.keys(object).length <= 0) {
			return false;
		};
		for (i1 in object) {
			if (object.hasOwnProperty(i1)) {
				op = i1.includes("_") ? i1.slice(0, i1.indexOf("_")) : i1;
				if(!["xy", "xz", "yz"].includes(op)) {
					return false;
				}
			}
		}
		return true;
	}
	function revolve(angle, points, center, format) {
	// returns a new version of the points where they are revolved by the angle
	// specified, around the center specified.
	// - you can use an array of points, or just one. it will return it in the
	//   same format.
	// - you can use these angle formats:
	//   - 3d (two numbers)
	//     - xy/z
	//     - xz/y
	//   - 2d
	//     - xy
	//     - xz
	//     - yz
	// - i modified this so that you can use objects.
	//   - if points is an object, it'll use the integer properties to make an
	//     array.
	//   - if the points are objects, it'll look for .x, .y, and .z. however, it
	//     will return an array instead of keeping it as is.
	// - if you use a 3d angle for the format, it'll use the center and that
	//   angle to make a Line that points will be revolved around. this is
	//   called "roll". (use a 2d angle for the angle parameter.)
	// - NOTE: this has been replaced by "rotate" in barky_graphics. revolve is
	//   kept purely to keep canvastools code operating.
		let i1 = 0;
		if(!center || !(Array.isArray(center) && center.length >= 3)) {
			center = [0, 0, 0];
		};
		let dist = 0;
		let r_points = [];
		// should be a separate, structured clone. since arrays are objects,
		// modifying the points array directly would modify whatever array was
		// used as points input, and this is supposed to just return points.
		let one_point = typeof points[0] === "number" && typeof points[1] === "number" && typeof points[2] === "number";
		let cos = (angle) => [1, 0, -1, 0][angle/(Math.PI/2)] ?? Math.cos(angle);
		let sin = (angle) => [0, 1, 0, -1][angle/(Math.PI/2)] ?? Math.sin(angle);
		if(one_point) {
		// if there's only one point, make it part of an array so the for loop
		// will accept it
			r_points[0] = structuredClone(points);
		}
		else if(typeof points !== "object") {
			console.log("invalid input.");
			return;
		}
		else if(Array.isArray(points)) {
			r_points = structuredClone(points);
		}
		else {
			console.log("this shouldn't happen");
		};
		let angletype = Array.isArray(angle) && angle.length >= 2 && typeof angle[0] === "number" && typeof angle[1] === "number";
		//angletype = angletype || angle instanceof Angle;
		if(angletype || isrevolutions(angle)) {
			angletype = "3d";
		}
		else if(typeof angle === "number") {
			angletype = "2d";
		}
		else {
			angletype = null;
			console.log("invalid angle: " + angle);
		};
		let formattype = null;
		if(["xy", "xz", "yz"].includes(format)) {
			formattype = "2d";
		}
		else if(["neo", "old", "xz/y"].includes(format)) {
			formattype = "3d";
		}
		else if(!format) {
			formattype = "3d";
			format = "neo";
		}
		else if(Array.isArray(format) && format.length >= 2 && typeof format[0] === "number" && typeof format[1] === "number") {
			formattype = "roll";
		}
		else {
			console.log("invalid angle format: " + format);
			format = "neo";
			formattype = "3d";
		};
		if((angletype === "3d") !== (formattype === "3d")) {
			console.log("you used a " + angletype + " angle with a " + formattype + " format.");
		};
		// format is now known, it's xy/z if 3d and xy, xz, or yz if 2d
		let axis1 = 0;
		let axis2 = 0;
		if(["xy", "xz", "yz"].includes(format)) {
			axis1 = "xyz".indexOf(format.charAt(0));
			//axis2 = (axis1 + 1)%3;
			axis2 = "xyz".indexOf(format.charAt(1));
			// easier to work with, this way
		};
		let coortemp = [];
		let angletemp = 0;
		let matrix = null;
		// used in neo and roll
		let oldmatrix = null;
		// used only in roll
		if(format === "neo") {
			matrix = [
				[1, 0, 0],
				[0, 1, 0],
				[0, 0, 1]
			];
			if(isrevolutions(angle)) {
			// revolutions object
				let format = "";
				for (i1 in angle) {
					if (angle.hasOwnProperty(i1)) {
						format = (i1.includes("_") ? i1.slice(0, i1.indexOf("_")) : i1);
						matrix = revolve(angle[i1], matrix, false, format);
					}
				}
			}
			else {
				//let lr = getlinerevolve(angle);
				//matrix = revolve(lr.magnitude, matrix, [lr.axis.x, lr.axis.y, lr.axis.z], lr.axis.angle);
				//logspecial(matrix, "before", true);
				//logspecial({xy_: lr.axis.angle[0]*180/Math.PI, _z: lr.axis.angle[1]*180/Math.PI, magnitude: lr.magnitude*180/Math.PI,}, "lr", true);
				//matrix = lr.axis.linerevolve(lr.magnitude, matrix);
				//logspecial(matrix, "after", true);
				let glr = GLR.new(angle);
				matrix = revolve(glr.magnitude, matrix, null, GLR.axis(glr));
			};
			let hypot = [];
			for (i1 = 0; i1 < 3; i1++) {
				hypot[i1] = Math.hypot(
					matrix[i1][0] - matrix[(i1 + 1)%3][0],
					matrix[i1][1] - matrix[(i1 + 1)%3][1],
					matrix[i1][2] - matrix[(i1 + 1)%3][2]
				);
				if(Math.abs(Math.SQRT2 - hypot[i1]) > .00001) {
					console.log("bad angle: " + [angle[0]*180/Math.PI, angle[1]*180/Math.PI]);
					i1 += 3;
				};
			};
			matrix = {
				x: new Line(0, 0, 0, Angle.get(...matrix[0])),
				y: new Line(0, 0, 0, Angle.get(...matrix[1])),
				z: new Line(0, 0, 0, Angle.get(...matrix[2])),
			};
			// convert these points into Lines.
		}
		else if(formattype === "roll") {
			if(typeof format[2] === "number") {
				angle = posmod(angle + format[2], 2*Math.PI);
			};
			oldmatrix = [
				structuredClone([format[0], format[1], 0]),
				rolldirection([format[0], format[1], 0]),
				rolldirection([format[0], format[1], Math.PI/2])
			];
			// if you make these angles into Lines, they should all be
			// perpendicular to each other.
			matrix = [
				structuredClone([format[0], format[1], 0]),
				rolldirection([format[0], format[1], angle]),
				rolldirection([format[0], format[1], posmod(angle + Math.PI/2, 2*Math.PI)])
			];
			// same thing, except they're rotated by whatever 2d angle was
			// specified
			/*
			logspecial([
				format[0]*180/Math.PI,
				format[1]*180/Math.PI,
				angle*180/Math.PI
			], "angle", true);
			logspecial([
				Angle.numbers(oldmatrix[0]),
				Angle.numbers(oldmatrix[1]),
				Angle.numbers(oldmatrix[2])
			], "oldmatrix", true);
			logspecial([
				Angle.numbers(matrix[0]),
				Angle.numbers(matrix[1]),
				Angle.numbers(matrix[2])
			], "matrix", true);
			//*/
			let compare = [];
			for (i1 = 0; i1 < 3; i1++) {
				compare[0] = Angle.compare(oldmatrix[i1], oldmatrix[(i1 + 1)%3]);
				compare[1] = Angle.compare(matrix[i1], matrix[(i1 + 1)%3]);
				if(Math.abs(compare[0] - Math.PI/2) > .00001 || Math.abs(compare[1] - Math.PI/2) > .00001) {
					console.log("bad angle: " + [format[0]*180/Math.PI, format[1]*180/Math.PI, angle*180/Math.PI]);
					i1 += 3;
				};
			}
			for (i1 = 0; i1 < 3; i1++) {
				oldmatrix[i1] = new Line(0, 0, 0, oldmatrix[i1]);
				matrix[i1] = new Line(0, 0, 0, matrix[i1]);
			}
			// this works just like the other revolve, checking where each point
			// is on the old axes and translating that to the new axes
			// -
			// the matrix axes are numbers instead of letters because they're
			// placed around the revolve line's angle rather than space
		}
		for (i1 = 0; i1 < r_points.length; i1++) {
			if(!Array.isArray(r_points[i1])) {
				r_points[i1] = [r_points[i1].x, r_points[i1].y, r_points[i1].z];
			};
			coortemp = Points.subtract(r_points[i1], center);
			// coordinates relative to the center
			if(formattype === "2d" && (coortemp[axis1] || coortemp[axis2])) {
				let temp = Point2.rotate([coortemp[axis1], coortemp[axis2]], angle);
				r_points[i1][axis1] = center[axis1] + temp[0];
				r_points[i1][axis2] = center[axis2] + temp[1];
			}
			else if(["3d", "roll"].includes(formattype) && (coortemp[0] || coortemp[1] || coortemp[2])) {
			// if all coordinates are zero, rotating it won't move it.
				if(format === "neo") {
					r_points[i1] = [
						matrix.x.findposition(coortemp[0]),
						matrix.y.findposition(coortemp[1]),
						matrix.z.findposition(coortemp[2]),
					];
					// translate its distances across the old axes into what x/y/z
					// those distances mean on the new axes.
					r_points[i1] = [
						center[0] + r_points[i1][0][0] + r_points[i1][1][0] + r_points[i1][2][0],
						center[1] + r_points[i1][0][1] + r_points[i1][1][1] + r_points[i1][2][1],
						center[2] + r_points[i1][0][2] + r_points[i1][1][2] + r_points[i1][2][2],
					];
					// but findposition returns three-coordinates arrays, so you
					// gotta sum them up. add the center back while you're at it.
				}
				else if(format === "old") {
					// if both are zero, it's right on the center, meaning
					// there's no point revolving (and Angle.get will turn up
					// errors)
					dist = Math.hypot(coortemp[0], coortemp[1], coortemp[2]);
					angletemp = Angle.get(coortemp[0], coortemp[1], coortemp[2]);
					// original angle
					angletemp[0] += angle[0];
					angletemp[1] += angle[1];
					// modified angle
					angletemp = Angle.correct(angletemp);
					// make sure it isn't out of bounds
					angletemp = Angle.numbers(angletemp);
					r_points[i1][0] = center[0] + angletemp[0]*dist;
					r_points[i1][1] = center[1] + angletemp[1]*dist;
					r_points[i1][2] = center[2] + angletemp[2]*dist;
				}
				else if(formattype === "roll") {
					r_points[i1] = [
						oldmatrix[0].findplace(coortemp),
						oldmatrix[1].findplace(coortemp),
						oldmatrix[2].findplace(coortemp)
					];
					// find its place in the coordinate system formed around the
					// oldmatrix
					r_points[i1] = [
						matrix[0].findposition(r_points[i1][0]),
						matrix[1].findposition(r_points[i1][1]),
						matrix[2].findposition(r_points[i1][2])
					];
					// translate that into the new matrix
					r_points[i1] = [
						center[0] + r_points[i1][0][0] + r_points[i1][1][0] + r_points[i1][2][0],
						center[1] + r_points[i1][0][1] + r_points[i1][1][1] + r_points[i1][2][1],
						center[2] + r_points[i1][0][2] + r_points[i1][1][2] + r_points[i1][2][2],
					];
					// findposition returns arrays, so sum them up
				};
			}
		}
		//
		if(one_point) {
			r_points = r_points[0];
		};
		return r_points;
	}
	let Rel = {
	// means "relative angle", as in the difference between one 3d angle and
	// another.
	// - relative angles consist of a line revolve, and a roll change.
	// - how it works is:
	//   - get getlinerevolve and roll of angle1
	//   - apply an inverse of that getlinerevolve to angle2, and subtract the
	//     roll
	//   - get the getlinerevolve of this new angle, but trim it down to the
	//     axis angle and magnitude
	//   - include the difference between angle1 and angle2's roll
	// - they're applied by taking the angle numbers, revolving them with the
	//   magnitude and axis direction the relative angle specifies, converting
	//   it back to an angle, and adding the roll change.
		get: function(angle1, angle2) {
		// creates a relative angle, angle2 minus angle1.
			//let lr = getlinerevolve(angle1);
			let lr = GLR.new(angle);
			let num = Angle.roll.numbers(angle2);
			// short for "angle numbers and satellite". Angle.numbers and
			// satellite of angle2
			num = revolve(posmod(-lr.magnitude, 2*Math.PI), num, false, GLR.axis(lr));
			// revert to what would make angle1 [0, 0]
			let rel = Angle.get(...num[0]);
			rel = GLR.new(rel);
			// line revolve of that
			num = revolve(rel.magnitude, Angle.roll.numbers([0, 0]), false, GLR.axis(rel));
			num = revolve(lr.magnitude, num, false, GLR.axis(lr));
			// what Rel.apply does, with unnecessary bits cut out
			let roll = Angle.roll.get(num)[2];
			rel = {
				xy: GLR.axis(rel)[0],
				z: GLR.axis(rel)[1],
				magnitude: rel.magnitude,
				rollchange: posmod(
					//(angle2[2] ?? 0) - (angle1[2] ?? 0),
					(angle2[2] ?? 0) - roll,
					2*Math.PI
				),
			};
			return rel;
		},
		apply: function(absangle, relangle) {
		// applies the relative angle to the absolute angle, returning a new
		// absolute angle
		// - how it works is that it saves the revolution and roll that would
		//   bring [1, 0, 0] and [1, 1, 0] to what the absangle starts as,
		//   applies the relative angle to [1, 0, 0] and [1, 1, 0], then adds
		//   back that line revolve and roll
			//let lr = getlinerevolve(absangle);
			let lr = GLR.new(absangle);
			// axis, magnitude
			//
			let num = Angle.roll.numbers([0, 0, 0]);
			// convert angle to numbers, do an inverse line revolve back to
			// angle [0, 0, 0]. the actual math for that is a waste of time but
			// that's the principle.
			num = revolve(relangle.magnitude, num, false, [relangle.xy, relangle.z]);
			if(relangle.rollchange) {
				num = Angle.roll.get(num);
				num[2] = posmod(num[2] + relangle.rollchange, 2*Math.PI);
				num = Angle.roll.numbers(num);
			};
			num = revolve(lr.magnitude, num, false, GLR.axis(lr));
			return Angle.roll.get(num);
		},
		invert: function(relangle) {
			let _return = structuredClone(relangle);
			_return.magnitude = posmod(-_return.magnitude, 2*Math.PI);
			_return.rollchange = posmod(-_return.rollchange, 2*Math.PI);
			return _return;
		},
		orient: function(absangle, relangle, points, center) {
		// - to get a relative angle that can be used as a 3d orientation thing:
		//   - create a [0, 0, 0] angle. (or any angle, really. as long as you
		//     can get the same thing later.)
		//   - when applying revolutions to the shape in question, also apply
		//     revolutions to this angle, using Angle.roll.numbers(angle) and
		//     Angle.roll.get
		//   - use Rel.get on the angle you started with and this new angle
		// - to use it, just put it into this function.
		// - absangle: the angle you start with, like the [0, 0, 0] i used as an
		//   example.
			let _points = revolve(relangle.magnitude, structuredClone(points), center, [relangle.xy, relangle.z]);
			let newangle = Rel.apply(absangle, relangle);
			return (
				relangle.rollchange
				?
				revolve(relangle.rollchange, _points, center, newangle)
				// apply roll
				:
				_points
			);
		},
		useless: function(relangle) {
			function uselessnum(input) {
				return Math.min(Math.abs(input), Math.abs(input - 2*Math.PI))/(2*Math.PI) < .0000000001;
			}
			return uselessnum(relangle.magnitude) && uselessnum(relangle.rollchange);
		},
		//rand: (includeroll) => Rel.get(Angle.rand(includeroll), Angle.rand(includeroll)),
		// Angle.rand includeroll is gone now, and this isn't worth making a
		// workaround for
	};
	function calcroll(angle, revolutions) {
	// this will return an array of three numbers. they represent the new xy/z
	// angle and the roll.
	// - angle: this is the absolute angle you start with. if you do specify a
	//   third number for roll, it is assumed it starts at zero.
	// - revolutions: it's kinda like Operations, create an object with properties
	//   named after rotations formats. (xy, xz, yz, xy/z. like operations, you
	//   can write an underscore after the format and it'll use everything before
	//   that as the angle format.) it will apply these revolutions and calculate
	//   the roll.
		let i1 = 0;
		let point = [];
		let returnvalue = [];
		returnvalue[2] = (angle.length >= 3 ? angle[2] : 0);
		point[0] = Angle.numbers(angle);
		point[1] = revolve(angle, [1, 1, 0]);
		/*
		let inverseangle = [
			posmod(2*Math.PI - angle[0], 2*Math.PI),
			-angle[1]
		];
		point[0] = revolve(inverseangle, point[0]);
		// revolve back to [1, 0, 0], aka xy/z 0, 0
		let point[1] = [1, 1, 0];
		// add satellite we can measure roll from
		point[0] = revolve(angle, point[0]);
		point[1] = revolve(angle, point[1]);
		// revolve back to where it was
		// -
		//*/
		// i never actually intended to use this code. it's just a clearer way
		// of showing what i'm doing. point[1] should be in the same place it
		// would be if point[0] started out at an xy/z of 0, 0 and was revolved
		// by angle to get where it is.
		let format = "";
		for (i1 in revolutions) {
			if (revolutions.hasOwnProperty(i1)) {
				if(i1.includes("_")) {
					format = i1.slice(0, i1.indexOf("_"));
				}
				else {
					format = i1;
				};
				point = revolve(revolutions[i1], point, false, format);
			}
		}
		returnvalue[0] = Angle.get(point[0][0], point[0][1], point[0][2]);
		// absolute angle after revolutions
		returnvalue[1] = returnvalue[0][1];
		returnvalue[0] = returnvalue[0][0];
		let inverseangle = [
			posmod(2*Math.PI - returnvalue[0], 2*Math.PI),
			-returnvalue[1]
		];
		point = revolve(inverseangle, point);
		// revolve to [1, 0, 0]
		if(Math.abs(point[1][0] - point[0][0]) > .0000000001) {
		// they *should* have the same x.
			console.log("this shouldn't happen");
		};
		returnvalue[2] += get2dangle(point[1][1] - point[0][1], point[1][2] - point[0][2], true);
		// the point[1]'s relation to point[0] should be a yz angle, so turn
		// that into a 0 to 2 pi number. that's roll.
		// - this used to start as [1, 0, 1] and make the 2d angle with z before
		//   y, but this is better. x (is 1 at 0 angle) and y = normal 2d angle
		//   system, y (1 at 0 angle) and z = roll angle
		return returnvalue;
	}
	let GLR = {
	// pseudoclass. stores orientation, sort of. an object storing the data for
	// a revolution from [1, 0, 0] to the specified angle. (which can include
	// roll.)
	// - the theory this all revolves around is finding the circle that the
	//   angle numbers and [1, 0, 0] rest on.
	// - structure:
	//   - axis_xy_is_0, axis_z, axis getter: the axis used for the revolve. xy
	//     is always 90 unless axis_xy_is_0 is on. axis_z varies. axis is a
	//     getter that simplifies this into a real angle.
	//   - magnitude: a 2d angle for how much to revolve
	//   - roll: the roll of the original angle. if roll is involved, do a yz
	//     revolve with this angle before the line revolve.
		new: function(angle) {
			angle ??= [0, 0, 0];
			let axis_z = 0;
			let axis_xy_is_0 = false;
			let magnitude = null;
			if(angle[1] === 0) {
				// axis is perpendicular to the xy plane
				axis_xy_is_0 = true;
				axis_z = Math.PI/2;
				magnitude = angle[0];
				if(magnitude < Math.PI) {
					magnitude = posmod(-magnitude, 2*Math.PI);
					axis_z *= -1;
				};
			}
			else if(Math.abs(angle[1]) === Math.PI/2) {
				axis_z = 0;
				magnitude = posmod(-angle[1], 2*Math.PI);
			}
			else if([0, Math.PI].includes(angle[0]) && !angle[1]) {
				// axis is vertical
				axis_z = Math.PI/2;
				magnitude = posmod(angle[1] + angle[0], 2*Math.PI);
			}
			else {
				// the theory behind this process is: the angle numbers of [0, 0] and the
				// target angle fall on the same circle, so this is trying to find the
				// correct axis and magnitude.
				// - that axis is always along the yz plane.
				let anglenum = Angle.numbers(angle);
				//
				magnitude = Math.acos(anglenum[0]);
				// the angle for where it is on the circle.
				//
				axis_z = Angle.get(0, -anglenum[2], anglenum[1]);
				// flatten it into a yz angle, rotate it 90 degrees so it's
				// perpendicular
				let axis_xy = axis_z[0];
				axis_z = axis_z[1];
				axis_xy = Math.round(axis_xy / (Math.PI/2));
				// convert to 0-4 number (it should be infinitesimally close to a
				// 0/90/180/270 angle)
				if(axis_xy >= 2) {
					// if it's 270, flip it
					axis_xy = 4 - axis_xy;
					axis_z *= -1;
					magnitude = posmod(-magnitude, 2*Math.PI);
				};
				axis_xy_is_0 = !axis_xy;
			};
			return {
				axis_xy_is_0,
				axis_z,
				magnitude,
				roll: angle[2] ?? 0,
			};
		},
		axis: (_this) => [
			!_this.axis_xy_is_0 * Math.PI/2,
			_this.axis_z
		],
		apply: function(_this, point) {
			let _point = structuredClone(point);
			if(_this.roll) {
				_point = revolve(_this.roll, _point, null, "yz");
			};
			if(_this.magnitude) {
				_point = revolve(_this.magnitude, _point, null, GLR.axis(_this));
			};
			return _point;
		},
		to_points: function(_this, include_z) {
			let array = [
				GLR.apply(_this, [1, 0, 0]),
				GLR.apply(_this, [0, 1, 0])
			];
			if(include_z) {
				array[2] = GLR.apply(_this, [0, 0, 1]);
			};
			return array;
		},
		// converts it to the Angle.numbers for an x pole and a y pole.
		from_points: function(points) {
			let glr = GLR.new(Angle.get(...points[0]));
			// GLR that brings [1, 0, 0] to points[0]
			let temp = structuredClone(glr);
			temp.magnitude = posmod(2*Math.PI - temp.magnitude, 2*Math.PI);
			temp = GLR.apply(temp, structuredClone(points[1]));
			// inverse that revolution so it can discern roll
			glr.roll = get2dangle(temp[1], temp[2]);
			return glr;
		},
		// converts it back
		revolve: function(_this, format, angle, center) {
			let temp = revolve(angle, GLR.to_points(_this), center, format);
			return GLR.from_points(temp);
		},
		// applies a revolution
	};
	function rolldirection(angle) {
	// returns an xy/z for what direction roll points in.
	// - the way revolve works is that it revolves the points around whatever
	//   line and magnitude would bring a [1, 0, 0] point to the angle
	//   specified.
	// - so the way roll works is that 0 will always be whatever direction a
	//   [0, 1, 0] point would be in if it was dragged along.
	//   - 90 would be a [0, 0, 1] point.
		let i1 = 0;
		let xy_ = angle[0];
		let _z = angle[1];
		let roll = angle[2] ?? 0;
		let satel = [0, Math.cos(roll), -Math.sin(roll)];
		// or [0, 1, 0] if roll is 0, [0, 0, -1] if roll is 90
		let anglenum = Angle.numbers(angle);
		let doublecheck = null;
		let revolvetype = null;
		// for logging errors
		if(_z === 0) {
			satel = revolve(xy_, satel, null, "xy");
			doublecheck = revolve(xy_, [1, 0, 0], null, "xy");
			revolvetype = "_z === 0";
		}
		else if(Math.abs(_z) === Math.PI/2) {
			let temp = posmod(_z, 2*Math.PI);
			satel = revolve(temp, satel, null, "xz");
			doublecheck = revolve(temp, [1, 0, 0], null, "xz");
			revolvetype = "Math.abs(_z) === Math.PI/2";
		}
		else if([0, Math.PI].includes(xy_)) {
			let temp = posmod(_z + xy_, 2*Math.PI);
			satel = revolve(temp, satel, null, "xz");
			doublecheck = revolve(temp, [1, 0, 0], null, "xz");
			revolvetype = "[0, Math.PI].includes(xy_)";
		}
		else {
			revolvetype = "main";
			function linerevolve(point) {
			// something's wrong with how this works because running it on [1,
			// 0, 0] doesn't make it close to the anglenum.
			// - run through the process:
			//   - use getlinerevolve to get the axis, magnitude, and circ_hw
			//     - nothing's wrong with this, i tested it with a ProcAnim
			//   - get the findplace
			//   - move it to the revolve plane
			//   - make y a number from -1 to 1 by dividing it by circ_hw
			//   - xy revolve
			//   - multiply it by circ_hw again, move it to the revolve plane
			//     again
			//   - reverse the move to the revolve plane
				let satel = structuredClone(point);
				let lr = GLR.new(angle);
				let line = new Line(0, 0, 0, GLR.axis(lr));
				let circ_hw = Angle.numbers(angle);
				circ_hw = Math.abs(Math.sin(get2dangle(circ_hw[2], circ_hw[1])));
				if(angle[0] < Math.PI) {
					lr.magnitude = posmod(-lr.magnitude, 2*Math.PI);
				}
				// lr.axis, lr.magnitude, lr.circ_hw
				// this is how much to rotate by.
				// -
				// that's the axis and magnitude that takes [1, 0, 0] to anglenum, so
				// now we figure out what doing the same thing does to [1, 1, 0]
				// - (n/a here) get coordinates relative to fulcrum
				let axisplace = line.findplace(satel);
				// need this number for later
				satel = line.plane().movetoplane(satel);
				// to move it to the revolution plane, make it into a line parallel to
				// the axis and find where that intersects with the plane
				satel[1] /= circ_hw;
				satel = revolve(lr.magnitude, satel, false, "xy");
				satel[1] *= circ_hw;
				satel = line.plane().planepoint(satel[0], satel[1], "z");
				// - revolve
				// - reverse the lr.circ_hw division
				// - put it on the revolution plane (z is made unreliable by the 2d
				//   revolution, so you need planepoint to get the right z)
				//*
				satel = new Line(...satel, GLR.axis(lr));
				satel = satel.findposition(axisplace);
				//*/
				// - reverse the move to plane
				return satel;
			}
			// all of this code would be much easier if i could use line revolve
			// the normal way, but i can't because line revolve uses this.
			// - thankfully it's doable because the line revolve axis is always
			//   on the yz plane
			satel = linerevolve(satel);
			doublecheck = linerevolve([1, 0, 0]);
		};
		doublecheck = Math.hypot(
			anglenum[0] - doublecheck[0],
			anglenum[1] - doublecheck[1],
			anglenum[2] - doublecheck[2]
		);
		if(doublecheck >= .00001) {
			console.log(
				revolvetype + " rolldirection error: " + doublecheck + " units away." + String.fromCharCode(10) +
				"angle: " + Angle.convert(angle)
			);
		};
		return Angle.get(
			satel[0] - anglenum[0],
			satel[1] - anglenum[1],
			satel[2] - anglenum[2]
		);
	}
	function rollinverse(angle, rollangle) {
	// does the opposite of roll direction, taking a direction perpendicular to
	// the angle and figuring out which roll would produce that.
		let temp = Math.abs(Angle.compare(angle, rollangle) - Math.PI/2);
		if(temp > .0000000001) {
			console.log("rollinverse: rollangle is not perpendicular. " + temp);
			return;
		};
		let points = Angle.numbers(angle);
		points = [
			structuredClone(points),
			structuredClone(points)
			// satellite
		];
		temp = Angle.numbers(rollangle);
		points[1][0] += temp[0];
		points[1][1] += temp[1];
		points[1][2] += temp[2];
		// 0: angle numbers, 1: satellite
		//let lr = getlinerevolve(angle);
		let lr = GLR.new(angle);
		lr.magnitude = posmod(-lr.magnitude, 2*Math.PI);
		//points = lr.axis.linerevolve(lr.magnitude, points);
		points = revolve(lr.magnitude, points, null, GLR.axis(lr));
		// this should revolve it back to [1, 0, 0]
		temp = [];
		temp[0] = Math.hypot(
			points[0][0] - 1,
			points[0][1],
			points[0][2],
		);
		temp[1] = Math.abs(points[1][0] - 1);
		temp[2] = Math.abs(Math.hypot(points[1][1], points[1][2]) - 1);
		if(temp[0] > .0000000001) {
			console.log("rollinverse: point is " + temp[0] + " away from [1, 0, 0]");
		};
		if(temp[1] > .0000000001 || temp[2] > .0000000001) {
			console.log("rollinverse: satellite x is " + temp[0] + " away from 1 and satellite y/z hypotenuse is " + temp[2] + " away from 1.");
		};
		return get2dangle(
			points[1][1] - points[0][1],
			points[1][2] - points[0][2]
		);
	}
	function tricoordinates(tri, point, inverse) {
	// converts 2d or 3d coordinates to coordinates defined by the triangle.
	// - inverse: the opposite process, converting triangle coordinates to
	//   2d/3d.
	// - the way it works is this:
	//   - point 0 of the triangle is [0, 0]
	//   - point 1 is [1, 0]
	//   - point 2 is [0, 1].
	//   - the coordinates are a measure of how far along each side of the
	//     triangle the point is.
	//   - it uses the line from 0 to 1 and the line from 0 to 2 as axes. in
	//     other words, to find "x" it finds which 0-to-2-parallel line the
	//     point is on, and where it intersects with the 0 to 1 line. (0
	//     being at point 0, 1 being point 1, and possibly more or less than
	//     that, but that would make it outside the triangle.) "y" is the
	//     opposite.
	//     =
	//         1y--2
	//            / \
	//      .5y--*---*
	//          /   / \
	//     0y--0---*---1
	//        /   /   /
	//       0x .5x  1x
	//   - points are outside the triangle if x and y adds up to more than
	//     1, or if either is negative.
	// - anyway, i use this for 3d texturing.
	//   - get perspectived triangle points
	//   - run _2dpoly.execute
	//     - run screeninverse to figure out what 3d point this pixel
	//       represents
	//     - use tricoordinates to convert it to triangle coordinates
	//     - use inverse tricoordinates with the 2d triangle assigned to that 3d
	//       triangle to figure out which pixel of the texture image to
	//       reference for the color
		let i1 = 0;
		let mode = null;
		let _point = null;
		if(tri[0].length === 2 && tri[1].length === 2 && tri[2].length === 2 && (inverse || point.length === 2)) {
			mode = "2d";
			_point = point;
		}
		else if(tri[0].length === 3 && tri[1].length === 3 && tri[2].length === 3 && (inverse || point.length === 3)) {
			mode = "3d";
			_point = Plane.frompoints(tri).movetoplane(point);
		}
		else {
			console.log("inconsistent coordinate array lengths. (or maybe it was nullish or something.)");
			return;
		};
		if(inverse) {
			let newpoint = structuredClone(tri[0]);
			for (i1 = 0; i1 < (mode === "2d" ? 2 : 3); i1++) {
				newpoint[i1] += point[0]*(tri[1][i1] - tri[0][i1]);
				newpoint[i1] += point[1]*(tri[2][i1] - tri[0][i1]);
			};
			return newpoint;
		}
		else {
			let xunit = [];
			let yunit = [];
			// (by x and y i mean how they work in triangle coordinates. these
			// are variables for how 1 x/y of triangle coordinates converts to
			// 3d space.)
			let alldist = [];
			let sum = {
				x: 0,
				y: 0,
				all: 0,
			};
			for (i1 = 0; i1 < (mode === "2d" ? 2 : 3); i1++) {
				xunit[i1] = tri[1][i1] - tri[0][i1];
				yunit[i1] = tri[2][i1] - tri[0][i1];
				alldist[i1] = _point[i1] - tri[0][i1];
				sum.x += xunit[i1];
				sum.y += yunit[i1];
				sum.all += alldist[i1];
			};
			// as in the change in position that comes from moving 1 in this
			// triangle axis, and the total distances from point 0 to the main
			// point. n1 number of xunits plus n2 number of yunits = alldist.
			// that's the math we gotta do.
			// -
			// n1 * xdist[0] + n2 * ydist[0] = alldist[0],
			// n1 * xdist[1] + n2 * ydist[1] = alldist[1],
			// and n1 * xdist[2] + n2 * ydist[2] = alldist[2], so:
			// -
			// n1 * sum.x + n2 * sum.y = sum.all
			if(mode === "2d") {
				let axis = {
					x: new Line(...tri[0], 0, Angle.get(...xunit, 0)),
					y: new Line(...tri[0], 0, Angle.get(...yunit, 0)),
				};
				return [
					axis.x.findplace(_point)/Math.hypot(...xunit),
					axis.y.findplace(_point)/Math.hypot(...yunit)
				];
			}
			else if(mode === "3d") {
				let axis = {
					x: new Line(...tri[0], Angle.get(...xunit)),
					y: new Line(...tri[0], Angle.get(...yunit)),
				};
				return [
					axis.x.findplace(_point)/Math.hypot(...xunit),
					axis.y.findplace(_point)/Math.hypot(...yunit)
				];
			};
		}
	}
	function functiontimer(func, args) {
	// executes the function and returns the number of seconds it took to
	// execute.
		let starttime = new Date();
		func(...args);
		let endtime = new Date();
		return ((endtime.valueOf() - starttime.valueOf())/1000);
	}
	function forinspecial(code, object, runforparents, fis_i) {
	/*
	forinspecial(function(property, keychain, parent) {
		let propstring = keychain[keychain.length - 1];
	}, object, runforparents);
	//*/
	// if this works as intended, it will allow the function specified
	// to run for every property and property's property and property's
	// property's property, and so on. this is possible thanks to it
	// calling itself.
	// - the code should be a function with these arguments:
	//   - property (not the name/string, but the value stored in that
	//     property.)
	//   - keychain (an array of the strings of the property, the property's
	//     property, etc chain that this property is part of. .length can be
	//     used to know how deep in it is too.)
	//   - parent: the object the property is a property of (you could get this
	//     by using fis_i but that's annoying)
	// - runforparents: a boolean. if true, code will run for properties
	//   that are objects themselves. if not, it'll skip those.
	// - fis_i: don't type anything for this. this is just a variable,
	//   the only reason it's a parameter is so it can be passed into
	//   into the next iteration.
	// =
	// moved to reusables
		if(fis_i === undefined) {
			fis_i = [];
		};
		if(fis_i.length > 1000) {
			return;
		};
		let fis_level = fis_i.length;
		// represents how many levels in it is. 0 is a property of the
		// object. 1 is a property's property. etc.
		for (fis_i[fis_level] in object) {
			if (object.hasOwnProperty(fis_i[fis_level])) {
			// check every property
				if(typeof object[fis_i[fis_level]] === "object" && !Array.isArray(object[fis_i[fis_level]]) && object[fis_i[fis_level]]) {
				// if this property is an object of its own, (and not an array or
				// null) run the function on it. (retain fis_i so you can keep track
				// of the keys)
				// - long story short, Object.keys().length CANNOT be
				//   used to check if something's an object. if it's a
				//   string, for whatever goddamn reason
				//   Object.keys(stringvariable) will be an array of as
				//   number strings as there are characters in the
				//   string.
				// - gotta use typeof, and also check its truthy/falsy
				//   status because object is used for anything that it
				//   can't categorize. also null. null is an object. i
				//   don't care what smart ass reasons they have for
				//   that. that's fuckin stupid
				//   - eh i guess it's pretty bad faith to assume it's
				//     because something something "well technically,
				//     technically that's the closest thing null can be
				//     defined as,". these are programmers. they
				//     probably have practical reasons. (but they better
				//     be damned good ones.)
					if(runforparents) {
						code(object[fis_i[fis_level]], fis_i, object);
					};
					forinspecial(code, object[fis_i[fis_level]], runforparents, fis_i);
					fis_i.splice(fis_i.length - 1, 1);
					// make sure those properties aren't retained in
					// fis_i
				}
				else {
				// if not, run the code
					code(object[fis_i[fis_level]], fis_i, object);
				};
			};
		}
	}
	/*
	function hasproperty(object, property) {
		return (isobject(object) && Object.keys(object).includes(property));
	}
	function getproperty(object, propertyname) {
		if(object.hasproperty(propertyname)) {
			return object[propertyname];
		}
		else {
			return false;
		};
	}
	//*/
	function arraytoobject(array) {
		let i1 = 0;
		if(!Array.isArray(array)) {
			if(typeof array === "object") {
				return array;
			}
			else {
				console.log("invalid input.");
				return;
			};
		};
		object = {};
		for (i1 = 0; i1 < array.length; i1++) {
			object[i1] = structuredClone(array[i1]);
		};
		return object;
	};
	function objecttoarray(object) {
		let i1 = 0;
		if(Array.isArray(object) || typeof object !== "object") {
			console.log("invalid input.");
			return;
		};
		array = [];
		for (i1 in object) {
			if (object.hasOwnProperty(i1) && Number.isInteger(Number(i1)) && (i1 || i1 === 0)) {
				array[Number(i1)] = structuredClone(object[i1]);
			};
		}
		return array;
	};
	function objarraylength(object) {
	// returns a number equivalent to the .length of an array. one more than the
	// highest integer property.
	// =
	// moved to reusables
		let i1 = "";
		let highest = null;
		for (i1 in object) {
			if (
				object.hasOwnProperty(i1) && Number.isInteger(Number(i1)) && (i1 || i1 === 0)
				&&
				(highest === null || Number(i1) > highest)
			) {
				highest = Number(i1);
			};
		}
		if(highest === null) {
			return 0;
		}
		else {
			return highest + 1;
		};
	}
	function removewhitespace(input, join) {
	// used it on a bracketindent-ed JSON.stringify to convert it back to
	// JSON.parse-able text. (actually i don't know if JSON.parse is bothered by
	// whitespace but whatever. consistency. reversibility.)
	// - join: the character to use when .join-ing it back at the end. if it
	//   isn't a string, it'll return an unjoined array instead
	//   - NOTE: sets of quotes count as a single word.
		let i1 = 0;
		let i2 = 0;
		input = input.trim();
		let output = [];
		// an index for each word
		output[0] = "";
		let quotes = null;
		// stores null, or a character code for the kind of quotes it's in.
		let whitespacenum = 0;
		// a temp for the number of consecutive whitespaces
		for (i1 = 0; i1 < input.length; i1++) {
			let bool = false;
			// boolean for whether it entered quotes during this character. (to
			// keep quote enter conditions from also being quote exit
			// conditions)
			if(quotes === null && [34, 39, 96].includes(input.charCodeAt(i1))) {
			// enter quotes mode and save what kind of quote it is
				quotes = input.charCodeAt(i1);
				bool = true;
			};
			if(quotes !== null || input[i1].trim()) {
			// if it's in quotes, it shouldn't delete spaces and stuff like
			// that.
				output[output.length - 1] += input[i1];
				whitespacenum = 0;
			}
			else {
			// whitespace
				if(whitespacenum === 0) {
				// if onespace is on and this isn't a consecutive space, add a
				// new word
					output[output.length] = "";
				};
				whitespacenum++;
			};
			if(!bool && quotes !== null && input.charCodeAt(i1) === quotes) {
			// matches the beginning quotes, so exit quote mode
				quotes = null;
			};
		}
		if(typeof join === "string") {
			return output.join(join);
		}
		else {
			return output;
		};
	}
	function objlength(obj) {
	// returns the number of properties an object has.
		let i1 = 0;
		let num = 0;
		for (i1 in obj) {
			if (obj.hasOwnProperty(i1)) {
				num++;
			}
		}
		return num;
	};
	function newpropertyname(object, string) {
	// returns a version of the string you entered that, by adding numbers, is
	// not the name of a property the object already has.
	// - string: the name you want to give this property.
		let i1 = 0;
		let name = string;
		if(object.hasOwnProperty(string)) {
			let temp = (string ? "_" : "") + i1;
			// only add the underscore if string is truthy
			for (i1 = 1; object.hasOwnProperty(string + temp); i1++) {
			}
			name += temp;
			// increase i1 until it reaches a number that won't share a name with
			// another track.
		}
		return name;
	}
	function mapstructure(object, types) {
	// creates an array of arrays with property names. use it with compareobject
	// to check if the structure of two objects matches.
	// - types: if true, this will make it record the typeof instead of the
	//   property name.
	//   - obviously, only use this in combination with the normal mode, because
	//     otherwise changes to property names will slip through unnoticed.
		let i1 = 0;
		let array = [];
		for (i1 in object) {
			if (object.hasOwnProperty(i1)) {
				array[array.length] = (types ? typeofobject[i1] : i1);
				if(typeof object[i1] === "object") {
					array[array.length] = mapobjectstructure(object[i1]);
				};
			};
		}
		return array;
	}
	function noargumentscheck(args) {
	// returns a boolean for whether the function was run with no arguments.
	// - i use it for constructors because this is an easy way to be sure it's
	//   the kind of running where you're just running it so you can have an
	//   object with that class that you can insert the contents of another
	//   object into.
	// - anyway args should be an array or an object.
		let i1 = 0;
		for (i1 in args) {
			if (args.hasOwnProperty(i1) && typeof args[i1] !== "undefined") {
				return false;
			}
		}
		return true;
	}
	function getspheroidradius(angles, w, h, d) {
		return Math.hypot(
			(w/2)*Math.cos(angles[1])*Math.cos(angles[0])
			(h/2)*Math.cos(angles[1])*Math.sin(angles[0]),
			(d/2)*Math.sin(angles[1]),
		);
		// fucking really!!!??
		// - the me from a few whatevers ago sure was a bitch
	}
	function withinrect(x, y, rect) {
	// checks if the coordinates are within the rectangle object provided.
	// (which should be an object with .x, .y, .w, .h)
		return (
			x >= rect.x
			&&
			x < rect.x + rect.w
			&&
			y >= rect.y
			&&
			y < rect.y + rect.h
		);
	}
	function onrect(x, y, rect, leeway) {
		leeway ??= 0;
		if(leeway) {
			x = Math.floor(x/leeway)*leeway;
			y = Math.floor(y/leeway)*leeway;
		};
		return (
			(
				(Math.abs(x - rect.x) <= leeway || Math.abs(x - (rect.x + rect.w)) <= leeway)
				&&
				rect.y <= y && y <= (rect.y + rect.h)
			)
			//[rect.x, rect.x + rect.w].includes(x))
			// on an x line
			||
			(
				(Math.abs(y - rect.y) <= leeway || Math.abs(y - (rect.y + rect.h)) <= leeway)
				&&
				rect.x <= x && x <= (rect.x + rect.w)
			)
			//[rect.y, rect.y + rect.h].includes(y)
			// on a y line
		);
	}
	function reversearray(array) {
		let _array = [];
		let i1 = 0;
		for(i1 = array.length - 1; i1 >= 0; i1--) {
			_array[_array.length] = structuredClone(array[i1]);
		};
		return _array;
	};
	function randomarrayitem(array, number) {
	// use Infinity to return a shuffled array.
		if(array.length === 0) {
			return null;
		}
		else if(typeof number === "number" && number > 1) {
			let _array = structuredClone(array);
			let choices = [];
			let i1 = 0;
			for(i1 = 0; i1 < number && _array.length > 0; i1++) {
				let temp = Math.floor(Math.random()*_array.length);
				choices[i1] = structuredClone(_array[temp]);
				_array.splice(temp, 1);
			}
			return choices;
		}
		else {
			return structuredClone(array[ Math.floor(Math.random()*array.length) ]);
		};
	};
	function multirandom(obj) {
	// use a "_multi" property to specify properties that should have more than one item selected.
		let _obj = structuredClone(obj);
		let multi = {};
		if(_obj.hasOwnProperty("_multi")) {
			multi = structuredClone(_obj._multi);
			delete _obj._multi;
		}
		let i1 = 0;
		for(i1 in _obj) {
			if(_obj.hasOwnProperty(i1) && Array.isArray(_obj[i1])) {
				let num = multi.hasOwnProperty(i1) ? multi[i1] : 1;
				// number of array items to pick
				_obj[i1] = randomarrayitem(_obj[i1], num);
			}
		}
		return _obj;
	}
	function weightedselect(choices) {
	// input an object of numbers, and it'll use those as weights for random
	// selection, returning the property name of whatever it picked.
		let i1 = 0;
		let total = 0;
		let names = [];
		let odds = [];
		for(i1 in choices) {
			if(choices.hasOwnProperty(i1) && typeof choices[i1] === "number" && choices[i1] > 0) {
				names.push(i1);
				odds.push(choices[i1]);
				total += choices[i1];
			}
		}
		if(!names.length) {
			return null;
		}
		let num = Math.random()*total;
		for(i1 = 0; i1 < odds.length; i1++) {
			num -= odds[i1];
			if(num < 0) {
				return names[i1];
			};
		}
		console.log("this shouldn't happen");
		return null;
	}
	Angle.roll = {
	// i've phased out roll/satellite stuff form Angle, because it was always
	// stupid. but there's ProcAnims and stuff that used them, so... this stores
	// alternatives that keep around roll/satellites.
		get: function(numsatel) {
		// this interprets your input as an array of two points: an angle
		// numbers and a roll satellite. it returns an angle with roll.
			let angle = Angle.get(...numsatel[0]);
			angle[2] = [
				numsatel[1][0] - numsatel[0][0],
				numsatel[1][1] - numsatel[0][1],
				numsatel[1][2] - numsatel[0][2],
			];
			angle[2] = Angle.get(...angle[2]);
			angle[2] = rollinverse(angle, angle[2]);
			return angle;
		},
		numbers: function(_this) {
			let points = [];
			points[0] = Angle.numbers(_this);
			points[1] = Angle.numbers(rolldirection(_this));
			points[1][0] += points[0][0];
			points[1][1] += points[0][1];
			points[1][2] += points[0][2];
			return points;
		},
	};
	class ProcAnim {
	// a thing for making procedural animations.
	// - i have nowhere else to put this so, here's some semi-universal
	//   variables.
	//   - v.pos: position. an array for where the animation is played.
	//   - v.rhythm: this one, i've just invented. it's for mickey mousing.
	//     - this should be a string of letters and spaces.
	//     - each character is a frame.
	//     - if the character for the current frame is a letter, it's assumed a
	//       note plays in the accompanying music on this frame, and the
	//       animation will probably have something happen accordingly.
	//       - sometimes it will react differently depending on which note is
	//         used, but not always.
	//     - if the character is a space, there is no note on this frame.
	//     - if it's a dash, a note is being held. most of the time this is the
	//       same as a frame with no note, but not always.
	//     - any other characters will be ignored, so you can use |s to divide
	//       measures and .s to divide beats or whatever.
	//     - if the frame is past the end of the rhythm string, it loops
	//     - use rhythmat(v.rhythm, frame) to return the character for that frame.
		constructor() {
		// the functions will be overwritten by whatever you write, but these
		// are the templates your functions should be based on. under penalty
		// of:
		// - having variables disappear between frames
		// - having fillStyle and shit like that be an inconsistent mess
			this.v = {};
			// do not define anything here. do that in initB, because initA
			// clears this.
			this.initB = function() {
			// initialize variables, ctxsettings, and animations
				let v = this.v;
				let u = v.u;
				let ctx = v.ctxsettings.new;
				v.pos ??= [u.w/2, u.h/2];
				//ctx.fillStyle = "black";
				//v.variablename ??= 0;
				// - use ??= so that you don't overwrite the parent ProcAnim
				//   having set this already in initA
				//this.childanimationname = suite.childanimationname;
				//this.childanimationname.initA(u, duration, etc);
				v.initialized = true;
			};
			this.func = function(frame) {
				let i1 = 0;
				let i2 = 0;
				let i3 = 0;
				// this isn't related to ProcAnim, but forgetting i numbers can
				// cause a lot of trouble.
				let v = this.v;
				let u = v.u;
				let ctx = u.ctx;
				// for easy reference
				let exit = this.framestart(frame);
				if(exit) {
					return;
				};
				//
				// animate something.
				// - always define variables as a property of v, unless you're
				//   okay with them vanishing between frames.
				// - u stands for "universal object", it's an object that's a
				//   variable of the .run function. it contains things like the
				//   context, the frame width and height, (u.w and u.h
				//   respectively. you could also use ctx.canvas but whatever)
				//   the viewer, etc.
				// - don't worry about changing ctx properties. provided it
				//   isn't an object or function, it will be kept consistent
				//   from one frame to the next and will not interfere with the
				//   parent ProcAnim's ctx properties.
				//
				this.frameend(frame);
			};
		}
		initA(u, duration, etc) {
		// clears/creates .v, applies any variable definings specified
		// in etc, creates v.ctxsettings and v.initialized, runs initB.
		// - initB should contain initial variable definings, and running .initA
		//   for all the child ProcAnims it uses
			let i1 = 0;
			if(this.hasOwnProperty("v")) {
				for (i1 in this.v) {
					if(this.v.hasOwnProperty(i1)) {
						delete this.v[i1];
					};
				}
			}
			else {
				this.v = {};
			};
			// this may seem silly, but it's a way of making sure i can do fancy
			// object reference tricks. if an object is defined, object
			// reference disappears. so if i make it a reference to something
			// before i run initA, i can only retain that reference if that else
			// doesn't run.
			let v = this.v;
			v.u = u;
			v.duration = duration;
			if(etc) {
				for (i1 in etc) {
					if (etc.hasOwnProperty(i1)) {
						v[i1] = structuredClone(etc[i1]);
					}
				}
			}
			// for stuff like position, scale, etc. things that would clutter up
			// the arguments, but *would* be nice to specify
			if(!v.hasOwnProperty("ctxsettings") || !v.ctxsettings.hasOwnProperty("old") || !v.ctxsettings.hasOwnProperty("new")) {
				v.ctxsettings = {
					new: {},
					old: {},
				};
			}
			if(this.initB) {
				v.initialized = false;
				this.initB();
			}
			else {
				v.initialized = true;
			};
		}
		framestart(frame) {
		// plays at the beginning of every frame. returns a boolean for whether
		// it should return, also sets ctxsettings
			let v = this.v;
			let u = v.u;
			if(frame < 0 || frame >= v.duration) {
				return true;
				// tells it to return
			}
			if(!v.hasOwnProperty("initialized") || !v.initialized) {
				console.log("animation is not initialized. either initA was never run, or initB does not set .initialized as true.");
				return true;
			}
			v.ctxsettings.old = savectxsettings(u.ctx);
			// the settings of the outer ProcAnim at the time it played this one
			restorectxsettings(u.ctx, v.ctxsettings.new);
			// the settings within this ProcAnim, so that it can retain changes
			// from frame to frame
			return false;
		}
		frameend() {
		// sets ctxsettings
			let v = this.v;
			let u = v.u;
			v.ctxsettings.new = savectxsettings(u.ctx);
			restorectxsettings(u.ctx, v.ctxsettings.old);
		}
		render(ctx, u, duration, initarguments, funcarguments, sheet) {
		// runs through the ProcAnim and returns an object of imagedatas and
		// imageurls.
		// - there is no bgcolor argument because you can just do it yourself
		//   before running this. no sense making it so you have to create a new
		//   procanim just to start with an unorthodox static background
		// - u: specify extra properties for u, variables that you want all
		//   animations to be able to access. (for example, a viewer for 3d
		//   stuff)
		// - funcarguments: an array of arguments. basically, just write
		//   whatever you would write in a function parentheses, (except for
		//   frame) but put brackets around it.
		//   - thanks for spread syntax, whoever invented spread syntax. or put
		//     it in here. probably mozilla
		//   - without it i'd have to resort to an ugly-ass anonymous function
		// - sheet: an object with settings for turning it into a spritesheet.
		//   (it'll use the color of the 0, 0 pixel as the border color.)
		//   - ctx: required
		//   - columns: number of columns
		//   - borderwidth
			if(!u) {
				u = {};
			}
			else {
				if(u.hasOwnProperty("w")) {
					ctx.canvas.width = u.w;
				};
				if(u.hasOwnProperty("h")) {
					ctx.canvas.height = u.h;
				};
			};
			u.ctx = ctx;
			u.w = u.ctx.canvas.width;
			u.h = u.ctx.canvas.height;
			u.bg = u.ctx.getImageData(0, 0, u.w, u.h);
			// whatever image was there before
			u.imagedata = [];
			u.imageurl = [];
			u.mainanim = this;
			let frame = 0;
			// used as the iterator of the main procanim
			if(!funcarguments) {
				funcarguments = [];
			}
			funcarguments.splice(0, 0, frame);
			this.initA(u, duration, initarguments);
			for (frame = 0; frame < duration; frame++) {
				funcarguments[0] = frame;
				this.func(...funcarguments);
				u.imagedata[frame] = u.ctx.getImageData(0, 0, u.w, u.h);
				u.imageurl[frame] = u.ctx.canvas.toDataURL();
				u.ctx.putImageData(u.bg, 0, 0);
			}
			if(sheet && sheet.hasOwnProperty("ctx")) {
				sheet.columns ??= 4;
				sheet.borderwidth ??= 0;
				sheet.ctx.canvas.width = sheet.columns * (u.w + sheet.borderwidth) - sheet.borderwidth;
				sheet.ctx.canvas.height = Math.ceil(duration/sheet.columns) * (u.h + sheet.borderwidth) - sheet.borderwidth;
				sheet.ctx.fillStyle = getcolor(sheet.ctx, 0, 0);
				sheet.ctx.fillRect(0, 0, sheet.ctx.canvas.width, sheet.ctx.canvas.height);
				for (frame = 0; frame < duration; frame++) {
					sheet.ctx.putImageData(u.imagedata[frame], (frame%sheet.columns)*(u.w + sheet.borderwidth), Math.floor(frame/sheet.columns)*(u.h + sheet.borderwidth));
				};
			};
			return {imagedata: u.imagedata, imageurl: u.imageurl};
		}
		animtree(indent) {
		// returns a string visualizing all the procanims in this procanim, and
		// all the procanims in *those* procanims
		// - indent: used in recursion, ignore it
			let i1 = "";
			let output = [];
			indent ??= 0;
			for (i1 in this) {
				if (this.hasOwnProperty(i1) && this[i1] instanceof ProcAnim) {
					output[output.length] = "&#160;".repeat(indent + 1) + i1;
					// non-breaking space
					output[output.length] = this[i1].animtree(indent + 1);
				}
			}
			for (i1 = 0; i1 < output.length; i1++) {
				if(typeof output[i1] === "string") {
				}
				else if(Array.isArray(output[i1])) {
					output[i1] = output[i1].join(String.fromCharCode(10));
					output[i1] = "&#160;".repeat(indent) + output[i1];
				}
				else {
					console.log("this shouldn't happen");
				}
			}
			if(indent === 0) {
				return output;
			}
			else {
				return output.join(String.fromCharCode(10));
			}
		}
	}
	function rhythmat(rhythm, frame) {
		let i1 = 0;
		for(i1 = 0; i1 < rhythm.length; i1++) {
			if(rhythm.charAt(i1).toLowerCase() === rhythm.charAt(i1).toUpperCase() && ![" ", "-"].includes(rhythm.charAt(i1))) {
			// if it's not a letter, space, or dash, splice it out.
				rhythm = rhythm.slice(0, i1) + rhythm.slice(i1 + 1);
				i1--;
			}
		}
		return rhythm.charAt(frame%rhythm.length);
	}
	let suite = new ProcAnim();
	let slite = {};
	// this is for storing animations so minor that they can be functions. (ie
	// they don't need to save variables between frames, or preserve ctx
	// settings before running, or save changes to ctx settings within)
	// - it stands for "suite lite". i don't want the name to be too long, it
	//   sounds kinda funny, it's the same as suite except for one changed
	//   letter, which amuses me
	suite.dsrainbow2 = new ProcAnim();
	suite.dsrainbow2.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		v.ds_data ??= diamondsquare(false, 0, 0, 256, (input, level) => input + 64*randexponent(1, true)*( ( 2**(-1) )**(Math.log2(64) - level) ));
		v.initialized = true;
	};
	suite.dsrainbow2.func = function(frame, colorsatonce, flatten) {
	// - colorsatonce: there will be this many colors at the 1/6
	//   marks, and this many +1 between.
	//   - so if it's 1, it'll be orange until the 1/6 mark, then lime
	//     until the 2/6, etc, with the new color coming in for the
	//     lower value pixels first until the whole screen has become
	//     lime
	//   - but if it's 2, everything will be lime or mint by the 1/12
	//     mark. the first 1/6 will be orange, lime, and mint, the
	//     second will be lime, mint, and azure, etc. the idea of the
	//     1/6 marks being orange, lime, mint, etc only describes the
	//     highest value pixels
	// - flatten: the value of each pixel will only be relevant to
	//   determining which hue it is. the value when actually
	//   drawing it will bring it up to 255 so everything's just as
	//   dark/light.
	//   - recommended, since otherwise the boundary between lime
	//     and mint is too weak.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		// animate something.
		colorsatonce ??= 1;
		let ds_temp = 0;
		let colorsector = 0;
		let colortemp = "";
		// i've been trying to make every variable a property of one
		// variables object, since that's probably what a true ProcAnim
		// class will entail. ...but i might as well take the opportunity to
		// distinguish temps like these that change every frame from
		// everything else. these don't need to be stored between frames.
		for (i1 = 0; i1 < v.ds_data.length; i1++) {
			for (i2 = 0; i2 < v.ds_data[i1].length; i2++) {
				ds_temp = Math.floor(v.ds_data[i1][i2])%256;
				colorsector = 6*frame/v.duration;
				colorsector += colorsatonce*ds_temp/256;
				colorsector = Math.floor(colorsector)%6;
				/*
				colorsector = frame/v.duration + (ds_temp/256)*(v.duration/6);
				colorsector = Math.floor(6*colorsector)%6;
				//v.duration = 36
				// equivalent to colorsatonce: 36, flatten: false
				ora o -
				lim - o
				min   o -
				azu   - o
				pur -   o
				vio o   -
				//*/
				if(flatten) {
					ds_temp = 255;
				};
				ds_temp /= 4;
				colortemp = "rgb(";
				if((colorsector + 1)%6 < 2) {
					colortemp += Math.floor(4 * ds_temp);
				}
				else if(colorsector%3 === 1) {
					colortemp += Math.floor(3 * ds_temp);
				}
				else {
					colortemp += Math.floor(2 * ds_temp);
				};
				colortemp += ", ";
				if((colorsector + 5)%6 < 2) {
					colortemp += Math.floor(4 * ds_temp);
				}
				else if(colorsector%3 === 0) {
					colortemp += Math.floor(3 * ds_temp);
				}
				else {
					colortemp += Math.floor(2 * ds_temp);
				};
				colortemp += ", ";
				if((colorsector + 3)%6 < 2) {
					colortemp += Math.floor(4 * ds_temp);
				}
				else if(colorsector%3 === 2) {
					colortemp += Math.floor(3 * ds_temp);
				}
				else {
					colortemp += Math.floor(2 * ds_temp);
				};
				colortemp += ")";
				ctx.fillStyle = colortemp;
				ctx.fillRect(i1, i2, 1, 1);
			}
		}
		//
		this.frameend(frame);
	};
	suite.startrace = new ProcAnim();
	suite.startrace.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		v.pos ??= [u.w/2, u.h/2, 0];
		v.initialized = true;
	};
	suite.startrace.func = function(frame, xyrev, _3drev, starradius, dotradius, afterimages, dottedtrail, color) {
		let i0 = 0;
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		logspecial({frame, xyrev, _3drev, starradius, dotradius, afterimages, dottedtrail, color}, "= startrace =");
		let progress = 0;
		let currdotr = 0;
		let dotcoord = [];
		let prevcoord = [];
		let starplace = 0;
		for(i1 = 0; i1 < 5; i1++){
			prevcoord[i1] = [];
		}
		for(i0 = afterimages; i0 >= 0; i0--){
		// draw a bunch of afterimages first
			frame -= i0;
			if(frame >= 0 && frame < v.duration) {
				progress = frame/v.duration;
				// progress through the current star, expressed as a fraction
				if(!dottedtrail) {
					ctx.strokeStyle = color;
				};
				ctx.fillStyle = (dottedtrail && i0 !== 0 ? color : "white");
				/*
				if(v.mode === 1) {
					currdotr = easingplacement(0, dotradius, progress, "in/out", "sine");
					if(progress < .5) {
						starplace = easingplacement(0, .1, progress/2, "in/out", "sine");
					}
					else {
						starplace = easingplacement(.1, .2, (progress - .5)/2, "in/out", "sine");
					};
				}
				else {
				};
				//*/
				if(progress < .5) {
					currdotr = easingplacement(0, dotradius, progress*2, "out", "circ");
				}
				else {
					currdotr = easingplacement(dotradius, 0, (progress - .5)*2, "in", "circ");
				};
				starplace = easingplacement(0, .2, progress, "in/out", "circ") - .1;
				let startemp = Shape2d.build("star", 2*starradius, false, false, v.pos);
				for(i1 = 0; i1 < 5; i1++){
				// draw each dot and its trail
					//dotcoord = _3dstar(v.pos[0], v.pos[1], v.pos[2], starradius, (v.mode === 1 ? .1 : 0) + i1*.2 + starplace, xyrev);
					//dotcoord = _3dstar(v.pos[0], v.pos[1], v.pos[2], starradius, i1*.2 + starplace, xyrev);
					dotcoord = startemp.pathfraction(i1*.2 + starplace);
					dotcoord[2] = v.pos[2];
					dotcoord = revolve(xyrev, dotcoord, v.pos);
					dotcoord = revolve(_3drev, dotcoord, v.pos);
					// apply x scaling
					if(dottedtrail) {
						_3dcircle(viewer, ctx, dotcoord[0], dotcoord[1], dotcoord[2], currdotr, true);
					}
					else {
					// draw a smooth trail using _3dline
						if(i0 !== afterimages) {
						// if it's the first afterimage, there won't be
						// starting coordinates to use.
							_3dline(viewer, ctx, prevcoord[i1][0], prevcoord[i1][1], prevcoord[i1][2], dotcoord[0], dotcoord[1], v.pos[2], [2*prevcoord[i1][3], 2*currdotr]);
							// double the weight, since it's a radius being
							// turned into a diameter
							if(i0 === 0) {
							// make the end white
								_3dcircle(viewer, ctx, dotcoord[0], dotcoord[1], dotcoord[2], currdotr, true);
							};
						};
						prevcoord[i1] = [dotcoord[0], dotcoord[1], v.pos[2], currdotr];
						// save the coordinates and radius for use by the
						// next afterimage
					};
				}
			};
			frame += i0;
		}
		//
		this.frameend(frame);
	};
	suite.blast = new ProcAnim();
	suite.blast.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		v.pos ??= [u.w/2, u.h/2];
		v._lineexecute_code ??= function(context, x, y, weight) {
			circledraw(context, x, y, weight/2*(Math.random()/2 + .75), true);
		};
		v.initialized = true;
	};
	suite.blast.func = function(frame, angles, radius, starradius, starrev, length, color) {
	// - angles: this should be a 3d angle
	// - length: refers to the blast's length, in pixels. distance from the base
	//   to the end.
		let i0 = 0;
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		logspecial({angles, radius, starradius, starrev, length, color});
		// angles
		let blastcoord = [];
		let endcoord = [];
		let blastradius = 0;
		let prevcoord = [[], []];
		let starpoints = [];
		let anglenum = Angle.numbers(angles);
		for (i0 = 0; i0 < 2; i0++) {
			// the main part of the blast, then the white center
			progress = frame/v.duration;
			// progress through this blast
			// same meanings as before. the star, and the progress
			ctx.strokeStyle = (i0 ? "white" : color);
			blastradius = radius*easingplacement(1, 0, progress/2, "in", "sine");
			blastcoord = structuredClone(v.pos);
			// coordinates of the base of the blast
			for(i1=0; i1 < 3; i1++) {
				blastcoord[i1] += Math.random()*4*easingplacement(4, 1, progress, "out", "sine") - 2;
				// random offset that's wilder at the beginning
				blastcoord[i1] += anglenum[i1]*(blastradius + starradius)/8;
				// recoil with easing similar to the radius
			}
			blastradius += Math.random()*4 - 2;
			// and narrow a little as it fires (but add a little
			// randomness to that width so it looks erratic instead of
			// uniform)
			starpoints = [];
			// array of points to draw the star
			starpoints[10] = Math.random();
			// the angle for the star
			for (i1 = 0; i1 < 10; i1++) {
				starpoints[i1] = _3dstar(blastcoord[0], blastcoord[1], blastcoord[2], blastradius + (2*starradius - blastradius)/2, i1/10, starpoints[10]);
				starpoints[i1][2] = v.pos[2];
			}
			starpoints.splice(10, 1);
			starpoints = revolve(starrev, starpoints, v.pos);
			for (i1 = 0; i1 < 10; i1++) {
				nonaaline(ctx, starpoints[i1][0], starpoints[i1][1], starpoints[(i1+1)%10][0], starpoints[(i1+1)%10][1]);
			}
			//_3dstar(blastcoord[0], blastcoord[1], blastcoord[2], blastradius, "", Math.random(), "", [ctx, false, viewer]);
			if(i0 === 1) {
				// make the white center narrower
				blastradius *= Math.random();
			};
			endcoord = [];
			for (i1 = 0; i1 < 3; i1++) {
				endcoord[i1] = blastcoord[i1];
				// whole line jolts randomly
				//endcoord[i1] = v.pos[i1];
				// ending point remains stable
				//endcoord[i1] = blastcoord[i1];
				//blastcoord[i1] = v.pos[i1];
				// starting point remains stable
				endcoord[i1] += length*anglenum[i1];
			}
			_3dline(viewer, ctx, blastcoord[0], blastcoord[1], blastcoord[2], endcoord[0], endcoord[1], endcoord[2], blastradius);
			// this looks like one a' 'em homestucks,
			//blastcoord = revolve(angles, blastcoord, v.pos);
			//endcoord = revolve(angles, endcoord, v.pos);
			//_3dlineexecute(viewer, ctx, blastcoord[0], blastcoord[1], blastcoord[2], endcoord[0], endcoord[1], endcoord[2], blastradius, blastradius/2, v._lineexecute_code);
			// new version
			if(frame !== 0) {
			// draw an afterimage, if one exists
				_3dline(viewer, ctx, prevcoord[i0][0], prevcoord[i0][1], prevcoord[i0][2], prevcoord[i0][3], prevcoord[i0][4], prevcoord[i0][5], prevcoord[i0][6]);
				//_3dlineexecute(viewer, ctx, prevcoord[i0][0], prevcoord[i0][1], prevcoord[i0][2], prevcoord[i0][3], prevcoord[i0][4], prevcoord[i0][5], prevcoord[i0][6], prevcoord[i0][6]/2, v._lineexecute_code);
			};
			prevcoord[i0] = [blastcoord[0], blastcoord[1], blastcoord[2], endcoord[0], endcoord[1], endcoord[2], blastradius];
			// stores afterimage data, like before. just one frame of
			// afterimage.
		}
		//
		this.frameend(frame);
	};
	suite.starblast = new ProcAnim();
	suite.starblast.initB = function() {
	// initialize variables, ctxsettings, and animations
		let i1 = 0;
		let v = this.v;
		let u = v.u;
		u.viewer.offset.z = -24;
		v.pos ??= [u.w/2, u.h/2, 0];
		// coordinates of its center
		//v.mode ??= 0;
		// 1: weird easing thing i stumbled on
		suite.starblast.startrace = suite.startrace;
		suite.starblast.blast = suite.blast;
		v.startrace_v = [];
		v.blast_v = [];
		for (i1 = 0; i1 < 3; i1++) {
			v.startrace_v[i1] = {};
			this.startrace.v = v.startrace_v[i1];
			this.startrace.initA(u, null, {pos: v.pos});
			v.blast_v[i1] = {};
			this.blast.v = v.blast_v[i1];
			this.blast.initA(u, null, {pos: v.pos});
		}
		// thanks to object reference, position should change with the parent
		// ProcAnim's position. duration, i'll just set before every func
		// running.
		v.initialized = true;
	};
	suite.starblast.func = function(frame, framesperstar, starpause, pause, color, starradius, dotradius, xscaling, rotationperstar, afterimages, dottedtrail) {
	// - things this is missing compared to the original:
	//   - mode: i don't remember this super well and it'd have to be passed
	//     through arguments and shit...
	//   - the blast animation used to retain an afterimage from the previous
	//     blast.
	// - framesperstar: used as the duration for startrace
	// - starpause: frames between the beginnings and endings of starpause
	//   runnings
	// - pause: pause between  starradius, dottedtrail
	// - color: an array of three colors, used for the stars and blasts
	// - starradius: the radius of the stars in startrace (each one is smaller
	//   than the last, this is the radius of the largest. the blasts start
	//   twice as wide.)
	// - dotradius: the radius of the dots that trace the stars
	// - xscaling: the ratio of w/h for the star. this is used to determine the
	//   angle they have.
	// - rotationperstar: difference in orientation between stars (measured in
	//   circumferences, not radians)
	// - afterimages: number of frames to trace backward to create a trail.
	// - dottedtrail: by default, each afterimage connects to the last to make a
	//   smooth trail. this opts out of that.
	// - TODO
	//   - troubleshoot
	//     - the stuff that causes errors is that in suite.blast, the revolve
	//       returns undefined or something
	//     - since the blast is pretty versatile, i should probably have the
	//       stars in the background be in starblast's script instead..?
	//       - i'll add a parameter for running an anonymous function using the
	//         coordinates of the base of the blast as arguments. that way, i
	//         can keep the random offset.
		let i0 = 0;
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		if(!framesperstar && framesperstar !== 0) {
			framesperstar = 12;
		}
		if(!starpause && starpause !== 0) {
			starpause = 3;
		}
		if(!rotationperstar && rotationperstar !== 0) {
			rotationperstar = 1/45;
		}
		// measured in circumferences
		if(!color) {
			color = ["#3f3fbf", "#bf00bf", "#3fbf3f"];
		}
		if(!dotradius && dotradius !== 0) {
			dotradius = 4;
		}
		if(!xscaling && xscaling !== 0) {
			xscaling = Math.sqrt(2)/2;
		}
		// a scale factor like this makes it look more like it exists in
		// 3d space, thanks to the perspective tools.
		if(!afterimages && afterimages !== 0) {
			//afterimages = (v.mode === 1 ? Math.floor(.5*framesperstar) : Math.floor(.25*framesperstar));
			afterimages = Math.floor(.25*framesperstar);
		}
		if(!pause && pause !== 0) {
			pause = 2*afterimages;
		};
		// frames between the stars and the blasts
		if(!starradius && starradius !== 0) {
			starradius = u.h/4;
		}
		let starangle = [Math.cos(xscaling), 0];
		let blastangle = Math.cos(xscaling) - Math.PI/2;
		blastangle = [posmod(blastangle, 2*Math.PI), 0];
		// these are xz angles. the first is the angle the stars are
		// tilted at to compress them x-ways, the second is the
		// perpendicular angle the beam should fire at
		// temps
		//logspecial({frame, framesperstar, starpause, pause, color, starradius, dotradius, xscaling, rotationperstar, afterimages, dottedtrail});
		for (i1 = 0; i1 < 3; i1++) {
			v.startrace_v[i1].duration = framesperstar;
			v.startrace_v[i1].pos = v.pos;
			this.startrace.v = v.startrace_v[i1];
			suite.startrace.func(
				frame - i1*(framesperstar + starpause),
				(1 + i1)*rotationperstar*2*Math.PI,
				// xyrev: rotate a little with each star
				starangle,
				easingplacement(starradius, 0, (1 + i1)/4, "in", "sine"),
				// starradius: shrink a little with each star
				dotradius,
				afterimages,
				dottedtrail,
				color[i1]
				// color: use a new color in the array each time
			);
			v.blast_v[i1].duration = framesperstar;
			v.blast_v[i1].pos = v.pos;
			this.blast.v = v.blast_v[i1];
			suite.blast.func(
				-3*framesperstar - 2*starpause + frame - pause - i1*framesperstar,
				blastangle,
				// angles
				easingplacement(2*starradius, 0, i1/4, "out", "sine"),
				// radius: decrease with each blast
				starradius,
				starangle,
				2*u.w,
				// length
				color[i1]
			);
		}
		// TODO
		// - needs more breathing room between stars
		// - while the placement easing should definitely be slow at the
		//   points, the dot radius easing should be at it's maximum there
		// -
		// - make _3dline adjust weight using the z positions
		// - blast looks a little too erratic
		//   - make sure the randomness for the inner and outer are the same
		//     numbers?
		//   - decrease the randomness of the inner to make it more stable?
		//   - make it so the inner's radius is derivative of the outer's
		//     radius?
		//   - make it so the inner is .5 to 1 times as big?
		//   - add one frame of afterimage?
		// - add a parameter to _3dline for random weight, and use that?
		//   - eh, i dunno. that's not a job for _3dline because it'd be
		//     applied per pixel instead of per 3d distance.
		// -
		// - make the blasts cut off sharply, decreasing to 0 radius in the
		//   last few frames
		// - make it so the first star is tilted too
		// - increase the weight of the stars at the base of the blasts
		//78 frames
		//
		// add v., u.w, u.h
		// v.pos
		// currframe to frame
		// ctx2 to ctx
		// smoothtrail to dottedtrail
		//
		// at a bit of an impasse here.
		// - the goal of the ProcAnim class is to be able to subdivide and combine
		//   animations to create something interesting.
		// - this animation is kind of already there. to convert it, i should break
		//   it up into "dots tracing a star" and "homestuck blast"
		// - however. i don't feel like doing that
		//   - not right now, anyway
		// - but also. the more accumulation you have, the more parameters you need.
		//   presently there are 9 goddamn arguments.
		// - i think i'm gonna solve that with spread syntax. have arguments named
		//   after the subanimations.
		// - another problem: arguments are very limited, to the point that i'm
		//   considering making it the default to specify everything through the
		//   initA running
		//   - here's the thing: arguments entered through the etc parameter of
		//     initA become part of .v. that means they can be accessed very easily
		//     by the parent ProcAnim. parameters of .func cannot.
		//   - what that means for this animation is, the duration has to match the
		//     framesperstar, when framesperstar is a .func parameter that could
		//     change every frame for all i know.
		// - ANOTHER problem: how do i run multiple runnings of the same child
		//   animation over each other.
		//   - they'll all be using the same .v, so they'll overwrite each other's
		//     variables.
		//   - i can't just structuredClone them. structuredClone does not work on
		//     functions.
		//   - possible solutions
		//     - use toString(), .replace, and the function constructor
		//       - by far the wonkiest solution.
		//   - i think i have something.
		//   - create an array in the parent ProcAnim, that stores multiple .vs of
		//     the subanimation. when you're running the first iteration of the
		//     subanimation, set the subanimation's .v as [0]. for the second
		//     iteration, use [1].
		//   - this did require making a small change in initA though.
		//   - so in summary, to make an animation run multiple times...
		//     - in initB, create an array for it, make an empty object in as many
		//       indexes as there are runnings of it.
		//     - before the first initA, write "this.subanimationname.v =
		//       v.subanimationname[0]". do the same with [1] for the second, etc
		//     - and do the same every time you run a .func in your script.
		//
		this.frameend(frame);
	};
	suite.ds_bwcycle = new ProcAnim();
	suite.ds_bwcycle.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		v.ds_data ??= diamondsquare(false, 0, 0, 256, (input, level) => input + 64*randexponent(1, true)*( ( 2**(-1) )**(Math.log2(64) - level) ));
		v.increment ??= 128;
		v.initialized = true;
	};
	suite.ds_bwcycle.func = function(frame) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		//let temp = 0;
		for (i1 = 0; i1 < v.ds_data.length; i1++) {
			for (i2 = 0; i2 < v.ds_data[i1].length; i2++) {
				//temp = Math.floor(v.ds_data[i1][i2] + 256*currframe/numofframes)%256;
				if(Math.floor(v.ds_data[i1][i2] + frame)%v.increment < v.increment/2) {
					ctx.fillStyle = "white";
				}
				else {
					ctx.fillStyle = "black";
				};
				ctx.fillRect(i1, i2, 1, 1);
			}
		}
		//
		this.frameend(frame);
	};
	suite.revolvingrings = new ProcAnim();
	suite.revolvingrings.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		v.pos ??= [u.w/2, u.h/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		//this.childanimationname.initA(u, duration, etc);
		//
		v.initialized = true;
	};
	suite.revolvingrings.func = function(frame, shape2d, scale, numperring, accelfunc, ringspacing, ringinterval, donthidecenter) {
	// - shape2d: the shape it draws and rotates. it will be unaltered for
	//   shapes at the right side of the ring, and flipped in the y axis if the
	//   speed of the current ring is negative.
	// - scale: the number all shape2d dimensions are multiplied by
	// - numperring: number of shape duplicates the ring has
	// - accelfunc: either a number or a function.
	//   - every ring is faster than the last, ie the amount it revolves per
	//     frame is higher.
	//   - if it's a number, this should by how much of a difference there is
	//     between rings, measured in revolutions-per-frame. this will also be
	//     the revolution speed of the first ring.
	//   - if it's a function, it should have one parameter, "ringnum", and
	//     return the number of revolutions per frame it should have given that
	//     parameter.
	//     - so you could enter "(ringnum) => 1/3 + ringnum/12" for it to start
	//       at 1/3 and increase to 5/12, 6/12, 7/12, etc
	// - ringspacing: number of pixels between rings
	// - ringinterval: number of frames between the appearance of new rings
	// - donthidecenter: by default, the innermost ring is hidden since
	//   otherwise it blinks obnoxiously.
	// - TODO
	//   - use an easing thing by default, making the speed increase the same
	//     every time is underwhelming
	//   - add a boolean parameter that makes the rings stop appearing so that
	//     the last one leaves the screen before the animation ends.
	//     - use pos, u.w/u.h, and Math.hypot to figure out how long it takes to
	//       leave the screen
	//     - you'd also need to add the lowest x value of the path. what a pain.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		if(!shape2d) {
			shape2d = new Shape2d([
				{
					x: 0,
					y: 0,
				},
				{
					x: 1,
					y: 0,
				},
				{
					x: 1/3,
					y: 1/3,
				},
				{
					x: 1/3,
					y: 0,
				},
			]),
			scale = 12;
		}
		scale ??= 1;
		numperring ??= 21;
		// numperring
		if(!["function", "number"].includes(typeof accelfunc)) {
			accelfunc = 1/32;
		};
		ringspacing ??= 16;
		if(!ringinterval) {
			ringinterval = 4;
		};
		//
		let path = structuredClone(shape2d.path);
		for(i1 = 0; i1 < path.length; i1++) {
			path[i1][0] *= scale;
			path[i1][1] *= scale;
		};
		let negpath = structuredClone(path);
		for(i1 = 0; i1 < negpath.length; i1++) {
			negpath[i1][1] *= -1;
		};
		// flipped version
		let drawring = function(ctx, pos, r, shape2d, path, num, rev) {
			let i1 = 0;
			let i2 = 0;
			let _path = null;
			let revtemp = 0;
			for(i1 = 0; i1 < num; i1++) {
				revtemp = (rev + i1/num)*2*Math.PI;
				_path = structuredClone(path);
				for (i2 = 0; i2 < _path.length; i2++) {
					_path[i2][2] = 0;
				}
				_path = structuredClone(revolve(revtemp, _path, false, "xy"));
				for (i2 = 0; i2 < _path.length; i2++) {
					_path[i2].splice(2, 1);
					_path[i2][0] += r*Math.cos(revtemp);
					_path[i2][1] += r*Math.sin(revtemp);
				}
				shape2d.draw(ctx, pos[0], pos[1], false, shape2d.closed, _path);
			}
		};
		let numofrings = Math.ceil(frame/ringinterval);
		let r = 0;
		let frameselapsed = 0;
		// for this ring, that is
		let revoffset = 0;
		let ringspeed = 0;
		for(i1 = 0; i1 < numofrings + (donthidecenter ? 0 : -1); i1++) {
			//ctx.strokeStyle = ["#fb0", "#ff0", "#bf0", "#0fb", "#0ff", "#0bf", "#b0f", "#f0f", "#f0b"][i1%9];
			frameselapsed = frame - i1*ringinterval;
			r = frameselapsed*ringspacing/ringinterval;
			ringspeed = 0;
			if(typeof accelfunc === "function") {
				ringspeed = accelfunc(i1)*(i1%2 === 1 ? -1 : 1);
			}
			else if(typeof accelfunc === "number") {
				ringspeed = accelfunc*(i1 + 1)*(i1%2 === 1 ? -1 : 1);
			}
			else {
				console.log("this shouldn't happen");
			};
			revoffset = 2*Math.PI*((ringspeed*frameselapsed)%1);
			drawring(ctx, v.pos, r, shape2d, (ringspeed < 0 ? negpath : path), numperring, revoffset);
		}
		//circledraw(ctx, v.pos[0], v.pos[1], 32, true);
		//
		this.frameend(frame);
	};
	suite.shimmershape = new ProcAnim();
	suite.shimmershape.initB = function() {
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		//ctx.fillStyle = "black";
		//v.variablename ??= 0;
		v.initialized = true;
	};
	suite.shimmershape.func = function(frame, shape2d, numofpoints, cyclelength) {
	// connects many path fractions to draw a rough version of the shape, and
	// changes the offset for all of them every frame. the result is a distorted
	// version that's weird and warbly at the curves and corners.
	// - shape: shape2d
	// - numofpoints: if this is 16, it'll connect the points at the 1/16, 2/16,
	//   etc. you get the idea
	// - cyclelength: number of frames it takes for it to repeat. lower numbers
	//   are faster, etc. negative numbers make it go backwards.
	// - i think this might be what "shaky" line art like omori uses?
	//   - or maybe it's just slightly randomizing the coordinates.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		if(!numofpoints) {
			numofpoints = Math.ceil(shape2d.length/8);
			// in other words, the length of the path between path fractions is
			// 8 pixels or less.
		};
		let reverse = cyclelength < 0;
		if(typeof cyclelength !== "number") {
			cyclelength = 8;
		};
		cyclelength = Math.abs(cyclelength);
		let newshape = [];
		let offset = null;
		if(cyclelength === 0) {
			offset = 0;
		}
		else if(reverse) {
			offset = 1 - (frame%cyclelength)/cyclelength;
		}
		else {
			offset = (frame%cyclelength)/cyclelength;
		}
		offset /= numofpoints;
		for (i1 = 0; i1 < numofpoints - (shape2d.closed ? 0 : 1); i1++) {
			newshape[i1] = shape2d.pathfraction(offset + i1/numofpoints);
		}
		if(!shape2d.closed) {
		// if it isn't closed, make sure there's always a point at the beginning
		// and end.
			if(reverse || frame%cyclelength !== 0) {
				newshape.splice(0, 0, shape2d.pathfraction(0));
			};
			if(!reverse || frame%cyclelength !== 0) {
				newshape[newshape.length] = shape2d.pathfraction(1);
			};
		};
		shape2d.draw(ctx, v.pos[0], v.pos[1], false, shape2d.closed, newshape);
		//
		this.frameend(frame);
	};
	suite.polaris = new ProcAnim();
	suite.polaris.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		v.easing ??= {};
		v.easing.inorout ??= "in/out";
		v.easing.type ??= "sine";
		v.easing.overshoot ??= false;
		ctx.fillStyle = "white";
		v.initialized = true;
	};
	suite.polaris.func = function(frame, easefactor, revspeed, offcenter, starratio, radius) {
	// an animation of a sky of stars rotating.
	// - easefactor: fraction of the speed to ease.
	//   - for example, a value of 1/8 eith a revspeed of 1/32 will have the
	//     amount it moves per frame be (1/32)*(1 - 1/8) + (1/32 with easing
	//     applied)*1/8
	//   - easing is applied per revolution, ie it moves slower at the
	//     beginning/end of each revolution and faster in the middle
	//   - it uses sine in/out easing, but it's stored in v. variables, so that
	//     can be changed if you want.
	// - revspeed: revolutions per frame
	// - offcenter: the distance between the center of revolution and the point
	//   the stars are placed around. (having some difference adds some weight
	//   to it.)
	// - starratio: number of stars it places per pixel of circumference for the
	//   current ring
	// - radius: a number or function for the radius of the stars.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		revspeed ??= 1/32;
		easefactor ??= 1/8;
		offcenter ??= 16;
		starratio ??= 1/128;
		radius ??= () => Math.floor(1 + randexponent(2)*2);
		if(!v.hasOwnProperty("stars")) {
		// create the stars if there are none.
		// - i would put this in initB, but then the most important parameters
		//   would have to be crammed into the etc parameter. lame.
			let center = Math.random()*2*Math.PI;
			center = [v.pos[0] + offcenter*Math.cos(center), v.pos[1] + offcenter*Math.sin(center)];
			// a random point [offcenter] pixels away from v.pos
			let maxr = Math.max(
				Math.hypot(center[0], center[1]),
				// distance from top left
				Math.hypot(u.w - center[0], center[1]),
				// distance from top right
				Math.hypot(center[0], u.h - center[1]),
				// distance from bottom left
				Math.hypot(u.w - center[0], u.h - center[1]),
				// distance from bottom right
			);
			v.stars = [];
			let temp = 0;
			for (i1 = 0; i1 < maxr; i1++) {
				for (i2 = 0; i2 < Math.round(starratio*i1*2*Math.PI); i2++) {
					temp = Math.random()*2*Math.PI;
					v.stars[v.stars.length] = [center[0] + i1*Math.cos(temp), center[1] + i1*Math.sin(temp)];
				}
			}
		};
		let r = typeof radius === "function" ? 0 : radius;
		let temp = [];
		temp = 1/revspeed;
		// frames per revolution
		let angletemp = (frame%temp)/temp;
		// place within the rotation
		angletemp = temp*(1 - easefactor)*angletemp + easingplacement(0, temp*easefactor, angletemp, v.easing.inorout, v.easing.type, v.easing.overshoot);
		//let angletemp = temp*Math.floor(frame/temp) + temp*(1 - easefactor)*(frame%temp)/temp + easingplacement(0, temp*easefactor, (frame%temp)/temp, v.easing.inorout, v.easing.type, v.easing.overshoot);
		// substitute for frame number, adjusted to add easing
		/*
		if(v.hasOwnProperty("angletemp")) {
			console.log("frame " + frame + ": " + ((angletemp < v.angletemp ? temp : 0) + angletemp - v.angletemp));
		}
		v.angletemp = angletemp;
		//*/
		angletemp *= revspeed*2*Math.PI;
		for (i1 = 0; i1 < v.stars.length; i1++) {
			if(typeof radius === "function") {
				r = radius();
			};
			temp = revolve(angletemp, [v.stars[i1][0], v.stars[i1][1], 0], [v.pos[0], v.pos[1], 0], "xy");
			circledraw(ctx, temp[0], temp[1], r, true);
		}
		//
		this.frameend(frame);
	};
	suite.rhythmicshine = new ProcAnim();
	suite.rhythmicshine.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		//v.pos ??= [u.w/2, u.h/2];
		v.lines ??= [];
		v.initialized = true;
	};
	suite.rhythmicshine.func = function(frame, rhythm, shinelength, rotamount) {
	// - rhythm: rhythm string (see the comments at the top of the ProcAnim class
	//   for details)
	// - shinelength: frames per shine
	// - rotamount: amount of rotations each line does before it ends
	// - TODO
	//   - better defaults
	//   - figure out a rhythm that works well with it
	//   - maybe make shinelength an array of colors
	//   - maybe make shines hourglass-like
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		rhythm ??= "o".repeat(v.duration);
		shinelength ??= 4;
		rotamount ??= 1/2;
		if(rhythmat(rhythm, frame).toUpperCase() !== rhythmat(rhythm, frame).toLowerCase()) {
			v.lines[v.lines.length] = {
				x: Math.floor(Math.random()*u.w),
				y: Math.floor(Math.random()*u.h),
				angle: Math.random()*2*Math.PI,
				frame,
			};
		}
		let temp = null;
		for (i1 = 0; i1 < v.lines.length; i1++) {
			if((frame - v.lines[i1].frame) <= shinelength) {
				temp = {
					x: v.lines[i1].x,
					y: v.lines[i1].y,
					angle: v.lines[i1].angle + (frame - v.lines[i1].frame)*2*Math.PI*(rotamount/shinelength),
				};
				temp.x1 = temp.x - Math.hypot(u.w, u.h)*Math.cos(temp.angle);
				temp.y1 = temp.y - Math.hypot(u.w, u.h)*Math.sin(temp.angle);
				temp.x2 = temp.x + Math.hypot(u.w, u.h)*Math.cos(temp.angle);
				temp.y2 = temp.y + Math.hypot(u.w, u.h)*Math.sin(temp.angle);
				nonaaline(ctx, temp.x1, temp.y1, temp.x2, temp.y2);
			}
			else {
				v.lines.splice(i1, 1);
				i1--;
			};
		}
		//
		this.frameend(frame);
	};
	suite.linerevolvetest = new ProcAnim();
	suite.linerevolvetest.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		ctx.font = "16px 'fomp2'";
		ctx.textBaseline = "top";
		v.initialized = true;
	};
	suite.linerevolvetest.func = function(frame, a_color, b_color, timetable, xymode, zmode, rollmode) {
	// - timetable: decides how long each action takes.
	//   - roll
	//   - pause1
	//   - xyz
	//   - pause2
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		a_color = a_color ? a_color : "#ff007f";
		b_color = b_color ? b_color : "#007fff";
		let center = [u.w/2, u.h/2, -u.w/2];
		// for easy reference.
		let sphere_r = Math.min(u.w, u.h)/4;
		ctx.strokeStyle = "#3f3f3f";
		ctx.fillStyle = "#3f3f3f";
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		sphere_r, false);
		let point_r = 2.5;
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		point_r, true);
		if(!v.hasOwnProperty("angle")) {
		// random angle, with roll
			v.angle = [];
			//
			if(typeof xymode === "number") {
				v.angle[0] = xymode*Math.PI/180;
			}
			else {
				v.angle[0] = Math.random()*2*Math.PI;
			};
			//
			if(typeof zmode === "number") {
				v.angle[1] = zmode*Math.PI/180;
			}
			else if(zmode === "+") {
				v.angle[1] = Math.random()*Math.PI/2;
			}
			else if(zmode === "-") {
				v.angle[1] = -Math.random()*Math.PI/2;
			}
			else {
				v.angle[1] = (2*Math.random() - 1)*Math.PI/2;
			};
			//
			if(typeof rollmode === "number") {
				v.angle[2] = rollmode*Math.PI/180;
			}
			else {
				v.angle[2] = Math.random()*2*Math.PI;
			};
		};
		if(typeof timetable !== "object") {
			timetable = {};
		};
		/*
		timetable.xyz ??= v.duration/2;
		timetable.pause1 ??= 0;
		timetable.roll ??= v.duration/2;
		timetable.pause2 ??= 0;
		//*/
		timetable.xyz ??= v.duration/4;
		timetable.pause1 ??= v.duration/4;
		timetable.roll ??= v.duration/4;
		timetable.pause2 ??= v.duration/4;
		let starts = {};
		starts.xyz_a = 0;
		starts.pause1_a = starts.xyz_a + timetable.xyz;
		starts.roll_a = starts.pause1_a + timetable.pause1;
		starts.roll_b = 0;
		starts.pause1_b = starts.roll_b + timetable.roll;
		starts.xyz_b = starts.pause1_b + timetable.pause1;
		starts.pause2 = timetable.xyz + timetable.pause1 + timetable.roll;
		starts.end = starts.pause2 + timetable.pause2;
		function inphase(phase) {
			let nextphase = {
				xyz_a: "pause1_a",
				pause1_a: "roll_a",
				roll_a: "pause2",
				roll_b: "pause1_b",
				pause1_b: "xyz_b",
				xyz_b: "pause2",
				pause2: "end",
			};
			//console.log("starts[" + phase + "] = " + starts[phase]
			//+ String.fromCharCode(10) + "starts[" + nextphase[phase] + "] = " + starts[nextphase[phase]]);
			return frame >= starts[phase] && frame < starts[nextphase[phase]];
		}
		// all this, just to be able to quickly check what phase it's in...
		// maybe i could streamline this with a ProcAnim static method or
		// something but i sure as hell won't do it today
		let points = {
			a: [
				[1, 0, 0],
				[1, 1, 0]
			],
			b: [
				[1, 0, 0],
				[1, 1, 0]
			],
		};
		points.a = [];
		points.b = [];
		//let distances = [];
		for (i1 = 0; i1 <= 8; i1++) {
			for (i2 = 0; i2 <= 8; i2++) {
				points.a[points.a.length] = [
					i1/8,
					i2/8,
					0
				];
				points.b[points.b.length] = [
					i1/8,
					i2/8,
					0
				];
				/*
				distances[distances.length] = Math.hypot(
					i1/8,
					i2/8,
					0
				);
				//*/
			}
		}
		// yes, the most efficient way is to have this start over every frame.
		function xyz_phase(points, angle, frametemp) {
			let angletemp = [];
			angletemp[0] = (
				angle[0] < Math.PI
				?
				frametemp*angle[0]
				:
				2*Math.PI + frametemp*(angle[0] - 2*Math.PI)
			);
			// multiply its distance from 0/360 by frametemp
			angletemp[1] = frametemp*angle[1];
			//logspecial({angletemp, points});
			return revolve(angletemp, points);
		}
		function roll_phase(points, angle, frametemp, set) {
			if(set === "a") {
				let angletemp = (v.angle[2] < Math.PI ? v.angle[2]*frametemp : 2*Math.PI + (v.angle[2] - 2*Math.PI)*frametemp);
				// same as xy
				if(inphase("roll_a")) {
					let anglenum = Angle.numbers(v.angle.slice(0, 2));
					ctx.strokeStyle = "white";
					_3dline(u.viewer, ctx,
						center[0] - sphere_r*anglenum[0],
						center[1] - sphere_r*anglenum[1],
						center[2] - sphere_r*anglenum[2],
						center[0] + sphere_r*anglenum[0],
						center[1] + sphere_r*anglenum[1],
						center[2] + sphere_r*anglenum[2]
					);
				}
				return revolve(angletemp, points, false, v.angle.slice(0, 2));
			}
			else if(set === "b") {
				let angletemp = (v.angle[2] < Math.PI ? v.angle[2]*frametemp : 2*Math.PI + (v.angle[2] - 2*Math.PI)*frametemp);
				// same as xy
				if(inphase("roll_b")) {
					ctx.strokeStyle = "white";
					_3dline(u.viewer, ctx,
						center[0] - sphere_r,
						center[1],
						center[2],
						center[0] + sphere_r,
						center[1],
						center[2]
					);
				}
				return revolve(angletemp, points, false, [0, 0]);
			}
			else {
				console.log("include the set.");
				return;
			};
		}
		if(inphase("xyz_a")) {
		// set a: xyz before the roll
			frametemp = (frame - starts.xyz_a)/timetable.xyz;
			// 0 = beginning of revolution, 1 = end
			points.a = xyz_phase(points.a, v.angle, frametemp);
			// xy/z revolution
			let anglenum = Angle.numbers(v.angle.slice(0, 2));
			ctx.strokeStyle = "green";
			_3dcircle(u.viewer, ctx,
				center[0] + sphere_r*anglenum[0],
				center[1] + sphere_r*anglenum[1],
				center[2] + sphere_r*anglenum[2],
				point_r,
				false
			);
		}
		else if(inphase("pause1_a")) {
			points.a = xyz_phase(points.a, v.angle, 1);
			let anglenum = Angle.numbers(v.angle.slice(0, 2));
			ctx.strokeStyle = "green";
			_3dcircle(u.viewer, ctx,
				center[0] + sphere_r*anglenum[0],
				center[1] + sphere_r*anglenum[1],
				center[2] + sphere_r*anglenum[2],
				point_r,
				false
			);
		}
		else if(inphase("roll_a")) {
			points.a = xyz_phase(points.a, v.angle, 1);
			// apply the first phase's revolution
			frametemp = (frame - starts.roll_a)/timetable.roll;
			points.a = roll_phase(points.a, v.angle, frametemp, "a");
		};
		if(inphase("roll_b")) {
		// set b: roll before xyz (aka what a is trying to recreate)
			frametemp = (frame - starts.roll_b)/timetable.roll;
			points.b = roll_phase(points.b, v.angle, frametemp, "b");
			// roll
		}
		else if(inphase("pause1_b")) {
			points.b = roll_phase(points.b, v.angle, 1, "b");
		}
		else if(inphase("xyz_b")) {
			points.b = roll_phase(points.b, v.angle, 1, "b");
			frametemp = (frame - starts.xyz_b)/timetable.xyz;
			points.b = xyz_phase(points.b, v.angle, frametemp);
		};
		if(inphase("pause2")) {
		// make sure all revolutions are done
			points.a = xyz_phase(points.a, v.angle, 1);
			points.a = roll_phase(points.a, v.angle, 1, "a");
			points.b = roll_phase(points.b, v.angle, 1, "b");
			points.b = xyz_phase(points.b, v.angle, 1);
		};
		for (i1 in {b: true, a: true}) {
			if (points.hasOwnProperty(i1)) {
				if(i1 === "a") {
					ctx.strokeStyle = a_color;
					ctx.fillStyle = a_color;
				}
				else if(i1 === "b") {
					ctx.strokeStyle = b_color;
					ctx.fillStyle = b_color;
				};
				// points[set][point or satellite][coordinate]
				_3dline(u.viewer, ctx,
					center[0],
					center[1],
					center[2],
					center[0] + sphere_r*points[i1][0][0],
					center[1] + sphere_r*points[i1][0][1],
					center[2] + sphere_r*points[i1][0][2]
				);
				_3dline(u.viewer, ctx,
					center[0] + sphere_r*points[i1][0][0],
					center[1] + sphere_r*points[i1][0][1],
					center[2] + sphere_r*points[i1][0][2],
					center[0] + sphere_r*points[i1][1][0],
					center[1] + sphere_r*points[i1][1][1],
					center[2] + sphere_r*points[i1][1][2]
				);
				for (i2 = 0; i2 < points[i1].length; i2++) {
					_3dcircle(u.viewer, ctx,
						center[0] + sphere_r*points[i1][i2][0],
						center[1] + sphere_r*points[i1][i2][1],
						center[2] + sphere_r*points[i1][i2][2],
					point_r, i2 === 0);
					// filled circle for the point, hollow circles for
					// satellites
					/*
					let r = Math.hypot(points[i1][i2][0], points[i1][i2][1], points[i1][i2][2]);
					if(Math.abs(r - distances[i2]) > .0000000001) {
						console.log("point[" + i1 + "][" + i2 + "] dist = " + r);
					};
					//*/
				}
			}
		}
		// draw the points
		ctx.fillStyle = "white";
		let text = numalign([Math.trunc(v.angle[0]*180/Math.PI), Math.trunc(v.angle[1]*180/Math.PI), Math.trunc(v.angle[2]*180/Math.PI)]);
		text[0] = "xy  : " + text[0];
		text[1] = "z   : " + text[1];
		text[2] = "roll: " + text[2];
		let lineheight = 12;
		for (i1 = 0; i1 < text.length; i1++) {
			ctx.fillText(text[i1], 4, i1*lineheight);
		}
		let currphase = [];
		for (i1 in starts) {
			if (starts.hasOwnProperty(i1) && inphase(i1)) {
				currphase[currphase.length] = i1;
			}
		}
		for (i1 = 0; i1 < currphase.length; i1++) {
			if(currphase[i1].endsWith("_a")) {
				ctx.fillStyle = a_color;
				ctx.fillText(currphase[i1].slice(0, currphase[i1].lastIndexOf("_a")), 4, u.h - (2 + i1)*lineheight);
			}
			else if(currphase[i1].endsWith("_b")) {
				ctx.fillStyle = b_color;
				ctx.fillText(currphase[i1].slice(0, currphase[i1].lastIndexOf("_b")), 4, u.h - (2 + i1)*lineheight);
			}
			else {
				ctx.fillText(currphase[i1], 4, u.h - (2 + i1)*lineheight);
			}
		}
		if(inphase("pause2")) {
			let diff = Math.hypot(
				points.a[1][0] - points.b[1][0],
				points.a[1][1] - points.b[1][1],
				points.a[1][2] - points.b[1][2]
			);
			ctx.fillStyle = (diff <= .00001 ? "green" : "orange");
			ctx.fillText(diff, 4, text.length*lineheight);
		};
		// write the angle and diff
		//
		this.frameend(frame);
	};
	suite.glrtest = new ProcAnim();
	suite.glrtest.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		v.x = randexponent(1, true);
		ctx.font = "16px 'fomp2'";
		ctx.textBaseline = "top";
		v.initialized = true;
	};
	suite.glrtest.func = function(frame) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		let center = [u.w/2, u.h/2, -u.w/2];
		// for easy reference.
		let sphere_r = Math.min(u.w, u.h)/4;
		ctx.strokeStyle = "#3f3f3f";
		ctx.fillStyle = "#3f3f3f";
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		sphere_r, false);
		let point_r = 2.5;
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		point_r, true);
		//
		let angle = 2*Math.PI*frame/v.duration;
		//*
		angle = [0, Math.sin(angle), Math.cos(angle)];
		angle[0] = v.x;
		angle[1] *= Math.sin(Math.acos(v.x));
		angle[2] *= Math.sin(Math.acos(v.x));
		angle = Angle.get(...angle);
		//*/
		ctx.fillStyle = "white";
		ctx.strokeStyle = "white";
		let anglenum = Angle.numbers(angle);
		_3dcircle(u.viewer, ctx,
			center[0] + sphere_r*anglenum[0],
			center[1] + sphere_r*anglenum[1],
			center[2] + sphere_r*anglenum[2],
		point_r, true);
		//let lr = getlinerevolve(angle);
		//anglenum = Angle.numbers(lr.axis.angle);
		let lr = GLR.new(angle);
		anglenum = Angle.numbers(GLR.axis(lr));
		let circ_hw = Angle.numbers(angle);
		circ_hw = Math.abs(Math.sin(get2dangle(circ_hw[2], circ_hw[1])));
		_3dline(u.viewer, ctx,
			center[0] - sphere_r*anglenum[0],
			center[1] - sphere_r*anglenum[1],
			center[2] - sphere_r*anglenum[2],
			center[0] + sphere_r*anglenum[0],
			center[1] + sphere_r*anglenum[1],
			center[2] + sphere_r*anglenum[2]
		);
		let pc = {
			center: perspectiveconvert(u.viewer, center[0], center[1], center[2]),
			right: perspectiveconvert(u.viewer, center[0] + sphere_r, center[1], center[2]),
			bottom: perspectiveconvert(u.viewer, center[0], center[1] + sphere_r*circ_hw, center[2]),
		};
		pc.radius = [
			pc.right[0] - pc.center[0],
			pc.bottom[1] - pc.center[1],
		];
		circledraw(ctx, pc.center[0], pc.center[1], pc.radius);
		_3dcircle(u.viewer, ctx,
			center[0] + sphere_r*Math.cos(lr.magnitude),
			center[1] + sphere_r*Math.sin(lr.magnitude)*circ_hw,
			center[2],// + sphere_r*Math.cos(Math.asin(circ_hw)),
		point_r, true);
		// show the magnitude
		let text = logspecial({
			xy: numalign([angle[0]*180/Math.PI, 360])[0],
			z: numalign([angle[1]*180/Math.PI, -90])[0],
			frame_angle: numalign([360*frame/v.duration, 360])[0],
			axis_angle: numalign([get2dangle(anglenum[1], anglenum[2])*180/Math.PI, 360])[0],
			circ_hw,
			//anglenum_y: Angle.numbers(angle)[1],
			magnitude: lr.magnitude*180/Math.PI,
		}, false, "get").split(String.fromCharCode(10));
		let lineheight = 12;
		for (i1 = 0; i1 < text.length; i1++) {
			ctx.fillText(text[i1], 4, i1*lineheight);
		}
		v.circgraph ??= [];
		v.circgraph[frame] = circ_hw;
		let temp = (u.w/v.duration);
		for (i1 = 0; i1 < v.circgraph.length; i1++) {
			ctx.fillStyle = i1 === frame ? "white" : "#3f3f3f";
			ctx.fillRect(temp*i1, u.h, temp, -v.circgraph[i1]*u.h/4);
		}
		//
		this.frameend(frame);
	};
	suite.rolldirtest = new ProcAnim();
	suite.rolldirtest.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		v.angle ??= Angle.rand();
		//v.angle[1] = 0;
		//v.angle[1] = .0000000001;
		let anglenum = Angle.numbers(v.angle);
		v.circle = [];
		let i1 = 0;
		for (i1 = 0; i1 < v.duration; i1++) {
		// does the math for every frame
		// - this is done at initialization because i want to be able to draw
		//   the whole circle.
			v.circle[i1] = {
				roll: 2*Math.PI*i1/v.duration,
				// this is the roll angle
			};
			let ref = v.circle[i1];
			let temp = rolldirection([v.angle[0], v.angle[1], ref.roll]);
			// roll direction
			ref.inaccuracy = Angle.compare(v.angle, temp);
			// 2d angle between them
			ref.inaccuracy = Math.abs(Math.PI/2 - ref.inaccuracy)/(Math.PI/2);
			// how far it is from 90, measured in 90 degree arcs (0 means it's
			// perpendicular)
			ref.inaccuracy = Math.trunc(ref.inaccuracy*(10**10))/(10**10);
			ctx.strokeStyle = "rgb(255" + (", " + (255*ref.accuracy)).repeat(2) + ")";
			ref.point = Angle.numbers(temp);
			ref.point[0] += anglenum[0];
			ref.point[1] += anglenum[1];
			ref.point[2] += anglenum[2];
		}
		ctx.font = "16px 'fomp2'";
		ctx.textBaseline = "top";
		v.initialized = true;
	};
	suite.rolldirtest.func = function(frame) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		let center = [u.w/2, u.h/2, -u.w/2];
		// for easy reference.
		let sphere_r = Math.min(u.w, u.h)/4;
		ctx.strokeStyle = "#3f3f3f";
		ctx.fillStyle = "#3f3f3f";
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		sphere_r, false);
		let point_r = 2.5;
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		point_r, true);
		//
		let point = Angle.numbers(v.angle);
		let satel = v.circle[frame].point;
		let temp = u.w/v.duration;
		for (i1 = 0; i1 < v.duration; i1++) {
		// i could optimize this by figuring all of this out at initB instead of
		// every frame but, i don't care
			let ref1 = v.circle[i1];
			let ref2 = v.circle[(i1 + 1)%v.duration];
			ctx.strokeStyle = "rgb(255" + (", " + (255*(1 - Math.min(ref1.inaccuracy, 1)))).repeat(2) + ")";
			_3dline(u.viewer, ctx,
				center[0] + sphere_r*ref1.point[0],
				center[1] + sphere_r*ref1.point[1],
				center[2] + sphere_r*ref1.point[2],
				center[0] + sphere_r*ref2.point[0],
				center[1] + sphere_r*ref2.point[1],
				center[2] + sphere_r*ref2.point[2]
			);
			ctx.fillStyle = (i1 === frame ? "white" : ctx.strokeStyle);
			ctx.fillRect(i1*temp, u.h, temp, -ref1.inaccuracy*u.h/4);
		}
		// draw the circle
		//let lr = getlinerevolve(v.angle);
		//let lr_num = Angle.numbers(lr.axis.angle);
		let lr = GLR.new(v.angle);
		let circ_hw = Angle.numbers(v.angle);
		circ_hw = Math.abs(Math.sin(get2dangle(circ_hw[2], circ_hw[1])));
		let lr_num = Angle.numbers(GLR.axis(lr));
		ctx.strokeStyle = "green";
		let pc = {
			center: perspectiveconvert(u.viewer, center[0], center[1], center[2]),
			right: perspectiveconvert(u.viewer, center[0] + sphere_r, center[1], center[2]),
			bottom: perspectiveconvert(u.viewer, center[0], center[1] + sphere_r*circ_hw, center[2]),
		};
		pc.radius = [
			pc.right[0] - pc.center[0],
			pc.bottom[1] - pc.center[1],
		];
		circledraw(ctx, pc.center[0], pc.center[1], pc.radius);
		_3dline(u.viewer, ctx,
			center[0] - sphere_r*lr_num[0],
			center[1] - sphere_r*lr_num[1],
			center[2] - sphere_r*lr_num[2],
			center[0] + sphere_r*lr_num[0],
			center[1] + sphere_r*lr_num[1],
			center[2] + sphere_r*lr_num[2]
		);
		ctx.fillStyle = "white";
		ctx.strokeStyle = "white";
		_3dline(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
			center[0] + sphere_r*point[0],
			center[1] + sphere_r*point[1],
			center[2] + sphere_r*point[2]
		);
		_3dcircle(u.viewer, ctx,
			center[0] + sphere_r*point[0],
			center[1] + sphere_r*point[1],
			center[2] + sphere_r*point[2],
		point_r, true);
		_3dline(u.viewer, ctx,
			center[0] + sphere_r*point[0],
			center[1] + sphere_r*point[1],
			center[2] + sphere_r*point[2],
			center[0] + sphere_r*satel[0],
			center[1] + sphere_r*satel[1],
			center[2] + sphere_r*satel[2]
		);
		_3dcircle(u.viewer, ctx,
			center[0] + sphere_r*satel[0],
			center[1] + sphere_r*satel[1],
			center[2] + sphere_r*satel[2],
		point_r, true);
		let text = logspecial({
			inaccuracy: v.circle[frame].inaccuracy,
			xy: numalign([Math.round(v.angle[0]*180/Math.PI), 360])[0],
			z: numalign([Math.round(v.angle[1]*180/Math.PI), -90])[0],
			roll: numalign([Math.round(v.circle[frame].roll*180/Math.PI), 360])[0],
		}, false, "get").split(String.fromCharCode(10));
		let lineheight = 12;
		for (i1 = 0; i1 < text.length; i1++) {
			ctx.fillText(text[i1], 4, i1*lineheight);
		}
		//
		this.frameend(frame);
	};
	suite.linefindtest = new ProcAnim();
	suite.linefindtest.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		ctx.font = "16px 'fomp2'";
		ctx.textBaseline = "top";
		v.initialized = true;
	};
	suite.linefindtest.func = function(frame, mode, mod, increment) {
	// tests both Line.findposition and Line.findplace
	// - mode
	//   - "place": it gets coordinates using .findplace, and draws circles
	//     there
	//   - "position": it gets coordinates using angle numbers, and draws the
	//     .findplace it gets at those coordinates.
	// - mod: if true for place mode, it uses findposition on the random place
	//   then findplace on it. if true for position mode, it uses findplace then
	//   findposition. either way, it *should* barely change it.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		increment = typeof increment === "number" ? increment : 1/8;
		mode = ["place", "position"].includes(mode) ? mode : "position";
		mod = true;
		//
		let center = [u.w/2, u.h/2, -u.w/2];
		// for easy reference.
		let sphere_r = Math.min(u.w, u.h)/4;
		ctx.strokeStyle = "#3f3f3f";
		ctx.fillStyle = "#3f3f3f";
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		sphere_r, false);
		let point_r = 2.5;
		_3dcircle(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
		point_r, true);
		//
		function getstyle(value) {
			if(value < 0) {
			// redder the lower it is, peaking at -1
				return "rgb(255" + (", " + ((1 - Math.abs(i1))*255)).repeat(2) + ")";
			}
			else if(value > 0) {
			// more cyan the higher it is, peaking at 1
				return "rgb(" + ((1 - Math.abs(i1))*255) + ", 255, 255)";
			}
			else {
				return "white";
			};
			// looks like one of those three-flavor popsicles.
		}
		let line = new Line(0, 0, 0, Angle.rand());
		let anglenum = Angle.numbers(line.angle);
		let prevpos = null;
		let prevneg = null;
		ctx.strokeStyle = "white";
		for (i1 = 0; i1 <= 1; i1 += increment) {
			for (i2 = -1; i2 <= Math.sign(i1); i2 += 2) {
				ctx.fillStyle = getstyle(i2*i1);
				if(mode === "place") {
					let point = line.findposition(i2*i1);
					if(mod) {
						point = line.findposition(line.findplace(point));
					}
					//*
					if(Math.sign(i2*i1) === 1) {
						_3dline(u.viewer, ctx,
							center[0] + sphere_r*prevpos[0],
							center[1] + sphere_r*prevpos[1],
							center[2] + sphere_r*prevpos[2],
							center[0] + sphere_r*point[0],
							center[1] + sphere_r*point[1],
							center[2] + sphere_r*point[2]
						);
						prevpos = structuredClone(point);
					}
					else if(Math.sign(i2*i1) === -1) {
						_3dline(u.viewer, ctx,
							center[0] + sphere_r*prevneg[0],
							center[1] + sphere_r*prevneg[1],
							center[2] + sphere_r*prevneg[2],
							center[0] + sphere_r*point[0],
							center[1] + sphere_r*point[1],
							center[2] + sphere_r*point[2]
						);
						prevneg = structuredClone(point);
					}
					else {
						prevpos = structuredClone(point);
						prevneg = structuredClone(point);
					};
					//*/
					_3dcircle(u.viewer, ctx,
						center[0] + sphere_r*point[0],
						center[1] + sphere_r*point[1],
						center[2] + sphere_r*point[2],
					point_r, true);
				}
				else if(mode === "position") {
					let point = [
						i2*i1*anglenum[0],
						i2*i1*anglenum[1],
						i2*i1*anglenum[2]
					];
					if(mod) {
						point = line.findposition(line.findplace(point));
					};
					let place = line.findplace(point);
					let pc = perspectiveconvert(u.viewer,
						center[0] + sphere_r*point[0],
						center[1] + sphere_r*point[1],
						center[2] + sphere_r*point[2]
					);
					ctx.fillText(Math.round(place/increment), pc[0], pc[1]);
				};
			}
		}
		ctx.strokeStyle = "green";
		_3dline(u.viewer, ctx,
			center[0],
			center[1],
			center[2],
			center[0] + sphere_r*anglenum[0],
			center[1] + sphere_r*anglenum[1],
			center[2] + sphere_r*anglenum[2]
		);
		ctx.fillStyle = "yellow";
		let text = logspecial({
			xy: numalign([Math.round(line.angle[0]*180/Math.PI), 360])[0],
			z: numalign([Math.round(line.angle[1]*180/Math.PI), -90])[0],
		}, false, "get").split(String.fromCharCode(10));
		let lineheight = 12;
		for (i1 = 0; i1 < text.length; i1++) {
			ctx.fillText(text[i1], 4, i1*lineheight);
		}
		//
		this.frameend(frame);
	};
	suite.skill_up = new ProcAnim();
	suite.skill_up.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2, -u.w/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		v.stretch ??= u.h/2;
		// how many pixels long the stretch is
		v.stretchtime = 12;
		v.weight ??= 4;
		v.endpause ??= 8;
		if((v.particles ?? null) === null) {
			v.particles = [];
			let i1 = 0;
			for (i1 = 0; i1 < 48; i1++) {
				v.particles[i1] = {
					pos: [
						Math.floor(Math.random()*u.w),
						u.h + Math.floor(Math.random()*u.h),
						-Math.floor(Math.random()*u.w),
					],
					stretchstart: Math.floor(Math.random()*(v.duration - (v.stretchtime + v.endpause))),
				};
			}
		}
		v.color ??= "#003fff";
		//
		v.initialized = true;
	};
	suite.skill_up.func = function(frame) {
	// needs much more polish.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		viewer = u.viewer;
		ctx.strokeStyle = v.color;
		for (i1 = 0; i1 < v.particles.length; i1++) {
			let time = (frame - v.particles[i1].stretchstart)/v.stretchtime;
			// negative if it hasn't happened yet, over 1 if it has
			let ymod = -2*u.h*frame/(v.duration - (v.stretchtime + v.endpause));
			// how much to increase the y by, not factoring in the earthworming
			if(time < 0) {
				_3dcircle(
					viewer,
					ctx,
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod,
					v.particles[i1].pos[2],
					v.weight/2,
					true
				);
			}
			else if(time >= 0 && time < .5) {
				time = easingplacement(0, 1, time*2, "in/out", "sine");
				_3dline(
					viewer,
					ctx,
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod,
					v.particles[i1].pos[2],
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod - time*v.stretch,
					v.particles[i1].pos[2],
					v.weight
				);
			}
			else if(time >= .5 && time < 1) {
				time = easingplacement(0, 1, (time - .5)*2, "in/out", "sine");
				_3dline(
					viewer,
					ctx,
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod - time*v.stretch,
					v.particles[i1].pos[2],
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod - v.stretch,
					v.particles[i1].pos[2],
					v.weight
				);
			}
			else if(time >= 1) {
				_3dcircle(
					viewer,
					ctx,
					v.particles[i1].pos[0],
					v.particles[i1].pos[1] + ymod - v.stretch,
					v.particles[i1].pos[2],
					v.weight/2,
					true
				);
			}
			else {
				console.log("this shouldn't happen");
			};
		}
		//
		this.frameend(frame);
	};
	suite.fireplaceybg = new ProcAnim();
	suite.fireplaceybg.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2, -u.w/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		v.color1 ??= "#7fff00";
		v.color2 ??= "#000000";
		// these must be hexadecimal codes.
		v.waveinterval = 4;
		v.waveinterval = Math.floor(v.duration/v.waveinterval)/v.duration;
		// converts it to an even divisor of v.duration. i think.
		v.bumpiness = 4;
		// number of pixels each column can vary from the previous
		v.speedvariation = .25;
		// each column moves 1 - speedvariation to 1 + speedvariation times
		// faster than the previous
		v.waveduration = 8;
		// number of frames it takes a wave column with .pos 0 to go from the
		// bottom of the screen to the top
		// - the initial speed is u.h/v.waveduration
		if((v.waves ?? null) === null) {
			v.waves = [];
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			for (i1 = 0; i1 < v.duration/v.waveinterval; i1++) {
				v.waves[i1] = {};
				v.waves[i1].cols = [];
				let ref = v.waves[i1].cols;
				for (i2 = 0; i2 < u.w; i2++) {
					for (i3 = 0; i3 < 2; i3++) {
						let index = [Math.floor(u.w/2 - i2), Math.ceil(u.w/2 + i2)][i3];
						//ref[i2] = 1 + Math.random();
						ref[index] = (1 + Math.random()*v.speedvariation);
						if(Math.random() < .5) {
							ref[index] = 1/ref[index];
						};
						if(i2 !== 0) {
							ref[index] *= ref[index + [1, -1][i3]];
						};
					}
				}
				let temp = Math.floor(Math.random()*u.w);
			}
		}
		//
		v.initialized = true;
	};
	suite.fireplaceybg.func = function(frame) {
	// TODO
	// - render after images for each wave? both the current frame and the
	//   afterimages are partial opacity and the same color, so it looks blurry
	// - render last indexes on the first frames
	// - improve the random speed
	//   - the way i want it is that every column's speed is derivative of the
	//     adjacent columns, and peaks and valleys form
	//   - but the problem is that column 0 always has the least range.
	//   - also i think something's wrong with how i apply random
	//     multiplication/division, even though it looks sound to me. things
	//     always get high at the ends, never low
	// - i am too bored of this to improve it, though,
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		let newest = Math.floor(v.waves.length*frame/v.duration);
		// the wave that began most recently.
		function renderwave(index) {
			let wave = v.waves[index];
			let wavestart = v.waveinterval*index;
			if(frame >= wavestart && frame < wavestart + v.waveduration) {
				ctx.fillStyle = colorgradient(v.color1, v.color2, posmod(frame - wavestart, v.waveduration)/v.waveduration);
				let i1 = 0;
				let i2 = 0;
				for (i1 = 0; i1 < wave.cols.length; i1++) {
					let speed1 = wave.cols[i1]*u.h/v.waveduration;
					let speed2 = u.h/v.waveduration;
					ctx.fillRect(i1, u.h, 1, Math.round(-(speed1 + speed2)/2)*(frame - wavestart));
				}
			}
			else {
				ctx.fillStyle = v.color2;
				ctx.fillRect(0, 0, u.w, u.h);
			};
		}
		for (i1 = newest + 1; i1 < v.waves.length; i1++) {
			renderwave(i1);
		}
		for (i1 = 0; i1 <= newest; i1++) {
			renderwave(i1);
		}
		// render every wave, starting from the oldest to the newest. since this
		// loops, you should start with the wave that begins after, and cycle
		// around.
		//
		this.frameend(frame);
	};
	suite.twitchyshape = new ProcAnim();
	suite.twitchyshape.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2, -u.w/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		//
		v.initialized = true;
	};
	suite.twitchyshape.func = function(frame, shape2d, x, y, scale, randrange, randfactor) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		if(!(shape2d instanceof Shape2d)) {
			shape2d = Shape2d.build("star", 128);
		}
		x = typeof x === "number" ? x : u.w/2;
		y = typeof y === "number" ? y : u.h/2;
		scale = typeof scale === "number" ? scale : 1;
		randrange = typeof randrange === "number" ? randrange : 8;
		randfactor = typeof randfactor === "number" ? randfactor : 2;
		let polygon = shape2d.path;
		for (i1 = 0; i1 < polygon.length; i1++) {
			polygon[i1] = [
				scale*polygon[i1][0] + x + Math.trunc(randrange*randexponent(randfactor, true)),
				scale*polygon[i1][1] + y + Math.trunc(randrange*randexponent(randfactor, true)),
			];
		}
		_2dPoly.draw(ctx, polygon, "both");
		//
		this.frameend(frame);
	};
	slite.drawtile = function(ctx, x, y, type, size, params) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		if(!params) {
			params = {};
		};
		if(type === "grass") {
		// params structure:
		// - rows (as in the number of them)
		// - blade_h (maximum height of a blade of grass, measured as a fraction of size)
		// - colors (array of colors for it to cycle through)
		// value is the number of silhouettes
			params.rows ??= 4;
			params.blade_h ??= 3/8;
			if((params.colors ?? null) === null) {
				params.colors = [
					"rgb(0,223,79)",
					"rgb(0,239,95)",
					"rgb(0,255,127)"
				];
				params.colors = [
					params.colors[0],
					params.colors[1]
				];
				// used to be dark to medium to light to medium, but it's
				// better if it's only two colors. it only needs just barely
				// enough for silhouettes to be possible, if the color
				// pattern is too distinct it'll easier to notice the
				// grid...
			}
			let colors = params.colors;
			let colorindex = Math.floor(Math.random()*colors.length);
			ctx.fillStyle = colors[colorindex];
			ctx.fillRect(x, y, size, size);
			let overflow = [];
			// structure:
			// - x
			// - h
			// - color
			for (i1 = 0; i1 < params.rows; i1++) {
				colorindex++;
				colorindex %= colors.length;
				let row_y = Math.floor(size*((i1 + 1)/params.rows));
				for (i2 = 0; i2 < size; i2++) {
					let temp = Math.floor(randexponent(1)*params.blade_h*size);
					// height of the blade
					if(temp > row_y) {
						overflow[overflow.length] = {
							x: i2,
							h: temp - row_y,
							color: colorindex,
						};
						temp = row_y;
					};
					ctx.fillStyle = colors[colorindex];
					ctx.fillRect(x + i2, y + row_y, 1, -temp);
					ctx.fillRect(x + i2, y + row_y, 1, size - row_y);
				};
			}
			for (i1 = 0; i1 < overflow.length; i1++) {
				ctx.fillStyle = colors[overflow[i1].color];
				ctx.fillRect(x + overflow[i1].x, y + size, 1, -overflow[i1].h);
			}
		}
		else if(type === "brick") {
		// params:
		// - rows: number of rows
		// - columns: number of columns
		// - desiccation: pixels will only be drawn if a Math.random() is
		//   below this.
		// - thickness: pixel width of the lines between bricks
		// - linecolor
		// - valuefunc, colorfunc: function for generating a random number,
		//   and a function for returning a brick color using that number.
			params.rows ??= 4;
			params.columns ??= 4;
			params.desiccation ??= .875;
			params.thickness ??= 1;
			params.linecolor ??= hsvtorgb(30, 25, 94.75, true);
			//params.valuefunc ??= () => (1 - randexponent(3)) < .75 ? .5 : 1;
			params.valuefunc ??= (centerfactor) => Math.floor( randexponent(4*centerfactor) *3)/3;
			//params.colorfunc ??= (value) => "hsl(" + [0, /*Math.floor(75*value) +*/ "100%", "87.5%"].join(",") + ")";
			params.colorfunc ??= (value) => hsvtorgb(
				(1 - value)*0 + value*30,
				(1 - value)*75 + value*25,
				(1 - value)*87.5 + value*94.75,
			true);
			let edgecloseness = (rect, x, y) => Math.min(
				Math.abs(rect.x - x),
				// the point to the left on the rectangle, at the same y
				Math.abs(rect.x + rect.w - x),
				// the point to the right
				Math.abs(rect.y - y),
				// up
				Math.abs(rect.y + rect.h - y)
				// down
			);
			let block = {
				w: size/params.columns,
				h: size/params.rows,
			};
			for (i1 = 0; i1 < size; i1++) {
			// x
				for (i2 = 0; i2 < size; i2++) {
				// y
					let rect = [
						Math.floor(i1/block.w),
						Math.floor(i2/block.h)
					];
					let temp = rect[0]%2 === rect[1]%2;
					rect = {
						x: (rect[0] - (temp ? 0 : 1))*block.w,
						y: rect[1]*block.h,
						w: block.w*2,
						h: block.h,
					};
					let edgedist = edgecloseness(rect, i1, i2);
					let centerfactor = Math.min(block.w*2/2, block.h/2);
					// maximum edgedist
					centerfactor = edgedist/centerfactor;
					ctx.fillStyle = (
						edgedist < params.thickness && Math.random() < params.desiccation
						?
						params.linecolor
						:
						params.colorfunc(params.valuefunc(centerfactor))
					);
					ctx.fillRect(x + i1, y + i2, 1, 1);
				}
			}
		}
		else if(type === "road") {
		// params:
		// - roadcolor
		// - gapfill (color used to draw over all areas it sprays, before
		//   they're sprayed)
		// - path
		//   - "ul_corner", "ur_corner", etc
		//   - "vert"
		//   - "hori"
		//   - "u_end", "r_end", etc
		//   - "center"
		//   - "u_cross", "r_cross", etc
		//   - "cross"
		// - spray
		//   - r
		//   - density (measured in pixels per spray area)
		// - spraysperpixel
			params.roadcolor ??= ["#efbf8f", "#efcfaf"];
			params.gapfill ??= "";
			//params.roadcolor ??= ["#2f2f5f", "#575f93", "#7f8fc7"];
			//params.gapfill ??= "black";
			params.path ??= "center";
			params.spray ??= {};
			params.spray.r ??= 1/4;
			params.spray.density ??= 1/4;
			params.spraysperpixel ??= 1/8;
			//
			let spray_r = params.spray.r*size;
			let spray_density = Math.floor(params.spray.density*Math.PI*spray_r**2);
			let data = [];
			for (i1 = 0; i1 < size; i1++) {
				data[i1] = [];
				for (i2 = 0; i2 < size; i2++) {
					data[i1][i2] = 0;
				}
			}
			function spray(x, y) {
				let i1 = 0;
				for (i1 = 0; i1 < spray_density; i1++) {
					let temp = [
						spray_r*randexponent(2),
						Math.random()*2*Math.PI
					];
					temp = [
						Math.floor(x + Math.cos(temp[1])*temp[0]),
						Math.floor(y + Math.sin(temp[1])*temp[0])
					];
					if(temp[0] >= 0 && temp[0] < size && temp[1] >= 0 && temp[1] < size) {
						data[ temp[0] ][ temp[1] ]++;
					};
				}
			}
			function spraythisrect(rect) {
				if(params.gapfill) {
					let temp = ctx.fillStyle;
					ctx.fillStyle = params.gapfill;
					ctx.fillRect(x + rect.x, y + rect.y, rect.w, rect.h);
					ctx.fillStyle = temp;
				};
				let numofsprays = rect.w*rect.h*params.spraysperpixel;
				for (i1 = 0; i1 < numofsprays; i1++) {
					spray(rect.x + Math.random()*rect.w, rect.y + Math.random()*rect.h);
				}
			}
			let road_w = size - (2*spray_r);
			let rect = {
				x: spray_r,
				y: spray_r,
				w: road_w,
				h: road_w,
			};
			spraythisrect(rect);
			let ends = [false, false, false, false];
			// r, d, l, u
			let temp = "";
			if(["ul", "ur", "dr", "dl"].includes(params.path.slice(0, 2)) && params.path.slice(2) === "_corner") {
				temp = params.path.slice(0, 2);
			}
			if(["r", "d", "l", "u"].includes(params.path[0]) && ["_end", "_cross"].includes(params.path.slice(1))) {
				temp = params.path[0];
			};
			if(temp.includes("l")) {
				ends[0] = true;
			};
			if(temp.includes("u")) {
				ends[1] = true;
			};
			if(temp.includes("r")) {
				ends[2] = true;
			};
			if(temp.includes("d")) {
				ends[3] = true;
			};
			if(["r", "d", "l", "u"].includes(params.path[0]) && params.path.slice(1) === "_cross") {
				ends = [true, true, true, true];
				ends[ ["r", "d", "l", "u"].indexOf(params.path[0]) ] = false;
			};
			if(params.path === "cross") {
				ends = [true, true, true, true];
			};
			if(params.path === "vert") {
				ends = [false, true, false, true];
			};
			if(params.path === "hori") {
				ends = [true, false, true, false];
			};
			if(ends[0]) {
			// right
				rect = {
					x: size - spray_r,
					y: spray_r,
					w: spray_r,
					h: road_w,
				};
				spraythisrect(rect);
			};
			if(ends[1]) {
			// down
				rect = {
					x: spray_r,
					y: size - spray_r,
					w: road_w,
					h: spray_r,
				};
				spraythisrect(rect);
			};
			if(ends[2]) {
			// left
				rect = {
					x: 0,
					y: spray_r,
					w: spray_r,
					h: road_w,
				};
				spraythisrect(rect);
			};
			if(ends[3]) {
			// up
				rect = {
					x: spray_r,
					y: 0,
					w: road_w,
					h: spray_r,
				};
				spraythisrect(rect);
			};
			if(!Array.isArray(params.roadcolor)) {
				ctx.fillStyle = params.roadcolor;
			}
			for(i1 = 0; i1 < data.length; i1++) {
				for(i2 = 0; i2 < data[i1].length; i2++) {
					if(Array.isArray(params.roadcolor)) {
						if(data[i1][i2] > 0) {
							ctx.fillStyle = params.roadcolor[ Math.min(data[i1][i2], params.roadcolor.length) - 1 ];
							ctx.fillRect(x + i1, y + i2, 1, 1);
						}
					}
					else {
						for(i3 = 0; i3 < data[i1][i2]; i3++) {
							ctx.fillRect(x + i1, y + i2, 1, 1);
						}
					}
				}
			}
		}
	};
	slite.jankynumbers = function(ctx, x, y, number, string, spacing, intensity, scaleintensity) {
	// - number: the number it's drawing
	// - string: strings to write next to the number. if it's only one string,
	//   it'll come after. if it's an array of two strings, it'll be the one
	//   that comes before and the one that comes after.
	// - spacing: spacing between characters.
	//   - i don't know a better way to get the x position of each character and
	//     i only use monospace fonts anyway.
	// - intensity: the number it should multiply random offsets by
	// - scaleintensity: if this is truthy, it'll also multiply the offset by
	//   the value of the number. if it's a number, it'll add this to the number
	//   before multiplying (for example, if you want it to have zero intensity
	//   at 100, make this -100.)
		let i1 = 0;
		if(!string) {
			string = number.toString();
		}
		else if(typeof string === "string") {
			string = number + string;
		}
		else if(Array.isArray(string) && string.length === 2 && typeof string[0] === "string" && typeof string[1] === "string") {
			string = string[0] + number + string[1];
		}
		else {
			console.log("invalid string parameter.");
			return;
		};
		if(!spacing && spacing !== 0) {
			let temp = Number(ctx.font.slice(0, ctx.font.indexOf("px")))/2;
			spacing = (temp ? temp : 8);
		};
		if(!intensity) {
			intensity = spacing/2;
		};
		if(typeof scaleintensity === "number") {
			number += scaleintensity;
		};
		scaleintensity = scaleintensity || typeof scaleintensity === "number";
		// it's only used as a boolean after this point
		for (i1 = 0; i1 < string.length; i1++) {
			let shake = [
				Math.random()*2*Math.PI,
				randexponent(2)
			];
			// angle, intensity
			shake = [
				intensity*shake[1]*Math.cos(shake[0]),
				intensity*shake[1]*Math.sin(shake[1]),
			];
			if(scaleintensity) {
				shake[0] *= number;
				shake[1] *= number;
			};
			shake = [
				Math.trunc(shake[0]),
				Math.trunc(shake[1])
			];
			ctx.fillText(string[i1], x + i1*spacing + shake[0], y + shake[1]);
		}
	};
	slite.gleam = {
		create: function(size, hw_ratio) {
			// creates an object slite.gleam.draw can draw
			let i1 = 0;
			let w = size;
			let h = size*hw_ratio;
			let angle = randexponent(2, true)*2*Math.PI/8;
			let shape = Shape2d.build("ellipse", [w, h]);
			let length = objarraylength(shape);
			for(i1 = 0; shape.hasOwnProperty(i1); i1++) {
				shape[i1].elbow.direction = {in: "out", out: "in"}[ shape[i1].elbow.direction ];
			};
			return {shape, w, h, angle};
		},
		draw: function(time, gleam, ctx, x, y) {
			let i1 = 0;
			let path = new Shape2d();
			let overshoot_time = 1/2;
			for(i1 in gleam.shape) {
				if(gleam.shape.hasOwnProperty(i1)) {
					path[i1] = structuredClone(gleam.shape[i1]);
					if(!isNaN(Number(i1))) {
						let temp = easing(2*time, "out", "circ", [2, overshoot_time, "out"]);
						path[i1].y *= temp;
					}
				}
			}
			path = structuredClone(path.path);
			_2dPoly.draw(ctx, path, "fill", false, [x, y]);
			let flare_duration = 1/2;
			let flare_turn = 1/8;
			if(overshoot_time <= 2*time && 2*time <= overshoot_time + flare_duration) {
			// hashtag-shaped lens flare
				let r = null;
				for(i1 = 0; i1 < path.length; i1++) {
					let temp = Math.hypot(path[i1][0], path[i1][1]);
					if(r === null || temp < r) {
						r = temp;
					};
				}
				let nums = [gleam.w*1/16, 4*gleam.h];
				// width/height of the bars
				let flare = [
					Shape2d.build("rect", [nums[0], nums[1]], false, false, [-(r/2 + nums[0]/2), 0]),
					Shape2d.build("rect", [nums[0], nums[1]], false, false, [ (r/2 + nums[0]/2), 0]),
					Shape2d.build("rect", [nums[1], nums[0]], false, false, [0, -(r/2 + nums[1]/2)]),
					Shape2d.build("rect", [nums[1], nums[0]], false, false, [0,  (r/2 + nums[1]/2)])
				];
				let angle = (2*time - overshoot_time)/flare_duration;
				angle = easing(angle, "out", "square")*flare_turn*2*Math.PI;
				angle += gleam.angle;
				for(i1 = 0; i1 < flare.length; i1++) {
					flare[i1].rotate.angle = angle;
					flare[i1] = structuredClone(flare[i1].path);
				}
				// hashtag-shaped lens flare
				//
				for(i1 = 0; i1 < flare.length; i1++) {
					_2dPoly.draw(ctx, flare[i1], "fill", false, [x, y]);
				};
			}
		},
	};
	suite.gleams = new ProcAnim();
	suite.gleams.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2, -u.w/2];
		v.numofgleams ??= 1;
		if((v.gleam ?? null) === null) {
			v.gleam = [];
			v.offsets = [];
			let i1 = 0;
			for(i1 = 0; i1 < v.numofgleams; i1++) {
				v.gleam[i1] = slite.gleam.make((1 + randexponent(2, true)/2)*u.w/2, 5/4);
				v.offsets[i1] = [
					Math.floor(v.pos[0] + randexponent(2, true)*u.w/2),
					Math.floor(v.pos[1] + randexponent(2, true)*u.h/2)
				];
			};
		}
		//
		v.initialized = true;
	};
	suite.gleams.func = function(frame, gleamspacing, gleamlength) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		ctx.fillStyle = "black";
		ctx.fillRect(0, 0, u.w, u.h);
		ctx.fillStyle = "white";
		ctx.strokeStyle = "white";
		gleamspacing ??= 4;
		gleamlength ??= 8;
		for(i1 = 0; i1 < v.gleam.length; i1++) {
			let temp = (frame - i1*gleamspacing);
			if(0 <= temp && temp < gleamlength) {
				slite.gleam.draw(temp/gleamlength, v.gleam[i1], ctx, ...v.offsets[i1]);
			};
		}
		//
		this.frameend(frame);
	};
	slite.ditherparallax = function(frame, ctx, input, direction) {
	/*
	slite.ditherparallax(frame, ctx, [
		{
			dither: "",
			cutoff: ,
			direction: ,
			speed: ,
			color: ,
		}
	], direction);
	//*/
	// - input: array of objects.
	//   - dither (name string)
	//   - invert: if present and true, it'll only draw if the dither returns
	//     false instead of true
	//   - cutoff, direction: cutoff is a coordinate, direction is a single
	//     letter. (u/d/l/r) "l" means it'll only draw dither on pixels with a
	//     lower x than cutoff, "u" means it draws on pixels with lower y, etc.
	//   - speed: number of pixels to scroll per frame
	//   - color
	// - direction: direction to use if it's absent from an input.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		direction = ["u", "d", "l", "r"].includes(direction) ? direction : "d";
		let dim = [ctx.canvas.width, ctx.canvas.height];
		const dithersobj = dithers;
		// right now they're stored in a screwy place...
		for(i1 = 0; i1 < input.length; i1++) {
			let dir = input[i1].hasOwnProperty("direction") ? input[i1].direction : direction;
			if(!input[i1].hasOwnProperty("cutoff")) {
				let temp = dim[ Math.sign("ud".includes(dir)) ];
				if(i1 === 0) {
					input[i1].cutoff = temp/2;
				}
				else if("dr".includes(dir)) {
					input[i1].cutoff = (temp + input[i1 - 1].cutoff)/2;
				}
				else {
					input[i1].cutoff = input[i1 - 1].cutoff/2;
				}
			}
			if(!input[i1].hasOwnProperty("speed")) {
				input[i1].speed = (i1 === 0 ? 0 : input[i1 - 1].speed + 1);
			}
			let bounds = [0, ctx.canvas.width, 0, ctx.canvas.height];
			// searches pixels with x between [0] and [1], y between etc etc
			bounds["rldu".indexOf(dir)] = input[i1].cutoff;
			let scroll = "lrud".indexOf(dir);
			scroll = [
				[0, 0, -1, 1][scroll] * frame * input[i1].speed,
				[-1, 1, 0, 0][scroll] * frame * input[i1].speed
			];
			if(input[i1].hasOwnProperty("color")) {
				ctx.fillStyle = input[i1].color;
			}
			else {
				ctx.fillStyle = "rgb(" + [255, Math.floor(255*i1/input.length), 0].join() + ")";
			}
			for(i2 = bounds[0]; i2 < bounds[1]; i2++) {
				for(i3 = bounds[2]; i3 < bounds[3]; i3++) {
					let coor = [i2 + scroll[0], i3 + scroll[1]];
					if(dither_interpreter(input[i1].dither, coor[0], coor[1], input[i1].hasOwnProperty("invert") && input[i1].invert)) {
						ctx.fillRect(i2, i3, 1, 1);
					};
				}
			}
		}
	}
	slite._2dpoly = {};
	// functions that are related to _2dPoly but not enough to be _2dPoly
	// functions directly.
	slite._2dpoly.random = function(r, numofpoints, condensefactor, angleoffset) {
	// returns a random _2dPoly that doesn't have hourglass intersections or
	// anything.
		let i1 = 0;
		condensefactor ??= 1;
		angleoffset = typeof angleoffset === "number" ? angleoffset : Math.random();
		let shape = [];
		for(i1 = 0; i1 < numofpoints; i1++) {
			let anglenum = 2*Math.PI*(i1/numofpoints) + angleoffset;
			anglenum = [
				Math.cos(anglenum),
				Math.sin(anglenum)
			];
			amplitude = r*(randexponent(condensefactor, true) + 1)/2;
			shape[i1] = [
				amplitude*anglenum[0],
				amplitude*anglenum[1]
			];
		};
		return shape;
	};
	slite._2dpoly.colorbydistance = function(_this, ctx, colorfunc, divideby) {
		colorfunc ??= (value) => "rgb(" + [255, Math.floor(value*255), 0].join(",") + ")";
		divideby ??= 1;
		_2dPoly.execute(_this, true, function(x, y) {
			let temp = _2dPoly.distfromedge(_this, x, y)/divideby;
			ctx.fillStyle = colorfunc(temp);
			ctx.fillRect(x, y, 1, 1);
		});
	};
	slite.walkers = {};
	// a "walker" is when you have it start at a random coordinate, add to a
	// value for that coordinate, have it move one pixel in a random direction,
	// and repeat. this can be used to create heightmaps and stuff like
	// diamondsquare. or fire, apparently.
	// - it's a lot more scraggly than diamond square though, and probably more
	//   intensive.
	slite.walkers.start = {
	// an object of functions for use in slite.walkers.create. they return
	// random starting positions, usually on the outline or inside of a
	// specified shape.
		circle: function(x, y, r, etc) {
		// - etc
		//   - "inside": it'll choose a point inside the circle. (points closer
		//     to the center are more likely, since it chooses a random angle
		//     and magnitude.)
		//   - "lopsided": it'll use randexponent to make it start near angle 0
		//     more often.
			etc ??= [];
			let angle = posmod(randexponent(etc.includes("lopsided") ? 1.5 : 1, true)*Math.PI, 2*Math.PI);
			// randexponent so that most of the landmass is on one side
			let magn = etc.includes("inside") ? Math.random() : 1;
			return [
				x + r*Math.cos(angle)*magn,
				y + r*Math.sin(angle)*magn
			];
			// start at a random place on the circle
		},
		rect: function(x, y, w, h) {
			x ??= 0;
			y ??= 0;
			return [
				x + Math.random()*w,
				y + Math.random()*h
			];
		},
		point: (x, y) => [x, y],
	};
	slite.walkers.create = function(w, h, start_func, start_args, numofwalkers, walkerlength, etc) {
	// - start_func: a string for the slite.walkers.start you want to use, or a
	//   function.
	// - start_args: an array of arguments to use in that.
	// - etc:
	//   - "eightdir": makes it so the walker moves in eight directions, just
	//     moving up/down 1 x/y instead of using the sin/cos of a random angle
	//   - "direct": if this is followed by a number, it'll use that as an
	//     angle, rerolling the random angle once if it wasn't within Math.PI/2
	//     of this. (ex if you set it as 3/2 pi, it'll reroll it once if the
	//     angle wasn't in the upper half.)
		let i1 = 0;
		let i2 = 0;
		if(typeof start_func !== "function" && (typeof start_func !== "string" || !slite.walkers.start.hasOwnProperty(start_func))) {
			return;
		};
		start_args ??= [];
		numofwalkers ??= 2**8;
		walkerlength ??= 2**7;
		etc ??= [];
		let data = [];
		for(i1 = 0; i1 < w; i1++) {
			data[i1] = [];
			for(i2 = 0; i2 < h; i2++) {
				data[i1][i2] = 0;
			}
		}
		for(i1 = 0; i1 < numofwalkers; i1++) {
			let coor = (
				typeof start_func === "string"
				?
				slite.walkers.start[start_func](...start_args)
				:
				start_func(...start_args)
			);
			coor[0] += .5;
			coor[1] += .5;
			// start in the center of the pixel
			for(i2 = 0; i2 < walkerlength; i2++) {
				let _coor = [Math.floor(coor[0]), Math.floor(coor[1])];
				if(withinrect(..._coor, {x: 0, y: 0, w: data.length, h: data[0].length})) {
				// if the walker is still on the screen, add a point to
				// their position's value in data
					data[ _coor[0] ][ _coor[1] ]++;
				};
				if(etc.includes("eightdir")) {
					let dir = Math.floor(Math.random()*8);
					// 567
					// 4 0
					// 321
					if([5, 6, 7].includes(dir)) {
						coor[1]--;
					}
					else if([3, 2, 1].includes(dir)) {
						coor[1]++;
					};
					if([5, 4, 3].includes(dir)) {
						coor[0]--;
					}
					else if([7, 0, 1].includes(dir)) {
						coor[0]++;
					};
				}
				else if(etc.includes("knight")) {
					let angle = Math.floor(Math.random()*8);
					let temp = angle%4;
					temp = temp === 1 || temp === 2;
					let x = temp ? 2 : 1;
					let y = temp ? 1 : 2;
					if(angle%8 < 4) {
						x *= -1;
					};
					if((angle + 6)%8 < 4) {
						y *= -1;
					};
					coor[0] += x;
					coor[1] += y;
				}
				else {
					let dir = Math.random()*2*Math.PI;
					//let dir = Math.random()*2*Math.PI;
					if(etc.includes("direct")) {
						let angle = etc[ (etc.indexOf("direct") + 1) ];
						if(typeof angle === "number") {
							let dist = Math.abs(angle - dir);
							if(dist >= Math.PI) {
								dist = 2*Math.PI - dist;
							};
							// make sure it's circular and all that, 359 and 0
							// are next to each other
							if(dist >= Math.PI/2) {
								dir = Math.random()*2*Math.PI;
							};
						}
					}
					coor[0] += Math.cos(dir);
					coor[1] += Math.sin(dir);
				};
			}
		}
		return data;
	};
	slite.walkers.draw = function(ctx, data, colorfunc) {
		let i1 = 0;
		let i2 = 0;
		colorfunc ??= (num) => "rgb(" + [255, 16*num, 0].join() + ")";
		for(i1 = 0; i1 < data.length; i1++) {
			for(i2 = 0; i2 < data[i1].length; i2++) {
				let num = data[i1][i2];
				if(num > 0) {
					ctx.fillStyle = colorfunc(num);
					ctx.fillRect(i1, i2, 1, 1);
				}
			}
		}
	};
	slite.walkers.shift = function(data, x, y) {
		let _data = structuredClone(data);
		x = posmod(x, _data.length);
		y = posmod(y, _data[0].length);
		if(x) {
			_data = _data.slice(-x).concat( _data.slice(0, -x) );
		};
		if(y) {
			let i1 = 0;
			for(i1 = 0; i1 < _data.length; i1++) {
				_data[i1] = _data[i1].slice(-y).concat( _data[i1].slice(0, -y) );
			}
		};
		return _data;
	};
	slite.walkers.add = function(data, create_args, subtract) {
	// creates a new walker data and adds that to the one you have.
	// - create_args: arguments for .create. skip w and h.
	// - subtract: boolean that will make it subtract the new amounts instead of adding them
		let i1 = 0;
		let i2 = 0;
		let _data = slite.walkers.create(data.length, data[0].length, ...create_args);
		for(i1 = 0; i1 < _data.length; i1++) {
			for(i2 = 0; i2 < _data[i1].length; i2++) {
				_data[i1][i2] = Math.max(0, (data[i1][i2] + (subtract ? -1 : 1)*_data[i1][i2]));
			}
		}
		return _data;
	};
	slite.walkers.flame = function(data, angle, magnitude, create_args) {
	/*
	slite.walkers.flame(data, angle, magnitude, [
		start_func,
		start_args,
		numofwalkers,
		walkerlength,
		etc
	])
	*/
	// animates it to resemble flames.
	// - angle, magnitude: used to get the x and y it uses in .shift.
	// - create_args: array of arguments for .add and .create. (if it's falsy,
	//   it'll skip this part.)
	//   - skip data, w, and h, since those are already inputted.
	// - it decays the current values by square rooting them if they're above 1,
	//   and subtracting them if they're 1.
	// - so far, i think it looks alright for a sun or something, but not for
	//   fire. bluh.
	//   - looks like fire you'd see in one of those crappy gba games that's
	//     like "check it out we can do 3d!!! kind of!"
		let i1 = 0;
		let i2 = 0;
		magnitude ??= 4;
		angle ??= 3*Math.PI/2;
		// straight up
		let x = Math.trunc(magnitude*Math.cos(angle));
		let y = Math.trunc(magnitude*Math.sin(angle));
		let _data = slite.walkers.shift(data, x, y);
		for(i1 = 0; i1 < _data.length; i1++) {
			for(i2 = 0; i2 < _data[i1].length; i2++) {
				//_data[i1][i2] = Math.max(0, _data[i1][i2] - decay);
				if(_data[i1][i2] === 1) {
					_data[i1][i2]--;
				}
				else {
					_data[i1][i2] = Math.floor(Math.sqrt(_data[i1][i2]));
				}
			}
		}
		if(create_args) {
			_data = slite.walkers.add(_data, create_args);
		}
		return _data;
	};
	slite.spiro = function(frame, r, rev) {
	/*
	slite.spiro(frame/8, [2, 1], [1, 1/2])
	// cardioid
	*/
	// returns the 2d coordinates of a point that revolves in a circle that
	// itself revolves.
	// - r: an array of the radii of each revolution.
	// - rev: an array of the lengths of each revolution, measured in how many
	//   frames one revolution takes.
	//   - negative numbers will be interpreted as counterclockwise
		let i1 = 0;
		let i2 = 0;
		if(r.length !== rev.length) {
			console.log("r array length doesn't match rev array.");
			return;
		}
		let coor = [0, 0];
		for(i1 = 0; i1 < r.length; i1++) {
			let negative = Math.sign(rev[i1]) === -1;
			let temp = Math.abs(rev[i1]);
			temp = 2*Math.PI*(frame%temp)/temp;
			if(negative) {
				temp = 2*Math.PI - temp;
			};
			temp = [
				r[i1]*Math.cos(temp),
				r[i1]*Math.sin(temp)
			];
			coor[0] += temp[0];
			coor[1] += temp[1];
		}
		return coor;
	}
	slite.harmonysprawl = function(ctx, x, y, rules, names, colors, node_r, start_r, circle_gap, onebranch, sector_gap, skiprings) {
	// this is procedural drawing, not animation... and it's an infographic too.
	// whatever
	// - rules: an array of arrays, for which chords each chord can go to. write
	//   all chords as numbers.
	//   - NOTE start at one, not zero.
	// - names: an array of strings to write for each chord
	// - colors: an array of colors for the nodes.
	// - start_r: the radius of the circle the first ring sits on.
	// - circle_gap: the radius difference between circles
	// - node_r: node radius
	// - onebranch: if you only want to graph one chord's branch, give that
	//   chord's index.
	//   - again, start at one.
	// - sector_gap: determines how much spacing there is between different
	//   branches' dedicated sectors.
		let i1 = 0;
		let i2 = 0;
		rules ??= [
			[1, 2, 3, 4, 5, 6, 7],
			[1, 5, 7],
			[1, 4, 6],
			[1, 2, 5, 7],
			[1, 6],
			[1, 2, 3, 4, 5],
			[1]
		];
		for(i1 = 0; i1 < rules.length; i1++) {
			for(i2 = 0; i2 < rules[i1].length; i2++) {
				rules[i1][i2]--;
			};
		};
		names ??= ["I", "ii", "iii", "IV", "V", "vi", "vii" + String.fromCharCode(176)];
		if(!Array.isArray(colors)) {
			colors = [
				"rgb(119, 187, 255)",
				"rgb(255, 68, 51)",
				"rgb(119, 0, 255)"
			];
			colors = [
				colors[0],
				colors[1],
				colors[1],
				colors[0],
				colors[0],
				colors[1],
				colors[2]
			];
		};
		node_r ??= 8;
		circle_gap ??= node_r * 4;
		start_r ??= 1*circle_gap;
		sector_gap ??= 1/4;
		let centerchord = null;
		for(i1 = 0; i1 < rules.length; i1++) {
		// checks for chords that can lead to every chord. if this exists, it'll
		// be the center of the concentric circles.
			let bool = true;
			for(i2 = 0; i2 < rules.length; i2++) {
				if(!rules[i1].includes(i2)) {
					bool = false;
					i2 += rules.length;
				};
			}
			if(bool) {
				centerchord = i1;
				i1 += rules.length;
			};
		}
		if(
			typeof onebranch === "number"
			&&
			1 <= onebranch && onebranch < rules.length + 1
			&&
			(centerchord === null || centerchord !== onebranch - 1)
		) {
			onebranch--;
		}
		else {
			onebranch = null;
		};
		ctx.font = "16px 'fomp2'";
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		let tree = {};
		// an object of trees. it iterates to extend them over and over until it
		// can't extend anymore. the structure is a chain of objects. it has a
		// property for each chord it's allowed to continue into, which in turn
		// is an object of chords that chord can continue into.
		// - nulls are used to say, "this chord hasn't been extended as its own
		//   tree yet.", the tree extendy thing searches for them...
		function createbranch(property, keychain) {
			let ref = rules[ Number(keychain[keychain.length - 1]) ];
			// array of possible continuations
			for(let i1 = 0; i1 < ref.length; i1++) {
				if(!keychain.includes(ref[i1].toString())) {
					// avoid any continuations that have already been used
					let _keychain = structuredClone(keychain);
					_keychain[_keychain.length] = ref[i1].toString();
					property[ ref[i1] ] = {};
					createbranch(property[ ref[i1] ], _keychain);
				};
			}
		}
		if(centerchord !== null) {
			tree[centerchord] = {};
			createbranch(tree[centerchord], [centerchord.toString()]);
		}
		else {
			for(i1 = 0; i1 < rules.length; i1++) {
				tree[i1] = {};
				createbranch(tree[i1], [i1.toString()]);
			}
		};
		// create the tree
		function stringify(tree, propertyname) {
			let i1 = 0;
			let i2 = 0;
			let text = [];
			if(propertyname === null) {
				for(i1 in tree) {
					text[text.length] = stringify(tree[i1], i1);
				}
			}
			else {
				text[0] = names[ Number(propertyname) ];
				for(i1 in tree) {
					let temp = stringify(tree[i1], i1).split(String.fromCharCode(10));
					for(i2 = 0; i2 < temp.length; i2++) {
						temp[i2] = String.fromCharCode(9) + temp[i2];
					}
					text[text.length] = temp.join(String.fromCharCode(10));
				}
			}
			text = text.join(String.fromCharCode(10));
			return text;
		};
		//let text = stringify(tree, null);
		//console.log(text);
		let nodes = [];
		// array sorted by which ring they're on.
		// - node data is a bunch of objects with data for connecting them.
		//   - chord: the index of the chord this node represents
		//   - parent: the index its parent has in the nodes array for this
		//     ring.
		//   - ancestor: the chord of the ring 1/0 level it descends from.
		//   - x, y: coordinates for drawing
		// - NOTE index 0 is the center of the circles, which is empty unless
		//   centerchord exists.
		let sectors = [];
		// sorted by ring, then by ancestor. each index is an array of the
		// lowest and highest node indexes with that ancestor.
		function createnodes(tree, propertyname, parent, level) {
		// create .chord, .parent, .ancestor
			let i1 = 0;
			let i2 = 0;
			nodes[level] ??= [];
			let index = nodes[level].length;
			nodes[level][index] = {
				chord: Number(propertyname),
				parent,
			};
			let ancestor = null;
			if(level < 1) {
				// it can stay null
			}
			else if(level === 1) {
				ancestor = nodes[level][index].chord;
			}
			else if(level > 1) {
				ancestor = nodes[level - 1][parent].ancestor;
			}
			else {
				console.log("this shouldn't happen");
			};
			nodes[level][index].ancestor = ancestor;
			if(ancestor !== null) {
				sectors[level] ??= [];
				sectors[level][ancestor] ??= [null, null];
				let ref = sectors[level][ancestor];
				if(ref[0] === null || index < ref[0]) {
					ref[0] = index;
				};
				if(ref[1] === null || index > ref[1]) {
					ref[1] = index;
				};
			};
			for(i1 in tree) {
				createnodes(tree[i1], i1, index, level + 1);
			};
		};
		if(centerchord === null) {
			nodes[0] = [];
			nodes[0][0] = {chord: null, parent: null};
			// if a node's chord is null, no circled name will be made. if the
			// parent is null, no connection will be made. i'd still like a
			// central node, even if it's empty.
			for(i1 in tree) {
				createnodes(tree[i1], i1.toString(), 0, 1);
			}
		}
		else {
			createnodes(tree[centerchord], centerchord.toString(), null, 0);
		};
		let styletemp = [ctx.fillStyle, ctx.strokeStyle];
		ctx.strokeStyle = "silver";
		let drawcondition = (node_ancestor) => onebranch === null || [null, onebranch].includes(node_ancestor);
		function getangle(level, ancestor, index) {
			let i1 = 0;
			let circdivisor = rules.length - (centerchord !== null);
			//console.log("circdivisor: " + circdivisor);
			let angle = (sectors[level][ancestor][1] - sectors[level][ancestor][0]);
			angle = (
				angle === 0
				// highest and lowest are the same, only one index
				?
				.5
				:
				(index - sectors[level][ancestor][0])/angle
			);
			angle = sector_gap/2 + angle*(1 - sector_gap);
			//console.log("place: " + angle);
			angle /= circdivisor;
			angle += (ancestor - (centerchord === null || ancestor >= centerchord))/circdivisor;
			console.log("ancestor: " + ancestor);
			console.log("sector: " + [(ancestor - (centerchord === 0 ? 1 : 0)), circdivisor].join("/"));
			angle = posmod(angle - 1/(2*circdivisor), 1);
			angle *= 2*Math.PI;
			return angle;
		}
		if(!skiprings) {
			for(i1 = 1; i1 < nodes.length; i1++) {
				circledraw(ctx, x, y, start_r + (i1 - 1)*circle_gap, false);
			};
		};
		for(i1 = 0; i1 < nodes.length; i1++) {
			for(i2 = 0; i2 < nodes[i1].length; i2++) {
			// create x and y, and draw lines connecting to parents
				let node = nodes[i1][i2];
				node.x = x;
				node.y = y;
				if(i1 > 0) {
					let r = start_r + (i1 - 1)*circle_gap;
					//let angle = getangle(i1, node.ancestor, i2);
					//*
					let angle = 2*Math.PI*i2/nodes[i1].length;
					if(i1 > 1) {
					// there's complicated reasons for this but basically, each
					// branch should be centered over where it started from.
						angle = posmod(angle - 2*Math.PI*1/(2*rules.length), 2*Math.PI);
					}
					//*/
					node.x += r*Math.cos(angle);
					node.y += r*Math.sin(angle);
				};
				if(
					drawcondition(node.ancestor)
					&&
					node.parent !== null && i1 > 0
				) {
				// connect it to the parent, in the parent's color
					let parent = nodes[i1 - 1][node.parent];
					ctx.strokeStyle = colors[parent.chord];
					//ctx.strokeStyle = "black";
					nonaaline(ctx, parent.x + 1, parent.y, node.x + 1, node.y);
					nonaaline(ctx, parent.x - 1, parent.y, node.x - 1, node.y);
					nonaaline(ctx, parent.x, parent.y + 1, node.x, node.y + 1);
					nonaaline(ctx, parent.x, parent.y - 1, node.x, node.y - 1);
					//ctx.strokeStyle = colors[parent.chord];
					ctx.strokeStyle = "white";
					nonaaline(ctx, parent.x, parent.y, node.x, node.y);
				}
			}
		}
		function drawnode(x, y, chord) {
			ctx.fillStyle = colors[chord];
			circledraw(ctx, x, y, node_r, true);
			ctx.strokeStyle = styletemp[1];
			circledraw(ctx, x, y, node_r, false);
			ctx.fillStyle = ctx.strokeStyle;
			ctx.fillText(names[chord], Math.floor(x) - 1, Math.floor(y));
			ctx.fillText(names[chord], Math.floor(x) + 1, Math.floor(y));
			ctx.fillText(names[chord], Math.floor(x), Math.floor(y) + 1);
			ctx.fillText(names[chord], Math.floor(x), Math.floor(y) - 1);
			ctx.fillText(names[chord], Math.floor(x) - 1, Math.floor(y) + 1);
			ctx.fillStyle = "white";
			ctx.fillText(names[chord], Math.floor(x), Math.floor(y));
		};
		for(i1 = 0; i1 < nodes.length; i1++) {
			for(i2 = 0; i2 < nodes[i1].length; i2++) {
			// create x and y, and draw lines connecting to parents
				let node = nodes[i1][i2];
				if(drawcondition(node.ancestor) && node.chord !== null) {
					drawnode(node.x, node.y, node.chord);
				};
			}
		}
		ctx.fillStyle = styletemp[0];
		ctx.strokeStyle = styletemp[1];
	}
	suite.waveattack = new ProcAnim();
	suite.waveattack.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/4, u.h/2, -u.w/2];
		v.nodes ??= [];
		//
		v.initialized = true;
	};
	suite.waveattack.func = function(frame, sizes, colors, arc_speed, wave_speed, startangle, breakdown, breaklength, shove_speed, shove_decel) {
	// an animation of a thing circling, and a wave being created from that.
	// it's complicated.
	// - sizes: object of different dimensions
	//   - r: radius of the arc
	//   - circler: radius of the circling thing itself
	//   - wave: weight of the wave
	// - colors: object of colors
	//   - circler
	//   - wave
	//   - waveedge
	// - arc_speed: angle the circling thing moves per frame
	// - wave_speed: pixels the nodes of the wave move per frame
	// - startangle, breakdown, breaklength: the place on the circle it starts,
	//   the place it freezes, and how long.
	// - shove_speed, shove_decel: used in Physics.shove for a speed boost at
	//   the end.
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		sizes ??= {};
		sizes.r ??= u.w/8;
		sizes.circler ??= sizes.r/4;
		sizes.wave ??= false;
		colors ??= {};
		colors.circler ??= "white";
		colors.wave ??= "orange";
		colors.waveedge ??= "#3f3fff";
		arc_speed ??= -(2*Math.PI/7);
		wave_speed ??= sizes.r*4/3;
		startangle ??= 2*Math.PI*1/4;
		breakdown ??= 2*Math.PI*3/4;
		breaklength ??= 7;
		shove_speed ??= wave_speed;
		shove_decel ??= shove_speed/7;
		let breakframe = (breakdown - startangle)/arc_speed;
		if(breakframe < 0) {
			breakframe += 2*Math.PI/arc_speed;
		};
		let framechange = 0;
		let breakfuncframe = null;
		if(frame >= breakframe) {
			breakfuncframe = frame - breakframe;
			// used in the slite or whatever the breakdown animation is
			if(breakfuncframe > breaklength) {
			// change frame so it draws like the freeze never happened
				framechange = -breaklength;
				frame += framechange;
			}
			else {
			// change frame so it draws the last frame before the freeze
				framechange = breakframe - frame;
				frame = breakframe;
			};
		};
		let wave_angle = (startangle + 2*Math.PI*3/4)%(2*Math.PI);
		// always perpendicular so that startangle is the trough of the wave
		wave_speed = [
			wave_speed*Math.cos(wave_angle),
			wave_speed*Math.sin(wave_angle)
		];
		// numbers to add to each node
		if(breakfuncframe > breaklength) {
			let temp = Physics.shove(frame - breakframe, shove_speed, shove_decel);
			temp -= Physics.shove((frame - 1) - breakframe, shove_speed, shove_decel);
			wave_speed[0] += temp*Math.cos(wave_angle);
			wave_speed[1] += temp*Math.sin(wave_angle);
		};
		// add the shove
		for(i1 = 0; i1 < v.nodes.length; i1++) {
			v.nodes[i1][0] += wave_speed[0];
			v.nodes[i1][1] += wave_speed[1];
		};
		// move that nodes that are already there
		let temp = Math.max(
			(arc_speed < 0 ? -2*Math.PI : 0),
			Math.min( frame*arc_speed,
			(arc_speed < 0 ? 0 : 2*Math.PI) )
		);
		console.log(frame + ": " + Angle.convert(temp));
		let circler = posmod(startangle + temp, 2*Math.PI);
		// angle of circler;
		circler = [
			v.pos[0] + sizes.r*Math.cos(circler),
			v.pos[1] + sizes.r*Math.sin(circler)
		];
		v.nodes[v.nodes.length] = structuredClone(circler);
		// make new node
		let intersect = [
			v.pos[0] + sizes.r*Math.cos(startangle),
			v.pos[1] + sizes.r*Math.sin(startangle),
			null,
			null,
			circler[0],
			circler[1],
			null,
			null
		];
		intersect[2] = intersect[0] + Math.cos(wave_angle);
		intersect[3] = intersect[1] + Math.sin(wave_angle);
		intersect[6] = intersect[4] + Math.cos(startangle);
		intersect[7] = intersect[5] + Math.sin(startangle);
		intersect = fourpointintersect(...intersect, true);
		if(typeof intersect !== "string") {
			v.nodes[v.nodes.length] = structuredClone(intersect);
		};
		ctx.fillStyle = colors.wave;
		_2dPoly.draw(ctx, v.nodes, "fill");
		if(typeof intersect !== "string") {
			v.nodes.splice(v.nodes.length - 1, 1);
		}
		ctx.strokeStyle = colors.waveedge;
		_2dPoly.draw(ctx, v.nodes, "stroke", sizes.wave, null, "skiplaststroke");
		ctx.fillStyle = colors.circler;
		circledraw(ctx, ...circler, sizes.circler, true);
		if(breakfuncframe !== null) {
			//
			// run code here, probably a slite.
			//
		};
		frame -= framechange;
		// frameend doesn't use frame, but just in case it does someday
		//
		this.frameend(frame);
	};
	slite.linkage = class {
		constructor(type) {
		// structure:
		// - nodes
		//   - [node names]
		//     - x, y
		// - location: array of arrays. each one is a location constraint; a
		//   list of nodes that have to remain the same distance from each
		//   other.
		// - base: duplicate of what nodes is like at the beginning, to prevent
		//   the length numbers from decaying.
			this.nodes = {};
			this.location = [];
			if(type === "klann") {
				this.nodes = {
					motor: {
						x: -8,
						y: 0,
					},
					legstart: {
						x: -8,
						y: -5,
					},
					leglimiter: {
						x: -12,
						y: -6,
					},
					//
					rotatorA: {
						x: -8,
						y: 4,
					},
					limit1A: {
						x: -12,
						y: -2,
					},
					kneeA: {
						x: -6.5,
						y: -13,
					},
					limit2A: {
						x: -17,
						y: -9,
					},
					toeA: {
						x: -23.5,
						y: 16,
					},
					// A is the one that starts lower
				};
				this.location = [
					["motor", "rotatorA", "rotatorB"],
					//
					["rotatorA", "limit1A", "limit2A"],
					["rotatorB", "limit1B", "limit2B"],
					//
					["leglimiter", "limit1A"],
					["leglimiter", "limit1B"],
					//
					["legstart", "kneeA"],
					["kneeA", "limit2A", "toeA"],
					["legstart", "kneeB"],
					["kneeB", "limit2B", "toeB"],
				];
				let temp = structuredClone(this.nodes);
				this.rotate("motor", "rotatorA", Math.PI);
				for(let i1 in this.nodes) {
					if(i1.endsWith("A")) {
						this.nodes[i1.slice(0, -1) + "B"] = structuredClone(temp[i1]);
					};
				}
			}
			this.base = structuredClone(this.nodes);
		}
		constraints(nodename) {
			let obj = {};
			// lengths, indexed by node name
			for(let i1 = 0; i1 < this.location.length; i1++) {
				let ref = this.location[i1];
				if(ref.includes(nodename)) {
					for(let i2 = 0; i2 < ref.length; i2++) {
						if(ref[i2] !== nodename && this.nodes.includes(ref[i2])) {
							let temp = this.base ?? this.nodes;
							obj[ref[i2]] = Math.hypot(
								temp[nodename].x - temp[ref[i2]].x,
								temp[nodename].y - temp[ref[i2]].y
							);
						}
					}
				}
			}
			return obj;
		}
		move(nodename, x, y, covered) {
			covered ??= [];
			covered[covered.length] = nodename;
			let node = this.nodes[nodename];
			let change = [
				x - node.x,
				y - node.y
			];
			node.x = x;
			node.y = y;
			let constraints = this.constraints(nodename);
			for(let i1 in constraints) {
				if(constraints.hasOwnProperty(i1) && !covered.includes(i1)) {
				// if there's a constraint for how far they have to be from each
				// other, apply that by recursing.
				// - avoid infinite loops by skipping parts that were already
				// moved.
					let _node = this.nodes[i1];
					let angle = get2dangle(
						_node.x - node.x,
						_node.y - node.y,
						true
					) ?? 0;
					this.move(
						i1,
						node.x + constraints[i1]*Math.cos(angle),
						node.y + constraints[i1]*Math.sin(angle),
						covered
					);
				}
			}
		}
		rotate(fulcrum, nodename, angle, fineness) {
			fulcrum = this.nodes[fulcrum];
			let node = this.nodes[nodename];
			let startangle = [
				node.x - fulcrum.x,
				node.y - fulcrum.y
			]
			let length = Math.hypot(...startangle);
			if(!length) {
				return;
			};
			startangle = get2dangle(...startangle, true) ?? 0;
			fineness ??= 16;
			movements = Math.ceil(fineness*Math.abs(angle)/(2*Math.PI));
			for(let i1 = 1; i1 <= movements; i1++) {
				let _angle = startangle + angle*i1/movements;
				this.move(
					nodename,
					length*Math.cos(_angle),
					length*Math.sin(_angle)
				);
			}
		}
	}
	slite.cardioidblob = function(ctx, time, x, y, r, angle) {
		//let _r = -Math.abs(2*time - 1) + 1;
		//_r *= r*Math.PI;
		// between 0 and half circumference
		angle ??= 3*Math.PI/2;
		let _angle = posmod(angle + 2*Math.PI*time, 2*Math.PI);
		let coor = [
			x + Math.cos(_angle)*r,
			y + Math.sin(_angle)*r,
		];
		let _r = Math.hypot(
			x + r*Math.cos(angle) - coor[0],
			y + r*Math.sin(angle) - coor[1]
		);
		if(ctx === "getdata") {
			return [coor[0], coor[1], _r];
		}
		else {
			circledraw(ctx, ...coor, _r);
		};
	};
	suite.hypnosis_partial = new ProcAnim();
	suite.hypnosis_partial.initB = function() {
	//this.hypnosis_partial = suite.hypnosis_partial;
	//this.hypnosis_partial.initA(u, v.duration, {pos: [u.w/2, u.h/2], r: u.w/8, direction: 3*Math.PI/2});
	//this.hypnosis_partial.func(frame, color0, color1, bloblength)
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		let i1 = 0;
		let i2 = 0;
		v.r ??= u.w/8;
		v.angle ??= 3*Math.PI/2;
		v.pos[0] -= v.r*Math.cos(v.angle);
		v.pos[1] -= v.r*Math.sin(v.angle);
		v.blob = [];
		for(i1 = 0; i1 < v.duration; i1++) {
			let temp = easing(i1/v.duration, "in/out", "cube");
			temp = (temp * 1/2) + ((i1/v.duration) * 1/2);
			v.blob[i1] = slite.cardioidblob("getdata", temp, v.pos[0], v.pos[1], v.r, v.angle);
			v.blob[i1][ v.blob[i1].length ] = i1;
		};
		ctx.fillStyle = "black";
		//
		v.initialized = true;
	};
	suite.hypnosis_partial.func = function(frame, color0, color1, bloblength) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		color0 ??= "#bf7fff";
		color1 ??= "magenta";
		bloblength ??= 4;
		let data = v.blob.slice(frame - bloblength, frame);
		data.sort((a, b) => (-Math.abs(b[3] - v.duration/2)) - (-Math.abs(a[3] - v.duration/2)) );
		for(i1 = 0; i1 < data.length; i1++) {
			ctx.strokeStyle = colormath(ctx, color0, color1, i1/(data.length - 1));
			circledraw(ctx, ...data[i1].slice(0, 3), true);
			circledraw(ctx, ...data[i1].slice(0, 3), false);
		}
		// TODO
		// - make this a separate ProcAnim named hypnosis or something
		// - make it play four times, rotating each time but keeping the zero
		//   radius point in the same spot
		//   - make them overlap a little in timing
		//   - have them reverse direction at the right places to make it sort
		//     of draw a clover?
		//   - wait, i can do this with a nested procanim. why don't i do that
		//     more often, timing is always a pain in the ass
		//
		this.frameend(frame);
	};
	suite.hypnosis = new ProcAnim();
	suite.hypnosis.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		let i1 = 0;
		let i2 = 0;
		this.hypnosis_partial = suite.hypnosis_partial;
		v.spacing = 14;
		v.durations = 16;
		v.startangle = 3*Math.PI/2;
		v.anglechange = -Math.PI/2;
		v.numofpartials = 4;
		v.lastinit = null;
		// you need to run initA when you switch from one partial to the next,
		// and in a lot of cases you'll need to run multiple on one frame. this
		// helps it know where to rerun initA
		v.v_backups = [];
		// and you gotta save and restore this
		// - why did i make a system where you can do everything BUT run the
		//   same animation multiple times? am i that dumb?
		v.createbackup = function(v) {
			let i1 = 0;
			let backup = {};
			for (i1 in v) {
				if (v.hasOwnProperty(i1) && typeof v[i1] !== "function" && !["u", "ctx"].includes(i1)) {
					backup[i1] = structuredClone(v[i1]);
				}
			}
			return backup;
		};
		v.restorebackup = function(v, backup) {
			let i1 = 0;
			for (i1 in backup) {
				if (backup.hasOwnProperty(i1)) {
					v[i1] = structuredClone(backup[i1]);
				}
			}
		}
		//
		v.initialized = true;
	};
	suite.hypnosis.func = function(frame, color0, color1, bloblength) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		for(i1 = 0; i1 < v.numofpartials; i1++) {
			let start = i1*v.spacing;
			if(start <= frame && frame < start + v.durations) {
				if(v.lastinit !== i1) {
					this.hypnosis_partial.initA(u, v.durations, {
						pos: structuredClone(v.pos),
						r: u.w/8,
						angle: posmod(v.startangle + i1*v.anglechange, 2*Math.PI),
					});
					v.lastinit = i1;
					if(!!v.v_backups[i1]) {
						v.restorebackup(this.hypnosis_partial.v, v.v_backups[i1]);
					};
				};
				this.hypnosis_partial.func(frame - start, color0, color1, bloblength);
				v.v_backups[i1] = v.createbackup(this.hypnosis_partial.v);
			};
		}
		// TODO
		// - it doesn't overlap properly and there's an awkward change partway
		//   through every partial.
		// - make this a more general ProcAnim for this exact kind of multiple
		//   runnings.
		//
		this.frameend(frame);
	};
	slite.star = {
	// v.star = slite.star.create(x, y, r, points, angle);
	// let points = slite.star.points(v.star, r*frame/duration, 2*Math.PI*frame/duration);
		create: function(x, y, r, points, angle) {
			x ??= 0;
			y ??= 0;
			r ??= 1;
			points = typeof points === "number" && points >= 4 ? points : 5;
			angle ??= 0;
			return {
				x,
				y,
				r,
				points,
				angle,
				progress: 0,
			};
		},
		points: function(_this, progress, angle) {
		// - _this: star created by the create function.
		// - progress: how many pixels outward each side should be moved.
		// - angle: adds to the angle the star already has.
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			progress ??= 0;
			angle ??= 0;
			progress += _this.progress;
			angle += _this.angle;
			let tips = [];
			for(i1 = 0; i1 < _this.points; i1++) {
				let _angle = 2*Math.PI*i1/_this.points + angle;
				_angle = posmod(_angle, 2*Math.PI);
				tips[i1] = [
					_this.x + _this.r*Math.cos(_angle),
					_this.y + _this.r*Math.sin(_angle)
				];
			}
			let interval = _this.points%2 ? Math.floor(_this.points/2) : _this.points/2 - 1;
			let data = [];
			// what it returns.
			function pitdata(point, otherside) {
				let i1 = 0;
				let i2 = 0;
				let temp = [
					0,
					-interval
				];
				let cutoff = [
					-1,
					-1 + interval
				];
				// how many places up or down from the relevant tip each point
				// is. (that is, the four points used in the fourpointintersect)
				for(i1 = 0; i1 < 2; i1++) {
					if(otherside) {
						temp[i1] *= -1;
						cutoff[i1] *= -1;
					};
					temp[i1] = posmod(point + temp[i1], _this.points);
					cutoff[i1] = posmod(point + cutoff[i1], _this.points);
				};
				let coor = fourpointintersect(
					...tips[ temp[0]   ],
					...tips[ temp[1]   ],
					...tips[ cutoff[0] ],
					...tips[ cutoff[1] ],
					true
				);
				// coordinates of the armpit.
				//console.log(point + (otherside ? "B" : "A") + ":" + coor);
				const tip_angle = get2dangle(
					tips[point][0] - coor[0],
					tips[point][1] - coor[1]
				);
				cutoff = [...tips[cutoff[0]], ...tips[cutoff[1]]];
				// structured as a line fourpointintersect can use
				let out_angle = get2dangle(
					cutoff[0] - cutoff[2],
					cutoff[1] - cutoff[3],
				);
				// move parallel to the cutoff line
				let line = [
					coor[0] + progress*Math.cos(out_angle),
					coor[1] + progress*Math.sin(out_angle),
					tips[point][0] + progress*Math.cos(out_angle),
					tips[point][1] + progress*Math.sin(out_angle)
				];
				return {
					x: coor[0],
					y: coor[1],
					tip_angle,
					out_angle,
					cutoff,
					line,
				};
			};
			for(i1 = 0; i1 < _this.points; i1++) {
			// - find the armpits
			// - find the angle that makes it move outward
			// - find the lines that define the star, the ones relevant to
			//   said armpit (you draw a 5-point star by going from 0 to 2,
			//   4, 1, 3, right? those lines.)
			// - create a line using the pit and the angle
			// - find the intersection between that and the defining line
			// - find the intersection between that and the counterpart
				let pitA = pitdata(i1, false);
				let pitB = pitdata(i1, true);
				// in the form of two points, moved [progress] pixels in the
				// out_angle.
				//console.log(pitA);
				//console.log(pitB);
				//console.log([Angle.convert(pitA.tip_angle), Angle.convert(pitB.tip_angle)]);
				data[i1] = [
					pitA.line,
					pitB.line
				];
			}
			return data;
		},
	};
	slite.bean = function(fineness, scaling, h_squish, d_scaler) {
	// BEAN
		let i1 = 0;
		let i2 = 0;
		fineness ??= 32;
		scaling ??= 64;
		h_squish ??= 3/4;
		d_scaler ??= 5/8;
		function bean(core, roller, buffer, fineness, squish) {
		// - core, roller: radii
		//   - look up cardioids and epicycloids. it's a shape made by
		//     tracing the edge of a circle as it rotates around another
		//     circle.
		//   - this function cheats a little bit though. normally, radii
		//     differences affect how many dips it has, but this will force
		//     1 dip no matter what. which doesn't quite make sense for
		//     "rolling".
		// - buffer: and epitrochoids are the same thing, except the point
		//   it traces is on the inside on the roller instead of the edge.
		//   makes it softer, and a little bigger.
		//   - roller + buffer = how far from the roller center the traced
		//     point is.
		// - fineness: how many points it makes.
		// - squish: number for scaling the points in the direction of the
		//   dip. (ex: 1 will look mostly like a cardioid, .75 will be
		//   squished 25% to look more like a bean.)
			let i1 = 0;
			core ??= 1;
			roller ??= 1/2;
			buffer ??= 0;
			fineness ??= 32;
			squish ??= 3/4;
			let points = [];
			for(let i1 = 0; i1 < fineness; i1++) {
				let core_angle = 2*Math.PI*i1/fineness;
				// angle from the core to the contact point
				let roller_angle = (core_angle*2)%(2*Math.PI);
				// angle from the roller to the contact point
				let coor = [
					(core*squish + roller)*Math.cos(core_angle),
					(core + roller)*Math.sin(core_angle)
				];
				// the *core gets it from the core to the contact point, the
				// roller gets it from there to the roller center
				coor[0] += (roller + buffer)*Math.cos(roller_angle);
				coor[1] += (roller + buffer)*Math.sin(roller_angle);
				//coor[0] *= squish;
				points[points.length] = structuredClone(coor);
			}
			return points;
		}
		let final = [];
		for(i1 = 0; i1 < fineness/4; i1++) {
			let angle = (Math.PI/2)*i1/(fineness/4);
			angle = [
				Math.cos(angle),
				Math.sin(angle)
			];
			let z = angle[1]*scaling*d_scaler;
			let points = [angle[0]*1, angle[0]*1/2, angle[1]*(-1/4)];
			points = bean(...points, fineness, h_squish);
			for(i2 = 0; i2 < points.length; i2++) {
				final[final.length] = [
					scaling*points[i2][0],
					scaling*points[i2][1],
					z
				];
				if(z) {
					final[final.length] = structuredClone(final[final.length - 1]);
					final[final.length - 1][2] *= -1;
				};
			}
		}
		return revolve(Math.PI/2, final, null, "xy");
	};
	slite.eye = class {
		constructor() {
			let ref = slite.eye.template;
			for(let i1 in ref) {
				if(ref.hasOwnProperty(i1)) {
					this[i1] = structuredClone(ref[i1]);
				};
			}
		}
		static template = {
			r: 1,
			corner: {
				l: [-1, 0],
				r: [1, 0],
			},
			top: [
				[-.5, -.5],
				[.5, -.5],
			],
			bottom: [
				[-.5, .5],
				[.5, .5],
			],
			closed: [],
			openness: [1, 1],
			// the way all of these work is:
			// - all points are cast onto a sphere with 1 radius, then
			//   multiplied by .radius.
			//   - if the hypotenuse of any point is above 1, it'll be made
			//     shorter.
			// - corner.l, top, and corner.r form the line the upper lid rests
			//   at
			// - same for bottom
			// - and corner.l, closed, and corner.r form the line the lids rest
			//   at when closed.
			// - openness[0] and openness[1] are numbers for how open the lids
			//   are.
			//   - if it's 1, they're where they are in top/bottom.
			//   - if it's 0, they're at closed.
			//   - if it's -1, they're at the opposite top/bottom.
			//   - anything above 1 or below -1... they just continue in that
			//     direction.
			//   - in other words, higher numbers open it wider, lower closes
			//     them.
			sclera: "white",
			iris: {
				type: "dome",
				r: 2,
			},
			pupil: {
				type: "circle",
				r: 1,
			},
		}
		static spherecast(x, y) {
		// converts x/y coordinates to a 3d angle for where that'd be projected
		// onto a sphere with 1 radius.
			let hypot = Math.hypot(x, y);
			let point = (
				hypot >= 1
				?
				[
					x/hypot,
					y/hypot,
					0
				]
				:
				[
					x,
					y,
					Math.sqrt(1 - x**2 - y**2)
				]
			);
			return Angle.get(...point);
		}
		get shape() {
		// returns the eye shape as a series of xy/z angles representing a
		// closed shape on the surface of the sphere.
		// - you only need to run this when corner, top, bottom, closed, or
		//   openness changes.
			let i1 = 0;
			let i2 = 0;
			let angle = {
				corner: {
					l: slite.eye.spherecast(...this.corner.l),
					r: slite.eye.spherecast(...this.corner.r),
				},
				top: [],
				bottom: [],
				closed: [],
			};
			let place = {
				top: [],
				bottom: [],
				closed: [],
			};
			let temp = ["top", "bottom", "closed"];
			for(i1 = 0; i1 < temp.length; i1++) {
				let _i1 = temp[i1];
				let ref = angles[_i1];
				for(i2 = 0; i2 < this[_i1].length; i2++) {
					ref[i2] = slite.eye.spherecast(...this[_i1][i2]);
					place[_i1][i2] = Angle.compare(ref[i2], i2 ? ref[i2 - 1] : angle.corner.l);
					// radians from this to the previous point
				}
				for(i2 = 1; i2 <= place[_i1].length; i2++) {
					place[_i1][i2] += place[_i1][i2 - 1];
					// radians from the first point to this
				}
				if(place[_i1].length) {
					let total = place[_i1][ place[_i1].length - 1 ] + Angle.compare(ref[ref.length - 1], angle.corner.r);
					// radians from the first point to the last
					for(i2 = 0; i2 <= place[_i1].length; i2++) {
						place[_i1][i2] /= total;
						// 0-1 numbers for where it is from the first point to
						// the last
					}
				}
			}
			function findalongpath(name, num) {
			// findalongpath("top", .5) = "find the halfway point of the top
			// lid's line." (as an angle.)
				for(let i1 = 0; i1 <= place[name].length; i1++) {
					let prev = i1 ? place[name][i1 - 1] : 0;
					let prev_angle = i1 ? angle[name][i1 - 1] : angle.corner.l;
					let next = i1 < place[name].length ? place[name][i1] : 1;
					let next_angle = i1 < place[name].length ? angle[name][i1] : angle.corner.r;
					if(num === prev) {
						return angle[name][i1 - 1];
					}
					else if(num === next) {
						return angle[name][i1];
					}
					else if(num > prev && num < next) {
						return Angle.between(prev_angle, next_angle, (num - prev)/(next - prev));
					};
				}
				console.log("this shouldn't happen");
				return null;
			}
			let shape = [];
			for(i0 = 0; i0 < 2; i0++) {
			// take into account all three lines and the openness numbers to
			// form the shape.
				let array = [];
				let open = this.openness[i0];
				if(open === 0) {
					array = structuredClone(angle.closed);
				}
				else {
					let lid = invertboolean(i0, open < 0) ? "bottom" : "top";
					open = Math.abs(open);
					// run for the top lid, then the bottom lid. if open is
					// negative, draw it as the opposite lid and invert open to
					// match.
					for(i1 = 0; i1 < angle[lid].length; i1++) {
						array[array.length] = Angle.between(findalongpath("closed", place[lid][i1]), angle[lid][i1], open);
					}
				}
				shape[shape.length] = angle.corner["lr"[i0]];
				if(i0) {
					for(i1 = array.length - 1; i1 >= 0; i1--) {
						shape[shape.length] = array[i1];
					}
				}
				else {
					shape = shape.concat(array);
				}
			}
			return shape;
		}
		render() {
			let i1 = 0;
			let i2 = 0;
			let shape = this.shape;
			let points = [];
			for(i1 = 0; i1 < shape.length; i1++) {
				points[i1] = Angle.numbers(shape[i1]);
				points[i1][0] *= this.r;
				points[i1][1] *= this.r;
				points[i1][2] *= this.r;
			}
			let raster = [];
			let w = 2*this.r + 1;
			for(i1 = 0; i1 < w**2; i1++) {
				raster[i1] = 0;
			}
			// make an empty image
			raster = Raster.ellipse(raster, w, 0, 0, 2*this.r, 2*this.r);
			// start with a full circle
			for(i1 = 0; i1 < shape.length; i1++) {
			// find the 2d version of the ellipse, and exclude pixels if they're
			// not inside it.
				let angle1 = shape[i1];
				let angle2 = shape[(i1 + 1)%shape.length];
				let axis = null;
				if(angle1[1] >= 0 || angle2[1] >= 0) {
				// if both points are on the back side, skip it. if only one is,
				// bring it to 0 z.
					axis = Quat.arc(angle1, angle2);
				}
				if(axis) {
				// don't do anything if they're both the same angle
					let magnitude = axis.magnitude;
					axis = axis.axis;
					// arc between them. the ellipse they're both on would be the
					let xy = Angle.numbers(axis).slice(0, 2);
					let minor = Math.hypot(...xy);
					// the radius of the narrowest dimension
					xy = get2dangle(...xy, true) ?? 0;
					// xy angle of that narrowest dimension (null means it's
					// perpendicular to the screen)
					for(i2 = 0; i2 < raster.length; i2++) {
						if(raster[i2]) {
							let x = i2%w - this.r;
							let y = Math.floor(i2/w) - this.r;
							// - minor*this.r = ellipse w
							// - this.r = ellipse h
							// - xy = how much it's rotated
							let temp = [
								Math.cos(-angle),
								Math.sin(-angle)
							];
							x = x*temp[0] - y*temp[1];
							y = x*temp[1] + y*temp[0];
							// "complex number" rotation
							// - (x, y), angle
							// - (x + y*i)*(cos(angle) + sin(angle)*i)
							// - (x*cos - y*sin) + (x*sin + y*cos)*i
							// - x = x*cos - y*sin, y = x*sin + y*cos
							// - somehow.
							// =
							// - you can tell if it's inside by rotating it by
							//   negative xy, and seeing if it's inside the
							//   unrotated version of the ellipse
							x /= minor;
							if(Math.hypot(x, y) > 1) {
								raster[i2] = 0;
							};
							// which can be done more simply by dividing x by minor
							// and checking if the hypotenuse is within this.r.
						}
					}
				};
			}
			// convert from angles to coordinates, multiply by radius
		}
	};
	slite.face = class {
		constructor() {
			let ref = slite.face.template;
			for(let i1 in ref) {
				if(ref.hasOwnProperty(i1)) {
					this[i1] = structuredClone(ref[i1]);
				};
			}
		}
		static template = {
			cranium: {
				w: 32,
				h: 28,
				d: 28,
				xz: 2*Math.PI*11/12,
				// how much to rotate it in the xz plane.
				// - when viewing the head from the left, positive is clockwise,
				//   negative is counterclockwise.
				// - the w/h/d numbers apply *after* rotation. the box the
				//   spheroid fits in will have the same dimensions no matter
				//   what this angle is.
				fineness: 4,
				// 8 would better fit the resolution, and it wouldn't break the
				// bank either... but i think a flatter and sharper spheroid is
				// closer to a real head than a rounder one.
			},
			mouth: {
				column: {
				// data for the rigid, skeletal parts of the mouth area.
				// - the properties define the position and dimensions of
				//   several half-ellipses.
				// - properties are cumulative. if an area's y is 4, that means
				//   that half-ellipse is 4 below the previous half-ellipse.
				// - if a property is missing, it uses 0.
				// - i recommend giving toptop more w and d than start. that
				//   emulates the maxilla better.
					start: {
					// where the cranium ends and the gums begin.
						y: 10,
						z: -1,
						// NOTE: these are relative to the center of the
						// cranium.
						w: 16,
						d: 16,
					},
					toptop: {
						y: 4,
						w: 2,
						d: 1,
					},
					topbottom: {
						y: 4,
					},
					// the top and bottom of the top row of teeth.
					bottomtop: {
						y: 4,
					},
					bottombottom: {
						y: 4,
					},
					// the bottom row of teeth
					end: {
						y: 4,
						w: -2,
						d: -1,
					},
					// chin
				},
				column_fineness: 16,
				// number of sides those half-ellipses have
				fineness: 16,
				// number of sides the mouth curve has (or one half of it
				// anyway. remember that it folds onto itself when closed.)
				fulcrum: {
					y: 0,
					z: 0,
				},
				// where the fulcrum of the jaw is, relative to the center of
				// the cranium.
			},
			convex: [],
			// points that are added to the main head shape. concave features
			// won't show. (put cheekbones and stuff in here.)
			concave: {
			// shapes that are drawn as part of the head, but in a way that
			// allows for concave features. (for example, if you put the nose
			// and ear shapes in .convex... it'll just look like they're wearing
			// a skintight bag over their head.)
				nose: {
					points: [],
				},
				ear: {
					points: [],
				},
			},
		}
		render() {
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let ref = this.cranium;
			let temp = Quat.new("xy", Math.PI/2);
			if(ref.xz) {
				temp = Quat.rotate(temp, "xz", ref.xz);
			};
			let shape = addspheroids([[0, 0, 0, ref.w, ref.h, ref.d, temp]], ref.fineness ?? 4);
			if(ref.xz) {
				temp = {
					h: Math.hypot(
						ref.d*Math.cos(-ref.xz + Math.PI/2),
						ref.h*Math.sin(-ref.xz + Math.PI/2)
					),
					d: Math.hypot(
						ref.d*Math.cos(-ref.xz),
						ref.h*Math.sin(-ref.xz)
					),
				};
				// this should be the new h and d after rotation, so divide all
				// y/z coordinates by these.
				for(i1 = 0; i1 < shape.length; i1++) {
					shape[i1][1] /= temp.h;
					shape[i1][2] /= temp.d;
				}
			}
			shape = shape.concat(shape.convex);
			// add cheekbones and stuff
			let jaw = [];
			// array of points that get rotated with the jaw
			ref = this.mouth.column;
			let column = {};
			temp = [
				"start",
				"toptop",
				"topbottom",
				"bottomtop",
				"bottombottom",
				"end"
			];
			if(
				(ref.start ?? null) === null
				||
				(ref.start.w ?? null) === null
				||
				(ref.start.d ?? null) === null
			) {
			// this is probably an accident, since it would mean a curve with
			// zero w or d
				console.log(".column.start is incomplete.");
				return;
			}
			for(i1 = 0; i1 < temp.length; i1++) {
				let _i1 = temp[i1];
				if(i1 === 0) {
					column[_i1] = structuredClone(ref[_i1]);
					column[_i1].y ??= 0;
					column[_i1].z ??= 0;
				}
				else {
					column[_i1] = structuredClone(column[temp[i1 - 1]]);
					// clone the previous level
					for(i2 = 0; i2 < 4; i2++) {
						column[_i1]["yzwd"[i2]] += ref[_i1]["yzwd"[i2]] ?? 0;
					}
				};
				for(i2 = 0; i2 <= this.mouth.column_fineness; i2++) {
				// get the points of the half-ellipse
					let angle = Math.PI*i2/this.mouth.column_fineness;
					let point = [
						Math.cos(angle)*column[_i1].w/2,
						column[_i1].y,
						column[_i1].z + Math.sin(angle)*column[_i1].d
					];
					if(i1 >= temp.length/2) {
						jaw[jaw.length] = structuredClone(point);
					}
					else {
						shape[shape.length] = structuredClone(point);
					}
				}
			}
			// now column is a copy of this.column, except complete
		}
	}
	slite.expression = class {
		constructor() {

		}
		static template = {
			jaw: {
				yz: 0,
				xz: 0,
			},
			// how much the jaw is opened, measured in radians
			mimetics: {
			// i don't know anything about mimetic muscles except that the word
			// is fun to say and basing variables off of those muscles would be
			// complicated and unintuitive. instead, how this works is that for
			// every push and pullable feature, there's an array of "drag this
			// point here" actions.
				mouth: [],
			},
		}
	};
	suite.test = new ProcAnim();
	suite.test.initB = function() {
	// initialize variables, ctxsettings, and animations
		let v = this.v;
		let u = v.u;
		let ctx = v.ctxsettings.new;
		v.pos ??= [u.w/2, u.h/2, -u.w/2];
		//v.variablename ??= 0;
		// - use ??= so that you don't overwrite the parent ProcAnim
		//   having set this already in initA
		let i1 = 0;
		let i2 = 0;
		this.revolvingrings = suite.revolvingrings;
		this.revolvingrings.initA(u, v.duration);
		this.shimmershape = suite.shimmershape;
		this.shimmershape.initA(u, v.duration);
		v.shape2d = new Shape2d([
			{
				x: -1,
				y: .5,
				elbow: {
					direction: "l",
				},
			},
			{
				x: -.5,
				y: -.5,
			},
			{
				x: 1,
				y: -.5,
				elbow: {
					direction: "in",
				},
			},
			{
				x: 0,
				y: .5,
				elbow: {
					x: -.5,
					y: 1.5,
				},
			},
		], true);
		v.shape2d.modcoordinates({multiply: [u.w/4, u.h/4]});
		this.polaris = suite.polaris;
		this.polaris.initA(u, v.duration);
		this.starblast = suite.starblast;
		this.starblast.initA(u, v.duration);
		ctx.strokeStyle = "white";
		this.rhythmicshine = suite.rhythmicshine;
		this.rhythmicshine.initA(u, v.duration);
		if((v.shape ?? null) === null) {
			v.shape = build3dshape("cube", Math.min(u.w, u.h)/2);
			let i1 = 0;
			for(i1 = 0; i1 < 6; i1++) {
				v.shape.faces[i1].fill = ["red", "orange", "yellow", "green", "blue", "purple"][i1];
			}
			v.shape = polysubdivide(v.shape, 4);
			for (i1 = 0; i1 < v.shape.faces.length; i1++) {
				if(v.shape.faces[i1].hasOwnProperty("hide")) {
					//delete v.shape.faces[i1].hide;
				};
			}
			v.shape.faces[0].stroke = "white";
		}
		//
		v.dithers = [];
		let numofdithers = 3;
		// NOTE don't make this higher than the number of distinct period.xs
		// there are in dithers.
		let periods = [];
		let lcd = 1;
		let log = [];
		v.dithers[0] = {
			dither: "carpet",
			invert: Math.random() < .5,
			speed: 1,
			color: "white",
		};
		for(i1 = v.dithers.length; i1 < numofdithers; i1++) {
			let temp = structuredClone(Object.keys(dithers));
			let dithername = randomarrayitem(temp);
			let period = (dithers[dithername].hasOwnProperty("period") ? dithers[dithername].period.x : 0);
			for(i2 = 0; (dithername !== "none" || dithername.startsWith("noise ") || lcd%period === 0) && i2 < 1000; i2++) {
				dithername = randomarrayitem(temp);
				period = (dithers[dithername].hasOwnProperty("period") ? dithers[dithername].period.x : 0);
			};
			periods[periods.length] = period;
			lcd = mathlcd(periods);
			let speed = (i1 === 0 ? 1 : v.dithers[i1 - 1].speed + 1);
			if(speed !== 1 && period && period%speed === 0) {
			// if it folds evenly into period.x, add to it until it doesn't
				for(; period%speed === 0 && speed < 1000; speed++) {
				}
			}
			v.dithers[i1] = {
				dither: dithername,
				invert: Math.random() < .5,
				speed,
				color: "white",
			};
			log[i1] = (v.dithers[i1].invert ? "inverted " : "") + v.dithers[i1].dither + " (" + v.dithers[i1].speed + ")";
		}
		//console.log(log.join(String.fromCharCode(10)));
		//
		//v.start_func = "circle";
		//v.start_args = [v.pos[0], v.pos[1], u.w/4, "lopsided"];
		//v.start_func = "point";
		//v.start_args = [v.pos[0], v.pos[1]];
		v.start_func = "circle";
		v.start_args = [v.pos[0], v.pos[1], u.w/8, "inside"];
		//v.start_func = "rect";
		//v.start_args = [u.w*3/8, u.h*3/8, u.w/4, u.h/4];
		v.fire = slite.walkers.create(u.w, u.h, v.start_func, v.start_args, null, null, ["direct", Math.PI*3/2]);
		//v.colorfunc = null;
		//v.colorfunc = (num) => "rgb(" + [16*num, 16*num, 16*num].join() + ")";
		//v.colorfunc = (num) => "rgb(" + [Math.max(0, 192 - 12*num), 191 - Math.min(64, 4*num), 191 + Math.min(64, 4*num)].join() + ")";
		//v.colorfunc = (num) => "rgb(" + [Math.min(191, 12*num), 127 + Math.min(64, 4*num), 255 - Math.min(64, 4*num)].join() + ")";
		v.colorfunc = (num) => (num > 8 ? "white" : "cornflowerblue");
		//
		v.cardioid = [];
		for(i1 = 0; i1 < v.duration; i1++) {
			//let coor = slite.spiro(i1/v.duration, [2, 1], [1, 1/2]);
			// cardioid
			let coor = slite.spiro(i1/v.duration, [1, 1], [1/7, 1]);
			coor[2] = 0;
			coor = revolve(Math.PI/2, coor, null, "xy");
			v.cardioid[i1] = [
				(coor[0]*u.w/8) + u.w/2,
				(coor[1]*u.w/8) + u.h/2,
			];
		}
		v.trace = v.duration;//3;
		// number of points it connects at once
		v.tunnel = {spacing: u.w/8, rings: 1};//64};
		// spacing is what it subtracts from z, rings is how many it draws
		//u.viewer.y = u.h*-2/8;
		v.pulse = {
			wavetype: "sine",
			size: 3/2,//1,
			z: v.tunnel.spacing*1,//22/7,
			rhythm: "o---------------",
			duration: 8,
			cutoff: 1,
			invert: true,
			magnitude: [],
		};
		// works like this:
		// - wave() is used to get a number.
		//   - wavetype is whether it's sine or saw or what
		//   - this is run separately for size and z. size is used as a
		//     multiplier for the points' distance from the center, and z is
		//     added to z
		//   - duration is how long one wave is. the frame number is divided by
		//     that.
		// - rhythm is used to determine when a pulse happens. the pulse isn't
		//   an uninterrupted wave, it's a single wave, equilibrium to crest to
		//   etc trough etc equilibrium.
		// - and cutoff cuts that off. so you can make it only go to the halfway
		//   point, and never drop below equilibrium.
		// - magnitude is an array created ahead of time for every frame. works
		//   like v.cardioid, it's more efficient to calculate it ahead of time.
		//   - each item is itself an array: the size, and the z. (for technical
		//     reasons they have to be separate. size compounds through
		//     multiplication, z through addition)
		// - invert inverts the movement of the waves
		for(i1 = 0; i1 < v.duration; i1++) {
			v.pulse.magnitude[i1] = {size: 1, z: 0};
		};
		for(i1 = 0; i1 < v.duration; i1++) {
			let rhythm = rhythmat(v.pulse.rhythm, i1);
			// rhythm is kind of stupid and i need to rehaul it, but for right
			// now, it's enough.
			if(rhythm.toUpperCase() !== rhythm.toLowerCase()) {
			// note on this frame: a wave starts
				for(i2 = 0; i2 < v.pulse.duration; i2++) {
					let frame = (i1 + i2)%v.duration;
					//let frame = posmod(i1 - i2, v.duration);
					let place = i2/v.pulse.duration;
					if(place <= v.pulse.cutoff) {
						let temp = wave(place, v.pulse.wavetype);
						if(temp > 0) {
							v.pulse.magnitude[frame].size *= temp*v.pulse.size + (1 - temp)*1;
						}
						else if(temp < 0) {
							v.pulse.magnitude[frame].size *= -temp*1/v.pulse.size + (1 - -temp)*1;
						}
						else if(temp !== 0) {
							console.log("this shouldn't happen");
						}
						v.pulse.magnitude[frame].z += wave(place, v.pulse.wavetype, 0, v.pulse.z);
					};
				}
			};
		};
		//console.log(v.pulse.magnitude);
		v.wavemod = (input, frame) => [
		// modifies coordinates based on the magnitude array of the given frame.
			(input[0] - v.pos[0])*v.pulse.magnitude[frame].size + v.pos[0],
			(input[1] - v.pos[1])*v.pulse.magnitude[frame].size + v.pos[1],
			input[2] + v.pulse.magnitude[frame].z
		];
		// TODO
		// - split this up into spirograph-drawing code and pulsating tunnel
		//   code
		// - make it smoother, have it define multiple points per frame
		//
		v.blob = [];
		v.bloblength = 4;
		for(i1 = 0; i1 < v.duration; i1++) {
			let temp = easing(i1/v.duration, "in/out", "cube");
			temp = (temp * 1/2) + ((i1/v.duration) * 1/2);
			v.blob[i1] = slite.cardioidblob("getdata", temp, v.pos[0], v.pos[1], u.w/8);
			v.blob[i1][ v.blob[i1].length ] = i1;
		};
		//
		v.star = slite.star.create(u.w/2, u.h/2, u.w/4, 5, 3*Math.PI/2);
		//
		v.average = 0;
		//
		ctx.fillStyle = "black";
		ctx.strokeStyle = "white";
		v.initialized = true;
	};
	suite.test.func = function(frame) {
		let i1 = 0;
		let i2 = 0;
		let i3 = 0;
		// this isn't related to ProcAnim, but forgetting i numbers can
		// cause a lot of trouble.
		let v = this.v;
		let u = v.u;
		let ctx = u.ctx;
		// for easy reference
		let exit = this.framestart(frame);
		if(exit) {
			return;
		};
		//
		/*
		if(frame === 0) {
			v.sphere = perfectsphere(5);
		}
		let sphere = revolve(2*Math.PI*frame/v.duration, v.sphere, null, "xz");
		sphere.sort((a, b) => a[2] - b[2]);
		for(i1 = 0; i1 < sphere.length; i1++) {
			let point = sphere[i1];
			let num = Math.round(255*(v.sphere[i1][2] + 1)/2);
			ctx.fillStyle = "rgb(255, " + num + ", 0)";
			ctx.fillRect(
				v.pos[0] + Math.trunc(point[0]*u.w/3) - 1,
				v.pos[1] + Math.trunc(point[1]*u.h/3) - 1,
				3, 3
			);
		}
		//*/
		/*
		if(frame === 0) {
			let scene = RoundScene.shirt(u.w/4);
			scene.lamps.push(new TriLamp(0, -u.h/2, -u.w/2, 1, 1, 1));
			scene.render(ctx);
		}
		//*/
		/*
		if(frame === 0) {
			v.walkers = new WalkerSet();
		}
		let spawn = 32;
		// number to delete/create every frame
		let stabilize = 128;
		// only delete if the population is higher than this
		v.walkers.append("sphere", [...v.pos, u.w/4], spawn);
		// generate new walkers
		let distfromcenter = (walker) => Math.hypot(...Points.subtract(Points.convert(walker), v.pos));
		v.walkers.sort((a, b) => distfromcenter(a) - distfromcenter(b));
		if(v.walkers.length > stabilize) {
		// get rid of the furthest walkers
			let temp = v.walkers.length - stabilize;
			v.walkers.splice(v.walkers.length - temp, temp);
		}
		for(i1 = 0; i1 < v.walkers.length; i1++) {
		// rise upward, further the closer it was to the center (counteracts
		// the way condense makes everything collapse into the center)
			let rise = Points.convert(v.walkers[i1]);
			rise = Math.hypot(...Points.subtract(rise, v.pos));
			rise /= 2*v.walkers.mediandist(v.pos);
			rise = mound(rise);
			rise *= 32;
			v.walkers[i1].velocity.y -= rise;
		}
		v.walkers.direct("angle", null, 4);
		// move back and forth a little
		v.walkers.process();
		// move
		v.walkers.condense(3, v.pos);
		v.walkers.draw(ctx, 0, 0, 0, 0, u.w, u.h, (list) => (
			list.length
			?
			"rgb(255, " + Math.min(Math.floor(list.length*255/4), 255) + ", 0)"
			:
			null
		));
		//*/
		/*
		if(frame === 0) {
			v.log = [];
		}
		let average_x = 0;
		let prev_x = null;
		let prev_y = null;
		let r = u.w/4;
		ctx.strokeStyle = "white";
		for(i1 = 0; i1 <= frame; i1++) {
			let angle = Math.PI*i1/(v.duration - 1);
			let x = r*Math.cos(angle);
			let y = r*Math.sin(angle);
			average_x += x;
			if(prev_x !== null && prev_y !== null) {
				for(i2 = 0; i2 < 2; i2++) {
					linespecial(ctx,
						v.pos[0] + prev_x,
						v.pos[1] + prev_y*(i2 ? -1 : 1),
						v.pos[0] + x,
						v.pos[1] + y*(i2 ? -1 : 1),
					v.pos.slice(0, 2));
				}
			};
			//
			prev_x = x;
			prev_y = y;
		}
		average_x /= frame + 1;
		v.log[v.log.length] = average_x;
		for(i1 = 0; i1 < v.log.length; i1++) {
			ctx.fillRect(v.pos[0] + v.log[i1], v.pos[1] + (v.log.length - 1) - i1, 1, 1);
		}
		ctx.fillStyle = "green";
		*/
		/*
		console.log([
			frame,
			average_x/r,
			Math.asin(frame/(v.duration - 1))/Math.PI,
			Math.acos(frame/(v.duration - 1))/Math.PI
		]);
		function randmove(mode) {
			let x = 0;
			let y = 0;
			if(mode === "eight") {
				let dir = Math.floor(Math.random()*8);
				if(dir%2 === 0) {
					//dir = Math.floor(Math.random()*8);
				};
				// 567
				// 4 0
				// 321
				if([5, 6, 7].includes(dir)) {
					y--;
				}
				else if([3, 2, 1].includes(dir)) {
					y++;
				};
				if([5, 4, 3].includes(dir)) {
					x--;
				}
				else if([7, 0, 1].includes(dir)) {
					x++;
				};
			}
			else if(mode === "four") {
				if(Math.random() < .5) {
					x = Math.random() < .5 ? -1 : 1;
				}
				else {
					y = Math.random() < .5 ? -1 : 1;
				};
			}
			else if(mode === "knight") {
				let angle = Math.floor(Math.random()*8);
				let temp = angle%4;
				temp = temp === 1 || temp === 2;
				x = temp ? 2 : 1;
				y = temp ? 1 : 2;
				if(angle%8 < 4) {
					x *= -1;
				};
				if((angle + 6)%8 < 4) {
					y *= -1;
				};
			}
			else if(mode === "diagonal") {
				x += Math.random() < .5 ? -1 : 1;
				y += Math.random() < .5 ? -1 : 1;
			}
			else if(mode === "hex") {
				let temp = Math.random() < 1/3;
				x = temp ? 0 : 2;
				y = temp ? 2 : 1;
				if(Math.random() < .5) {
					x *= -1;
				};
				if(Math.random() < .5) {
					y *= -1;
				};
			}
			else if(typeof mode === "number") {
				let angle = 2*Math.PI*Math.random();
				x = Math.trunc(Math.cos(angle)*mode);
				y = Math.trunc(Math.sin(angle)*mode);
			}
			else {
				if(typeof mode === "string" && mode.includes(":")) {
					mode = mode.split(":").slice(0, 2);
					mode = [
						Number(mode[0]),
						Number(mode[1])
					];
					if(
						mode[0] >= 0 && Number.isInteger(mode[0])
						&&
						mode[1] >= 0 && Number.isInteger(mode[1])
					) {
						if(Math.random() < .5) {
							x = mode[0];
							y = mode[1];
						}
						else {
							x = mode[1];
							y = mode[0];
						};
						if(Math.random() < .5) {
							x *= -1;
						};
						if(Math.random() < .5) {
							y *= -1;
						};
					};
				}
			}
			return {x, y};
		};
		if(frame === 0) {
			let numofwalkers = 64;
			v.walkers = [];
			for(i1 = 0; i1 < numofwalkers; i1++) {
				v.walkers[i1] = {x: v.pos[0], y: v.pos[1], colornum: Math.floor(Math.random()*3)};
				if(Math.random() < .5) {
				// adjustment for diagonal mode (so it doesn't look
				// checkerboard-y)
					let temp = randmove("four");
					v.walkers[i1].x += temp.x;
					v.walkers[i1].y += temp.y;
				};
			}
			v.data = {};
			// indexed by x position, then y position, value is how many times a
			// walker walked over it
			v.reproduction = 4;
			// modifies the odds of a walker duplicating on any given frame.
			// it's measured as what the population should be multiplied by by
			// the end.
		}
		let mode = "knight";
		// used in randmove
		let multiply = 1;
		// randmove is multiplied by a random number from 1 to this
		let decrement = .5;
		// after being drawn, pixels are decremented by this (and removed if
		// they reach 0)
		let reproduction = v.reproduction**(1/v.duration) - 1;
		// - end population = [start population] * (1 + [individual reproduction
		//   chance])**v.duration
		// - reproduction = (1 + [individual reproduction chance])**v.duration
		// - how did logarithms work again?
		//   - a**b = c, Math.log(c) / Math.log(a) = b
		//   - no, what i need here is the [duration] root of v.reproduction
		//   - which is reproduction ** (1/duration)
		// - individual reproduction chance = reproduction**(1/v.duration) - 1
		for(i1 = 0; i1 < v.walkers.length; i1++) {
		// advance walkers
			let ref = v.walkers[i1];
			if(Math.random() < reproduction) {
				v.walkers.splice(i1 + 1, 0, structuredClone(ref));
				//let temp = randmove("four");
				//v.walkers[i1 + 1].x += temp.x;
				//v.walkers[i1 + 1].y += temp.y;
			};
			let temp = randmove(mode);
			let _multiply = 1 + Math.floor(Math.random()*multiply);
			ref.x += temp.x*_multiply;
			ref.y += temp.y*_multiply;
			v.data[ref.x] ??= {};
			v.data[ref.x][ref.y] ??= 0;
			//v.data[ref.x][ref.y] = Math.floor(v.data[ref.x][ref.y]) + 1 + ref.colornum/10;
			v.data[ref.x][ref.y]++;
		}
		for(i1 in v.data) {
			if(v.data.hasOwnProperty(i1)) {
				for(i2 in v.data[i1]) {
					if(v.data[i1].hasOwnProperty(i2)) {
						let temp = [255, 255, 255];
						//temp[Math.round((v.data[i1][i2]%1)*10)] = Math.min(Math.floor(v.data[i1][i2])*16, 255);
						temp[Math.floor(Math.random()*3)] = Math.min(v.data[i1][i2]*16, 255);
						ctx.fillStyle = "rgb(" + temp.join(", ") + ")";
						//ctx.fillStyle = "rgb(255, " + Math.min(v.data[i1][i2]*16, 255) + ", 0)";
						ctx.fillRect(Number(i1), Number(i2), 1, 1);
						v.data[i1][i2] -= decrement;
						if(v.data[i1][i2] <= 0) {
							delete v.data[i1][i2];
						}
					}
				}
			}
		}
		//*/
		/*
		if(frame === 0) {
			let directions = "672067212364236035701756531453114107054605434174207602124632467";
			let x = 4;
			let y = 0;
			let w = 8;
			let h = 8;
			v.order = [];
			for(i1 = 0; i1 < directions.length; i1++) {
				v.order[i1] = w*y + x;
				let angle = Number(directions[i1]);
				let temp = angle%4;
				temp = temp === 1 || temp === 2;
				let _x = temp ? 2 : 1;
				let _y = temp ? 1 : 2;
				if(angle%8 < 4) {
					_x *= -1;
				};
				if((angle + 6)%8 < 4) {
					_y *= -1;
				};
				x += _x;
				y += _y;
				if(x < 0 || x >= w || y < 0 || y >= h) {
					console.log("this shouldn't happen");
					x = 0;
					y = 0;
				}
			}
			v.order[v.order.length] = w*y + x;
			v.pattern_w = w;
			v.pattern_h = h;
		}
		let w = v.pattern_w;
		let h = v.pattern_h;
		let frameskip = 1;
		let array = [];
		for(i1 = 0; i1 < w*h; i1++) {
			array[i1] = false;
		}
		for(i1 = 0; i1 < frameskip*frame && i1 < v.order.length; i1++) {
			array[v.order[i1]] = true;
		}
		ctx.fillStyle = "white";
		for(i1 = 0; i1 < u.w; i1 += w) {
			for(i2 = 0; i2 < u.h; i2 += h) {
				for(i3 = 0; i3 < array.length; i3++) {
					if(array[i3]) {
						ctx.fillRect(i1 + i3%w, i2 + Math.floor(i3/w), 1, 1);
					}
				}
			}
		}
		//*/
		/*
		if(frame === 0) {
		// trying to make an effect like the stuff in street fighter alpha when
		// you win with a super. it kinda sucks though.
		// - square works but it's as underwhelming as i expected
		//   - maybe i could randomize the value of each sector?
		// - tri looks like an incoherent blob. not sure if i screwed up or if
		//   that's just how it turns out
		// - saw looks wrong. i don't know where the spiralling comes from,
		//   shouldn't it just be a radial gradient?
		// - and i'm not interested enough to fix any of it.
			v.type = ["square", "tri", "saw"][0];
			v.density = 16;
			//v.density = 1 + Math.floor(randexponent(2)*32);
			v.contrast = u.w/2;
			v.colorfunc = (num) => "rgb(" + (Math.floor(wave(num/2, "tri")*255) + ", ").repeat(1) + "255, 255)";
			v.speed = 1;
			// measured in how many cycles it goes through by the end
			v.wavewidth = u.w/2;
			//
			v.breaks = [];
			for(i1 = 0; i1 < v.density; i1++) {
				v.breaks[i1] = Math.random();
			}
			if(v.breaks%2 && (v.type === "square" || v.type === "tri")) {
				v.breaks[v.breaks.length] = Math.random();
			}
			v.breaks.sort((a, b) => a - b);
			// an array of 0-1 numbers for where to place turning points
			v.values = null;
			if(v.type === "tri") {
				let start = Math.floor(Math.random()*v.breaks.length);
				let negative = Math.random() < .5;
				let value = 0;
				v.values = [];
				for(i1 = 0; i1 < v.breaks.length; i1++) {
				// the relationship of angle difference to value difference is
				// totally linear, and always the same slope.
					let _i1 = (start + i1)%v.breaks.length;
					v.values[_i1] = value;
					negative = !negative;
					value += (negative ? -1 : 1)*(
						_i1 === v.breaks.length - 1
						?
						1 - v.breaks[_i1] + v.breaks[0]
						:
						v.breaks[_i1 + 1] - v.breaks[_i1]
					);
				}
			}
			function angletovalue(angle) {
				let num = angle/(2*Math.PI);
				let prevbreak = null;
				let nextbreak = null;
				let difference = null;
				let place = null;
				if(num < v.breaks[0] || num >= v.breaks[v.breaks.length - 1]) {
					prevbreak = v.breaks.length - 1;
					nextbreak = 0;
					difference = 1 - v.breaks[v.breaks.length - 1] + v.breaks[0];
					if(num < v.breaks[0]) {
						place = (1 - v.breaks[prevbreak] + num)/difference;
					}
					else if(num >= v.breaks[prevbreak]) {
						place = (num - v.breaks[prevbreak])/difference;
					};
				}
				for(let i1 = 0; i1 < v.breaks.length - 1; i1++) {
					if(num >= v.breaks[i1] && num < v.breaks[i1 + 1]) {
						prevbreak = i1;
						nextbreak = i1 + 1;
						difference = v.breaks[i1 + 1] - v.breaks[i1];
						place = (num - v.breaks[i1])/difference;
					}
				}
				if(prevbreak === null) {
					console.log("this shouldn't happen");
					return;
				};
				return (
					v.type === "square" ? (prevbreak%2)/2 :
					v.type === "tri" ? (v.values[prevbreak] + place*(v.values[nextbreak] - v.values[prevbreak])) :
					v.type === "saw" ? place :
					null
				);
			}
			v.pixels = [];
			let angle_values = {};
			for(i1 = 0; i1 < u.w; i1++) {
				v.pixels[i1] = [];
				for(i2 = 0; i2 < u.h; i2++) {
					let temp = get2dangle(
						i1 - v.pos[0],
						i2 - v.pos[1],
						true
					);
					temp = typeof temp === "string" ? 0 : temp;
					angle_values[temp] ??= angletovalue(temp);
					v.pixels[i1][i2] = angle_values[temp];
				}
			}
			// for some reason, looking at v.angle_values in the console crashes
			// firefox.
			// - maybe just from the sheer number of properties. 65536 minus any
			//   groups of pixels with the same angle.
			//   - come to think of it, when you open a really big array, it
			//     breaks it up into 100-item chunks. there's no convenient way
			//     to do that for objects...
		}
		for(i1 = 0; i1 < u.w; i1++) {
			for(i2 = 0; i2 < u.h; i2++) {
				let dist = Math.hypot(i1 - v.pos[0], i2 - v.pos[1]);
				temp = v.pixels[i1][i2] + frame/(v.duration/v.speed) - (dist/v.wavewidth);
				temp = posmod(temp, 1);
				ctx.fillStyle = v.colorfunc(temp);
				ctx.fillRect(i1, i2, 1, 1);
			}
		}
		//*/
		/*
		if(frame === 0) {
			v.ants = [];
			for(i1 = 0; i1 < 64; i1++) {
				v.ants[i1] = [
					Math.floor(Math.random()*u.w),
					Math.floor(Math.random()*u.h)
				];
			}
			ctx.fillStyle = "white";
		}
		const speed = 1.5;
		for(i1 = 0; i1 < v.ants.length; i1++) {
			ctx.fillRect(Math.floor(v.ants[i1][0]), Math.floor(v.ants[i1][1]), 1, 1);
			let dir = Math.min(Math.random(), Math.random());
			if(Math.random() < .5) {
				dir *= -1;
			};
			dir = posmod(1 + dir, 4);
			dir *= Math.PI/2;
			v.ants[i1][0] = posmod(v.ants[i1][0] + speed*Math.cos(dir), u.w);
			v.ants[i1][1] = posmod(v.ants[i1][1] + speed*Math.sin(dir), u.h);
		};
		// trying to emulate ant movement. i don't think i did very well.
		// - it kinda resembles snow though.
		//*/
		/*
		if(frame === 0) {
			const w = 8;
			const h = 8;
			v.points = [];
			for(i1 = -(w - 1)/2; i1 <= (w - 1)/2; i1++) {
				for(i2 = -(h - 1)/2; i2 <= (h - 1)/2; i2++) {
					v.points[v.points.length] = {
						x: i1,
						y: i2,
					};
				}
			}
			v.points.sort((a, b) => get2dangle(a.x, a.y) - get2dangle(b.x, b.y));
		}
		const dim = 32;
		const traillength = 8;//v.points.length;
		for(i1 = 0; i1 < Math.min(traillength, v.points.length); i1++) {
			let temp = 255//Math.round(255*i1/traillength);
			ctx.fillStyle = "rgb(" + temp + ", " + temp + ", " + temp + ")";
			let point = v.points[(frame + i1)%v.duration];
			ctx.fillRect(
				v.pos[0] + point.x*dim - dim/2,
				v.pos[1] + point.y*dim - dim/2,
				dim,
				dim
			);
		}
		// i thought this would look weirder.
		//*/
		/*
		let offset = frame/v.duration;
		offset = easing(offset, "out", "sine");
		offset *= 2*2*Math.PI;
		offset = [
			2*Math.cos(offset),
			2*Math.sin(offset)
		];
		let rings = 32;
		ctx.strokeStyle = "white";
		for(let i0 = 0; i0 < 2; i0++) {
			if(i0 === 0) {
				ctx.translate(offset[0], offset[1]);
			}
			else if(i0 === 1) {
				ctx.translate(-2*offset[0], -2*offset[1]);
			};
			for(i1 = 0; i1 < rings; i1 += 2) {
				circledraw(ctx, v.pos[0], v.pos[1], i1);
			}
		}
		ctx.translate(offset[0], offset[1]);
		//*/
		/*
		if(frame === 0) {
			let colors = Color.palette(ctx);
			//(ctx, a, b, c, skin, outline, wildcard)
			let square_w = 48;
			for(i1 = 0; i1 < colors.length; i1++) {
				let x = i1%4;
				let y = Math.floor(i1/4);
				x = v.pos[0] + square_w*(x - 2);
				y = v.pos[1] + square_w*(y - 2);
				ctx.fillStyle = colors[i1];
				ctx.clearRect(x, y, square_w, square_w);
				ctx.fillRect(x, y, square_w, square_w);
			}
		}
		//*/
		/*
		if(frame === 0) {
		// going for something like the herringbone brick pattern
			v.h = [
				Math.sin(3/5*Math.PI/2),
				Math.sin(1/5*Math.PI/2),
				Math.sin((-1/5)*Math.PI/2),
				Math.sin((-3/5)*Math.PI/2)
			];
			// important heights used
			v.legs = 6;
			// number of legs
			const fineness = 64;
			let y = [
				v.h[0],//-1,
				v.h[0],
				v.h[2]
			];
			let xz = [
				1/v.legs,//null,
				1,
				1/v.legs
			];
			// these are used to create points. (xz is 0 to 1 numbers turned
			// into angles turned into cos/sin.) it forms a partial outline
			// that, when duplicated, will be the tesselation we need.
			// this outline, when duplicated, will be the tesselation we need
			// - because it's easier,
			function processleg(y, xz) {
			// converts it from corners/intersections to enough points to
			// actually look like it's projected onto a sphere.
				let points = [];
				let cos = (num) => Math.cos(2*Math.PI*num);
				let sin = (num) => Math.sin(2*Math.PI*num);
				let leg = [];
				for(let i1 = 0; i1 < y.length; i1++) {
					let temp = Math.cos(Math.asin(y[i1]));
					// cosine for whatever angles would create the given y.
					// makes sure it's projected like a sphere, not a cylinder.
					leg[i1] = [
						xz[i1] ? temp*cos(xz[i1]) : 0,
						y[i1],
						xz[i1] ? temp*sin(xz[i1]) : 0
					];
				}
				for(let i1 = 0; i1 < leg.length - 1; i1++) {
					let prev = leg[i1];
					let next = leg[i1 + 1];
					let axis = Plane.frompoints([
						[0, 0, 0],
						prev,
						next
					]).line().angle;
					let magnitude = Angle.compare(
						Angle.get(...prev),
						Angle.get(...next)
					);
					// not sure which direction it's in yet
					let temp = [
						Quat.apply(Quat.new(axis, magnitude), prev),
						Quat.apply(Quat.new(axis, posmod(2*Math.PI - magnitude, 2*Math.PI)), prev)
					];
					magnitude *= (
						Math.hypot(
							temp[1][0] - next[0],
							temp[1][1] - next[1],
							temp[1][2] - next[2]
						)
						<
						Math.hypot(
							temp[0][0] - next[0],
							temp[0][1] - next[1],
							temp[0][2] - next[2]
						)
						?
						// means the inverted version was closer (but -180 to 180
						// angles are easier to divide than 0 to 360 angles)
						-1
						:
						1
					);
					let _fineness = Math.ceil(fineness * magnitude/(2*Math.PI));
					// vanilla fineness is how many sides a circle has, this is
					// how many sides the arc has
					points[points.length] = structuredClone(prev);
					for(let i2 = 1; i2 < _fineness; i2++) {
						let _magn = posmod(magnitude*i2/_fineness, 2*Math.PI);
						points[points.length] = Quat.apply(Quat.new(axis, _magn), prev);
					}
				}
				points[points.length] = leg[leg.length - 1];
				return points;
			}
			v.points = [];
			v.points[0] = processleg(y, xz);
			// each index of points is a group of points, representing an
			// unclosed shape.
			y = [
				v.h[3],//1,
				v.h[3],
				v.h[1]
			];
			xz = [
				1.5/v.legs,//null,
				.5/v.legs,
				1.5/v.legs
			];
			v.points[1] = processleg(y, xz);
			for(i1 = 1; i1 < v.legs; i1++) {
			// rotate to make duplicates
				v.points[2*i1] = revolve(2*Math.PI*i1/v.legs, v.points[0], null, "xz");
				v.points[2*i1 + 1] = revolve(2*Math.PI*i1/v.legs, v.points[1], null, "xz");
			}
		}
		let points = structuredClone(v.points);
		for(i1 = 0; i1 < points.length; i1++) {
			let format = "yz";
			let angle = 2*Math.PI*frame/v.duration;
			if(format === "xz") {
				angle /= v.legs;
			}
			points[i1] = revolve(angle, points[i1], null, format);
			// rotate with each frame
			for(i2 = 0; i2 < points[i1].length; i2++) {
				let ref = points[i1][i2];
				points[i1][i2] = (
					ref[2] < 0
					?
					null
					// hide any that shouldn't be visible from the camera's
					// perspective
					:
					perspectiveconvert(
						u.viewer,
						v.pos[0] + ref[0]*u.w/4,
						v.pos[1] + ref[1]*u.w/4,
						central_z(u.viewer) + ref[2]*u.w/4
					).slice(0, 2)
					// resize, perspective convert
				);
			}
		}
		ctx.strokeStyle = "white";
		for(i1 = 0; i1 < points.length; i1++) {
			for(i2 = 0; i2 < points[i1].length - 1; i2++) {
				let prev = points[i1][i2];
				let next = points[i1][i2 + 1];
				if(prev && next) {
				// if neither are null, draw a line
					linespecial(ctx, ...prev, ...next, v.pos.slice(0, 2));
				}
			}
		}
		//*/
		/*
		if(frame === 0) {
			v.points = slite.bean();
			ctx.fillStyle = "orange";
			ctx.strokeStyle = "white";
		}
		let rand = 0*Math.random()/v.duration;
		let points = revolve(2*Math.PI*(frame/v.duration + rand), v.points, null, "xz");
		//let partrand = (num, factor) => factor*Math.random() + (1 - factor)*num;
		//let points = revolve(2*Math.PI*partrand(frame/v.duration, 1/16), v.points, null, "xz");
		for(i1 = 0; i1 < points.length; i1++) {
			points[i1][0] += v.pos[0];
			points[i1][1] += v.pos[1];
			points[i1][2] += v.pos[2];
			points[i1] = perspectiveconvert(u.viewer, ...points[i1]).slice(0, 2);
		}
		//_2dPoly.draw(ctx, _2dPoly.convexed(points, u.viewer), "both");
		for(i1 = 0; i1 < points.length; i1++) {
			let coor = [
				Math.trunc(points[i1][0]),
				Math.trunc(points[i1][1])
			];
			ctx.strokeRect(
				coor[0] - .5,
				coor[1] - .5,
				2,
				2
			);
		}
		//*/
		/*
		let randpoint = () => [
			Math.floor(Math.random()*u.w),
			Math.floor(Math.random()*u.h)
		];
		if(frame === 0) {
			let shape = addspheroids([[0, 0, 0, 16, 16, 16]]);
			for(i1 = 0; i1 < shape.length; i1++) {
				//console.log(Math.hypot(...shape[i1]));
			}
			//console.log(structuredClone(shape));
			shape = _2dPoly.convexed(shape, !u.viewer, [u.w/2, u.h/2, 0]);
			//console.log(shape);
			ctx.strokeStyle = "white";
			ctx.fillStyle = "orange";
			_2dPoly.draw(ctx, shape, "both");
			let data = _2dPoly.getdata(shape, true);
			ctx.fillStyle = "#3fbf3f7f";
			for(i1 = 0; i1 < data.within.length; i1++) {
				if(data.within[i1]) {
					ctx.fillRect(
						data.rect.x + (i1%data.rect.w),
						data.rect.y + Math.floor(i1/data.rect.w),
					1, 1);
				}
			}
		}
		//*/
		/*
		let shape1 = [randpoint(), randpoint(), randpoint()];
		let shape2 = [randpoint(), randpoint(), randpoint()];
		let merge = _2dPoly.mergedata([
			_2dPoly.getdata(shape1, true),
			_2dPoly.getdata(shape2, true)
		]);
		ctx.fillStyle = "orange";
		for(i1 = 0; i1 < 0*merge.within.length; i1++) {
			if(merge.within[i1]) {
				ctx.fillRect(
					merge.rect.x + (i1%merge.rect.w),
					merge.rect.y + Math.floor(i1/merge.rect.w),
				1, 1);
			}
		}
		_2dPoly.draw(ctx, shape1, "both");
		_2dPoly.draw(ctx, shape2, "both");
		ctx.fillStyle = "#3fbf3f7f";
		for(i1 = 0; i1 < merge.within.length; i1++) {
			if(merge.within[i1]) {
				ctx.fillRect(
					merge.rect.x + (i1%merge.rect.w),
					merge.rect.y + Math.floor(i1/merge.rect.w),
				1, 1);
			}
		}
		//*/
		/*
		let numofpoints = 7;
		let dists = [];
		let points = [];
		for(i1 = 0; i1 < numofpoints; i1++) {
			dists[i1] = (1 - randexponent(2))*Math.min(u.w, u.h)/2;
		}
		for(i1 = 0; i1 < numofpoints; i1++) {
			let angle = 2*Math.PI*i1/numofpoints;
			points[i1] = [
				v.pos[0] + dists[i1] * Math.cos(angle),
				v.pos[1] + dists[i1] * Math.sin(angle)
			];
		}
		ctx.fillStyle = "orange";
		ctx.strokeStyle = "white";
		let start = new Date().valueOf();
		_2dPoly.draw(ctx, points, "both");
		v.average += new Date().valueOf() - start;
		if(frame === v.duration - 1) {
			v.average /= 1000*v.duration;
			//console.log(v.average);
		}
		*/
		/*
		function randpoint() {
			let point = [
				Math.floor(Math.random()*u.w),
				Math.floor(Math.random()*u.h),
				-Math.floor(Math.random()*u.w)
			];
			return perspectiveconvert(u.viewer, ...point).slice(0, 2);
		};
		for(i1 = 0; i1 < 4; i1++) {
			let point = [
				randpoint(),
				randpoint()
			];
			//[u.w/2, u.h/4],
			//[u.w/2, u.h/2]
			let r = randexponent(2)*u.w/2;
			ctx.strokeStyle = "silver";
			circledraw(ctx, ...point[0], Math.hypot(point[1][0] - point[0][0], point[1][1] - point[0][1]));
			ctx.fillStyle = "white";
			ctx.fillRect(...point[0], 1, 1);
			ctx.strokeStyle = "white";
			circledraw(ctx, ...point[1], r);
		};
		//
		let colors = ["white", "cyan", "yellow"];
		let i0 = 0;
		for(i0 = Math.min(frame, colors.length - 1); i0 >= 0; i0--) {
			const time = easing(1 - 2*Math.abs((frame - i0)/v.duration - .5), "out/in");
			const _time = 2*easing((frame - i0)/v.duration, "in/out");
			// - _time is just the rotation
			// - out/in for weirdness and tension, especially since it slows
			//   down at the peak of the rotation speed
			// - the Math.abs crap looks complicated, but it just turns a 0 to 1
			//   number into a 0 to 1 to 0 number
			//   - part of the reason _time is separate is so the rotation
			//     doesn't change direction
			// - the in/out being used on the rotation makes it easier to see
			//   when it forms a star or pentagon
			const r = v.star.r;
			v.star.r *= 1 + i0/4;
			let points = slite.star.points(v.star, v.star.r*time, 2*Math.PI*_time);
			v.star.r = r;
			ctx.strokeStyle = colors[i0];
			for(i1 = 0; i1 < points.length; i1++) {
				for(i2 = 0; i2 < points[i1].length; i2++) {
					linespecial(
						ctx,
						...points[i1][i2],
						[v.star.x, v.star.y]
					);
				}
			}
		}
		//
		function randpoint() {
			let point = [
				Math.floor(Math.random()*u.w),
				Math.floor(Math.random()*u.h),
				-Math.floor(Math.random()*u.w)
			];
			return perspectiveconvert(u.viewer, ...point).slice(0, 2);
		};
		let points = [
			randpoint(),
			randpoint(),
			randpoint(),
			randpoint()
		];
		ctx.strokeStyle = "silver";
		for(i1 = 0; i1 < points.length; i1++) {
			for(i2 = i1 + 1; i2 < points.length; i2++) {
				let r = [
					points[i2][0] - points[i1][0],
					points[i2][1] - points[i1][1]
				];
				if(r[0] > u.w/2) {
					r[0] = u.w - r[0];
				};
				if(r[1] > u.h/2) {
					r[1] = u.h - r[1];
				};
				r = Math.hypot(...r);
				let temp = [
					Math.hypot(
						points[i1][0] - u.w/2,
						points[i1][1] - u.h/2
					),
					Math.hypot(
						points[i2][0] - u.w/2,
						points[i2][1] - u.h/2
					)
				];
				circledraw(ctx, ...points[temp[1] < temp[0] ? i2 : i1], r, false, false, false);
			}
		};
		//
		let data = v.blob.slice(frame - v.bloblength, frame);
		data.sort((a, b) => (-Math.abs(b[3] - v.duration/2)) - (-Math.abs(a[3] - v.duration/2)) );
		for(i1 = 0; i1 < data.length; i1++) {
			ctx.strokeStyle = colormath(ctx, "#bfbfff", "white", i1/(data.length - 1));
			circledraw(ctx, ...data[i1].slice(0, 3), true);
			circledraw(ctx, ...data[i1].slice(0, 3), false);
		}
		ctx.strokeStyle = "white";
		//*/
		// TODO
		// - make this a separate ProcAnim named hypnosis or something
		// - make it play four times, rotating each time but keeping the zero
		//   radius point in the same spot
		//   - make them overlap a little in timing
		//   - have them reverse direction at the right places to make it sort
		//     of draw a clover?
		//   - wait, i can do this with a nested procanim. why don't i do that
		//     more often, timing is always a pain in the ass
		/*
		let shape = [];
		// an array of 3d points. the portion of the cardioid this frame is
		// drawing.
		for(i1 = v.trace; i1 >= 0; i1--) {
			let temp = posmod(frame - i1, v.duration);
			temp = structuredClone(v.cardioid[temp]);
			temp[2] = v.pos[2];
			shape[shape.length] = structuredClone(temp);
		}
		for(i1 = 0; i1 < shape.length - 1; i1++) {
			let point1 = structuredClone(shape[i1]);
			let point2 = structuredClone(shape[i1 + 1]);
			for(i2 = 0; i2 < v.tunnel.rings; i2++) {
				let _point1 = structuredClone(point1);
				let _point2 = structuredClone(point2);
				_point1[2] -= i2*v.tunnel.spacing;
				_point2[2] -= i2*v.tunnel.spacing;
				let _frame = posmod(frame + (v.pulse.invert ? -1 : 1)*i2, v.duration);
				_point1 = v.wavemod(_point1, _frame);
				_point2 = v.wavemod(_point2, _frame);
				_3dline(u.viewer, ctx, ..._point1, ..._point2);
			}
		}
		//
		ctx.fillStyle = "orange";
		ctx.fillRect(0, 0, u.w, u.h);
		v.fire = slite.walkers.flame(v.fire, null, null, [
			v.start_func, v.start_args, null, null, ["direct", Math.PI*3/2]
		]);
		slite.walkers.draw(ctx, v.fire, v.colorfunc);
		//
		ctx.fillStyle = "black";
		ctx.fillRect(0, 0, u.w, u.h);
		ctx.fillStyle = "white";
		ctx.strokeStyle = "white";
		ctx.font = "16px 'fomp2'";
		ctx.strokeStyle = "white";
		ctx.fillStyle = "orange";
		let shape = slite._2dpoly.random(u.w/2, 7, wave(frame/(v.duration*4), "sine", 1, 2), 0);
		for(i1 = 0; i1 < shape.length; i1++) {
			shape[i1][0] += v.pos[0];
			shape[i1][1] += v.pos[1];
		};
		_2dPoly.draw(ctx, shape, "both");
		//slite._2dpoly.colorbydistance(shape, ctx, (value) => "rgb(" + [Math.floor(value*255), 127 + Math.floor(value*255/2), 255].join(",") + ")", u.w/4);
		//
		let x1 = Math.floor(Math.random()*u.w);
		let y1 = Math.floor(Math.random()*u.h);
		let x2 = Math.floor(Math.random()*u.w);
		let y2 = Math.floor(Math.random()*u.h);
		nonaaline(ctx, x1, y1, x2, y2);
		circledraw(ctx, x1, y1, 8);
		circledraw(ctx, x2, y2, 4);
		//
		slite.ditherparallax(frame, ctx, v.dithers);
		slite.jankynumbers(ctx, u.w/2, u.h/2, frame, [" ".repeat(3 - frame.toString().length), "%"], false, 1/32, true);
		let size = 32;
		if(frame === 1) {
			ctx.fillStyle = "gray";
			ctx.fillRect(0, 0, 128, 128);
			for (i1 = 0; i1 < 4; i1++) {
				for (i2 = 0; i2 < 4; i2++) {
					slite.drawtile(ctx, 32*i1, 32*i2, "grass", 32);
				}
			}
			slite.drawtile(ctx, 0, 0, "road", 32, {path: "ul_corner"});
			slite.drawtile(ctx, 32, 0, "road", 32, {path: "u_cross"});
			slite.drawtile(ctx, 64, 0, "road", 32, {path: "ur_corner"});
			slite.drawtile(ctx, 0, 32, "road", 32, {path: "l_cross"});
			slite.drawtile(ctx, 32, 32, "road", 32, {path: "cross"});
			slite.drawtile(ctx, 64, 32, "road", 32, {path: "r_cross"});
			slite.drawtile(ctx, 0, 64, "road", 32, {path: "dl_corner"});
			slite.drawtile(ctx, 32, 64, "road", 32, {path: "d_cross"});
			slite.drawtile(ctx, 64, 64, "road", 32, {path: "dr_corner"});
			//
			slite.drawtile(ctx, 96, 0, "road", 32, {path: "u_end"});
			slite.drawtile(ctx, 96, 32, "road", 32, {path: "d_end"});
			slite.drawtile(ctx, 96, 64, "road", 32, {path: "vert"});
			slite.drawtile(ctx, 0, 96, "road", 32, {path: "l_end"});
			slite.drawtile(ctx, 32, 96, "road", 32, {path: "r_end"});
			slite.drawtile(ctx, 64, 96, "road", 32, {path: "hori"});
			slite.drawtile(ctx, 96, 96, "road", 32, {path: "center"});
			//
			slite.drawtile(ctx, 128, 0, "grass", 32);
			temp = ctx.getImageData(128, 0, 32, 32);
			for (i1 = 0; i1 < 2; i1++) {
				for (i2 = 0; i2 < 2; i2++) {
					ctx.putImageData(temp, 128 + 32*i1, 32*i2);
				}
			}
		}
		//
		let ds_size = 16*2**(frame%3);
		let temp = frame%(3*4);
		temp = Math.floor(temp/3);
		let floor = temp%2 < 1;
		let norepeat = temp%4 < 2;
		if(frame < 12 && norepeat && floor) {
			console.log(ctx);
			for (i1 = 0; i1 < u.w; i1 += ds_size) {
				for (i2 = 0; i2 < u.h; i2 += ds_size) {
					//(input, level) => input*(1 - 1/variation + Math.random()*2/variation)
					diamondsquare(ctx, i1, i2, (norepeat ? 2 : 1) * ds_size, (input, level) => input + 32*randexponent(1, true)*( ( 2**(-1) )**(Math.log2(64) - level) ) + 4*randexponent(1, true), function(ctx, x, y, value) {
						ctx.fillStyle = "rgb(" + [255, (floor ? Math.floor(value/16)*16 : value), 0].join(",") + ")";
						ctx.fillRect(x, y, 1, 1);
					});
				}
			}
		};
		//*/
		//let shape = structuredClone(v.shape);
		//shape.points = revolve(2*Math.PI*frame/16, shape.points, false, "xz");
		//_3dpoly(u.viewer, ctx, shape, v.pos, false, false, false, false);
		//this.revolvingrings.func(frame);
		//this.shimmershape.func(frame, v.shape2d);
		//console.log("frame " + frame + ": " + (32*Math.floor(frame/32) + 16*(frame%32)/32 + easingplacement(0, 16, (frame%32)/32, "in/out", "sine")));
		//this.polaris.func(frame, 0);
		//this.starblast.func(frame);
		//this.rhythmicshine.func(frame, "o   .o   .o   .o   |");
		//
		this.frameend(frame);
	};
	document.write(
		`<br><label>tool: <select id="hider_select">
		</select></label>`
	);
	document.write(`<div name="hider" id="hider_procanim">`);
	class OldAnimator {
	// an old class that creates an animation player. i've rewritten it, but i
	// don't feel like rewriting the procanim code that used the old one.
	// ProcAnim is already sorta unsalvageably messy.
	// structure:
	// - name
	// - ctx: canvas the animation is displayed on. element id is name +
	//   "_canvas".
	// - frames: array of ImageDatas. it animates by using putImageData with
	//   this. add to this by using .clear to clear the canvas, applying edits,
	//   and using .set to put it in .frames.
	// - background: color to use when clearing the canvas.
	// - a few getters/setters
	// - ui: object describing what buttons/inputs to create. the property
	//   name is the type/name.
	//   - fps (frames per second, number input)
	//   - play (button)
	//   - loop (checkbox)
	//   - pingpong (checkbox, makes it go back and forth)
	//   - sheet (hideable canvas of all the frames. update it with
	//     .updatesheet.)
	//     - hidden by default.
	//     - cols: number of columns.
	//   - "button_" + whatever: extra button
	//   -
	//   - save: buttons that save images of the canvas or the spritesheet.
	//     - no_frame, no_sheet: by default, buttons for both the frame and the
	//       sheet are created.
	//     - prefix, name, suffix: the saved file name will be prefix + name +
	//       suffix. the reason i bother splitting it up is because if name is
	//       omitted, it defaults to filedate().
	//   =
	//   - properties of properties:
	//     - br: adds a linebreak before it. (or multiple, if the value is a
	//       number instead of a boolean.)
	//     - space: adds a space before it.
	//     - onclick: function you want run when it's clicked
	//     - text: text you want it to use. (by default, it'll just use the
	//       property name.)
	//   - the html id will be .name + "_" + the property name of the html
	//     element. so fps would be "anim_fps" or whatever.
	//     - except for "button_". it'll omit the beginning of that.
	//   - null is treated the same as an empty object.
	// - fps, looping: getters/setters connected to the html elements if those
	//   exist, primitives if not.
		/*
		new OldAnimator(
			"name",
			{
				fps: {
					br: true,
				},
				play: {
					space: true,
				},
				loop: {
					br: true,
				},
			},
			div, fps, background, w, h
		);
		*/
		constructor(name, ui, div, fps, background, w, h) {
			let i1 = 0;
			if(!div) {
				document.write(`<div id="` + name + `_div"></div>`);
				div = document.getElementById(name + `_div`);
			};
			if(!Number.isInteger(fps) || fps <= 0) {
				fps = 24;
			};
			ui ??= structuredClone(OldAnimator.default_ui);
			w ??= 256;
			h ??= 256;
			background ??= "black";
			this.name = name;
			this.div = div;
			this.defaultfps = fps;
			this.background = background;
			let temp = name + `_canvas`;
			let string = ``;
			string += `<canvas id="` + temp + `" name="` + temp + `" width=` + w + ` height=` + h + `></canvas>`;
			for(i1 in ui) {
				if(ui.hasOwnProperty(i1)) {
					ui[i1] ??= {};
					let obj = ui[i1];
					const text = (
						obj.hasOwnProperty("text") ? obj.text :
						i1.startsWith("button_") ? i1.slice("button_".length) :
						i1
					);
					if(obj.hasOwnProperty("br")) {
						if(Number.isInteger(obj.br) && obj.br >= 0) {
							string += `<br>`.repeat(obj.br);
						}
						else if(obj.br) {
							string += `<br>`;
						};
					};
					if(obj.hasOwnProperty("space") && obj.space) {
						string += ` `;
					};
					if(i1 === "fps") {
						string += `<label>` + text + `: <input type="number" id="` + name + `_fps" value=` + fps + `>`;
					}
					else if(i1 === "play") {
						string += `<button id="` + name + `_play">` + text + `</button></label>`;
					}
					else if(i1 === "loop") {
						string += `<label>` + text + `: <input type="checkbox" id="` + name + `_loop"></label>`;
					}
					else if(i1 === "pingpong") {
						string += `<label>` + text + `: <input type="checkbox" id="` + name + `_pingpong"></label>`;
					}
					else if(i1 === "sheet") {
						string += `<button id="` + name + `_hidesheet">show sheet</button></label>`;
						string += `<br><canvas id="` + name + `_sheet" name="` + temp + `" width=` + w + ` height=` + h + ` hidden></canvas>`;
					}
					else if(i1 === "save") {
						let frame = !("no_frame" in obj) || !obj.no_frame;
						let sheet = (!("no_sheet" in obj) || !obj.no_sheet) && "sheet" in ui;
						string += (
							(frame ? `<button id="` + name + `_save_frame">save frame</button>` : ``)
							+
							(frame && sheet ? ` ` : ``)
							+
							(sheet ? `<button id="` + name + `_save_sheet">save sheet</button>` : ``)
						);
					}
					else if(i1.startsWith("button_")) {
						string += `<button id="` + name + `_` + i1.slice("button_".length) + `">` + text + `</button>`;
					}
					else {
						console.log("invalid ui property name.");
					};
				}
			}
			div.innerHTML = string;
			this.ctx = document.getElementById(temp).getContext("2d");
			this.ctx.fillStyle = background;
			this.ctx.fillRect(0, 0, w, h);
			this.viewer = {
				x: this.w/2,
				y: this.h/2,
				z: this.w/2,
				ratio: this.w/60,
				// ratio = pixels/degrees, screen_pixels = 60*degrees
				// if ratio === screen_pixels/60
				// screen_pixels = 60*screen_pixels/60
				offset: {
					x: 0,
					y: 0,
					z: 0,
				},
				lamp: {
				// USE .single === true IF THERE'S ONLY ONE LAMP.
					x: this.w,
					y: 0*this.h,
					z: -this.w,
					brightness: 1,
					baselightlevel: -1,
					single: true,
				},
				// baselightlevel
				// until i figure out how to convert colors to rgb, colors should be an
				// array.
			};
			// viewer is kind of a mess and should really be a class. don't try
			// too hard to make sense of this.
			this.frames = [];
			this._frame = 0;
			this._playing = false;
			this.interval = null;
			if(ui.hasOwnProperty("fps")) {
				Object.defineProperty(this, "fps", {
					get() {
						let temp = Number(document.getElementById(this.name + `_fps`).value);
						if(!Number.isInteger(temp) || temp <= 0) {
							temp = this.defaultfps;
							document.getElementById(this.name + `_fps`).value = temp;
						};
						return temp;
					},
					set(value) {
						let temp = Number(value);
						if(!Number.isInteger(temp) || temp <= 0) {
							temp = this.defaultfps;
						};
						document.getElementById(this.name + `_fps`).value = temp;
					},
				})
			}
			else {
				this.fps = fps;
			};
			for(i1 = 0; i1 < 2; i1++) {
				let type = ["loop", "pingpong"][i1];
				let propertyname = ["looping", "pingpong"][i1]
				if(ui.hasOwnProperty(type)) {
					Object.defineProperty(this, propertyname, {
						get() {
							return document.getElementById(this.name + `_` + type).checked;
						},
						set(value) {
							document.getElementById(this.name + `_` + type).checked = !!value;
						},
					})
				}
				else {
					this[propertyname] = false;
				};
			}
			// define fps, loop, and pingpong as a getter/setter if there's an
			// html element, and a primitive if it's not.
			this.reverse = false;
			// boolean for whether it's playing backwards. necessary for
			// pingpong.
			let _this = this;
			for(i1 in ui) {
				if(ui.hasOwnProperty(i1) && ui[i1]) {
				// add event listeners
					if(i1 === "play") {
						document.getElementById(name + `_` + i1).onclick = function() { _this.playpause(_this) };
					}
					else if(i1 === "pingpong") {
						document.getElementById(name + `_` + i1).onclick = function() { _this.reverse = false };
						// keeps reverse from lingering outside of pingpong.
					}
					else if(i1 === "sheet") {
						let ref = document.getElementById(_this.name + `_` + i1);
						this.sheet = ref.getContext("2d");
						this.sheet_cols = ui[i1].cols ?? 0;
						document.getElementById(name + `_hidesheet`).onclick = function() {
							ref.hidden = !ref.hidden;
							document.getElementById(_this.name + `_hidesheet`).innerHTML = (ref.hidden ? "show" : "hide") + " sheet";
						};
						this.updatesheet();
					}
					else if(i1 === "save") {
						let _name = (ui[i1].prefix ?? "") + (ui[i1].name ?? filedate()) + (ui[i1].suffix ?? "") + ".png";
						if(!("no_frame" in ui[i1]) || !ui[i1].no_frame) {
							document.getElementById(name + `_` + i1 + `_frame`).onclick = function() { savecanvas(_this.ctx.canvas, _name) };
						};
						if((!("no_sheet" in ui[i1]) || !ui[i1].no_sheet) && "sheet" in ui) {
							let sheet = document.getElementById(_this.name + `_sheet`);
							document.getElementById(name + `_` + i1 + `_sheet`).onclick = function() { savecanvas(sheet, _name) };
						};
					}
					else if(ui[i1].hasOwnProperty("onclick")) {
						let id = name + "_" + (
							i1.startsWith("button_")
							?
							i1.slice("button_".length)
							:
							i1
						);
						document.getElementById(id).onclick = ui[i1].onclick;
					}
				}
			}
			this.ui = ui;
		}
		static default_ui = {
			fps: {
				br: true,
			},
			play: {
				space: true,
			},
			loop: {
				br: true,
			},
			pingpong: {
				br: true,
			},
			save: {
				br: true,
			},
			sheet: {
				br: true,
			},
		}
		get w() {
			return this.ctx.canvas.width;
		}
		set w(value) {
			this.ctx.canvas.width = value;
		}
		get h() {
			return this.ctx.canvas.height;
		}
		set h(value) {
			this.ctx.canvas.height = value;
		}
		get duration() {
			return this.frames.length;
		}
		set duration(value) {
			if(Number.isInteger(value) && value >= 0) {
				if(value < this.duration) {
					this.frames = this.frames.slice(0, value);
				}
				else if(value > this.duration) {
					let temp = this.ctx.getImageData(0, 0, this.w, this.h);
					this.clear();
					let i1 = 0;
					for(i1 = this.duration; i1 < value; i1++) {
						this.frames[i1] = this.ctx.getImageData(0, 0, this.w, this.h);
					}
					this.ctx.putImageData(temp, 0, 0);
				}
			}
		}
		get frame() {
			return this._frame;
		}
		set frame(value) {
			if(this.duration === 0) {
				this._frame = 0;
			}
			else if(Number.isInteger(value)) {
				this._frame = value%this.duration;
			};
		}
		get playing() {
			return this._playing;
		}
		set playing(value) {
			if(this.duration === 0) {
				value = false;
			};
			this._playing = !!value;
			if(value) {
				let _this = this;
				this.interval = setInterval(function() { _this.updateframe(_this) }, 1000/this.fps);
			}
			else {
				clearInterval(this.interval);
				this.interval = null;
			};
			document.getElementById(this.name + `_play`).innerHTML = (value ? "pause" : "play");
		}
		clear() {
			this.ctx.clearRect(0, 0, this.w, this.h);
			this.ctx.fillStyle = this.background;
			this.ctx.fillRect(0, 0, this.w, this.h);
		}
		saveframe(frame, ctx, x, y) {
			ctx ??= this.ctx;
			x ??= 0;
			y ??= 0;
			this.frames[frame] = ctx.getImageData(x, y, this.w, this.h);
			if(this.frames.includes(undefined)) {
				this.clear();
				let i1 = 0;
				for(i1 = 0; i1 < this.duration; i1++) {
					if(!this.frames[i1]) {
						this.frames[i1] = ctx.getImageData(0, 0, this.w, this.h);
					}
				}
				ctx.putImageData(this.frames[frame], 0, 0);
			};
		}
		updateframe(_this) {
			_this ??= this;
			if(_this.duration === 0) {
				_this.clear();
			}
			else {
				if(_this.playing) {
					_this.frame = posmod(_this.frame + (_this.reverse ? -1 : 1), _this.duration);
					// loop back to the opposite end if you reach the end. (that
					// way, when it reaches the end and isn't looping, it stops
					// at the first frame.)
					// - the order isn't 0 1 2 3, it's 1 2 3 0. (since it
					//   already starts at 0, and animations that aren't playing
					//   are supposed to show the first frame.)
				};
				_this.ctx.putImageData(_this.frames[_this.frame], 0, 0);
				if(_this.frame === ((!!_this.reverse === !!_this.pingpong) ? 0 : _this.duration - 1)) {
				// end of the animation, so stop the interval or switch
				// directions
				// - if pingpong is false
				//   - if reverse is false, the last frame is duration - 1, and
				//     it resets back to 0. so end at 0.
				//   - if reverse is true, the last frame is 0, and it resets
				//     back to duration - 1, so end at duration - 1
				// - if pingpong is true
				//   - if reverse is false, it should switch directions at
				//     duration - 1.
				//   - if reverse is true, it should switch directions or end at
				//     0.
				// - 0 if both are false or both are true. duration - 1
				//   otherwise.
					if(_this.pingpong) {
					// if it's not looping and it's already in the second
					// half, stop. no matter what, switch directions.
						if(!_this.looping && _this.reverse) {
							_this.playing = false;
						};
						_this.reverse = !_this.reverse;
					}
					else if(!_this.looping) {
						_this.playing = false;
					};
				};
			};
		}
		playpause(_this) {
			_this ??= this;
			_this.playing = !_this.playing;
		}
		updatesheet(_this, ctx, cols, gap, gapcolor) {
		// makes the specified canvas a spritesheet of all the frames. or if
		// there's no ctx specified and the OldAnimator has a sheet element, it
		// edits that.
			let i1 = 0;
			_this ??= this;
			ctx ??= _this.sheet;
			cols ??= _this.sheet_cols;
			gap ??= 0;
			gapcolor ??= _this.background;
			if((ctx ?? null) === null) {
				console.log("sheet canvas is unspecified.");
				return;
			};
			if((ctx ?? null) === null) {
				console.log("number of rows is unspecified.");
				return;
			};
			cols = cols ? cols : _this.duration;
			// if it's falsy, it'll print them all in one row.
			ctx.canvas.width = cols*_this.w;
			ctx.canvas.height = Math.ceil(_this.duration/cols)*_this.h;
			ctx.fillStyle = gapcolor;
			ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			for(i1 = 0; i1 < _this.duration; i1++) {
				ctx.putImageData(
					_this.frames[i1],
					(i1%cols)*(_this.w + gap),
					Math.floor(i1/cols)*(_this.h + gap)
				);
			}
		}
	};
	let anim = new OldAnimator(
		"anim",
		{
			fps: {
				br: true,
			},
			play: {
				space: true,
			},
			loop: {
				br: true,
			},
			pingpong: {
				br: true,
			},
			save: {
				br: true,
			},
			sheet: {
				br: true,
				cols: 4,
			},
		},
		null,
		null,
		"black"
	);
	anim.run = {
		name: "test",
		ctx: anim.ctx,
		u: {viewer: anim.viewer},
		duration: 64,
		initarguments: null,
		funcarguments: null,
		sheet: null,
		// {ctx, columns, borderwidth}
	};
	/*;
	anim.run.name = "hypnosis";
	anim.run.duration = 16*4;
	anim.run.name = "fireplaceybg";
	anim.run.duration = 48;
	anim.run.name = ["linerevolve", "glr", "rolldir", "linefind", ""][0] + "test";
	anim.run.duration = 90;
	anim.run.name = "linerevolvetest";
	anim.run.duration = 96;
	anim.run.name = "dsrainbow2";
	anim.run.duration = 72;
	anim.run.funcarguments = [3, true];
	anim.run.name = "starblast";
	anim.run.duration = 96;
	//*/
	anim.frames = suite[anim.run.name].render(
		anim.run.ctx,
		anim.run.u,
		anim.run.duration,
		anim.run.initarguments,
		anim.run.funcarguments,
		anim.run.sheet
	).imagedata;
	delete anim.run;
	document.write(`<canvas id="` + anim.name + `_sheet"></canvas></div>`);
	anim.sheet = document.getElementById(anim.name + `_sheet`).getContext("2d");
	anim.updatesheet();
	document.getElementById("anim_hidesheet").click();
	anim.sheet.canvas.style["image-rendering"] = "crisp-edges";
	//
	// cobblestone pseudocode
	// - fill two arrays with random coordinates
	// - create a "radius" array
	// - paint the whole canvas black
	// - for loop
	// - for loop
	//   - for loop that checks for the shortest distance between two points
	//     points, this one checks every point
	//     - this one checks every point before this one
	//       - skip this point if the corresponding radius array index has been
	//         filled
	//         - if the current point is the last one and it does this, exit all
	//           loops
	//       - calculate distance with a2 + b2 = c2
	//       - but you also gotta make sure the measurements wrap around
	//         - if either dimension is larger than half the height/width of the
	//           image, add the height/width to the lower one and calculate
	//           again
	//       - if the other point has a radius, subtract that from the
	//         calculated distance
	//       - and of course etc etc "if this distance is shorter than the
	//         current record for shortest distance, make it the new shortest
	//         distance"
	//   - now that you have your pair...
	//   - if both coordinates have no radius, set the radius as half of the
	//     distance value, and draw a circle of that radius around them using
	//     math bullshit
	//     - remember to draw it in both axes, that way there won't be gaps
	//     - also draw it in white, and subtract 1 from the radius so there's a
	//       small gap between this circle and one that's meant to tangent it
	//     - use paintbucket on the center coordinate
	//   - if one of them has a radius, set the one without a circle's radius as
	//     the full distance and draw it
	// - thin everything out with this for loop (stops looping when erasecount
	//   is less than 1)
	//   - set variable erasecount as 0
	//   - another for loop that checks every pixel
	//     - if it's a black pixel, it has white cardinal neighbors, and every
	//       white cardinal neighbor has a black neighbor in the opposite
	//       direction, make this pixel white
	//       - tick up erasecount
	function changefocus(focus) {
	// overrides the changefocus in barky_main, so that it can pause/resume
	// processing for fg.
		let prevfocus = userfocus;
		userfocus = focus;
		if(prevfocus !== focus) {
			if(prevfocus === "fg") {
				clearInterval(fg.interval);
				fg.interval = null;
			}
			else if(focus === "fg") {
				fg.interval = setInterval(function() {
					fg.process(1/fg.fps);
				}, 1000/fg.fps);
			};
		};
	};
	document.onkeydown = function(e) {
		if(["textarea", "input"].includes(document.activeElement.tagName.toLowerCase())) {
			return;
		};
		function radiocycling(radioname) {
			let i1 = 0;
			let i2 = 0;
			let cyclestatus = "before";
			// before: it hasn't found the active radio button yet
			// during: it has found the active radio button and turned it off, but
			// it hasn't turned on the next yet
			// after: it's done
			for (i1 in document.getElementsByName(radioname)) {
				if (document.getElementsByName(radioname).hasOwnProperty(i1)) {
					if(document.getElementsByName(radioname)[i1].checked) {
						document.getElementsByName(radioname)[i1].checked = false;
						cyclestatus = "during";
					}
					else if(cyclestatus === "during") {
						document.getElementsByName(radioname)[i1].checked = true;
						cyclestatus = "after";
					};
				};
			}
			if(cyclestatus === "before" || cyclestatus === "during") {
			// the former happens if no radio buttons are checked, (happens
			// sometimes, i dunno why. complications from the page refreshing?)
			// the latter happens if the active button was the last one, meaning
			// it couldn't find a next button to activate.
				for (i1 in document.getElementsByName(radioname)) {
					if (
						document.getElementsByName(radioname).hasOwnProperty(i1)
						&&
						(
							cyclestatus === "before"
							||
							cyclestatus === "during"
						)
					) {
						document.getElementsByName(radioname)[i1].checked = true;
						cyclestatus = "after";
					};
				}
			};
		}
		//console.log(e.key);
		//console.log(e.shiftKey);
		//console.log(e.ctrlKey);
		let key = keyinterpreter(e.key);
		if(userfocus === "draw") {
			draw.buttonaction(e, true);
		}
		else if(["aa", "aapa"].includes(userfocus)) {
		// if it isn't in a textarea/input...
			let keymap = (aa.control.editmode ? aa.pa.ui.keymap : aa.ui.keymap);
			if(keymap.hasOwnProperty(key)) {
				let action = keymap[key];
				if(typeof action !== "string") {
					if(action.length > 2) {
						action = (
							e.ctrlKey
							?
							action.slice(2)
							:
							action.slice(0, 2)
						);
					};
					if(action.length === 1) {
						action = action[0];
					}
					else if(action.length === 2) {
						action = action[Number(e.shiftKey)];
					}
					else {
						console.log("this shouldn't happen");
					};
				};
				if(action) {
					e.preventDefault();
					if(aa.control.editmode) {
						aa.pa.ui.action(action, e.shiftKey, e.ctrlKey);
					}
					else {
						aa.ui.action(action, e.shiftKey, e.ctrlKey);
					}
				};
			};
		}
		else if(userfocus === "fg") {
			fg.keydown(e);
		}
		else if(userfocus === "fpt") {
			if(e.ctrlKey && key === "z") {
				if(e.shiftKey) {
					fpt.states.redo();
				}
				else {
					fpt.states.undo();
				};
			};
		}
		else if(userfocus === "bm") {
			let prevent = true;
			if(e.ctrlKey && e.shiftKey) {
				if(key === "z") {
					e.preventDefault();
					bm.states.redo();
				}
				else {
					prevent = false;
				};
			}
			else if(e.ctrlKey) {
				if(key === "z") {
					bm.states.undo();
				}
				else if(key === "s") {
					bm.save();
				}
				else if(key === "o") {
					bm.load();
				}
				else {
					prevent = false;
				};
			}
			else if(e.shiftKey) {
				prevent = false;
			}
			else if(key.length === 1 && "wasd".includes(key)) {
				let array = bm.valid.tools;
				let index = array.indexOf(bm.control.tool);
				index += (
					key === "w" ? -1 :
					key === "a" ? -3 :
					key === "s" ? 1 :
					key === "d" ? 3 :
					0
				);
				bm.control.tool = array[posmod(index, array.length)]
				let skip = structuredClone(bm.valid.refresh);
				skip.splice(skip.indexOf("ui"), 1);
				bm.refresh(skip);
			}
			else if(key.length === 1 && "tfgh".includes(key)) {
			// family selection
				let name = bm.control.partname;
				let parent = bm.control.body_part.parent;
				let siblings = AAX.getchildren(bm.body, parent);
				let select = (
					key === "t" ? (parent === "standpoint" ? "" : parent) :
					key === "f" ? (siblings.length <= 1 ? "" : siblings[posmod(siblings.indexOf(name) - 1, siblings.length)]) :
					key === "g" ? (AAX.getchildren(bm.body, name)[0] ?? "") :
					key === "h" ? (siblings.length <= 1 ? "" : siblings[posmod(siblings.indexOf(name) + 1, siblings.length)]) :
					""
				);
				if(select) {
					bm.control.partname = select;
					let skip = structuredClone(bm.valid.refresh);
					skip.splice(skip.indexOf("ui"), 1);
					skip.splice(skip.indexOf("states"), 1);
					bm.refresh(skip);
				};
			}
			else {
				prevent = false;
			};
			//
			if(prevent) {
				e.preventDefault();
			};
		}
		else if(userfocus === "px") {
			px.keydown(e);
		};
	};
	document.onkeyup = function(e) {
		if(userfocus === "fg") {
			fg.keyup(e);
		};
	};
	document.write(`<div name="hider" id="hider_drawing_app">`);
	let draw = {
		scale: 1,
		// the drawing area dimensions will be this times 256 and 192
		menuorientation: "horizontal",
		// used in createbuttons to figure out how the ui should work, where it
		// should go. at present all there is is vertical (below drawing area)
		// and horizontal (to the right of the drawing area)
		mouse: {
		// stores information about your current actions
			oldx: [],
			oldy: [],
			// this stores all the mouse positions of the stroke.
			//numofpositions: 10,
			// length of oldx and oldy
			// - now obsolete. there shouldn't be a limit, that makes it hard to
			//   do anything that has to be done on mouseup.
			x: null,
			y: null,
			tool: "pen",
			// tool currently selected.
			subtool: {
				pen: 0,
				paint: 0,
				eraser: 0,
			},
			// index of which kind of tool you're using (for example, which
			// brush, or dither)
			inversion: {
				pen: false,
				paint: false,
				eraser: false,
			},
			// stores whether the subtool is its inverse (for example, for paint
			// it's an inversion of the dither pattern. for pens it's a modified
			// form that's different for each.)
			strokedata: null,
			// stores stuff that has to be applied per stroke, like the pattern
			// for the smear pen
			clicktype: "none",
			// stores what kind of click it is so it won't draw between you
			// clicking a tool and ending your click, and it won't draw without
			// you actually clicking either
		},
		// works like pi.click.
		undodata: [],
		// stores imagedatas.
		// - NOTE: lower indexes are more recent. every new imagedata is put at
		//   the beginning.
		undoindex: 0,
		maxundos: 20,
		// setting for how many imagedatas it should be allowed to hold, how
		// many actions it can undo.
		colors: [],
		color1: 1,
		// color you draw with
		color2: 0,
		// color you erase with
		buttons: [],
		// rectangle x/y/w/h of the upper left corner of each button.
		rect: new Path2D(),
		// this will be used for "clip", a way of preventing drawing on the
		// margins. but it's also useful for other things, like resetting one
		// part of the ui using putImageData and the buttons rectangles
		pensize: 1,
		paintsize: 32,
		page: 0,
		// current page of the menu the program is on.
		misc: {
			rainbow: [],
			rainbowmode: false,
			// boolean that stores whether to actually use this.
			rainbowindex: 0,
			epilepsywarning: false,
			// boolean for whether the user has responded to the epilepsy warning
			// with "yes"
			epilepsytext: `PHOTOSENSITIVITY WARNING: this button turns on rainbow mode, which can result in rapid color changes, especially with large pen/paint sizes, or pens like sunset that involve a lot of redrawing. type "yes" if you have acknowledged the risk.\n\nset both pen size and paint size to smaller numbers if you're photosensitive. (pens often use both pen size and paint size. for example, the width of the sunset pen and the diameter of the spray pen are both determined by paint size.)`,
		},
		// place for storing misc data like rainbow.
	};
	draw.createbuttons = function() {
	// creates draw.buttons, draw.drawingarea, sets canvas dimensions
	// - NOTE this is where buttons are written, by the way. this isn't like one
	//   of those go-between functions that acts on existing data. if you wanna
	//   add a new button, you do that by defining it here.
		let x0 = null;
		let y0 = null;
		let i1 = 0;
		let i2 = 0;
		this.drawingarea = {
			x: 0,
			y: 0,
			w: 256 * this.scale,
			h: 192 * this.scale,
		}
		if(this.menuorientation === "horizontal") {
			this.ctx.canvas.width = this.drawingarea.w * 2;
			this.ctx.canvas.height = this.drawingarea.h;
			x0 = this.drawingarea.w;
			y0 = 0;
		}
		else if(this.menuorientation === "vertical") {
			this.ctx.canvas.width = this.drawingarea.w;
			this.ctx.canvas.height = this.drawingarea.h * 2;
			x0 = 0;
			y0 = this.drawingarea.h;
		}
		else {
			console.log("this shouldn't happen");
			return;
		};
		// same resolution as the ds.
		//
		// x0 and y0 are the top left corner of the menu. (as in where x should
		// be if it's "0".) everything will be measured relative to that.
		this.ctx.fillStyle = "white";
		this.buttons = [];
		// NOTE structure of draw.buttons:
		// - .buttons (array)
		//   - .buttons[0] (object storing the buttons of page 1)
		//     - .buttons[0][buttonname] (button object)
		//       - x, y, w, h (defines the rectangle)
		//       - tags (string or array storing strings for categories and
		//         stuff. like if i wanna check if it's a color button.)
		//       - split (string or array of "up", "down", "left", or "right",
		//         indicates that you should draw imaginary diagonal lines
		//         across the rectangle and only consider the input valid if
		//         it's within one of those quadrants)
		//       - hide (boolean, keeps drawbuttons from doing anything.)
		//       - key (the KeyboardEvent.key string of the key that should do
		//         the same thing as clicking this. use "ctrl + " to specify
		//         that ctrl must be held.)
		//       - image (drawImage() parameters)
		//         - file (file path)
		//         - sx, sy, sw, sh (rectangle parameters for the portion of the
		//           image you're using)
		//         =
		//         - the dx/dy/dw/dh parameters are just the button rectangle
		//           stuff, obviously
		//         - note that this is not affected by split, so... in cases
		//           like the subtool controls, only one button holds the image
		//           for all of them.
		//         - that might get complicated later though. i'm not
		//           implementing "active" images yet. (that is, images that
		//           appear only when the button is clicked)
		let block = 32 * draw.scale;
		// the width of one "block" of the golden ratio shit i planned this
		// around
		let temp = {
			x: null,
			y: y0,
			w: 5*block,
			h: 5*block,
		};
		temp.x = x0 + this.drawingarea.w - temp.w;
		// this is the palette area
		this.buttons[0] = {};
		// page 1.
		this.buttons[0].rainbow = {
			x: temp.x,
			y: temp.y,
			w: .5*block,
			h: .5*block,
			key: "1",
		};
		this.buttons[0].changerainbow = {
			x: temp.x + temp.w - .5*block,
			y: temp.y,
			w: .5*block,
			h: .5*block,
			key: "2",
		};
		this.buttons[0].colorchange = {
			x: temp.x,
			y: temp.y + temp.h - .5*block,
			w: .5*block,
			h: .5*block,
			key: "3",
		};
		this.buttons[0].colorstrings = {
			x: temp.x + temp.w - .5*block,
			y: temp.y + temp.h - .5*block,
			w: .5*block,
			h: .5*block,
			key: "4",
		};
		for(i1 = 0; i1 < this.colors.length; i1++) {
			this.buttons[0]["color_" + i1] = {
				x: temp.x + block*(.5 + i1%4),
				y: temp.y + block*(.5 + Math.floor(i1/4)),
				w: block,
				h: block,
				tags: "palette",
			};
		}
		temp = {
			x: temp.x,
			y: temp.y,
			w: 3*block,
			h: 3*block,
			key: "e",
		};
		temp.x -= temp.w;
		this.buttons[0].tool = structuredClone(temp);
		// button for switching tools
		temp = {
			x: temp.x,
			y: temp.y + temp.h,
			w: 2*block,
			h: 2*block,
			tags: "subtool",
		};
		this.buttons[0].subtool_u = structuredClone(temp);
		this.buttons[0].subtool_d = structuredClone(temp);
		this.buttons[0].subtool_l = structuredClone(temp);
		this.buttons[0].subtool_r = structuredClone(temp);
		this.buttons[0].subtool_u.split = "up";
		this.buttons[0].subtool_d.split = "down";
		this.buttons[0].subtool_l.split = "left";
		this.buttons[0].subtool_r.split = "right";
		this.buttons[0].subtool_u.key = "w";
		this.buttons[0].subtool_l.key = "a";
		this.buttons[0].subtool_d.key = "s";
		this.buttons[0].subtool_r.key = "d";
		// controls for switching subtools
		temp = {
			x: temp.x + temp.w,
			y: temp.y + temp.h,
			w: block,
			h: block,
		};
		temp.y -= temp.h;
		this.buttons[0].sizedown = structuredClone(temp);
		this.buttons[0].sizedown.key = "f";
		temp.y -= temp.h;
		this.buttons[0].sizeup = structuredClone(temp);
		this.buttons[0].sizeup.key = "r";
		temp = {
			x: x0,
			y: y0 + 5*block,
			w: 3*block,
			h: .5*block,
			hide: true,
		};
		this.buttons[0].subtoolnumber = structuredClone(temp);
		this.buttons[0].subtoolname = structuredClone(temp);
		this.buttons[0].subtoolname.y += temp.h;
		// these aren't really "buttons" but i gotta define where they are
		// somehow.
		// - two rows of text. subtoolnumber displays "[tool name] [subtool
		//   index]", subtoolname displays the name.
		this.buttons[0].undo = {
			x: temp.x + temp.w,
			y: temp.y,
			w: block,
			h: block,
			key: "ctrl + z",
		};
		this.buttons[0].redo = structuredClone(this.buttons[0].undo);
		this.buttons[0].redo.x += this.buttons[0].undo.w;
		this.buttons[0].redo.key = "ctrl + y";
		this.buttons[0].page = {
			x: null,
			y: null,
			w: block,
			h: block,
			split: [
				"down",
				"right"
			],
			key: "q",
		};
		this.buttons[0].page.x = x0 + this.drawingarea.w - this.buttons[0].page.w;
		this.buttons[0].page.y = y0 + this.drawingarea.h - this.buttons[0].page.h;
		// page 0 button defining
		this.buttons[0].tool.image = {
			file: new Image(),
			sx: 0,
			sy: null,
			sw: 96,
			sh: 96,
		};
		switch (this.mouse.tool) {
			case "pen":
				this.buttons[0].tool.image.file.sy = 0;
			break;
			case "paint":
				this.buttons[0].tool.image.file.sy = 96;
			break;
			case "eraser":
				this.buttons[0].tool.image.file.sy = 192;
			break;
			default:
				console.log("this shouldn't happen")
				this.mouse.tool = "pen";
				this.buttons[0].tool.image.file.sy = 0;
			break;
		};
		this.buttons[0].tool.image.file.src = "draw_tools.png";
		//this.buttons[0].tool.image.file.src = "https://barky.neocities.org/draw_tools.png";
		this.buttons[0].subtool_u.image = {
			file: new Image(),
			sx: 0,
			sy: 0,
			sw: 64,
			sh: 64,
		};
		this.buttons[0].subtool_u.image.file.src = "draw_subtoolcontrol.png";
		//this.buttons[0].subtool_u.image.file.src = "https://barky.neocities.org/draw_subtoolcontrol.png";
		temp = ["sizedown", "sizeup", "undo", "redo", "page"];
		for(i1 = 0; i1 < temp.length; i1++) {
			this.buttons[0][temp[i1]].image = {
				file: new Image(),
				sx: 0,
				sy: 32*i1,
				sw: 32,
				sh: 32,
			};
			this.buttons[0][temp[i1]].image.file.src = "draw_etc.png";
			//this.buttons[0][temp[i1]].image.file.src = "https://barky.neocities.org/draw_etc.png";
		}
		// page 0 image defining
		for(i1 = 1; i1 < this.buttons.length; i1++) {
			this.buttons[i1].page = structuredClone(this.buttons[0].page);
			delete this.buttons[i1].page.key;
			// otherwise, pressing the page key might trigger the page action
			// multiple times, for every single copy of the page button.
		}
		// create clones of page, so that it's on every page.
		this.menucorner = [x0, y0];
	};
	draw.drawbuttons = function() {
	// draws the buttons
		let i1 = "";
		this.ctx.fillStyle = "white";
		this.ctx.fillRect(this.menucorner[0], this.menucorner[1], this.drawingarea.w, this.drawingarea.h);
		this.ctx.strokeStyle = "#2f2f5f";
		let center = [null, null];
		for (i1 in this.buttons[this.page]) {
			if (
				this.buttons[this.page].hasOwnProperty(i1)
				&&
				(
					!this.buttons[this.page][i1].hasOwnProperty("hide")
					||
					!this.buttons[this.page][i1].hide
				)
			) {
				if(this.buttons[this.page][i1].hasOwnProperty("tags") && this.buttons[this.page][i1].tags.includes("palette")) {
					this.ctx.fillStyle = this.colors[Number(i1.slice(i1.indexOf("color_") + "color_".length))];
					this.ctx.fillRect(this.buttons[this.page][i1].x, this.buttons[this.page][i1].y, this.buttons[this.page][i1].w, this.buttons[this.page][i1].h);
				};
				if(this.buttons[this.page][i1].hasOwnProperty("split")) {
					/*
					center = fourpointintersect(
						this.buttons[this.page][i1].x, this.buttons[this.page][i1].y,
						this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h,
						this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y,
						this.buttons[this.page][i1].x, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h,
					);
					if(this.buttons[this.page][i1].split.includes("up")) {
						_2dPoly.draw(this.ctx, [
							[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y],
							[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y],
							center
						], "stroke", this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("down")) {
						_2dPoly.draw(this.ctx, [
							[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h],
							[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h],
							center
						], "stroke", this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("left")) {
						_2dPoly.draw(this.ctx, [
							[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h],
							[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y],
							center
						], "stroke", this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("right")) {
						_2dPoly.draw(this.ctx, [
							[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y],
							[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h],
							center
						], "stroke", this.scale);
					};
					//*/
					this.ctx.fillStyle = "#2f2f5f";
					if(this.buttons[this.page][i1].split.includes("up")) {
						this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y - this.scale, this.buttons[this.page][i1].w + 2*this.scale, 2*this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("down")) {
						this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h - this.scale, this.buttons[this.page][i1].w + 2*this.scale, 2*this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("left")) {
						this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y - this.scale, 2*this.scale, this.buttons[this.page][i1].h + 2*this.scale);
					};
					if(this.buttons[this.page][i1].split.includes("right")) {
						this.ctx.fillRect(this.buttons[this.page][i1].x + this.buttons[this.page][i1].w - this.scale, this.buttons[this.page][i1].y - this.scale, 2*this.scale, this.buttons[this.page][i1].h + 2*this.scale);
					};
				}
				else {
					/*
					_2dPoly.draw(this.ctx, [
						[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y],
						[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y],
						[this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h],
						[this.buttons[this.page][i1].x, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h]
					], "stroke", this.scale);
					//*/
					this.ctx.fillStyle = "#2f2f5f";
					this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y - this.scale, this.buttons[this.page][i1].w + 2*this.scale, 2*this.scale);
					this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h - this.scale, this.buttons[this.page][i1].w + 2*this.scale, 2*this.scale);
					this.ctx.fillRect(this.buttons[this.page][i1].x - this.scale, this.buttons[this.page][i1].y - this.scale, 2*this.scale, this.buttons[this.page][i1].h + 2*this.scale);
					this.ctx.fillRect(this.buttons[this.page][i1].x + this.buttons[this.page][i1].w - this.scale, this.buttons[this.page][i1].y - this.scale, 2*this.scale, this.buttons[this.page][i1].h + 2*this.scale);
				};
				//*
				if(this.buttons[this.page][i1].hasOwnProperty("image")) {
					/*
					this.ctx.drawImage(
						this.buttons[this.page][i1].image.file,
						this.buttons[this.page][i1].image.sx,
						this.buttons[this.page][i1].image.sy,
						this.buttons[this.page][i1].image.sw,
						this.buttons[this.page][i1].image.sh,
						this.buttons[this.page][i1].x,
						this.buttons[this.page][i1].y,
						this.buttons[this.page][i1].w,
						this.buttons[this.page][i1].h
					);
					//*/
					// this causes a domexception error, says anything that
					// involves undodata is insecure.
					// - the reason for this is the "same-origin policy"; a
					//   script may access the data of a second webpage, but
					//   only if they share a common origin.
					// - and apparently, existing in the same folder does not
					//   count as sharing a common origin.
					// - i saw someone say you can get around this by using a
					//   dropbox (somehow????? why the fuck is that good enough
					//   but an actual shared origin isn't????) so i uploaded
					//   the images to neocities. they do not display, but they
					//   don't cause domexception errors either.
					// - maybe it'll work when i upload it! i don't give a shit
					//   though! i don't want to upload it! i don't want to do
					//   all my programming in a fairly basic ide that's just
					//   meant for styling!
					//   - also the procedural animation is a fucking mess and
					//     totally unfinished. needta make that into functions
					//     or something first.
				};
				//*/
			};
		}
		// for now, i'm just gonna draw the outlines... i don't feel like
		// learning drawImage right now.
	};
	draw.checkbutton = function(keyboardevent) {
	// returns the string of the button clicked
	// - keyboardevent: this should be a KeyboardEvent. if there's a value here,
	//   it'll assume this function was run by the keyboard event listeners
	//   instead of the mouse event listeners.
		let i1 = "";
		let i2 = "";
		let i0 = null;
		let temp = 0;
		if(keyboardevent) {
			let key = keyboardevent.key;
			if(key.length === 1 && key.charCodeAt(0) >= 65 && key.charCodeAt(0) < 91) {
				key = key.toLowerCase();
			};
			// if it's a capital letter, make it lowercase. (whether is is or isn't
			// capital doesn't matter, e.shiftKey is the only thing that could be
			// relevant.)
			for(i0 = 0; i0 < this.buttons.length; i0++) {
			// search every page
				for (i1 in this.buttons[i0]) {
					if (
						this.buttons[i0].hasOwnProperty(i1)
						&&
						this.buttons[i0][i1].hasOwnProperty("key")
					) {
						if(this.buttons[i0][i1].key.slice(0, "ctrl + ".length) === "ctrl + ") {
							if(this.buttons[i0][i1].key.slice("ctrl + ".length) === key && keyboardevent.ctrlKey) {
								return i1;
							};
						}
						else if(this.buttons[i0][i1].key === key) {
							return i1;
						};
					};
				}
			}
		}
		else {
			for (i1 in this.buttons[this.page]) {
				if (
					this.buttons[this.page].hasOwnProperty(i1)
					&&
					withinrect(this.mouse.x, this.mouse.y, this.buttons[this.page][i1])
				) {
				// the click is within this button.
					if(this.buttons[this.page][i1].hasOwnProperty("split")) {
						temp = fourpointintersect(
							this.buttons[this.page][i1].x, this.buttons[this.page][i1].y,
							this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h,
							this.buttons[this.page][i1].x + this.buttons[this.page][i1].w, this.buttons[this.page][i1].y,
							this.buttons[this.page][i1].x, this.buttons[this.page][i1].y + this.buttons[this.page][i1].h,
						);
						temp = get2dangle(this.mouse.x - temp[0], this.mouse.y - temp[1], true);
						// angle relative to center of button
						if(temp === null) {
						// click is right in the center
							return i1;
						}
						temp = posmod(Math.round(temp/(Math.PI/2)), 4);
						temp = ["right", "down", "left", "up"][temp];
						if(this.buttons[this.page][i1].split.includes(temp)) {
							return i1;
						};
					}
					else {
						return i1;
					};
				}; // for if
			} // for
		} // else
		return "none";
	};
	draw.buttonaction = function(e, iskeyboardevent) {
	// there's two places this runs:
	// - ui mouse click: key is not specified, so checkbutton checks mouse x/y
	//   to figure out what the key is
	// - keyboard event: checkbutton just uses the keyboard event directly
	// - arguments
	//   - e: event. used to check if the ctrl button was held or whatever.
	//   - iskeyboardevent: determines how it runs checkbutton
		let action = null;
		let inversion = !!e.shiftKey;
		// if the shift key is held while pressing the tool/subtool selection
		// keys, or if the tool/subtool buttons are right-clicked, it's supposed
		// to select an inverse. this stores if there was a shift or right
		// click.
		// boolean storing if the shift
		this.clearclip();
		// allow drawing anywhere (since graphical ui-changy stuff will require that)
		if(iskeyboardevent) {
			action = this.checkbutton(e);
		}
		else {
			action = this.checkbutton();
			if(e.button === 2 || e.button === 1) {
				inversion = true;
			};
		};
		//console.log(action);
		if(action === "none") {
			// don't do anything
		}
		else if(this.buttons[this.page][action].hasOwnProperty("tags")) {
			if(this.buttons[this.page][action].tags.includes("palette")) {
				this.misc.rainbowmode = false;
				let temp = invertboolean( invertboolean(true, this.mouse.tool === "eraser") , inversion);
				temp = (temp ? "color1" : "color2");
				// change color1, unless you're using the eraser. change the
				// other color if inversion is on.
				this[temp] = Number(action.slice(action.indexOf("colors_") + "colors_".length));
				//this.colorselectgraphic();
			}
			else if(this.buttons[this.page][action].tags.includes("subtool")) {
				if(action === "subtool_r") {
					this.mouse.subtool[this.mouse.tool]++;
					// cycle up in the array where the subtools are stored
				}
				else if(action === "subtool_l") {
					this.mouse.subtool[this.mouse.tool] += this[this.mouse.tool].length - 1;
				}
				else if(action === "subtool_u") {
					this.mouse.subtool[this.mouse.tool] += this[this.mouse.tool].length - 4;
				}
				else if(action === "subtool_d") {
					this.mouse.subtool[this.mouse.tool] += 4;
				};
				this.mouse.subtool[this.mouse.tool] %= this[this.mouse.tool].length;
				if(inversion) {
					this.mouse.inversion[this.mouse.tool] = true;
				}
				else {
					this.mouse.inversion[this.mouse.tool] = false;
				};
				this.subtooltext();
				//console.log([this.mouse.clicktype, this.mouse.tool, this[this.mouse.tool][this.mouse.subtool[this.mouse.tool]].name].join(", "));
				// good night, sweet prince. i finally don't need you,
			};
		}
		else if(action === "tool") {
			let temp = ["pen", "paint", "eraser"];
			this.mouse.tool = temp[(temp.indexOf(this.mouse.tool) + 1)%temp.length];
			if(inversion) {
				this.mouse.inversion[this.mouse.tool] = true;
			}
			else {
				this.mouse.inversion[this.mouse.tool] = false;
			};
			this.subtooltext();
			//console.log([this.mouse.clicktype, this.mouse.tool, this[this.mouse.tool][this.mouse.subtool[this.mouse.tool]].name].join(", "));
			// TODO change icon
		}
		else if(["sizedown", "sizeup"].includes(action)) {
			let temp = invertboolean( invertboolean(true, this.mouse.tool === "pen") , inversion);
			temp = (temp ? "paintsize" : "pensize");
			// in other words, modify paintsize. but if the current tool is pen,
			// modify pensize instead. but if inversion is on, modify the other
			// size instead.
			this[temp] = Math.max(this[temp] + (action === "sizedown" ? -1 : action === "sizeup" ? 1 : 0), 1);
			// decrease by one, but don't go below one.
			this.subtooltext();
		}
		else if(action === "undo") {
			this.undo();
		}
		else if(action === "redo") {
			this.redo();
		}
		else if(action === "rainbow") {
			if(draw.misc.rainbowmode || draw.misc.epilepsywarning) {
				this.misc.rainbowmode = !this.misc.rainbowmode;
			}
			else {
			// safety first kiddos
			// - good thing prompt is so easy to use. it'd be a real pain in
			//   the ass to make a system for creating prompts in canvas.
			// - then again, maybe i'll have to do that eventually anyway.
				let temp = prompt(draw.misc.epilepsytext);
				if(temp === "yes") {
					this.misc.rainbowmode = !this.misc.rainbowmode;
					draw.misc.epilepsywarning = true;
					// turn off photosensitivity warnings
				};
			};
		}
		else if(action === "changerainbow") {
			let input = prompt(`type a list of color indexes, separated by spaces. the rainbow mode will shift through those instead. (type "pong" at the beginning to make it pingpong between the beginning and end colors, and type "reset" to use the default rainbow.)`);
			if(input) {
				input = removewhitespace(input);
				let pingpong = input[0] === "pong";
				if(pingpong) {
					input.splice(0, 1);
				}
				if(input.length === 1 && input[0] === "reset") {
					this.createrainbow();
				}
				else if(input.length > 1) {
					let i1 = 0;
					let error = false;
					for(i1 = 0; i1 < input.length; i1++) {
						input[i1] = Number(input[i1]);
						if(!Number.isInteger(input[i1]) || input[i1] < 0 || input[i1] >= this.colors.length) {
							alert("invalid index.");
							error = true;
							i1 += input.length;
						};
					}
					if(!error) {
						if(pingpong) {
							for(i1 = input.length - 2; i1 >= 1; i1--) {
								input[input.length] = input[i1];
							}
						}
						this.misc.rainbow = structuredClone(input);
					};
				}
				else {
					alert("invalid input.");
				};
			}
		}
		else if(action === "colorchange") {
			let input = prompt("type a palette number, a colon, and a color to change the color of that palette slot. (you can input multiple colors by separating them with asterisks.)");
			if(input) {
				input = removewhitespace(input, "").split("*");
				let i1 = 0;
				let index = -1;
				for(i1 = 0; i1 < input.length; i1++) {
					index++;
					index %= this.colors.length;
					let temp = input[i1].indexOf(":");
					if(temp !== -1) {
						let num = Number(input[i1].slice(0, temp));
						input[i1] = input[i1].slice(temp + 1);
						if(Number.isInteger(num) && 0 <= num && num < this.colors.length) {
							index = num;
						};
					};
					this.colors[index] = input[i1].trim();
				}
				this.drawbuttons();
				this.subtooltext();
			};
		}
		else if(action === "colorstrings") {
			let text = structuredClone(this.colors);
			let i1 = 0;
			for(i1 = 0; i1 < text.length; i1++) {
				text[i1] = i1 + ": " + text[i1];
			};
			alert("the current palette is:" + String.fromCharCode(10) + text.join(" *" + String.fromCharCode(10)));
		}
		else if(action === "page") {
		};
	};
	draw.colorselectgraphic = function() {
	// draws a border around the colors that you have selected as color1 and
	// color2.
		this.ctx.putImageData(this.buttons.colors.image, this.buttons.colors.x, this.buttons.colors.y);
		// erase whatever selection borders were there before
		let temp = {
			r: Math.floor(this.buttons.colors.w/16),
			// diameter is half of one subbutton
			margin: Math.floor(this.buttons.colors.w/32),
			// an eighth of one subbutton
		};
		this.ctx.fillStyle = "#ffdfbf";
		circledraw(this.ctx, this.buttons.colors.sub[this.color2].x + this.buttons.colors.sub[this.color2].w - (temp.r + temp.margin) + 1, this.buttons.colors.sub[this.color2].y + this.buttons.colors.sub[this.color2].h - (temp.r + temp.margin) + 1, temp.r, true);
		this.ctx.fillStyle = "white";
		circledraw(this.ctx, this.buttons.colors.sub[this.color2].x + this.buttons.colors.sub[this.color2].w - (temp.r + temp.margin), this.buttons.colors.sub[this.color2].y + this.buttons.colors.sub[this.color2].h - (temp.r + temp.margin), temp.r, true);
		this.ctx.fillStyle = "#2f2f5f";
		circledraw(this.ctx, this.buttons.colors.sub[this.color1].x + temp.r + temp.margin + 1, this.buttons.colors.sub[this.color1].y + temp.r + temp.margin + 1, temp.r, true);
		this.ctx.fillStyle = "black";
		circledraw(this.ctx, this.buttons.colors.sub[this.color1].x + temp.r + temp.margin, this.buttons.colors.sub[this.color1].y + temp.r + temp.margin, temp.r, true);
		/*
		if(this.color1 === this.color2) {
			this.ctx.strokeStyle = "#ffdfbf";
			this.ctx.drawborder(this.buttons.colors.sub[this.color1].x, this.buttons.colors.sub[this.color1].y, this.buttons.colors.sub[this.color1].w, this.buttons.colors.sub[this.color1].h, 3);
			this.ctx.strokeStyle = "#2f2f5f";
			this.ctx.fillStyle = "black";
			this.ctx.drawborder(this.buttons.colors.sub[this.color1].x + 1, this.buttons.colors.sub[this.color1].y + 1, this.buttons.colors.sub[this.color1].w - 1, this.buttons.colors.sub[this.color1].h - 1, 2, 1);
		}
		else {
			this.ctx.strokeStyle = "#ffdfbf";
			this.ctx.fillStyle = "white";
			this.ctx.drawborder(this.buttons.colors.sub[this.color2].x, this.buttons.colors.sub[this.color2].y, this.buttons.colors.sub[this.color2].w, this.buttons.colors.sub[this.color2].h, 3, -2);
			this.ctx.strokeStyle = "#2f2f5f";
			this.ctx.fillStyle = "black";
			this.ctx.drawborder(this.buttons.colors.sub[this.color1].x, this.buttons.colors.sub[this.color1].y, this.buttons.colors.sub[this.color1].w, this.buttons.colors.sub[this.color1].h, 3, 2);
		};
		//*/
	};
	draw.subtooltext = function() {
		this.ctx.textBaseline = "bottom";
		let temp = [];
		let i1 = 0;
		this.clearclip();
		this.ctx.font = "16px 'fomp2'";
		for(i1 = 0; i1 < 2; i1++) {
			temp[0] = "subtool" + ["number", "name"][i1];
			// the lengths i go for DRY.
			if(this.buttons[this.page].hasOwnProperty(temp[0])) {
				// if the ui is on the page the subtool number/name display is on,
				this.clearclip();
				this.rect = new Path2D();
				this.rect.rect(this.buttons[this.page][temp[0]].x + 1, this.buttons[this.page][temp[0]].y + 1, this.buttons[this.page][temp[0]].w - 2, this.buttons[this.page][temp[0]].h - 2);
				// the top row is part of the boxes of the buttons above it
				this.ctx.clip(this.rect);
				// make sure it doesn't go out of bounds
				if(i1 === 1 && this.mouse.inversion[this.mouse.tool]) {
					this.ctx.fillStyle = "black";
					this.ctx.fillRect(this.buttons[this.page][temp[0]].x + 1, this.buttons[this.page][temp[0]].y + 1, this.buttons[this.page][temp[0]].w - 2, this.buttons[this.page][temp[0]].h - 2);
					// clear it
					this.ctx.fillStyle = "white";
				}
				else {
					this.ctx.fillStyle = "white";
					this.ctx.fillRect(this.buttons[this.page][temp[0]].x + 1, this.buttons[this.page][temp[0]].y + 1, this.buttons[this.page][temp[0]].w - 2, this.buttons[this.page][temp[0]].h - 2);
					// clear it
					this.ctx.fillStyle = "#2f2f5f";
				};
				if(i1 === 0) {
					temp[1] = this.mouse.subtool[this.mouse.tool];
					// the number index
					temp[1] = numalign([temp[1], Math.max(this.pen.length, this.paint.length, this.eraser.length) - 1])[0];
					// makes sure it has whatever number of spaces will make
					// the ones digit in the same place every time
					temp[1] = this.mouse.tool + " ".repeat(6 - this.mouse.tool.length) + " " + temp[1];
					temp[1] += " " + numalign([this.mouse.tool === "pen" ? this.pensize : this.paintsize, 100])[0] + "px";
				}
				else if(i1 === 1) {
					temp[1] = this[this.mouse.tool][ this.mouse.subtool[this.mouse.tool] ].name;
				};
				//console.log(temp.join(": "));
				this.ctx.fillText(
					temp[1],
					this.buttons[this.page][temp[0]].x + 2,
					this.buttons[this.page][temp[0]].y + this.buttons[this.page][temp[0]].h - 1
				);
			};
		};
		this.ctx.fillStyle = (this.mouse.inversion[this.mouse.tool] ? "white" : "#2f2f5f");
		let grid = {
			ref: this.buttons[this.page].subtoolname,
		};
		grid.x = grid.ref.x + grid.ref.w - 1;
		grid.y = grid.ref.y + 2;
		grid.scale = 2;
		grid.rowwidth = 4;
		grid.maxrows = Math.floor((grid.ref.y + grid.ref.h - grid.y - 1)/grid.scale) + 1;
		grid.numofgroups = Math.ceil(Math.ceil(this[this.mouse.tool].length/grid.rowwidth)/grid.maxrows);
		for(i1 = 0; i1 < this[this.mouse.tool].length; i1++) {
			let row = Math.floor(i1/grid.rowwidth);
			let col = i1%grid.rowwidth;
			let group = Math.floor(row/grid.maxrows);
			row %= grid.maxrows;
			let coor = [
				grid.x + grid.scale*(-grid.rowwidth + col),
				grid.y + grid.scale*row
			];
			coor[0] += grid.scale*(group - (grid.numofgroups - 1))*(grid.rowwidth + 1);
			if(i1 === this.mouse.subtool[this.mouse.tool]) {
				this.ctx.fillRect(coor[0] - 1, coor[1] - 1, 3, 3);
			}
			else {
				this.ctx.fillRect(coor[0], coor[1], 1, 1);
			}
		}
		this.ctx.textBaseline = "alphabetic";
		this.clearclip();
		// allow it to draw anywhere again
		//
		// i can't figure this out at all, what the fuuuuck
		// - i'm debugging this and i just don't get why the second line doesn't
		//   write. the text is right, the fillStyle is right, the dimensions
		//   and positions are right, i just don't get it...
		//   - well for one thing the clip needs to be saved and restored, not
		//     redefined
		// - you would think the way this works is:
		//   - save() before any paths are defined
		//   - .restore() every time you're about to define a path, to be sure
		//     it's a blank slate first
		//   - define path, clip
		//   - draw
		//   - restore()
		//   =
		//   - but that doesn't work and i can't even begin to wrap my head
		//     around where it breaks since this shit carries over from one
		//     thing to another to another...
		// - also i just learned .save() and .restore() save things like
		//   fillStyle and strokeStyle too, so i'm gonna need an alternative
		//   approach
	};
	draw.clearclip = function() {
	// - for some reason mdn neglects to mention that it doesn't just clear
	//   the settings but also the image. could not tell you why.
	// - or, for that matter, why i cannot find the data for the current clip
	//   region anywhere in the context properties. that'd make all of this a
	//   lot more simple.
		let canvastemp = {};
		let i1 = "";
		for (i1 in this.ctx) {
			if (["string", "number", "boolean"].includes(typeof this.ctx[i1])) {
			// forgoing "this.ctx.hasOwnProperty(i1)" because things specific to
			// it being a canvas context (ie fillStyle, shit like that. what i'm
			// trying to save.) don't count
				canvastemp[i1] = this.ctx[i1];
			};
		}
		// saves all the simple data, avoids stuff like the object references
		// and class methods. font, fillStyle, strokeStyle, etc
		let imagetemp = this.ctx.getImageData(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
		this.ctx.reset();
		for (i1 in canvastemp) {
			if (canvastemp.hasOwnProperty(i1)) {
				this.ctx[i1] = canvastemp[i1];
			};
		}
		this.ctx.putImageData(imagetemp, 0, 0);
		// restore everything
	}
	draw.ready = function(skipclearing) {
	// makes sure everything's ready for the user to start drawing.
		this.clearclip();
		this.rect = new Path2D();
		// creates a path
		this.rect.rect(this.drawingarea.x, this.drawingarea.y, this.drawingarea.w, this.drawingarea.h);
		// path method that makes it a rectangle
		this.ctx.clip(this.rect);
		// canvas method that makes it only draw within that area
		let color = (this.mouse.tool === "eraser" ? this.colors[this.color2] : this.colors[this.color1]);
		color = Color.rgb(this.ctx, color);
		color[color.length] = 1;
		color = "rgba(" + color.join() + ")";
		this.ctx.fillStyle = color;
		this.ctx.strokeStyle = color;
		/*
		for(i1 = 0; i1 < this.mouse.numofpositions; i1++) {
			this.mouse.oldx[i1] = null;
			this.mouse.oldy[i1] = null;
		}
		//*/
		if(!skipclearing) {
			draw.mouse.oldx = [];
			draw.mouse.oldy = [];
			// this needs to be cleared so it doesn't keep around positions from the
			// previous stroke.
		};
	};
	draw.setmousecoor = function(e) {
		this.mouse.oldx.splice(0, 0, this.mouse.x);
		this.mouse.oldy.splice(0, 0, this.mouse.y);
		//this.mouse.oldx.splice(this.mouse.numofpositions, 1);
		//this.mouse.oldy.splice(this.mouse.numofpositions, 1);
		// add something new to the beginning, shift up
		let click = clickxy(e, "draw");
		this.mouse.x = click[0];
		this.mouse.y = click[1];
	};
	draw.undo = function() {
		if(this.undoindex + 1 < this.undodata.length) {
			this.undoindex += 1;
			this.ctx.putImageData(this.undodata[this.undoindex], this.drawingarea.x, this.drawingarea.y);
		};
		//console.log("undoindex: " + this.undoindex);
	};
	draw.redo = function() {
		if(this.undoindex > 0) {
			this.undoindex -= 1;
			this.ctx.putImageData(this.undodata[this.undoindex], this.drawingarea.x, this.drawingarea.y);
		};
		//console.log("undoindex: " + this.undoindex);
	};
	draw.pen = [
	// array of subtools, storing names and functions.
	// - the down/move/up functions are always run with draw and the inversion
	//   boolean as parameters, so keep that in mind if you create any special
	//   arguments for internal use.
	// - other properties:
	//   - epilepsy: brushes that redraw enough to seem kind of dangerous if
	//     rainbow mode is on. draw.mousemove will prompt the user before
	//     they're allowed to use it.
		{
			name: "basic",
			move: function(draw, inversion) {
				//nonaaline(draw.ctx, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, (inversion ? draw.paintsize : draw.pensize));
				linespecial(function(x, y, progress) {
					circledraw(draw.ctx, x, y, 2*(inversion ? draw.paintsize : draw.pensize) - 1.5, true);
				}, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y);
			},
		},
		{
			name: "scratchy A",
			move: function(draw, inversion) {
				// this is fun as hell when you go back 10 positions, but maybe
				// that's overdoing it a little.
				// - not sure whether to go with 3 or 5.
				// - 5 looks kinda like, uh... palm from hunter x hunter's hair?
				//   weird. messy. wiry. it's possible to get the geometric,
				//   net-shaped stuff from higher levels if you go fast enough.
				// - 3 looks more stable, but...
				// - ah fuck it both are prone to getting wonky at times. it
				//   looks better with 5 because the change isn't sudden.
				let temp = (inversion ? 10 : 5);
				if(draw.mouse.oldx[temp - 1] !== null && draw.mouse.oldy[temp - 1] !== null) {
					nonaaline(draw.ctx, draw.mouse.oldx[temp - 1], draw.mouse.oldy[temp - 1], draw.mouse.x, draw.mouse.y, draw.pensize);
				};
				//draw.ctx.strokeStyle = draw.colors[draw.color2];
				//temp = 3;
				//if(draw.mouse.oldx[temp - 1] !== null && draw.mouse.oldy[temp - 1] !== null) {
				//	nonaaline(draw.ctx, draw.mouse.oldx[temp - 1], draw.mouse.oldy[temp - 1], draw.mouse.x, draw.mouse.y);
				//};
				//draw.ctx.strokeStyle = draw.colors[draw.color1];
			},
		},
		{
			name: "scratchy B",
			move: function(draw) {
				let numoflines = 3;
				let variation = 4;
				let positionsback = 1;
				let condensefactor = 3;
				//
				let rand = [];
				let i1 = 0;
				//nonaaline(draw.ctx, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.pensize);
				if(draw.mouse.oldx[positionsback] !== null && draw.mouse.oldy[positionsback] !== null) {
					for(i1 = 0; i1 < numoflines; i1++) {
						rand = [
							Math.trunc(randexponent(condensefactor, true)*(variation + 1)),
							Math.trunc(randexponent(condensefactor, true)*(variation + 1))
						];
						nonaaline(draw.ctx, draw.mouse.oldx[positionsback] + rand[0], draw.mouse.oldy[positionsback] + rand[1], draw.mouse.x + rand[0], draw.mouse.y + rand[1], draw.pensize);
					}
				};
				// TODO: use strokedata to make it use random numbers from last
				// time?
				// - specifically, for every numoflines, a line is created that
				//   randomly varies from the previous in a new way.
				// - each random position is built off of the last.
				// 3312
			},
		},
		{
			name: "spray paint",
			move: function(draw, inversion) {
				let numofsprays = (inversion ? 2 : 1)*4;
				// this is how many spray thingies are made between mousemove
				// positions. make this higher, and the line gets smoother but
				// also denser.
				let numofdots = (inversion ? 2 : 1)*16/((8**2)*Math.PI);
				// the same ratio of dots per area as 16 dots in a radius of 8
				let sprayradius = draw.paintsize;
				numofdots *= (sprayradius**2) * Math.PI;
				// multiply by area
				let condensefactor = (inversion ? 4 : 2);
				//
				let spray_x = 0;
				let spray_y = 0;
				// temps for storing the center of the current spray
				let temp = null;
				for(i1 = 1; i1 <= numofsprays; i1++) {
					spray_x = Math.floor(draw.mouse.oldx[0] + (draw.mouse.x - draw.mouse.oldx[0])*i1/numofsprays);
					spray_y = Math.floor(draw.mouse.oldy[0] + (draw.mouse.y - draw.mouse.oldy[0])*i1/numofsprays);
					for(i2 = 0; i2 < numofdots; i2++) {
						temp = [
							randexponent(condensefactor)*sprayradius,
							Math.random()*2*Math.PI
						];
						temp = [
							Math.trunc(temp[0]*Math.cos(temp[1])),
							Math.trunc(temp[0]*Math.sin(temp[1]))
						];
						circledraw(
							draw.ctx,
							spray_x + temp[0],
							spray_y + temp[1],
							draw.pensize/2,
							true,
						);
						/*
						draw.ctx.fillRect(
							spray_x + Math.trunc(randexponent(condensefactor, true)*(sprayradius + 1)),
							spray_y + Math.trunc(randexponent(condensefactor, true)*(sprayradius + 1)),
							1,
							1
						);
						//*/
						// the +1 is so the range is 0 and radius, instead of 0
						// and radius - 1.
					}
				}
				// nailed the settings on my first try. wow.
				// - that said, this should scale based on... i dunno, i guess
				//   the paint size? which i want to be variable.
			},
		},
		{
			name: "smear",
			down: function(draw, inversion) {
				let numofdots = 16/((8**2)*Math.PI);
				// proper ratio of dots per area.
				let smearradius = .5*draw.paintsize;
				numofdots *= (smearradius**2) * Math.PI;
				// multiply by area
				if(inversion) {
					numofdots *= 2;
				};
				draw.mouse.strokedata = [];
				for(i1 = 0; i1 < numofdots; i1++) {
					draw.mouse.strokedata[draw.mouse.strokedata.length] = [
						Math.trunc(randexponent(1, true)*(smearradius + 1)),
						Math.trunc(randexponent(1, true)*(smearradius + 1))
					];
				}
			},
			move: function(draw) {
				draw.ctx.lineexecute(draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, 8, function(context, x, y, weight) {
					let i1 = 0;
					for(i1 = 0; i1 < draw.mouse.strokedata.length; i1++) {
						circledraw(
							draw.ctx,
							Math.floor(x + draw.mouse.strokedata[i1][0]),
							Math.floor(y + draw.mouse.strokedata[i1][1]),
							draw.pensize/2,
							true,
						);
						//context.fillRect(Math.floor(x + draw.mouse.strokedata[i1][0]), Math.floor(y + draw.mouse.strokedata[i1][1]), 1, 1);
					}
				}, true);
				// hmmmm.
				// - the way i wanted it was that the smear array is created at
				//   mousedown, and remains the same the whole stroke
				//   - it's 4am and i am not doing that.
				// - but this does look sort neat in its own right. it might be
				//   able to replace the heavier version of spray i was
				//   considering? but that'd probably mean i'd have to give up
				//   on what i wanted before, unless i can differentiate them
				//   somehow.
				// - eh. i dunno how good this looks. it looks amateurish, and
				//   not in a good way... like the kind of thing that looks
				//   "neat" but not good or actually useful
				// -
				// - i finished it. it looks very nice. it'd be good for
				//   imitating a paintbrush, or texturing something like wood
			},
		},
		{
			name: "boxy",
			move: function(draw) {
				if(Math.abs(draw.mouse.oldx[0] - draw.mouse.x) > Math.abs(draw.mouse.oldy[0] - draw.mouse.y)) {
					draw.mouse.y = draw.mouse.oldy[0];
				}
				else {
					draw.mouse.x = draw.mouse.oldx[0];
				};
				nonaaline(draw.ctx, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.pensize);
			},
		},
		{
			name: "octo",
			move: function(draw) {
				let roundfactor = 8;
				//
				let dist = Math.hypot(draw.mouse.x - draw.mouse.oldx[0], draw.mouse.y - draw.mouse.oldy[0]);
				let angle = get2dangle(draw.mouse.x - draw.mouse.oldx[0], draw.mouse.y - draw.mouse.oldy[0], true);
				let anglechange = 0;
				let oldx = null;
				let oldy = null;
				if(draw.mouse.strokedata === null) {
					oldx = Math.round(draw.mouse.oldx[0]/roundfactor)*roundfactor;
					oldy = Math.round(draw.mouse.oldy[0]/roundfactor)*roundfactor;
				}
				else {
					oldx = draw.mouse.strokedata[1];
					oldy = draw.mouse.strokedata[2];
				};
				let newx = draw.mouse.x;
				let newy = draw.mouse.y;
				if(angle !== null) {
					angle /= 2*Math.PI;
					angle = Math.round(angle*8)%8;
					if(draw.mouse.strokedata !== null) {
						anglechange = angle - draw.mouse.strokedata[0];
						if(Math.abs(anglechange) > 4) {
							anglechange *= -1;
						};
						if(anglechange < 0) {
							angle = posmod(draw.mouse.strokedata[0] - 1, 8);
						}
						else if(anglechange > 0) {
							angle = posmod(draw.mouse.strokedata[0] + 1, 8);
						}
						else if(anglechange === 0) {
							angle = draw.mouse.strokedata[0];
						}
						else {
							console.log("this shouldn't happen");
						};
					};
					draw.mouse.strokedata = [];
					draw.mouse.strokedata[0] = angle;
					// store it for the next line to check, a number from 0 to 7
					angle *= 2*Math.PI/8;
					// turn it into a 1/8 angle
					newx = oldx + Math.round(dist*Math.cos(angle)/roundfactor)*roundfactor;
					newy = oldy + Math.round(dist*Math.sin(angle)/roundfactor)*roundfactor;
					draw.mouse.strokedata[1] = newx;
					draw.mouse.strokedata[2] = newy;
					// make sure the angle is whatever the closest 1/8 angle is,
					// and round it to the nearest %2 === 0 position.
				}
				nonaaline(draw.ctx, oldx, oldy, newx, newy, draw.pensize);
				// unfinished. it goes totally haywire. i think i get what the
				// problem is though.
				// - all it is is the draw.mouse.x/y redefinings piling up until
				//   the place where you're actually moving the mouse and the
				//   place it thinks the mouse is are totally different.
				// - i'm gonna have to make it so it modifies new variables
				//   based on draw.mouse.x/y and oldx/y, and has nonaaline use
				//   that while the originals remain unchanged.
			},
		},
		{
			name: "sunset",
			move: function(draw, inversion) {
				let blobw = (inversion ? draw.pensize : draw.paintsize);
				let blobh = (inversion ? draw.paintsize : draw.pensize);
				let positionsback = 16;
				//
				let i1 = 0;
				for(i1 = 0; i1 < positionsback; i1++) {
					if((draw.mouse.oldx[positionsback - i1] || draw.mouse.oldx[positionsback - i1] === 0) && (draw.mouse.oldy[positionsback - i1] || draw.mouse.oldy[positionsback - i1] === 0)) {
					// skip this position if it's nullish
						draw.ctx.lineexecute(draw.mouse.oldx[positionsback - i1], draw.mouse.oldy[positionsback - i1], draw.mouse.oldx[positionsback - (i1 + 1)], draw.mouse.oldy[positionsback - (i1 + 1)], (positionsback - i1 + 1)/(positionsback + 1), function(context, x, y, weight) {
							circledraw(context, x, y, [Math.ceil(weight*blobw/2), Math.ceil(weight*blobh/2)], true);
						}, true);
					};
				}
				if((draw.mouse.oldx[0] || draw.mouse.oldx[0] === 0) && (draw.mouse.oldy[0] || draw.mouse.oldy[0] === 0)) {
					draw.ctx.lineexecute(draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, 1/positionsback, function(context, x, y, weight) {
						circledraw(context, x, y, [Math.ceil(weight*blobw/2), Math.ceil(weight*blobh/2)], true);
					}, true);
				};
				// draws with an elliptical particle, but for the last 5
				// positions the particle is smaller
			},
		},
		{
			name: "stroke",
			move: function(draw) {
				nonaaline(draw.ctx, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.paintsize + 2*draw.pensize);
			},
			up: function(draw) {
				let i1 = 0;
				draw.ctx.strokeStyle = draw.colors[draw.color2];
				for(i1 = Math.min(draw.mouse.oldx.length, draw.mouse.oldy.length) - 1; i1 > 0; i1--) {
					nonaaline(draw.ctx, draw.mouse.oldx[i1], draw.mouse.oldy[i1], draw.mouse.oldx[i1 - 1], draw.mouse.oldy[i1 - 1], draw.paintsize);
				}
				nonaaline(draw.ctx, draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.paintsize);
				draw.ctx.strokeStyle = draw.colors[draw.color1];
			},
		},
		{
			name: "diamond dots",
			move: function(draw) {
				let i0 = 0;
				let i1 = 0;
				let i2 = 0;
				let grid = 4;
				let sizes = [1, 2, 3, 4];
				// each iteration of i0 will increase the radius of the dots it
				// draws to this.
				let easing = "linear";
				// applied to the different radii. but apparently linear works
				// best anyway...
				//
				let temp = null;
				let radius = 0;
				// this is the radius of the area it finds dot coordinates in.
				for(i0 = 0; i0 < sizes.length; i0++) {
					radius = easingplacement(0, draw.paintsize/2, ((sizes.length - i0)/sizes.length), "out", easing);
					for(i1 = Math.floor(draw.mouse.x - radius); i1 <= Math.ceil(draw.mouse.x + radius); i1++) {
						for(i2 = Math.floor(draw.mouse.y - radius); i2 <= Math.ceil(draw.mouse.y + radius); i2++) {
							if(
								(i1%(2*grid) === 0 && i2%(2*grid) === 0)
								||
								(i1%(2*grid) === grid && i2%(2*grid) === grid)
							) {
								temp = Math.hypot(i1 - draw.mouse.x, i2 - draw.mouse.y)/radius;
								if(temp <= 1) {
									circledraw(draw.ctx, i1, i2, sizes[i0], true);
								};
							}
						}
					}
				}
			},
		},
		{
			name: "wom wom wom",
			// this one's more of a toy than anything. i guess it'd be good for
			// drawing intestines. or poop.
			down: function(draw) {
				draw.mouse.strokedata = 0;
			},
			move: function(draw, inversion) {
				let ctx = draw.ctx;
				const numofangles = 24;//*4;
				// number of different box dimensions it draws before repeating
				// itself.
				const numofboxes = 1;//*4;
				// number of boxes it draws between this position and the last.
				let r = draw.paintsize/2;
				let dist = [
					draw.mouse.x - draw.mouse.oldx[0],
					draw.mouse.y - draw.mouse.oldy[0]
				];
				let i1 = 0;
				for(i1 = 1; i1 <= numofboxes; i1++) {
					pos = [
						draw.mouse.oldx[0] + dist[0]*i1/numofboxes,
						draw.mouse.oldy[0] + dist[1]*i1/numofboxes,
					];
					draw.mouse.strokedata++;
					draw.mouse.strokedata %= numofangles;
					if(i1 > 1 && draw.misc.rainbowmode) {
						draw.advancerainbow();
					}
					let anglenum = Math.PI*(
						inversion
						?
						Math.random()
						:
						(draw.mouse.strokedata/numofangles)
					);
					anglenum = [Math.cos(anglenum), Math.sin(anglenum)];
					let rect = [
						Math.floor(pos[0] - anglenum[0]*r),
						Math.floor(pos[1] - anglenum[1]*r),
						// x, y
						Math.floor(pos[0] + anglenum[0]*r),
						Math.floor(pos[1] + anglenum[1]*r)
						// x2, y2
					];
					rect[2] -= rect[0];
					rect[3] -= rect[1];
					// w, h
					ctx.fillRect(
						rect[0],
						rect[1],
						rect[2],
						draw.pensize
					);
					// top
					ctx.fillRect(
						rect[0] + rect[2],
						rect[1],
						draw.pensize,
						rect[3]
					);
					// right
					ctx.fillRect(
						rect[0] + draw.pensize,
						rect[1] + rect[3],
						rect[2],
						draw.pensize
					);
					// bottom
					ctx.fillRect(
						rect[0],
						rect[1] + draw.pensize,
						draw.pensize,
						rect[3]
					);
					// left
				}
			},
		},
		{
			name: "motion",
			move: function(draw) {
				let ctx = draw.ctx;
				const numofpatches = 2;
				// number of patches it draws between this position and the last.
				const linesperpatch = 1;
				const positionrange = draw.paintsize/2;
				// the amount it can stray from the line between this position
				// and the last.
				const condensefactor = 1;
				// for randexponent
				const linelength = draw.paintsize;
				let dist = [
					draw.mouse.x - draw.mouse.oldx[0],
					draw.mouse.y - draw.mouse.oldy[0]
				];
				let anglenum = get2dangle(...dist, true);
				if(anglenum === null) {
					return;
				};
				anglenum = [Math.cos(anglenum), Math.sin(anglenum)];
				let i1 = 0;
				let i2 = 0;
				for(i1 = 1; i1 <= numofpatches; i1++) {
					pos = [
						draw.mouse.oldx[0] + dist[0]*i1/numofpatches,
						draw.mouse.oldy[0] + dist[1]*i1/numofpatches,
					];
					if(i1 > 1 && draw.misc.rainbowmode) {
						draw.advancerainbow();
					};
					for(i2 = 0; i2 < linesperpatch; i2++) {
						let temp = [
							Math.random()*2*Math.PI,
							positionrange*randexponent(condensefactor)
						];
						temp = [
							pos[0] + temp[1]*Math.cos(temp[0]),
							pos[1] + temp[1]*Math.sin(temp[0])
						];
						let x1 = Math.floor(temp[0] - anglenum[0]*linelength/2);
						let y1 = Math.floor(temp[1] - anglenum[1]*linelength/2);
						let x2 = Math.floor(temp[0] + anglenum[0]*linelength/2);
						let y2 = Math.floor(temp[1] + anglenum[1]*linelength/2);
						nonaaline(ctx, x1, y1, x2, y2, draw.pensize);
					}
				}
			},
		}
		/*
		{
			name: "",
			move: function(draw) {
				//
			},
		}
		//*/
		//
		// - coiling line
		// - line that has a wavy thickness
		// - smear (every stroke it picks a few random positions in a
		//   circular area then sets that to be pasted on every mousemove)
		// - spray paint (da classic) (also just really good for coloring in
		//   general)
		//   - same smear shit applies
		// - denser spray paint
		//   - i'm not gonna bother with any pen settings besides width, but
		//     two versions should be enough options.
		//   - not sure if this will mean more dots or closer positions
		//     though.
		// - hollow
		//draw.ctx.lineexecute(x1, y1, x2, y2, weight, code, true);
	];
	draw.paint = [];
	// same thing, except paint functions work a little different.
	// - there's no down, move, or up functions, all there is is a name, which
	//   can be used in the dithers global object
	// - dithers have a function that either returns true or false.
	// - you can add a boolean property, "erases", to make false results draw in
	//   color2 instead of just not drawing anything.
	// - inversions don't work how they do for pens. the modifying stuff is done
	//   in the place whether .dither is run, not here. the boolean is inverted.
	// - for the sake of consistency and avoiding redundancy and shit like that,
	//   do not create dithers that are true for more than 50% of pixels.
	// - if there's a "period" property, x will be %ed by period.x and y will be
	//   %ed by period.y. this makes logic simpler, and makes it possible to
	//   calculate how much coverage there is
	//
	// neat combinations:
	// - pythagorean + 2x2 squared
	//   - has an interesting texture to it. creates these roundish 5-pixel
	//     formations in a tilted grid of repetitions
	//   - 59/80 pixels covered, and the area before it repeats is 20x20
	// - inverted pythagorean + inverted 3x3
	//   - tesselated plusses with dotted outlines
	// - inverted triangle + inverted 3x3
	//   - 23/24, 12x12
	//   - inverted triangle, but bigger and dotted
	// - inverted pinwheel + hardware
	//   - there's like an outer grid that's sorta chewed on, and an inner grid
	//     that looks formulaic and techy
	//   - 2/3, 12x12
	//   - resembles plaid
	// - inverted sand + sierpinski
	//   - makes it look less patterny
	//   - hard to even see where it repeats, really
	// - inverted sand + inverted sierpinski
	//   - 1279/1296, (~80/81) 72x72
	//   - doesn't look very patterny
	//   - you know how sometimes combining dithers creates like a grid where
	//     the first dither breaks, so it just looks like a bunch of clusters of
	//     dither in a grid formation? this is like that, except the clusters
	//     are positioned like sand's pixels are.
	// - inverted sand + hardware
	//   - creates a grid
	// - inverted sand + inverted hardware
	// - inverted sand + pythagorean
	//   - tilted grid, except not quite, the cells aren't squares
	// - inverted sand + inverted pythagorean
	//   - same thing
	// - houndstooth + inverted sierpinski
	// - houndstooth + inverted pythagorean
	// - houndstooth + inverted 2x2 dots
	// - houndstooth + inverted 3x3 dots
	draw.eraser = [];
	draw.eraser[draw.eraser.length] = {
		name: "basic",
		move: function(draw) {
			draw.ctx.lineexecute(draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.paintsize, function(context, x, y, weight) {
				context.fillRect(Math.floor(x - weight/2), Math.floor(y - weight/2), weight, weight);
			}, true);
		},
	};
	draw.initialize = function() {
	// does all the stuff that starts it up. except defining functions i guess.
	// - this doesn't have to be a function, but there was a problem i thought
	//   it'd solve, and i figure it's better to have everything neatly wrapped
	//   in one anyway.
		for (i1 in dithers) {
			if (dithers.hasOwnProperty(i1)) {
				draw.paint[draw.paint.length] = {
					name: i1,
				};
				//if(["noise .78125%", "noise 25%", "noise 50%"].includes(i1)) {
				if(dithers[i1].hasOwnProperty("erases") && dithers[i1].erases) {
					draw.paint[draw.paint.length - 1].erases = true;
				};
			}
		}
		let temp = [];
		temp[0] = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
		temp[1] = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
		// this should get the dimensions of the screen.
		if(temp[1] > temp[0]) {
			this.menuorientation = "vertical";
		}
		else {
			this.menuorientation = "horizontal";
		};
		document.write("<br><canvas id='draw_canvas' alt='canvas of a simple drawing app.' width=1 height=1></canvas>");
		// dimensions will be set by .createbuttons
		this.ctx = document.getElementById("draw_canvas").getContext("2d");
		//this.ctx.save();
		// this saves the clip data, so i can restore() it back to being able to
		// draw anywhere.
		// - not that i can find for the life of me *where* it's stored. mdn won't
		//   give up shit.
		let lightest = [null, null];
		let darkest = [null, null];
		// lightness value, and index
		for(i1 = 0; i1 < 16; i1++) {
			let array = [
				Math.floor(Math.random()*360),
				Math.floor(Math.random()*100)
			];
			if(i1 === 0) {
				array[2] = Math.floor((1 - randexponent(3))*100);
				// a mostly white color
			}
			else if(i1 === 1) {
				array[2] = Math.floor(randexponent(3)*100);
				// a mostly black color
			}
			else {
				array[2] = Math.floor((.5 + randexponent(3, true)/2)*100);
			};
			if(lightest[0] === null || array[2] > lightest[0]) {
				lightest = [array[2], i1];
			};
			if(darkest[0] === null || array[2] < darkest[0]) {
				darkest = [array[2], i1];
			};
			array[1] += "%";
			array[2] += "%";
			this.colors[i1] = "hsl(" + array.join(", ") + ")";
			// random colors, bimches.
		}
		temp = [
			lightest[1],
			darkest[1]
		];
		// only the indexes matter
		lightest = this.colors[temp[0]];
		darkest = this.colors[temp[1]];
		this.colors.splice(temp[0], 1);
		this.colors.splice(temp[1], 1);
		this.colors.splice(0, 0, darkest);
		this.colors.splice(0, 0, lightest);
		// put the lightest and darkest at the beginning
		this.createrainbow();
		/*
		for(i1 = 0; i1 < this.mouse.numofpositions; i1++) {
			this.mouse.oldx[i1] = null;
			this.mouse.oldy[i1] = null;
		}
		//*/
		this.createbuttons();
		this.ctx.canvas.style["image-rendering"] = "crisp-edges";
		// there we go bitches. only took way way way too long for me to learn
		// there was a way to turn that off...
		this.drawbuttons();
		this.ctx.fillStyle = this.colors[this.color2];
		this.ctx.fillRect(this.drawingarea.x, this.drawingarea.y, this.drawingarea.w, this.drawingarea.h);
		// untransparent it
		this.undodata.splice(this.undoindex, 0, this.ctx.getImageData(this.drawingarea.x, this.drawingarea.y, this.drawingarea.w, this.drawingarea.h));
		// if you don't do this, it won't have data to recall when trying to undo
		// the first action.
		// - NOTE if you're tearing your hair out wondering what firefox's
		//   fucking problem is... i don't have an answer for you, but i do know
		//   this is only seen as a problem because of the drawImage command in
		//   drawbuttons. that's what causes this error.
		// - my best, very vague guess is...
		//   - to draw an image, you first have to create a new Image Object or
		//     whatever, right?
		//   - i think maybe it's getting anxious about this being somewhat sort
		//     of somewhat close to a hacker being able to hijack the asset
		//     images, modify them somehow?
		//   - it doesn't like that i'm using getImageData after i do that
		//     because somehow,
		this.ctx.font = "16px 'fomp2'";
		//this.colorselectgraphic();
		this.subtooltext();
		this.ready();
	};
	draw.createrainbow = function() {
	// creates draw.misc.rainbow, an array of numbers that, when used as
	// draw.colors indexes, will give you the colors in order of hue.
	// - this should be run every time the palette changes.
		this.misc.rainbow = [];
		let temp = null;
		let minsaturation = 25;
		for(i1 = 0; i1 < this.colors.length; i1++) {
			temp = gethsv(this.colors[i1], this.ctx);
			if(temp[1] >= minsaturation) {
				this.misc.rainbow[this.misc.rainbow.length] = {
					index: i1,
					hue: temp[0],
				};
			};
		}
		function huesort(a, b) {
			return a.hue - b.hue;
		};
		this.misc.rainbow.sort(huesort);
		for(i1 = 0; i1 < this.misc.rainbow.length; i1++) {
			this.misc.rainbow[i1] = this.misc.rainbow[i1].index;
		}
		// use draw.mouse.oldx.length%draw.misc.rainbow.length as an index,
		// and this will give you an order of draw.colors indexes that
		// creates a rainbow.
	};
	draw.advancerainbow = function() {
		//draw.color1 = draw.misc.rainbow[draw.mouse.oldx.length%draw.misc.rainbow.length];
		this.misc.rainbowindex++;
		this.misc.rainbowindex %= this.misc.rainbow.length;
		this.color1 = this.misc.rainbow[this.misc.rainbowindex];
		this.ctx.strokeStyle = this.colors[this.color1];
		this.ctx.fillStyle = this.colors[this.color1];
	};
	function symboldrawing(ctx, name, offset, size, color) {
	// draws various icons used in graphics.
	// - actually i drew them in aseprite first but as it turns out, those can't
	//   be used unless the html is on an actual server. because of "same origin
	//   policy", which protects me from the dangers of using a file on my
	//   computer with another file on my computer.
	//   - *scuttle scuttle scuttle* ...did you hear that? *scuttle scuttle
	//     scuttle* it sounds like it's coming from... the ceiling-- *the tiles
	//     give out under the weight of a stream of programming redditors
	//     explaining why this makes perfect sense actually, and i'm the one
	//     being unreasonable*
	//     - if a tool feels stupid, convoluted, and nonsensical to the person
	//       using it, it's a bad tool.
	// - NOTE don't use the pen, erase, or paint. those were written back when
	//   this system was astoundingly shitty
		let i1 = 0;
		let i2 = 0;
		offset ??= [0, 0];
		function drawshape(shape, strokeorfill, etc) {
			if(strokeorfill !== "stroke") {
				_2dPoly.draw(ctx, shape, "fill", false, offset, etc);
			};
			if(["stroke", "both"].includes(strokeorfill)) {
				_2dPoly.draw(ctx, shape, "stroke", false, [offset[0] - 0, offset[1] - 0], etc);
				_2dPoly.draw(ctx, shape, "stroke", false, [offset[0] - 1, offset[1] - 0], etc);
				_2dPoly.draw(ctx, shape, "stroke", false, [offset[0] - 0, offset[1] - 1], etc);
				_2dPoly.draw(ctx, shape, "stroke", false, [offset[0] - 1, offset[1] - 1], etc);
			};
		}
		function drawline(x1, y1, x2, y2) {
			let styletemp = ctx.fillStyle;
			ctx.fillStyle = ctx.strokeStyle;
			if(offset) {
				x1 += offset[0];
				y1 += offset[1];
				x2 += offset[0];
				y2 += offset[1];
			}
			ctx.lineexecute(x1, y1, x2, y2, false, function(ctx, x, y, weight) {
				ctx.fillRect(x - 1, y - 1, 2, 2);
			});
			ctx.fillStyle = styletemp;
		}
		function convertpoints(multiply) {
			//let styletemp = ctx.fillStyle;
			//ctx.fillStyle = "orange";
			let i1 = 0;
			let i2 = 0;
			multiply ??= 1;
			for (i1 in points) {
				if (points.hasOwnProperty(i1)) {
					for(i2 = 0; i2 < points[i1].length; i2++) {
						points[i1][i2] = {
							x: multiply*points[i1][i2][0],
							y: multiply*points[i1][i2][1],
						};
						//ctx.fillRect(points[i1][i2].x - 2, points[i1][i2].y - 2, 4, 4);
					}
				};
			}
			//ctx.fillStyle = styletemp;
		}
		color ??= ["black", "white", "gray"];
		let multiply = 1;
		if(["pen", "paint", "eraser"].includes(name)) {
			color = [
				"#2f2f5f",
				"white",
				"#63639f"
			];
			multiply = 4;
			ctx.fillStyle = color[0];
			ctx.fillRect(offset[0], offset[1], multiply*24, multiply*24);
		};
		let points = {};
		if(name === "pen") {
			points.top = [
				[16, 16],
				[17, 16],
				[22, 11],
				[22, 8],
				[16, 2]
			];
			points.side = [
				structuredClone(points.top[points.top.length - 1]),
				[7, 11],
				[7, 13],
				[3, 15],
				[2, 22]
			];
			points.slot = [
				structuredClone(points.side[points.side.length - 1]),
				[6, 18]
			]
			convertpoints(multiply);
			points.side[2].elbow = {x: multiply*6, y: multiply*15};
			points.side[3].elbow = {direction: "d"};
			ctx.strokeStyle = color[2];
			ctx.fillStyle = color[1];
			let shape = new Shape2d(points.top).path;
			drawshape(shape, "stroke", "skiplaststroke");
			// from the end of the clip to the top
			shape = new Shape2d(points.side).path;
			drawshape(shape, "stroke", "skiplaststroke");
			// top to tip
			let mirror = (coor) => [multiply*24 - coor[1], multiply*24 - coor[0]];
			let diagonals = [];
			for(i1 = 0; i1 < 3; i1++) {
				let ref = points.side[i1];
				let temp = [ref.x, ref.y];
				if(i1 === 0) {
					temp[0] += -1*multiply;
					temp[1] += 1*multiply;
				};
				diagonals[i1] = temp.concat(mirror(temp));
			};
			drawshape([
				diagonals[0].slice(0, 2),
				diagonals[0].slice(2, 4),
				diagonals[1].slice(2, 4),
				diagonals[1].slice(0, 2),
			], "fill");
			for(i1 = 0; i1 < shape.length; i1++) {
				shape[i1] = mirror(shape[i1]);
			}
			drawshape(shape, "stroke", "skiplaststroke");
			// other side
			for(i1 = 0; i1 < diagonals.length; i1++) {
				drawline(...diagonals[i1]);
			}
			// diagonal lines
			let temp = [points.slot[0].x, points.slot[0].y, points.slot[1].x, points.slot[1].y];
			drawline(...temp);
			ctx.fillStyle = color[2];
			circledraw(ctx, points.slot[1].x, points.slot[1].y, multiply + 1, true);
			//paintbucket(ctx, offset[0] + 48, offset[1] + 48);
		}
		else if(name === "pencil") {
			size ??= 24;
			let points = {
				top: [
					[7, 0],
					[7 + 1.5, 0 + 1.5],
					[7 + 3.5, 0 + 3.5],
					[7 + 5, 0 + 5]
				],
				edge: [],
				// edge where the sharpened part meets the unsharpened part
				graphite: [
					[9.5, 0],
					[12, 2.5]
				],
				tip: [[0, 12]],
			};
			for(i1 = 0; i1 < points.top.length; i1++) {
				points.edge[i1] = [
					points.top[i1][0] - 7,
					points.top[i1][1] + 7
				];
			};
			convertpoints(size/12);
			let temp = [
				structuredClone(points.top[0]),
				structuredClone(points.top[ points.top.length - 1 ]),
				structuredClone(points.edge[0]),
				structuredClone(points.edge[ points.edge.length - 1 ]),
			];
			ctx.fillStyle = color[0];
			_2dPoly.draw(ctx, temp, "fill", false, offset);
			for(i1 = 1; i1 < points.top.length - 1; i1++) {
				ctx.strokeStyle = color[1];
				let coor = [
					offset[0] + points.top[i1][0], offset[1] + points.top[i1][1],
					offset[0] + points.edge[i1][0], offset[1] + points.edge[i1][1]
				];
				nonaaline(ctx, ...coor);
				ctx.fillStyle = color[0];
				ctx.fillRect(...coor.slice(0, 2), 1, 1);
				ctx.fillRect(...coor.slice(2, 4), 1, 1);
			};
			temp = [
				structuredClone(points.graphite[0]),
				structuredClone(points.graphite[1]),
				structuredClone(points.tip[0])
			];
			_2dPoly.draw(ctx, temp, "fill", false, offset);
			temp = [
				structuredClone(points.edge[0]),
				structuredClone(points.edge[ points.edge.length - 1 ]),
				structuredClone(points.tip[0])
			];
			ctx.strokeStyle = color[0];
			_2dPoly.draw(ctx, temp, "stroke", false, offset);
		}
	}
	draw.initialize();
	draw.mousedown = function(e) {
		//changefocus("draw");
		//console.log(e);
		draw.setmousecoor(e);
		//console.log([userfocus, draw.mouse.x, draw.mouse.y]);
		let i1 = 0;
		if(!withinrect(draw.mouse.x, draw.mouse.y, draw.drawingarea)) {
		// the user clicked outside the drawing area
			draw.mouse.clicktype = "ui";
			draw.buttonaction(e);
		}
		else {
			draw.mouse.clicktype = "drawing";
			if(["pen", "paint"].includes(draw.mouse.tool) && draw.misc.rainbowmode) {
			// rainbow mode
				draw.advancerainbow();
			};
			if(draw[draw.mouse.tool][draw.mouse.subtool[draw.mouse.tool]].hasOwnProperty("down")) {
				draw[draw.mouse.tool][draw.mouse.subtool[draw.mouse.tool]].down(draw, draw.mouse.inversion[draw.mouse.tool]);
			};
			// set strokedata
		};
		draw.ready();
		draw.mousemove(e);
	};
	draw.mousemove = function(e) {
		if(draw.mouse.clicktype !== "drawing") {
			return;
		};
		draw.setmousecoor(e);
		let temp = [];
		let i1 = 0;
		let i2 = 0;
		if(["pen", "paint"].includes(draw.mouse.tool) && draw.misc.rainbowmode) {
		// rainbow time.
			draw.advancerainbow();
		};
		draw.ready(true);
		if(draw.mouse.tool === "pen") {
			if(draw.pen[draw.mouse.subtool.pen].hasOwnProperty("move")) {
				draw.pen[draw.mouse.subtool.pen].move(draw, draw.mouse.inversion[draw.mouse.tool]);
			};
		}
		else if(draw.mouse.tool === "paint") {
			if(dithers.hasOwnProperty(draw.paint[draw.mouse.subtool.paint].name)) {
			// used to be
			// "draw.paint[draw.mouse.subtool.paint].hasOwnProperty("dither")",
			// but for
				draw.ctx.lineexecute(draw.mouse.oldx[0], draw.mouse.oldy[0], draw.mouse.x, draw.mouse.y, draw.paintsize, function(context, x, y, weight) {
					let i1 = 0;
					let i2 = 0;
					let temp = "";
					for(i1 = Math.floor(x - weight/2); i1 < Math.floor(x - weight/2) + weight; i1++) {
						for(i2 = Math.floor(y - weight/2); i2 < Math.floor(y - weight/2) + weight; i2++) {
							temp = dither_interpreter(draw.paint[draw.mouse.subtool.paint].name, i1, i2, draw.mouse.inversion[draw.mouse.tool]);
							// this will either return true, or false.
							// - for dithers, inversion reverses the true/false
							//   outcome. "inversion" is a more fitting term for
							//   these than it is for alternate versions of a
							//   brush
							if(temp) {
								context.fillRect(i1, i2, 1, 1);
							}
							else if(draw.paint[draw.mouse.subtool.paint].hasOwnProperty("erases") && draw.paint[draw.mouse.subtool.paint].erases) {
							// the erases property makes it so it erases instead
							// of just not doing anything
								context.fillStyle = draw.colors[draw.color2];
								context.fillRect(i1, i2, 1, 1);
								context.fillStyle = draw.colors[draw.color1];
							};
						}
					}
				}, true);
			}
			else {
				console.log("i made a new kind of dither and forgot to make draw.mousemove accommodate it.");
			};
		}
		else if(draw.mouse.tool === "eraser") {
			if(draw.eraser[draw.mouse.subtool.eraser].hasOwnProperty("move")) {
				draw.eraser[draw.mouse.subtool.eraser].move(draw, draw.mouse.inversion[draw.mouse.tool]);
			};
		}
		else {
			console.log("this shouldn't happen");
		};
	};
	draw.mouseup = function(e) {
		draw.setmousecoor(e);
		if(draw.mouse.clicktype === "drawing") {
			if(draw[draw.mouse.tool][draw.mouse.subtool[draw.mouse.tool]].hasOwnProperty("up")) {
				draw[draw.mouse.tool][draw.mouse.subtool[draw.mouse.tool]].up(draw, draw.mouse.inversion[draw.mouse.tool]);
			};
			//console.log("undoindex (before changes): " + draw.undoindex);
			draw.undodata.splice(draw.undoindex, 0, draw.ctx.getImageData(draw.drawingarea.x, draw.drawingarea.y, draw.drawingarea.w, draw.drawingarea.h));
			draw.undodata = structuredClone(draw.undodata.slice(0, draw.maxundos));
			// trim away anything past .maxundos
			draw.undodata.splice(0, draw.undoindex);
			// if undoindex is higher than zero, (ie the user had done some
			// undos before this) delete everything more recent
			draw.undoindex = 0;
			//console.log("undoindex (after changes): " + draw.undoindex);
		};
		draw.mouse.clicktype = "none";
	};
	//document.getElementById("draw_canvas").addEventListener("mousedown", draw.mousedown);
	//document.getElementById("draw_canvas").addEventListener("mousemove", draw.mousemove);
	//document.getElementById("draw_canvas").addEventListener("mouseup", draw.mouseup);
	document.getElementById("draw_canvas").addEventListener("pointerdown", draw.mousedown);
	document.getElementById("draw_canvas").addEventListener("pointermove", draw.mousemove);
	document.getElementById("draw_canvas").addEventListener("pointerup", draw.mouseup);
	document.getElementById("draw_canvas").addEventListener("pointerleave", draw.mouseup);
	document.getElementById("draw_canvas").style["touch-action"] = "none";
	// drawing tablet compatibility, (probably) phone compatibility.
	// - pointer events are a more broad event that can apply to tablets and
	//   touch. apparently mouse events are incompatible. (they can still
	//   trigger click events though?)
	//   - i'm confused how this works. when i have nothing but mouse events on,
	//     i can still make dots with the tablet... i assumed that was because
	//     only mousedown was compatible, but replacing pointerdown with that
	//     doesn't work.
	// - touch-action is a css property that determines what touching it with a
	//   finger or tablet does... that is, most of the time it just scrolls, but
	//   you can disable that with this.
	// - hopefully this works on mobile. guess i'll just have to wait and see.
	class App {
	// a class for creating a basic canvas app, with clickable areas and stuff.
	// - NOTE: draw is NOT one of these. the structure is similar because draw
	//   was the prototype.
		constructor() {
			this.prefix = "";
			// this is used for html element ids and shit like that
			this.clickarea = "none";
			// stores whether it clicked on the ui, the active area, the
			// mobile canvas, or none
			this.undodata = [];
			// stores data to be restored with undo/redo.
			// - NOTE: lower indexes are more recent. every new imagedata is put at
			//   the beginning.
			this.undoindex = 0;
			this.maxundos = 20;
			// setting for how many imagedatas it should be allowed to hold, how
			// many actions it can undo.
			this.uicolor = ["black", "white"];
			this.font = "16px 'fomp2'";
			this.buttons = {};
			this.page = 0;
			this.savechange = false;
			// this is turned off at the start of a click or key press, and
			// turned on if the action the user took happens to be one that
			// actually edits things. (for example, a drawing app would turn
			// it on in mousedown if the user clicked on the canvas.)
			this.misc = {};
			// place for storing misc data.
			/*
			this = {
				prefix: "",
				clickarea: "none",
				undodata: [],
				undoindex: 0,
				maxundos: 20,
				uicolor: ["black", "white"],
				font: "16px 'fomp2'",
				buttons: {},
				savechange: false,
				misc: {},
			};
			//*/
		}
		appinitA(prefix, canvases, uicolor) {
		// does all the stuff that starts it up. creates the div and canvases,
		// sets dimensions and colors, fills the canvases, creates event
		// listeners. this does NOT run createbuttons and drawbuttons.
		// - prefix: this should be the same string as the main app object.
		//   this.prefix gets set as that, and it's used for html element ids
		//   and crap like that
		// - canvases: an object.
		//   - for each property, it creates a canvas with the same name, and
		//     the w/h specified.
		//   - if there's no properties but w and h, it'll just create one
		//     canvas called "main".
		// - uicolor: array of colors that uicolor will be defined as.
		//   - really this is just a reminder to actually change it. just like
		//     prefix.
		//   - this can be an object instead of an array. but do create a "0"
		//     and "1" color, those are the default colors for outlines and
		//     non-outlines
		// - i wanna save the word "initialize" for stuff specific to each
		//   function.
		// - this is to be paired with appinitB, which is run at the end of your
		//   initialize. (it saves data to undodata, after all. that should be
		//   probably be done after you set things up.)
			this.prefix = prefix;
			document.write("<br><div id='" + this.prefix + "_area'></div>");
			this.div = document.getElementById(this.prefix + "_area");
			// so that the innerHTML can be accessed easily...
			if(uicolor) {
				this.uicolor = structuredClone(uicolor);
			};
			this.ctx = {};
			// ctx stores multiple contexts, all named. whenever a function
			// edits one, you should probably use an object reference variable
			// so you don't have to type all this out.
			//
			if(typeof canvases !== "object") {
				console.log("invalid canvases input.");
			};
			if(compareobject(Object.keys(canvases), ["w", "h"])) {
				let i1 = "main";
				this.div.innerHTML += "<canvas id='" + this.prefix + "_" + i1 + "canvas' width=" + canvases.w + " height=" + canvases.h + "></canvas>";
				this.ctx[i1] = document.getElementById(this.prefix + "_" + i1 + "canvas").getContext("2d");
			}
			else {
				let i1 = "";
				for (i1 in canvases) {
					if (canvases.hasOwnProperty(i1) && canvases[i1].hasOwnProperty("w") && canvases[i1].hasOwnProperty("h")) {
						this.div.innerHTML += "<br><canvas id='" + this.prefix + "_" + i1 + "canvas' width=" + canvases[i1].w + " height=" + canvases[i1].h + "></canvas>";
						this.ctx[i1] = document.getElementById(this.prefix + "_" + i1 + "canvas").getContext("2d");
					};
				}
				if(this.div.innerHTML.slice(0, "<br>".length) === "<br>") {
					this.div.innerHTML = this.div.innerHTML.slice("<br>".length);
				};
			};
			if(compareobject(this.ctx, {})) {
				console.log("invalid canvases input.");
			};
			function eventlisteners(ctx, app) {
				ctx.canvas.addEventListener("pointerdown", app.mousedown);
				ctx.canvas.addEventListener("pointermove", app.mousemove);
				ctx.canvas.addEventListener("pointerup", app.mouseup);
				ctx.canvas.addEventListener("pointerleave", app.mouseup);
				ctx.canvas.style["touch-action"] = "none";
				// event listeners compatible with drawing tablets and phones.
			};
			this.resetstyle();
			let i1 = "";
			for (i1 in this.ctx) {
				if(this.ctx.hasOwnProperty(i1)) {
					let ctx = this.ctx[i1];
					ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
					// untransparent it
					//ctx.canvas.style["image-rendering"] = "crisp-edges";
					// my personal preference...
					//eventlisteners(ctx, this);
					// this has to be done in a function because using "this" in an
					// event listener just gives you... the event, i think? or the
					// target?
				}
			}
			/*
			document.addEventListener("keydown", new Function("e", `
				if(userfocus === "` + this.prefix + `") {
					` + this.prefix + `.buttonaction(e, true);
				};
			`);
			//*/
			// haha yeah i'm not risking that
			// - i don't know shit about security risks but this isn't far from
			//   eval
			// - also this is less efficient than a normal anonymous function,
			//   not that i know shit about why
		}
		appinitB(saveddata) {
			this.undodata.splice(this.undoindex, 0, structuredClone(saveddata));
			// if you don't do this, it won't have data to recall when trying to
			// undo the first action.
			this.setgraphics();
		}
		resetstyle() {
		// resets all three canvases so that black is the stroke color, white is
		// the fill color, and this.font is the font.
			let i1 = "";
			for (i1 in this.ctx) {
				if(this.ctx.hasOwnProperty(i1)) {
					this.ctx[i1].fillStyle = this.uicolor[1];
					this.ctx[i1].strokeStyle = this.uicolor[0];
					this.ctx[i1].font = this.font;
				};
			}
		}
		drawbuttons(noimage, extracode) {
		// draws the buttons.
		// - any buttons without images, it'll draw the outline instead.
		// - noimage: if true, it'll skip the drawImage(). you might need this,
		//   sometimes drawImage causes domexception errors on every use of
		//   getImageData because of "same-origin policy". look it up.
		// - extracode: function it runs at the end.
		//   - for example, if you want to draw palette buttons, drawbuttons
		//     will not fill each button in its color, but you could do that by
		//     adding .hide to all of them and having extracode do that.
			let i0 = "";
			let i1 = "";
			let i2 = "";
			this.resetstyle();
			let center = [null, null];
			if(!compareobject(Object.keys(this.buttons), Object.keys(this.ctx))) {
				console.log("the property names of .buttons and .ctx don't match. that shouldn't happen");
			};
			for (i0 in this.buttons) {
			// this.buttons is divided up by canvas
				if(this.buttons.hasOwnProperty(i0)) {
					for (i1 in this.buttons[i0]) {
						if (
							this.buttons[i0].hasOwnProperty(i1)
							&&
							(
								!this.buttons[i0][i1].hasOwnProperty("hide")
								||
								!this.buttons[i0][i1].hide
							)
							&&
							(
								!this.buttons[i0][i1].hasOwnProperty("condition")
								||
								this.buttons[i0][i1].condition(this)
							)
						) {
							if(!noimage && this.buttons[i0][i1].hasOwnProperty("image")) {
								//*
								this.ctx[i0].drawImage(
									this.buttons[i0][i1].image.file,
									this.buttons[i0][i1].image.sx,
									this.buttons[i0][i1].image.sy,
									this.buttons[i0][i1].image.sw,
									this.buttons[i0][i1].image.sh,
									this.buttons[i0][i1].x,
									this.buttons[i0][i1].y,
									this.buttons[i0][i1].w,
									this.buttons[i0][i1].h
								);
								//*/
							}
							else if(this.buttons[i0][i1].hasOwnProperty("split")) {
								/*
								center = fourpointintersect(
									this.buttons[i0][i1].x, this.buttons[i0][i1].y,
									this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y + this.buttons[i0][i1].h,
									this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y,
									this.buttons[i0][i1].x, this.buttons[i0][i1].y + this.buttons[i0][i1].h,
								);
								if(this.buttons[i0][i1].split.includes("up")) {
									_2dPoly.draw(this.ctx[i0], [
										[this.buttons[i0][i1].x, this.buttons[i0][i1].y],
										[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y],
										center
									], "stroke");
								};
								if(this.buttons[i0][i1].split.includes("down")) {
									_2dPoly.draw(this.ctx[i0], [
										[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y + this.buttons[i0][i1].h],
										[this.buttons[i0][i1].x, this.buttons[i0][i1].y + this.buttons[i0][i1].h],
										center
										], "stroke"
									);
								};
								if(this.buttons[i0][i1].split.includes("left")) {
									_2dPoly.draw(this.ctx[i0], [
									[this.buttons[i0][i1].x, this.buttons[i0][i1].y + this.buttons[i0][i1].h],
									[this.buttons[i0][i1].x, this.buttons[i0][i1].y],
									center
									], "stroke");
								};
								if(this.buttons[i0][i1].split.includes("right")) {
									_2dPoly.draw(this.ctx[i0], [
									[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y],
									[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y + this.buttons[i0][i1].h],
									center
									], "stroke");
								};
								//*/
								//*
								if(this.buttons[i0][i1].split.includes("up")) {
									this.ctx[i0].strokeRect(this.buttons[i0][i1].x - .5, this.buttons[i0][i1].y - .5, this.buttons[i0][i1].w + 1, 1);
								};
								if(this.buttons[i0][i1].split.includes("down")) {
									this.ctx[i0].strokeRect(this.buttons[i0][i1].x + .5, this.buttons[i0][i1].y + this.buttons[i0][i1].h - .5, this.buttons[i0][i1].w + 1, 1);
								};
								if(this.buttons[i0][i1].split.includes("left")) {
									this.ctx[i0].strokeRect(this.buttons[i0][i1].x - .5, this.buttons[i0][i1].y - .5, 1, this.buttons[i0][i1].h + 1);
								};
								if(this.buttons[i0][i1].split.includes("right")) {
									this.ctx[i0].strokeRect(this.buttons[i0][i1].x + this.buttons[i0][i1].w - .5, this.buttons[i0][i1].y - .5, 1, this.buttons[i0][i1].h + 1);
								};
								//*/
							}
							else {
								_2dPoly.draw(this.ctx[i0], [
									[this.buttons[i0][i1].x, this.buttons[i0][i1].y],
									[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y],
									[this.buttons[i0][i1].x + this.buttons[i0][i1].w, this.buttons[i0][i1].y + this.buttons[i0][i1].h],
									[this.buttons[i0][i1].x, this.buttons[i0][i1].y + this.buttons[i0][i1].h]
								], "stroke");
							};
						}; // i1 if
					} // i1
				}; // i0 if
			} // i0
			if(extracode) {
				extracode();
			};
		}
		keycheck(keyboardevent) {
		// checks if the key you pressed is associated with a button, and
		// returns the name and object, in an array.
			let i0 = "";
			let i1 = "";
			let i2 = 0;
			let temp1 = 0;
			let temp2 = [];
			let buttonkey = "";
			let ctrl = false;
			let shift = false;
			// stores which key the button wants, and whether ctrl and/or shift
			// are needed
			//
			let key = keyboardevent.key;
			if(key.length === 1 && key.charCodeAt(0) >= 65 && key.charCodeAt(0) < 91) {
				key = key.toLowerCase();
			};
			// if it's a capital letter, make it lowercase. (whether is is or isn't
			// capital doesn't matter, e.shiftKey is the only thing that could be
			// relevant.)
			for (i0 in this.buttons) {
			// search every canvas
				if(this.buttons.hasOwnProperty(i0)) {
					for (i1 in this.buttons[i0]) {
						if (
							this.buttons[i0].hasOwnProperty(i1)
							&&
							this.buttons[i0][i1].hasOwnProperty("key")
						) {
							buttonkey = this.buttons[i0][i1].key;
							ctrl = false;
							shift = false;
							if(buttonkey.includes("ctrl + ")) {
								buttonkey = buttonkey.replaceAll("ctrl + ", "");
								ctrl = true;
							};
							if(buttonkey.includes("shift + ")) {
								buttonkey = buttonkey.replaceAll("shift + ", "");
								shift = true;
							};
							if(
								key === buttonkey
								&&
								keyboardevent.ctrlKey === ctrl
								&&
								keyboardevent.shiftKey === shift
								&&
								(
									!this.buttons[i0][i1].hasOwnProperty("keycondition")
									||
									this.buttons[i0][i1].keycondition(this)
								)
							) {
								// if the key pressed and the ctrl/shift usage match,
								// and there's no keycondition or the keycondition is
								// fulfilled, register it.
								return [i1, this.buttons[i0][i1]];
							};
						};
					} // i1

				}; // i0 if
			} // i0
			return ["none", {}];
		}
		mousecheck(mouseevent) {
		// checks if the place you clicked is a button, and returns the name and
		// object, in an array.
			let mouse = clickxy(mouseevent, this.prefix);
			mouse = {
				x: mouse[0],
				y: mouse[1],
			};
			let i1 = "";
			let i2 = 0;
			let temp1 = 0;
			let temp2 = [];
			let canvas = "";
			// the string for the ctx of the canvas you clicked on
			for (i1 in this.ctx) {
				if(this.ctx.hasOwnProperty(i1) && e.target === this.ctx[i1].canvas) {
					canvas = i1;
				}
			}
			for (i1 in this.buttons[canvas]) {
				if (
					this.buttons[canvas].hasOwnProperty(i1)
					&&
					withinrect(mouse.x, mouse.y, this.buttons[canvas][i1])
				) {
				// the click is within this button.
					if(this.buttons[canvas][i1].hasOwnProperty("split")) {
						temp1 = fourpointintersect(
							this.buttons[canvas][i1].x, this.buttons[canvas][i1].y,
							this.buttons[canvas][i1].x + this.buttons[canvas][i1].w, this.buttons[canvas][i1].y + this.buttons[canvas][i1].h,
							this.buttons[canvas][i1].x + this.buttons[canvas][i1].w, this.buttons[canvas][i1].y,
							this.buttons[canvas][i1].x, this.buttons[canvas][i1].y + this.buttons[canvas][i1].h,
						);
						temp1 = get2dangle(mouse.x - temp1[0], mouse.y - temp1[1], true);
						// angle relative to center of button
						if(temp1 === null) {
							// click is right in the center
							return [i1, this.buttons[canvas][i1]];
						}
						else {
							temp1 /= 2*Math.PI;
							temp1 = (temp1 + 1/8)%1;
							// now it's a measure of circumferences. (and shifted 1/8 so
							// it's easier to work with.)
							temp2 = ["right", "down", "left", "up"];
							for(i2 = 0; i2 < temp2.length; i2++) {
								if(
									this.buttons[canvas][i1].split.includes(temp2[i2])
									&&
									temp1 >= i2/4
									&&
									temp1 < (i2 + 1)/4
									&&
									(
										!this.buttons[canvas][i1].hasOwnProperty("condition")
										||
										this.buttons[canvas][i1].condition(this)
									)
								) {
									return [i1, this.buttons[canvas][i1]];
								};
							}
						};
					}
					else if (
						!this.buttons[canvas][i1].hasOwnProperty("condition")
						||
						this.buttons[canvas][i1].condition(this)
					) {
						return [i1, this.buttons[canvas][i1]];
					};
				};
			}
			return ["none", {}];
		}
		undo() {
			if(this.undoindex + 1 < this.undodata.length) {
				this.undoindex += 1;
				this.putundodata(this.undodata[this.undoindex]);
			};
		}
		redo() {
			if(this.undoindex > 0) {
				this.undoindex -= 1;
				this.putundodata(this.undodata[this.undoindex]);
			};
		}
		saveundodata() {
		// saves undodata. should be run at mouseup and keyup.
			if(this.savechange) {
				this.undodata.splice(this.undoindex, 0, structuredClone(saveddata));
				// use whatever you use as saveddata parameter in appinitB.
				this.undodata = structuredClone(this.undodata.slice(0, this.maxundos));
				// trim away anything past .maxundos
				this.undodata.splice(0, this.undoindex);
				// if undoindex is higher than zero, (ie the user had done some
				// undos before this) delete everything more recent
				this.undoindex = 0;
			};
		}
		clearclip() {
		// clears the clip region for every canvas context.
			let i1 = "";
			let i2 = "";
			let canvastemp = {};
			let imagetemp = null;
			for (i1 in this.ctx) {
				if(this.ctx.hasOwnProperty(i1)) {
					//
					canvastemp = {};
					for (i2 in this.ctx[i1]) {
						if (["string", "number", "boolean"].includes(typeof this.ctx[i1][i2])) {
							// forgoing "this.ctx.hasOwnProperty(i1)" because things specific to
							// it being a canvas context (ie fillStyle, shit like that. what i'm
							// trying to save.) don't count
							canvastemp[i2] = this.ctx[i1][i2];
						};
					}
					// saves all the simple data, avoids stuff like the object references
					// and class methods. font, fillStyle, strokeStyle, etc
					imagetemp = this.ctx[i1].getImageData(0, 0, this.ctx[i1].canvas.width, this.ctx[i1].canvas.height);
					// .reset() also clears the image, so you gotta save that
					this.ctx[i1].reset();
					console.log("reset");
					// clear clip
					for (i2 in canvastemp) {
						if (canvastemp.hasOwnProperty(i2)) {
							this.ctx[i1][i2] = canvastemp[i2];
						};
					}
					// restore the simple data
					this.ctx[i1].putImageData(imagetemp, 0, 0);
					// restore the image
					//
				}
			}
		}
		// TODO
		// - areas
		//   - i'm getting rid of activearea, but a system like it should exist.
		//     a system like buttons. a rectangle area it defines, and that
		//     clickarea detects.
		//   - clickarea will be the canvas name if no areas were clicked, and
		//     the area name if one was
		//   - just like buttons, area is split up by canvas
		// - add and implement mobilecanvas by default
		//   - gonna add booleans to the constructor for "ctrlbutton" and
		//     "shiftbutton"
		//   - keycheck does not check these. these buttons exist in the first
		//     place because the user presumably doesn't have access to a
		//     keyboard.
		//   - ctrl and shift are used for button shortcuts, but that's entirely
		//     different from how this is used. these are "action modifiers".
		//   - actually in that case i should just divorce it from ctrl/shift
		//     entirely.
		// - troubleshoot. the canvases aren't filled even though they should
		//   be.
		// - make it so .save is part of things.
		//   - not just an easy thing to set up
		//   - add import/export tools using JSON.stringify and JSON.parse
		//     (NOTE: that means functions can't be used in .save unless i set
		//     up toString and use the function constructor)
		// - done
		//   - add keyboard event listener
		//   - doublecheck that the canvas event listeners don't disappear once
		//     appinitA ends
		//     - i did a test. yeah, they stick around after the function that
		//       made them ends.
		//   - convert checkbutton and buttonaction
		//   - make it so buttons are separated by area.
		//     - there's pages AND areas. that's pretty annoying.
		//     - my current page system also only allows one set of pages...
		//     - i guess that's gonna need to get restructured.
		//     - the thing is, here's what makes the most sense to me, what seems
		//       the most versatile...
		//       - canvases
		//         - page groups
		//           - pages
		//             - buttons
		//               - properties
		//     - i assume you can tell why that's a hell no? that'd be so damn
		//       convoluted dude
		//     - i think i got it. instead of pages there are conditions.
		//       - buttons can have a boolean function that it uses to check
		//         this.page or whatever
		//       - a separate property called keycondition is used in keycheck
		//       - and the structure is:
		//         - canvases
		//           - buttons
		//             - properties
		//   - maybe make the ctxs more open-ended?
		//     - something like this:
		//       - ctx
		//         - active, ui, mobile (contexts)
		//     - hmmm.
		//     - i don't want to make it difficult to add more windows later on,
		//       but i don't want to make it take way too long to type a ctx...
		//     - then again, i don't think i'll actually type the ctx too much
		//       when programming.
		//       - graphics changes like setgraphics and drawbuttons will probably
		//         make a reference variable at the beginning anyway.
		//     - it'd also be good to have some consistency between the html ids
		//       and the ctx names. prefix + "_" + ctx property name + "canvas"
		//   - i'm probably gonna do away with the active/ui/mobile structure
		//     appinitA sets up. those will be the default used in the template,
		//     but appinitA will just use an object input. each property is a
		//     canvas, and has a w and h
	};
	// functions you're supposed to write yourself:
	// - .initialize: stuff that sets everything up.
	// - .createbuttons. the structure of buttons is:
	//   - .buttons (object, a property for each ctx.)
	//     - .buttons.ui (object storing the buttons of the ui canvas.)
	//       - .buttons.ui[buttonname] (button object)
	//         - x, y, w, h: defines the rectangle. this is the only
	//           mandatory field.
	//         - tags: string or array storing strings for categories and
	//           stuff. like if i wanna check if it's a color button.
	//         - split: string or array of "up", "down", "left", or "right",
	//           indicates that you should draw imaginary diagonal lines
	//           across the rectangle and only consider the input valid if
	//           it's within one of those quadrants
	//         - hide: boolean, keeps drawbuttons from doing anything.
	//         - key: the KeyboardEvent.key string of the key that should do
	//           the same thing as clicking this. use "ctrl + " and/or
	//           "shift + " to specify those buttons must be held.
	//         - image: drawImage() parameters
	//           - file: file path
	//           - sx, sy, sw, sh: rectangle parameters for the portion of the
	//             image you're using
	//           =
	//           - the dx/dy/dw/dh parameters are just the button rectangle
	//             stuff, obviously
	//           - note that this is not affected by split, so... in cases
	//             like the subtool controls, only one button holds the image
	//             for all of them.
	//           - that might get complicated later though. i'm not
	//             implementing "active" images yet. (that is, images that
	//             appear only when the button is clicked)
	//         - savechange: boolean. this should be true if the button edits
	//           the data that gets saved in undodata. it turns on the App
	//           object's savechange boolean, which triggers conditionals that
	//           trigger the functions that save stuff to undodata.
	//         - condition: a simple arrow function that returns a boolean. if
	//           it's false, the button won't be drawn and won't be clickable.
	//           - this can be used to make a page system.
	//           - why the workaround, you ask? because otherwise the structure
	//             of this.buttons has to be this.buttons > canvases > set of
	//             pages > individual pages > buttons > properties. which is. no
	//           - if there's no condition, it will always appear.
	//         - keycondition: an arrow function that's run on key presses.
	//           - buttons should generally be possible to activate by key no
	//             matter what, but, maybe an action is inapplicable under some
	//             circumstances. there's more uses for condition than just a
	//             page system, after all.
	//           - if a button fails to meet condition, it won't be drawn. that
	//             is not true for keycondition.
	// - setgraphics: evaluates the status of everything and enacts graphics
	//   changes
	// - putundodata: used by undo and redo, places whatever data is stored in
	//   undodata. for example, a drawing app would save ImageDatas, so this
	//   would just do putImageData wherever the drawing area is.
	// - mousedown, mousemove, mouseup
	//   - mousedown, you need to run buttonaction and all that in whatever way
	//     makes sense
	//   - mousemove, you probably don't need at all
	//   - mouseup adds to undodata and resets .clickarea
	//   - you should probably copy the template, for all of them.
	// - buttonaction: takes the name of a button (inputted using keycheck or
	//   mousecheck) and runs whatever code makes sense.
	// - keydown event listener: triggers buttonaction. userfocus has to match
	//   this.prefix though, so it doesn't run when the viewer isn't actually
	//   using this.
	// - keyup event listener: triggers saveundodata if .savechange is true
	// -
	// other crap to keep in mind:
	// - if this.savechange is not turned on during a click or key press, any
	//   changes it enacted will not be saved to undodata. buttons can turn this
	//   on with a .savechange property of their own, or you could type
	//   this.savechange = true during the action somewhere.
	// - .page is not actually part of the App class. i just have it in the
	//   template crap because it's a common thing to want.
	/*
	template. copy all this, replace all the XXXX, finish the functions, and it
	should work. probably.
	-
	let XXXX = new App();
	XXXX.initialize = function() {
		this.appinitA(
			"XXXX",
			// canvases
			{
				active: {
					w: 256,
					h: 192,
				},
				ui: {
					w: 256,
					h: 192,
				},
				mobile: {
					w: 128,
					h: 96,
				},
			},
			uicolor
		);
		this.createbuttons();
		let extracode = function() {
			//
		};
		// probably don't need this though
		this.drawbuttons(noimage, extracode);
		this.ctx.active.canvas.alt = "";
		this.ctx.ui.canvas.alt = "";
		this.ctx.mobile.canvas.alt = "";
		// type brief descriptions, for screen readers or unsupported browsers
		this.page = 0;
		//
		// extra shit goes here.
		//
		this.appinitB(saveddata);
	};
	XXXX.createbuttons = function() {
		let i1 = 0;
		let i2 = 0;
		this.buttons = {};
		for (i1 in this.ctx) {
		// buttons are divided up by which canvas they're on.
			if(this.ctx.hasOwnProperty(i1)) {
				this.buttons[i1] = {};
			};
		}
		let block = 32;
		// useful as an increment or whatever.
		let temp = {
			x: 0,
			y: 0,
			w: block,
			h: block,
		};
		canvas = "ui";
		// the buttons on the ui canvas.
		this.buttons[canvas].button1 = structuredClone(temp);
		this.buttons[canvas].button1.key = "ctrl + g";
		temp = {
			x: temp.x + temp.w,
			y: 0,
			w: block,
			h: block,
		};
		this.buttons[canvas].button2 = structuredClone(temp);
		temp = {
			x: temp.x + temp.w,
			y: temp.y + temp.h,
			w: block,
			h: block,
		};
		this.buttons[canvas].page = {
			x: this.ctx[canvas].canvas.width,
			y: this.ctx[canvas].canvas.height,
			w: block,
			h: block,
			split: [
				"down",
				"right"
			],
			key: "q",
		};
		// condition is purposefully omitted so it shows up on every page.
		this.buttons[canvas].page.x -= this.buttons[canvas].page.w;
		this.buttons[canvas].page.y -= this.buttons[canvas].page.h;
		// ui canvas button defining
		for (i1 in this.buttons[canvas]) {
			if (this.buttons[canvas].hasOwnProperty(i1) && !this.buttons[canvas][i1].hasOwnProperty("condition") && i1 !== "page") {
				this.buttons[canvas][i1].condition = (app) => app.page === 0;
				// type something like this, and the button will only be visible and
				// clickable if the this.page is 0. there's no page system built
				// into App inherently, but that's one way of doing it.
			}
		}
		// ui canvas condition defining (this example sets all buttons up to
		// this point to page 0. apparently, functions cannot be cloned easily.)
		this.buttons[canvas].page.image = {
			file: new Image(),
			sx: 0,
			sy: 0,
			sw: block,
			sh: block,
		};
		this.buttons[canvas].page.image.file.src = "filename.png";
		// ui canvas image defining
	};
	XXXX.setgraphics = function() {
		// type up shit that changes things
	};
	XXXX.putundodata = function(data) {
		// place what's there with the undodata provided.
	};
	XXXX.buttonaction = function(e, iskeyevent) {
	// - e: MouseEvent or KeyboardEvent
		let action = null;
		let button = null;
		if(iskeyboardevent) {
			action = this.keycheck(e);
			button = action[1];
			action = action[0];
		}
		else {
			action = this.mousecheck(e);
			button = action[1];
			action = action[0];
		};
		let i1 = 0;
		let i2 = "";
		switch (action) {
			case "none":
			break;
			case "undo":
				this.undo();
			break;
			case "redo":
				this.redo();
			break;
			case "page":
				//
			break;
		};
		if(button.hasOwnProperty("savechange") && button.savechange) {
			this.savechange = true;
		};
	};
	XXXX.mousedown = function(e) {
		//changefocus(XXXX.prefix);
		// userfocus is a global variable, makes sure keyboard events only
		// affect what's relevant
		XXXX.savechange = false;
		let mouse = clickxy(e, XXXX.prefix);
		mouse = {
			x: mouse[0],
			y: mouse[1],
		};
		let i1 = "";
		XXXX.clickarea = null;
		for (i1 in XXXX.ctx) {
			if(XXXX.ctx.hasOwnProperty(i1) && e.target === XXXX.ctx[i1].canvas) {
				XXXX.clickarea = i1;
			};
		};
		switch (XXXX.clickarea) {
			case "ui":
				draw.buttonaction(e);
			break;
			case "active":
				draw.buttonaction(e);
			break;
			case "mobile":
				draw.buttonaction(e);
			break;
		};
		draw.mousemove(e);
	};
	XXXX.mousemove = function(e) {
		let mouse = clickxy(e);
		mouse = {
			x: mouse[0],
			y: mouse[1],
		};
	};
	XXXX.mouseup = function(e) {
		let mouse = clickxy(e);
		mouse = {
			x: mouse[0],
			y: mouse[1],
		};
		if(XXXX.savechange) {
			XXXX.saveundodata();
		};
		XXXX.clickarea = "none";
	};
	XXXX.initialize();
	document.addEventListener("keydown", function(e) {
		XXXX.savechange = false;
		if(userfocus === "XXXX") {
			XXXX.buttonaction(e, true);
		};
	});
	document.addEventListener("keyup", function(e) {
		if(userfocus === "XXXX") {
			XXXX.saveundodata();
		};
	});
	//*/
	document.write(`</div>`);
	//
	document.write(`<div name="hider" id="hider_fighting_game_tester">`);
	let fg = {
	// fighting game testy thing.
		initialize: function() {
			let i1 = 0;
			let i2 = 0;
			this.p2 = structuredClone(this.p1);
			for(i1 = 1; i1 <= 2; i1++) {
				let ref = this["p" + i1];
				ref.x = this.visual.stage_w/2 + (i1 === 2 ? 1 : -1)*this.visual.w/4;
				Object.defineProperty(ref, "air", {
					get() {
						return this.y < 0;
					}
				});
				ref.held = structuredClone(ref.keys);
				for(i2 in ref.held) {
					if(ref.held.hasOwnProperty(i2)) {
						if(i1 === 2) {
							ref.keys[i2] = "";
							// not sure where to put p2 controls. i use a
							// laptop.
						};
						ref.held[i2] = false;
					}
				}
			};
			this.p1.char = this.char.unnamed;
			this.p2.char = this.char.unnamed;
			let html = [
				`<label>move list`,
				`<textarea id="fg_movelist" rows="12" cols="48"></textarea></label>`,
				`<button id="fg_applymovelist">apply</button>`,
				`<canvas id="fg_canvas"></canvas>`,
				`<div id="fg_display"></div>`
			].join(`<br>`);
			document.write(html);
			let array = [
				"movelist",
				"display",
				"canvas"
			];
			for(i1 = 0; i1 < array.length; i1++) {
				let ref = document.getElementById("fg_" + array[i1]);
				if(array[i1] === "canvas") {
					ref.width = this.visual.w;
					ref.height = this.visual.h;
					this.ctx = ref.getContext("2d");
				}
				else {
					this[ array[i1] ] = ref;
				};
				ref.onclick = function() { changefocus("fg") };
			}
			document.getElementById("fg_applymovelist").onclick = function() {
				changefocus("fg");
				fg.applymovelist();
			};
			this.movelist = document.getElementById("fg_movelist");
			this.display = document.getElementById("fg_display");
			this.movelist.value = [
				`qcf p: hadoken`,
				`z p: shoryuken`,
				`qcb k: tatsu`,
				`hcf p: special hadoken`,
				`f p: forward punch`,
				`f pk: grab`,
				`d d s: invite hell`
			].join(String.fromCharCode(10));
			this.applymovelist();
			fg.process(0);
		},
		movelist: null,
		display: null,
		ctx: null,
		visual: {
			w: 256,
			h: 192,
			stage_w: 512,
			color: "white",
			floor_color: "green",
			floor_level: 1/4,
			// 0 to 1, from the bottom of the screen to the top
			p1: "red",
			p2: "blue",
			player_size: 8,
			// visualized as circles for now
		},
		fps: 24,
		normals: {
			punch: {
				short: "p",
			},
			kick: {
				short: "k",
			},
			slash: {
				short: "s",
			},
		},
		char: {
		// stores all data that would be stored under the character rather
		// than the player. (ex: your defense is based on the defense ryu
		// has, right?)
			unnamed: {
			// there's only one character, though.
				specials: {},
				// structure:
				// - input: array of directions
				// - button: if they follow the directions and press this button, the
				//   special is executed.
				//   - this can be an array or string. arrays mean the player can use
				//     any index.
				// - ground, air: booleans for where it can be executed
				mass: 1,
				jump_velocity: -256,
				jumps: 3,
				// number of times you can jump
				f_walk: 128,
				b_walk: 64,
				// walk speeds (the fancy physics stuff isn't used here.)
				p: {
					duration: 1000,
				},
				k: {
					duration: 1000,
				},
				s: {
					duration: 1000,
				},
			},
		},
		p1: {
		// data that changes as the player moves and does things.
			x: null,
			y: 0,
			// [0, 0] is the horizontal center of the stage, on the ground.
			speed: [0, 0],
			// x velocity, y velocity
			direction: "",
			// direction being inputted. empty string means neutral, ie no
			// directions.
			specials: {},
			// an object of numbers for where they are in the specials. (-1
			// means they've inputted no steps, 0 means they're on the first
			// step, etc.)
			jumps: 0,
			// number of jumps since you landed.
			//last_direction_input: 0,
			// measured in new Date().valueOf()
			commitment: null,
			// object storing data for the non-cancellable action they're in the
			// middle of.
			// - name: name of the normal/special/etc
			// - type: "normal", "special", etc
			// - time: Date.valueOf() for when they performed it
			// - duration: how many milliseconds it'll last
			keys: {
				u: "w",
				l: "a",
				d: "s",
				r: "d",
				punch: "k",
				kick: "o",
				slash: "p",
			},
			held: null,
			// booleans for each key
			char: null,
			// reference to character data
		},
		p2: null,
		shorthand: {
			qcf: ["d", "df", "f"],
			qcb: ["d", "db", "b"],
			hcf: ["b", "db", "d", "df", "f"],
			hcb: ["f", "df", "d", "db", "b"],
			z: ["f", "d", "df"],
			bz: ["b", "d", "db"],
		},
		//direction_buffer: 1000/16,
		// for non-adjacent input combinations, (ex: f to d, d to d) the player
		// can spend this many ms in neutral between the inputs.
		physics: {
			gravity: 640,
			// measured in pixels per second per second
			// - 64 pixels = ~2 meters, let's say
			// - 32 pixels per meter
			// - 32*9.81 = ~320
			friction: 128,
			// the number of pixels per second per second it should detract from
			// a vector moving horizontally across the ground.
		},
		interval: null,
		game: {
		// stores temporary data that changes during the game and isn't tied to
		// either player (like the timer or whatever)
			left_player: "p1",
			// "p1", "", or "p2"
			// - "" means they're equal.
		},
		process: function(delta) {
		// various things executed per frame.
			let i0 = 0;
			let i1 = 0;
			let i2 = 0;
			let old_lp = fg.game.left_player;
			for(i0 = 1; i0 <= 2; i0++) {
			// gravity, speed
				let obj = fg["p" + i0];
				const old_air = obj.y < 0;
				obj.x += delta*obj.speed[0];
				obj.y += delta*obj.speed[1];
				if(!obj.direction.includes("d") && (obj.direction.includes("b") || obj.direction.includes("f"))) {
					obj.x += delta*(obj.direction.includes("b") ? -1 : 1)*fg.forward_sign(obj)*obj.char[obj.direction.slice(-1) + "_walk"];
				};
				if(obj.y < 0) {
				// gravity
					obj.speed[1] += delta*fg.physics.gravity;
				};
				if(obj.speed[0]) {
				// friction against the floor
					let sign = Math.sign(obj.speed[0]);
					obj.speed[0] -= (
						Math.sign(obj.speed[0])
						*
						delta
						*
						(obj.speed[0]/Math.hypot(...obj.speed))
						*
						fg.physics.friction
					);
					// you'd think the possible divide by zero would be okay
					// since it requires a Math.sign of zero, but 0*Infinity is
					// NaN, not zero.
					if(Math.sign(obj.speed[0]) !== sign) {
						obj.speed[0] = 0;
					};
				}
				obj.x = Math.min(Math.max(0, obj.x), fg.visual.stage_w);
				obj.y = Math.min(obj.y, 0);
				// don't pass through the floor
				if(old_air !== obj.y < 0) {
					fg.groundair_reset(obj);
				}
			}
			if(!fg.p1.commitment) {
				fg.display.innerHTML = "(" + fg.stance(fg.p1) + ")";
			}
			fg.game.left_player = ["p1", "", "p2"][Math.sign(fg.p1.x - fg.p2.x) + 1];
			if(fg.game.left_player !== old_lp && fg.game.left_player) {
			// reverse b/f directions.
			// - don't do anything if they only became equal
				for(i0 = 1; i0 <= 2; i0++) {
					let obj = fg["p" + i0];
					obj.direction = (
						obj.direction.includes("b") ? obj.direction.replace("b", "f") :
						obj.direction.includes("f") ? obj.direction.replace("f", "b") :
						obj.direction
					);
					if(obj.direction.includes("b") || obj.direction.includes("f")) {
						fg.advancespecials(obj);
						// so that specials get reset to zero if this
						// happens
					};
				}
			}
			let ctx = fg.ctx;
			let ref = fg.visual;
			ctx.fillStyle = ref.color;
			ctx.clearRect(0, 0, ref.w, ref.h);
			ctx.fillRect(0, 0, ref.w, ref.h);
			let floor_y = Math.ceil(ref.h*(1 - ref.floor_level));
			// canvas y to start the floor rectangle at.
			ctx.fillStyle = ref.floor_color;
			ctx.fillRect(0, floor_y, ref.w, ref.h - floor_y);
			let scroll = [
				(fg.p1.x + fg.p2.x)/2,
				-floor_y + ref.h/2
			];
			scroll = [
				Math.trunc(scroll[0] - ref.stage_w/2) + ref.stage_w/2,
				Math.ceil(
					fg.p1.y < -floor_y || fg.p2.y < -floor_y
					?
					(scroll[1] + Math.min(fg.p1.y, fg.p2.y))/2
					:
					scroll[1]
				)
			];
			// this is the absolute coordinates of the center of the screen.
			let toscreen = (x, y) => [
				x - scroll[0] + ref.w/2,
				y - scroll[1] + ref.h/2
			];
			// - translate coordinates by subtracting this and adding the halved
			//   halved dimensions
			ctx.strokeStyle = "gray";
			circledraw(ctx, ...toscreen(ref.stage_w/2, 0), ref.player_size);
			ctx.strokeStyle = ref.p1;
			circledraw(ctx, ...toscreen(fg.p1.x, fg.p1.y), ref.player_size/2);
			ctx.strokeStyle = ref.p2;
			circledraw(ctx, ...toscreen(fg.p2.x, fg.p2.y), ref.player_size/2);
		},
		groundair_reset: function(player) {
		// run when the player jumps or lands. resets all specials that no
		// longer apply to -1.
			let i1 = 0;
			player ??= fg.p1;
			let air = fg.stance(player) === "a";
			if(!air) {
				player.jumps = 0;
			};
			for(i1 in player.specials) {
				if(player.specials.hasOwnProperty(i1) && !player.char.specials[i1][air ? "air" : "ground"]) {
					player.specials[i1] = -1;
				};
			}
		},
		isdirection: (string) => (
			[1, 2].includes(string.length)
			&&
			(
				"ud".includes(string[0])
				||
				"bf".includes(string[string.length - 1])
			)
		),
		applymovelist: function(char) {
			let i0 = 0;
			let i1 = 0;
			char ??= "unnamed";
			fg.char[char].specials = this.interpret(fg.movelist.value);
			for(i0 = 0; i0 < 2; i0++) {
				let ref = fg[i0 ? "p2" : "p1"];
				ref.specials = {};
				if(ref.char === fg.char[char]) {
					for(i1 in ref.char.specials) {
						if(ref.char.specials.hasOwnProperty(i1)) {
							ref.specials[i1] = -1;
						};
					}
				}
			}
		},
		interpret: function(text) {
			let i1 = 0;
			let i2 = 0;
			let list = {};
			text = text.split(String.fromCharCode(10));
			for(i1 = 0; i1 < text.length; i1++) {
				let line = text[i1];
				let temp = line.indexOf(":");
				if(temp !== -1) {
					let input = line.slice(0, temp).trim().split(" ");
					let name = line.slice(temp + 1).trim();
					let ground = true;
					let air = false;
					if(input.length < 1) {
					}
					else if(input[0] === "(a)") {
						ground = false;
						air = true;
						input = input.slice(1);
					}
					else if(input[0] === "(ga)") {
						air = true;
						input = input.slice(1);
					};
					if(input.length >= 1 && name) {
						let button = input[input.length - 1];
						button = button.split("/");
						let bool = [];
						for(i2 = 0; i2 < button.length; i2++) {
							bool[i2] = false;
						}
						for(i2 in fg.normals) {
							if(fg.normals.hasOwnProperty(i2) && button.includes(fg.normals[i2].short)) {
								bool[ button.indexOf(fg.normals[i2].short) ] = true;
							}
						}
						// make sure all buttons are real buttons
						if(button.length === 1) {
							button = button[0];
						};
						list[name] = {
							input: [],
							button: structuredClone(button),
							ground,
							air,
							duration: 1000,
						};
						let ref = list[name];
						for(i2 = 0; i2 < input.length - 1; i2++) {
							if(fg.isdirection(input[i2])) {
								ref.input[ref.input.length] = input[i2];
							}
							else if(fg.shorthand.hasOwnProperty(input[i2])) {
								ref.input = ref.input.concat(fg.shorthand[ input[i2] ]);
							};
						}
					}
				}
			}
			return list;
		},
		adjacent: (d1, d2) => d1.includes(d2) || d2.includes(d1),
		directioninput: function(player) {
			player ??= fg.p1;
			let ref = player;
			const direction = ref.direction;
			//
			if(ref.commitment) {
				return;
			};
			if(direction.startsWith("u") && (ref.y >= 0 || ref.jumps < ref.char.jumps)) {
			// jump
				if(ref.y >= 0) {
					ref.jumps = 0;
				}
				ref.jumps++;
				ref.speed[1] = ref.char.jump_velocity;
			};
			fg.advancespecials(ref);
		},
		advancespecials: function(player) {
		// progresses or resets all specials.
			let i1 = 0;
			let i2 = 0;
			player ??= fg.p1;
			let ref = player;
			const direction = ref.direction;
			let air = fg.stance(player) === "a";
			//
			for(i1 in ref.specials) {
				if(ref.specials.hasOwnProperty(i1)) {
					if(
						ref.char.specials[i1].ground !== !air
						||
						ref.char.specials[i1].air !== air
					) {
					// make sure it stays at -1 if the ground/air doesn't match.
						ref.specials[i1] = -1;
					}
					else {
						let input = ref.char.specials[i1].input;
						// array of directions
						let step = ref.specials[i1];
						// which index the player is on
						if(
							step > input.length - 1
							||
							step < -1
						) {
							console.log("this shouldn't happen");
							ref.specials[i1] = -1;
							step = ref.specials[i1];
						};
						if(
							step !== input.length - 1
							&&
							input[step + 1] === direction
						) {
							ref.specials[i1]++;
							//console.log(i1 + ": " + ref.specials[i1]);
						};
					};
				}
			}
		},
		buttoninput: function(button, player) {
		// executes a special or normal, resets all special input chains to the
		// beginning
		// - button shouldn't be in short form.
			let i1 = 0;
			let i2 = 0;
			let normal = button;
			button = fg.normals[normal].short;
			player ??= fg.p1;
			let ref = player;
			if(ref.commitment) {
				return;
			};
			let special = null;
			// name of the special they end up performing
			let special_length = -1;
			// number of inputs to the special (this needs to be saved so that
			// if multiple specials apply, the one with a longer input will be
			// used)
			for(i1 in ref.specials) {
				if(ref.specials.hasOwnProperty(i1)) {
					let input = ref.char.specials[i1].input;
					// array of directions
					let step = ref.specials[i1];
					// which index the player is on
					if(
						step === input.length - 1
						&&
						(
							Array.isArray(ref.char.specials[i1].button)
							?
							ref.char.specials[i1].button.includes(button)
							:
							ref.char.specials[i1].button === button
						)
						&&
						input.length > special_length
						&&
						ref.direction === input[input.length - 1]
					) {
					// if it's at the end of the input, the button is right, and
					// it's the longest applicable special so far, set that as
					// the action.
						special = i1;
						special_length = input.length;
					};
					ref.specials[i1] = -1;
					// set all of them to -1 to start their input chain over.
				}
			}
			ref.commitment = (
				special
				?
				{
					name: special,
					// which non-cancellable action they're in the middle of
					type: "special",
					// whether it's
					time: new Date().valueOf(),
					duration: ref.char.specials[special].duration,
				}
				:
				{
					name: normal,
					type: "normal",
					time: new Date().valueOf(),
					duration: ref.char[button].duration,
				}
			);
			fg.display.innerHTML = "(" + fg.stance(ref) + ") " + ref.commitment.name;
			setTimeout(function() {
				ref.commitment = null;
			}, ref.commitment.duration);
		},
		stance: (player) => (
			player.y < 0 ? "a" :
			player.direction.startsWith("d") ? "c" :
			"s"
		),
		forward_sign: (player) => (
			player === fg.p1 ? (
				fg.game.left_player === "p2"
				?
				-1
				:
				1
			)
			:
			player === fg.p2 ? (
				fg.game.left_player === "p2"
				?
				1
				:
				-1
			)
			:
			null
		),
		keyevent: function(e, up) {
			let i0 = 0;
			let i1 = 0;
			let key = keyinterpreter(e.key);
			for(i0 = 1; i0 <= 2; i0++) {
				let ref = fg["p" + i0];
				for(i1 in ref.keys) {
					if(ref.keys.hasOwnProperty(i1) && ref.keys[i1] === key) {
						ref.held[i1] = !up;
						if(["u", "l", "d", "r"].includes(i1)) {
							let direction = "u".repeat(ref.held.u) + "d".repeat(ref.held.d) + "l".repeat(ref.held.l) + "r".repeat(ref.held.r);
							direction = direction.replace("ud", "").replace("lr", "");
							direction = (
								fg.forward_sign(ref) === -1
								?
								direction.replace("r", "b").replace("l", "f")
								:
								direction.replace("l", "b").replace("r", "f")
							);
							if(direction !== ref.direction) {
								ref.direction = direction;
								fg.directioninput(ref);
							};
						}
						else if(fg.normals.hasOwnProperty(i1)) {
							fg.buttoninput(i1, ref);
						};
					};
				}
			}
		},
		keydown: function(e) {
			fg.keyevent(e, false);
		},
		keyup: function(e) {
			fg.keyevent(e, true);
		},
	};
	fg.initialize();
	document.write(`</div>`);
	document.write(`<div name="hider" id="hider_sprite_arranger"></div>`);
	let sa = {
		tools: ["move", "swap", "paint"],
		// modes for what happens when you click the main canvas. i'm not
		// bothering with canvas uis, it's gonna be html
		buttons: ["import", "clear", "redimension", "change_block_increment", "change_move_increment", "change_background", "change_checker"],
		control: {
			//tool
			//increments
			// - these will be getter/setters tied to the html ui
			selection: {
				x: 0,
				y: 0,
				w: 1,
				h: 1,
			},
			input: [0, 0],
			// where the user last clicked the input, measured in sa.blocks
			clicktype: null,
			strokedata: null,
		},
		block: 8,
		// 8 means it'll use 8x8 pieces of the image.
		move: 4,
		// 4 means you can only move things to coordinates divisible by 4. (the
		// button that changes this only allows numbers that divide evenly into
		// block.)
		background: "purple",
		// null means it'll be transparent if a block is empty. make this a
		// color, and it'll be that color.
		checker: "#0000ff0f",
		// half the background tiles will have this color placed on them too.
		input: null,
		// inputted image. also used to check if it's started yet.
		data: [],
		// data for where you're placing blocks from the input.
		// - x indexes
		//   - y indexes
		//     - objects (or null, if there's nothing here.)
		//       - offset (two-number array for its pixel offset relative to the
		//         top-left corner.)
		//       - input (two-number array for which block it's referencing,
		//         from the input data.)
		// =
		// - the x/y indexes count by sa.blocks, not sa.moves. a block counts as
		//   being in that coordinate if its top-left corner is somewhere in
		//   there. (the offsets are always positive.)
		// - the input stuff is also counting by sa.blocks. not pixels.
		data_w: 64,
		data_h: 8,
		div: null,
		ctx: {
			input: null,
			main: null,
		},
		clean_image: null,
		initdata: function() {
			let i1 = 0;
			let i2 = 0;
			sa.data = [];
			for(i1 = 0; i1 < sa.data_w; i1++) {
				sa.data[i1] = [];
				for(i2 = 0; i2 < sa.data_h; i2++) {
					sa.data[i1][i2] = null;
				}
			}
		},
		initialize: function() {
			let i1 = 0;
			let i2 = 0;
			sa.div = document.getElementById("hider_sprite_arranger");
			let html = ``;
			html += `something for ungarbling sprite image data. i'm not sure if the popular sprite-ripping tools suck or if i'm using them wrong. so many repetitive mouse movements.`;
			html += `<br><label>image input: <input type="file" id="sa_fileinput"></label>`;
			for(i1 in sa.ctx) {
				if(sa.ctx.hasOwnProperty(i1)) {
					html += `<br><canvas id="sa_` + i1 + `"></canvas>`;
				}
			}
			html += `<br><div id="sa_coordisplay"></div>`;
			html += `<br><label>tool: <select id="sa_tool">`;
			for(i1 = 0; i1 < sa.tools.length; i1++) {
				html += `<option value="` + sa.tools[i1] + `"` + ` selected`.repeat(i1 === 0) + `>` + sa.tools[i1] + `</option>`;
			}
			html += `</select></label>`;
			html += `<br><label>import increments: <input type="text" id="sa_increments"></label>`;
			for(i1 = 0; i1 < sa.buttons.length; i1++) {
				html += `<br><button id="sa_button_` + sa.buttons[i1] + `">` + sa.buttons[i1].replaceAll("_", " ") + `</button>`;
			}
			sa.div.innerHTML = html;
			for(i1 in sa.ctx) {
				if(sa.ctx.hasOwnProperty(i1)) {
					let canvas = document.getElementById("sa_" + i1);
					canvas.style["image-rendering"] = "crisp-edges";
					canvas.style["touch-action"] = "none";
					canvas.hidden = true;
					sa.ctx[i1] = canvas.getContext("2d");
				}
			}
			sa.ctx.input.canvas.onpointerdown = function(e) {
				let click = sa.block_coor(...clickxy(e, "sa"));
				sa.control.input = [click.x, click.y];
				sa.refresh();
			};
			sa.ctx.main.canvas.onpointerdown = sa.mousedown;
			sa.ctx.main.canvas.onpointermove = sa.mousemove;
			sa.ctx.main.canvas.onpointerup = sa.mouseup;
			Object.defineProperty(sa.control, "tool", {
				get() {
					return document.getElementById("sa_tool").value;
				},
				set(value) {
					if(sa.tools.includes(value)) {
						document.getElementById("sa_tool").value = value;
					};
				},
			});
			Object.defineProperty(sa.control, "increments", {
				get() {
					let i1 = 0;
					let input = document.getElementById("sa_increments").value.split(",");
					for(i1 = 0; i1 < input.length; i1++) {
						input[i1] = Number(input[i1]);
						if(!Number.isInteger(input[i1]) || input[i1] <= 0) {
							input.splice(i1, 1);
							i1--;
						}
					}
					if(input.length) {
						document.getElementById("sa_increments").value = input.join(",");
					}
					else {
						input = [1, 1];
					};
					if(input.length%2) {
						input[input.length] = 1;
					};
					return input;
				},
				set(value) {
					if(Array.isArray(value)) {
						document.getElementById("sa_increments").value = value.join();
					};
				},
			});
			document.getElementById("sa_button_import").onpointerdown = function() {
				let i1 = 0;
				let coor = sa.rect_start(sa.control.selection);
				let positions = sa.incrementer(sa.control.increments);
				let inputdim = [Math.floor(sa.input.width/sa.block), Math.floor(sa.input.height/sa.block)];
				let start = inputdim[0]*sa.control.input[1] + sa.control.input[0];
				let end = Math.min(start + positions.length, inputdim[0]*inputdim[1]);
				// start and end of the data being imported, converted to single
				// numbers
				for(i1 = start; i1 < end; i1++) {
					let pos = [
						coor[0] + positions[i1 - start][0],
						coor[1] + positions[i1 - start][1]
					];
					if(
						pos[0] >= 0 && pos[0] < sa.data_w
						&&
						pos[1] >= 0 && pos[1] < sa.data_h
					) {
						sa.data[ pos[0] ][ pos[1] ] = {
							offset: [0, 0],
							input: [
								i1%inputdim[0],
								Math.floor(i1/inputdim[0])
							],
						};
						sa.clear_overlap(...pos);
					}
				}
				let temp = Math.min(end, inputdim[0]*inputdim[1] - 1);
				sa.control.input = [
					temp%inputdim[0],
					Math.floor(temp/inputdim[0])
				];
				sa.refresh();
			};
			document.getElementById("sa_button_clear").onpointerdown = function() {
				sa.rect_execute(sa.control.selection, function(x, y, outside) {
					sa.data[x][y] = null;
				});
				sa.refresh();
			};
			document.getElementById("sa_button_redimension").onpointerdown = function() {
				let i1 = 0;
				let i2 = 0;
				let input = prompt("enter new canvas dimensions. (measured in blocks, and separated by a comma.)");
				if(input && input.includes(",")) {
					input = input.split(",");
					input = [Number(input[0]), Number(input[1])];
					if(
						Number.isInteger(input[0]) && input[0] > 0
						&&
						Number.isInteger(input[1]) && input[1] > 0
					) {
						let old = [sa.data_w, sa.data_h];
						sa.data_w = input[0];
						sa.data_h = input[1];
						for(i1 = 0; i1 < old[0]; i1++) {
							if(old[1] > input[1]) {
							// decrease in height
								sa.data[i1] = sa.data[i1].slice(0, input[1]);
							}
							else if(old[1] < input[1]) {
							// increase in height
								for(i2 = old[1]; i2 < input[1]; i2++) {
									sa.data[i1][i2] = null;
								}
							}
						}
						if(old[0] > input[0]) {
						// decrease in width
							sa.data = sa.data.slice(0, input[0]);
						}
						else if(old[0] < input[0]) {
						// increase in width
							for(i1 = old[0]; i1 < input[0]; i1++) {
								sa.data[i1] = [];
								for(i2 = 0; i2 < input[1]; i2++) {
									sa.data[i1][i2] = null;
								}
							}
						}
						sa.control.selection = {
							x: 0,
							y: 0,
							w: 1,
							h: 1,
						};
						sa.control.input = [0, 0];
						sa.refresh();
					};
				}
			};
			function inc_change(move) {
				let input = Number(prompt("enter a new " + (move ? "placement" : "block") + " increment." + (move ? " it must divide evenly into the block increment." : "") + String.fromCharCode(10).repeat(2) + "this will wipe the canvas."));
				if(input && Number.isInteger(input) && input > 0 && (!move || sa.block%input === 0)) {
					sa[move ? "move" : "block"] = input;
					sa.initdata();
					sa.control.selection = {
						x: 0,
						y: 0,
						w: 1,
						h: 1,
					};
					sa.control.input = [0, 0];
					sa.refresh();
				}
			}
			document.getElementById("sa_button_change_block_increment").onpointerdown = function(){inc_change(false)};
			document.getElementById("sa_button_change_move_increment").onpointerdown = function(){inc_change(true)};
			function color_change(checker) {
				let color = prompt(
					checker
					?
					"enter a color for the checker pattern. (it can be a tint, or an opaque color. it'll be placed on half of the background tiles, to show the grid.)"
					:
					"enter a background color."
				);
				if(color !== null) {
					sa[checker ? "checker" : "background"] = color ? color : null;
					sa.refresh();
				}
			};
			document.getElementById("sa_button_change_background").onpointerdown = function() {color_change(false)};
			document.getElementById("sa_button_change_checker").onpointerdown = function() {color_change(true)};
			document.getElementById("sa_fileinput").oninput = function() {
				sa.readfile(document.getElementById("sa_fileinput").files[0]);
			};
		},
		readfile: function(file) {
		// run by load and the drag-and-drop event listener.
			let reader = new FileReader();
			reader.onload = function() {
				sa.input = structuredClone(reader.result);
				sa.start();
			};
			reader.readAsDataURL(file);
		},
		start: function() {
		// plays when the image is loaded, starts everything.
			let i1 = 0;
			let i2 = 0;
			for(i1 in sa.ctx) {
				if(sa.ctx.hasOwnProperty(i1)) {
					document.getElementById("sa_" + i1).hidden = false;
				}
			}
			let image = document.createElement("img");
			let ctx = sa.ctx.input;
			let canvas = sa.ctx.input.canvas;
			// image urls, ImageDatas, image elements, canvas elements, and
			// canvas contexts. god bless javascript. this is so dumb.
			image.src = sa.input;
			canvas.width = image.width;
			canvas.height = image.height;
			ctx.drawImage(image, 0, 0);
			//console.log([canvas.width, canvas.height]);
			sa.input = ctx.getImageData(0, 0, canvas.width, canvas.height);
			sa.control.input = [0, 0];
			sa.initdata();
			sa.refresh();
		},
		make_rect: function(x1, y1, x2, y2) {
			let rect = {
				x: x1,
				y: y1,
				w: x2 - x1,
				h: y2 - y1,
			};
			if(rect.w < 0) {
				rect.w--;
				rect.x++;
			}
			else {
				rect.w++;
			};
			if(rect.h < 0) {
				rect.h--;
				rect.y++;
			}
			else {
				rect.h++;
			};
			return rect;
		},
		select_rect: function(ctx, rect) {
		// draws a rectangle to indicate selection.
		// - x, y, w, and h should be measured in sa.block.
			let temp = [
				sa.block*rect.x + .5,
				sa.block*rect.y + .5,
				sa.block*rect.w,
				sa.block*rect.h
			];
			ctx.strokeStyle = "black";
			ctx.strokeRect(...temp);
			ctx.strokeStyle = "white";
			temp[0]--;
			temp[1]--;
			ctx.strokeRect(...temp);
		},
		rect_start: (rect) => [
			rect.x - (rect.w < 0),
			rect.y - (rect.h < 0)
		],
		in_rect: (rect, x, y) => (
			x >= Math.min(rect.x, rect.x + rect.w)
			&&
			x < Math.max(rect.x, rect.x + rect.w)
			&&
			y >= Math.min(rect.y, rect.y + rect.h)
			&&
			y < Math.max(rect.y, rect.y + rect.h)
		),
		rect_execute: function(rect, code) {
		// executes a (x, y, outside) function for every block in a rectangle.
		// - outside is a boolean for whether it's the edge of the rectangle.
			let i1 = 0;
			let i2 = 0;
			let x = Math.min(rect.x, rect.x + rect.w);
			let y = Math.min(rect.y, rect.y + rect.h);
			let w = Math.max(rect.x, rect.x + rect.w) - x;
			let h = Math.max(rect.y, rect.y + rect.h) - y;
			for(i1 = 0; i1 < rect.w; i1++) {
				for(i2 = 0; i2 < rect.h; i2++) {
					code(
						rect.x + i1,
						rect.y + i2,
						i1 === 0 || i1 === rect.w - 1 || i2 === 0 || i2 === rect.h - 1
					);
				}
			}
		},
		block_coor: function(x, y, detect) {
		// converts canvas coordinates to block coordinates
		// - detect: if true, it'll return which tile you clicked, or null if
		//   there's nothing in that spot.
		//   - that sounds like exactly the same thing, and it almost is
		//   - but depending on a tile's offset property, it can reach into the
		//     the blocks below and to the right.
			let obj = {
				x: Math.floor(x/sa.block),
				y: Math.floor(y/sa.block),
			};
			obj.offset = [
				Math.floor((x - obj.x*sa.block)/sa.move)*sa.move,
				Math.floor((y - obj.y*sa.block)/sa.move)*sa.move
			];
			if(detect) {
				let i1 = 0;
				let i2 = 0;
				for(i1 = 0; i1 < 2; i1++) {
				// this row, then the one above
					for(i2 = 0; i2 < 2; i2++) {
					// this column, then the one to the left
						let index = [obj.x - i2, obj.y - i1];
						//console.log(index)
						if(index[0] >= 0 && index[0] < sa.data_w && index[1] >= 0 && index[1] < sa.data_h) {
							let ref = sa.data[index[0]][index[1]];
							if(
								ref
								&&
								ref.offset[0] - i2 <= obj.offset[0]
								&&
								ref.offset[1] - i1 <= obj.offset[1]
							) {
							// the subtraction is because a click on the very
							// left edge counts, but not the right edge.
							// technically that's not inside the rectangle.
								return index;
							};
						}
					}
				}
				return null;
				// null if there's no block there.
			};
			return obj;
		},
		clear_overlap: function(x, y) {
		// deletes any blocks that are overlapping this one.
			let i1 = 0;
			let i2 = 0;
			let main = sa.data[x][y];
			if(!main) {
				return;
			};
			for(i1 = -1; i1 <= 1; i1++) {
				for(i2 = -1; i2 <= 1; i2++) {
				// check all eight neighbors
					let index = [x + i2, y + i1];
					if(
						index[0] >= 0 && index[0] < sa.data_w
						&&
						index[1] >= 0 && index[1] < sa.data_h
						&&
						(i1 || i2)
					) {
						let ref = sa.data[index[0]][index[1]];
						if(
							ref
							&&
							Math.abs((i2*sa.block + ref.offset[0]) - main.offset[0]) < sa.block
							&&
							Math.abs((i1*sa.block + ref.offset[1]) - main.offset[1]) < sa.block
						) {
						// if their top-left corner is less than sa.block away
						// from this one in either axis, delete it.
							sa.data[index[0]][index[1]] = null;
						};
					}
				}
			}
		},
		incrementer: function(array) {
		// runs through the increments and runs a list of x/y indexes.
			let i1 = 0;
			let i2 = 0;
			let place = [];
			let total = 1;
			for(i1 = 0; i1 < array.length; i1++) {
				place[i1] = 0;
				total *= array[i1];
			}
			function tickup(index) {
				place[index]++;
				if(place[index] >= array[index]) {
					place[index] = 0;
					if(index < place.length - 1) {
						tickup(index + 1);
					};
				}
			}
			let positions = [];
			for(i1 = 0; i1 < total; i1++) {
				let x_mult = 1;
				let y_mult = 1;
				let x = 0;
				let y = 0;
				for(i2 = 0; i2 < place.length; i2++) {
					if(i2%2) {
						y += y_mult*place[i2];
						y_mult *= array[i2];
					}
					else {
						x += x_mult*place[i2];
						x_mult *= array[i2];
					}
				}
				positions[positions.length] = [x, y];
				// for every number of a given place, multiply it by previous
				// maximums in that axis. (ex: for a [1, 2, 3, 2], a 1 in [3]
				// would mean a 2 y offset, since the previous y number was
				// another 2.)
				tickup(0);
			}
			return positions;
		},
		refresh: function() {
			let i1 = 0;
			let i2 = 0;
			sa.ctx.input.putImageData(sa.input, 0, 0);
			const ctx = sa.ctx.main;
			const input = sa.ctx.input;
			const dim = [
				sa.data_w*sa.block,
				sa.data_h*sa.block
			];
			ctx.canvas.width = dim[0];
			ctx.canvas.height = dim[1];
			ctx.clearRect(0, 0, ...dim);
			if(sa.background) {
				ctx.fillStyle = sa.background;
				ctx.fillRect(0, 0, ...dim);
			};
			if(sa.checker) {
				ctx.fillStyle = sa.checker;
				for(i1 = 0; i1 < sa.data_w; i1++) {
					for(i2 = 0; i2 < sa.data_h; i2++) {
						if(i1%2 === i2%2) {
							ctx.fillRect(sa.block*i1, sa.block*i2, sa.block, sa.block);
						};
					}
				}
			}
			for(i1 = 0; i1 < sa.data_w; i1++) {
				for(i2 = 0; i2 < sa.data_h; i2++) {
					let ref = sa.data[i1][i2];
					if(ref) {
						let temp = input.getImageData(
							sa.block*ref.input[0],
							sa.block*ref.input[1],
							sa.block, sa.block
						);
						ctx.putImageData(
							temp,
							sa.block*i1 + ref.offset[0],
							sa.block*i2 + ref.offset[1]
						);
					};
				}
			}
			sa.clean_image = ctx.getImageData(0, 0, ...dim);
			sa.select_rect(sa.ctx.input, {x: sa.control.input[0], y: sa.control.input[1], w: 1, h: 1});
			sa.select_rect(ctx, sa.control.selection);
		},
		paint: function(x, y) {
			sa.data[x][y] = {
				offset: [0, 0],
				input: structuredClone(sa.control.input),
			};
			sa.clear_overlap(x, y);
		},
		mousedown: function(e) {
			let i1 = 0;
			let i2 = 0;
			let click = clickxy(e, "sa");
			let block = sa.block_coor(...click, true);
			click = sa.block_coor(...click);
			let tool = sa.control.tool;
			let selection = sa.control.selection;
			sa.control.clicktype = "main";
			sa.control.strokedata = null;
			if(block && tool !== "move") {
				sa.control.selection = {
					x: block[0],
					y: block[1],
					w: 1,
					h: 1,
				};
				//sa.control.input = structuredClone(sa.data[click.x][click.y].input);
			};
			if(tool === "move") {
				sa.control.strokedata = {
					click,
					in_rect: sa.in_rect(selection, ...(block ?? [click.x, click.y])),
				};
			}
			else if(tool === "swap") {
				sa.control.strokedata = block ?? [click.x, click.y];
			}
			else if(tool === "paint") {
				sa.paint(click.x, click.y);
			};
			sa.refresh();
		},
		mousemove: function(e, finish) {
			let i1 = 0;
			let i2 = 0;
			let click = clickxy(e);
			let block = sa.block_coor(...click, true);
			click = sa.block_coor(...click);
			document.getElementById("sa_coordisplay").innerHTML = [
				"x: " + click.x + ":" + click.offset[0],
				"y: " + click.y + ":" + click.offset[1]
			].join("<br>");
			if(sa.control.clicktype !== "main") {
				return;
			}
			let tool = sa.control.tool;
			let selection = sa.control.selection;
			let stroke = sa.control.strokedata;
			let skip_refresh = false;
			let ctx = sa.ctx.main;
			ctx.putImageData(sa.clean_image, 0, 0);
			if(tool === "move") {
				if(stroke.in_rect) {
				// move
					let _data = structuredClone(sa.data);
					let _selection = structuredClone(selection);
					let diff = [
						(sa.block*click.x + click.offset[0]) - (sa.block*stroke.click.x + stroke.click.offset[0]),
						(sa.block*click.y + click.offset[1]) - (sa.block*stroke.click.y + stroke.click.offset[1])
					];
					if(stroke.in_rect || stroke.block) {
						diff = [
							[Math.trunc(diff[0]/sa.block), diff[0]%sa.block],
							[Math.trunc(diff[1]/sa.block), diff[1]%sa.block],
						];
						// number of blocks to move, number of pixels
						let func = function(x, y, outside, select) {
							let block = structuredClone(sa.data[x][y]);
							if(!block) {
								return;
							}
							sa.data[x][y] = null;
							let temp = [
								block.offset[0] + diff[0][1],
								block.offset[1] + diff[1][1]
							];
							block.offset[0] = posmod(temp[0], sa.block);
							block.offset[1] = posmod(temp[1], sa.block);
							let _x = x + diff[0][0] + Math.round((temp[0] - block.offset[0])/sa.block);
							let _y = y + diff[1][0] + Math.round((temp[1] - block.offset[1])/sa.block);
							if(_x < 0 || _x >= sa.data_w || _y < 0 || _y >= sa.data_h) {
								return;
							};
							sa.data[_x][_y] = structuredClone(block);
							if(outside) {
								sa.clear_overlap(_x, _y);
							};
							if(select) {
								sa.control.selection = {
									x: _x,
									y: _y,
									w: 1,
									h: 1,
								};
							}
						};
						if(stroke.in_rect) {
							sa.rect_execute(selection, func);
							selection.x += diff[0][0];
							selection.y += diff[1][0];
							selection.x = Math.min(sa.data_w, Math.max(selection.x, 0));
							selection.w = Math.min(sa.data_w, Math.max(selection.x + selection.w, 0)) - selection.x;
							selection.y = Math.min(sa.data_h, Math.max(selection.y, 0));
							selection.h = Math.min(sa.data_h, Math.max(selection.y + selection.h, 0)) - selection.y;
							// move the selection to match, but keep it inside
						}
						else {
							func(...stroke.block, true, true);
						};
						if(!finish) {
						// display changes, but restore the old version
							sa.refresh();
							skip_refresh = true;
							sa.data = structuredClone(_data);
							sa.control.selection = structuredClone(_selection);
						}
					}
				}
				else {
				// select
					let rect = sa.make_rect(stroke.click.x, stroke.click.y, click.x, click.y);
					if(finish) {
						sa.control.selection = structuredClone(rect);
					}
					else {
						sa.select_rect(ctx, rect);
					};
				}
			}
			else if(tool === "swap" && finish) {
			// swap the blocks at the beginning and end of the stroke
				let start = stroke;
				let _start = sa.data[ start[0] ][ start[1] ];
				let end = block ?? [click.x, click.y];
				let _end = sa.data[ end[0] ][ end[1] ];
				if(!_start && !_end) {
				}
				else if(!_start) {
					sa.data[ start[0] ][ start[1] ] = {
						offset: [0, 0],
						input: structuredClone(_end.input),
					};
					sa.data[ end[0] ][ end[1] ] = null;
				}
				else if(!_end) {
					sa.data[ end[0] ][ end[1] ] = {
						offset: [0, 0],
						input: structuredClone(_start.input),
					};
					sa.data[ start[0] ][ start[1] ] = null;
				}
				else {
					let temp = structuredClone(_start.input);
					_start.input = structuredClone(_end.input);
					_end.input = structuredClone(temp);
				};
				sa.control.selection = {
					x: end[0],
					y: end[1],
					w: 1,
					h: 1,
				};
			}
			else if(tool === "paint") {
				sa.paint(click.x, click.y);
				sa.refresh();
				skip_refresh = true;
			};
			if(finish) {
				if(!skip_refresh) {
					sa.refresh();
				};
				sa.control.clicktype = null;
			};
		},
		mouseup: function(e) {
			sa.mousemove(e, true);
		},
	};
	sa.initialize();
	//
	let palette = {
		colortypes: ["a", "b", "c", "skin", "outline", "wildcard"],
		ctx: null,
		initialize: function() {
			let i1 = 0;
			let html = [];
			for(i1 = 0; i1 < 3; i1++) {
				html[i1] = `<input type="color" id="palette_` + "abc"[i1] + `">`;
			}
			html = [
				`interactive tool for the rules i make character palettes with.
				<ul>
					<li>
					three base colors
					</li>
					<li>
					skin color
					</li>
					<li>
					dark color for outlines
					</li>
					<li>
					squarings of all of those, for lighting
					</li>
					<li>
					multiplications of the base colors, for variety
					</li>
					<li>
					white for lighting and eye whites
					</li>
					<li>
					transparency
					</li>
					<li>
					extra color for anything not covered by all that. (black,
					iris colors, visual effects)
					</li>
				</ul>`,
				`<label>` + html.join(` `) + ` base colors</label>`
			];
			for(i1 = 0; i1 < palette.colortypes.length; i1++) {
				let type = palette.colortypes[i1];
				if(type.length !== 1 || !"abc".includes(type)) {
					html[html.length] = `<label><input type="color" id="palette_` + type + `"> ` + type + `</label>`;
				}
			}
			html[html.length] = `<button id="palette_randomize">randomize</button>`;
			html[html.length] = `<canvas id="palette_canvas" width=32 height=32></canvas>`;
			html = `<div name="hider" id="hider_palette_tester">\n` + html.join(`<br>`) + `\n</div>`;
			document.write(html);
			for(i1 = 0; i1 < palette.colortypes.length; i1++) {
				document.getElementById("palette_" + palette.colortypes[i1]).onchange = palette.refresh;
			}
			document.getElementById("palette_randomize").onclick = palette.randomize;
			document.getElementById("palette_canvas").style["image-rendering"] = "crisp-edges";
			palette.ctx = document.getElementById("palette_canvas").getContext("2d");
			document.getElementById("palette_skin").value = "#6f9f9f";
			palette.randomize();
			// initialize the value, refresh
		},
		randomize: function() {
			let convert = (color) => Color.rgb(palette.ctx, color, true);
			let temp = Color.random(3);
			for(i1 = 0; i1 < 3; i1++) {
				document.getElementById("palette_" + "abc"[i1]).value = convert(temp[i1]);
			}
			document.getElementById("palette_outline").value = convert(Color.random(null, true));
			document.getElementById("palette_wildcard").value = convert(Color.random());
			palette.refresh();
		},
		refresh: function() {
			let ctx = palette.ctx;
			let dim = [ctx.canvas.width, ctx.canvas.height];
			let colors = [];
			for(i1 = 0; i1 < palette.colortypes.length; i1++) {
				colors[i1] = document.getElementById("palette_" + palette.colortypes[i1]).value;
			};
			colors = Color.palette(ctx, ...colors);
			ctx.clearRect(0, 0, dim[0], dim[1]);
			const w = 4;
			const h = Math.ceil(colors.length/w);
			dim[0] /= w;
			dim[1] /= h;
			for(let i1 = 0; i1 < colors.length; i1++) {
				ctx.fillStyle = colors[i1];
				ctx.fillRect(dim[0]*(i1%w), dim[1]*Math.floor(i1/w), dim[0], dim[1]);
			}
		},
	};
	palette.initialize();
	//
	document.write(`<div name="hider" id="hider_interactive_animation"></div>`);
	class Intanisy {
	// "interactive animation system"
		constructor() {
			let temp = {
				w: 256,
				h: 256,
				color: "white",
				div: null,
				ctx: null,
			};
			for(let i1 in temp) {
				if(temp.hasOwnProperty(i1)) {
					this[i1] = structuredClone(temp[i1]);
				};
			}
		}
		initialize(div) {
			this.div.innerHTML = `<canvas width=` + this.w + ` height=` + this.h + `></canvas>`;
			let canvas = div.querySelector("canvas");
			canvas.style["image-rendering"] = "crisp-edges";
			canvas.style["touch-action"] = "none";
			this.ctx = canvas.getContext("2d");
			canvas.onpointerdown = this.mousedown;
			canvas.onpointermove = this.mousemove;
			canvas.onpointerup = this.mouseup;
		}
		mousedown(e) {
			let click = clickxy(e);
		}
		mousemove(e) {
			let click = clickxy(e);
		}
		mouseup(e) {
			let click = clickxy(e);
		}
	}
	let ias = new Intanisy(document.getElementById("hider_intanisy"));
	//
	document.write(`<div name="hider" id="hider_background_maker"></div>`);
	let bgm = {
		draw: {
			ctx: null,
			ctx_ui: null,
			ui: {},
			ui_color: ["orange", "white", "#ffdfef"],
			valid: {
				tool: ["pen", "eraser", "colorpick"],
			},
			control: {
				_tool: 0,
				// get tool
				// set tool
				color_pen: "black",
				color_eraser: "white",
			},
			initialize: function() {
				let i1 = 0;
				let i2 = 0;
				let control = this.control;
				let valid = this.valid;
				Object.defineProperty(control, "tool", {
					get() {
						return valid.tool[ control._tool ];
					},
					set(value) {
						value = valid.tool.indexOf(value);
						if(value !== -1) {
							control._tool = value;
						};
					},
				})
				let html = [
					`<canvas id="bgm_draw" width=256 height=256></canvas>`,
					`<canvas id="bgm_draw_ui" width=256 height=256></canvas>`
				];
				document.getElementById("hider_background_maker").innerHTML = html.join("\n");
				const array = ["down", "move", "up"];
				for(i1 = 0; i1 < 2; i1++) {
					let canvas = document.getElementById(i1 ? "bgm_draw_ui" : "bgm_draw");
					canvas.style["image-rendering"] = "crisp-edges";
					// no antialiasing
					canvas.style["touch-action"] = "none";
					// this keeps it from sliding around when you're using a phone.
					this[i1 ? "ctx_ui" : "ctx"] = canvas.getContext("2d");
					this[i1 ? "ctx_ui" : "ctx"].font = "6px 'thick 4x4'";
					for(i2 = 0; i2 < array.length; i2++) {
						let type = array[i2];
						let name = (i1 ? "ui_" : "") + "mouse" + type;
						if(name in this) {
							canvas["onpointer" + type] = this[name];
						};
					}
				}
				let _this = this;
				this.ctx_ui.canvas.onpointerdown = function(e) {
					let click = clickxy(e, "bgm");
					let button = Rect.inside_multi(_this.ui, ...click);
					if(button) {
						_this.ui_action(button);
					}
				};
				this.ui = Rect.ui([
					{
						prefix: "tool",
						first: {
							suffix: this.valid.tool,
							w: 8, h: 2,
						},
						heading: 1,
					},
					{
						prefix: "color",
						first: {
							suffix: ["pen", "eraser"],
							w: 4, h: 2, horizontal: true,
						},
						heading: 1,
					},
					{
						prefix: "misc",
						first: {
							suffix: ["canvas_w", "canvas_h"],
							w: 4, h: 2,
						},
						heading: 1,
					}
				]);
				let ui_block = 8;
				for(i1 in this.ui) {
					if(this.ui.hasOwnProperty(i1)) {
						this.ui[i1].x *= ui_block;
						this.ui[i1].y *= ui_block;
						this.ui[i1].w *= ui_block;
						this.ui[i1].h *= ui_block;
					}
				}
				this.ui_refresh();
			},
			ui_refresh: function() {
				let i1 = 0;
				let i2 = 0;
				let ctx = this.ctx_ui;
				let outlines = {};
				let dim = [0, 0];
				for(i1 in this.ui) {
					if(this.ui.hasOwnProperty(i1)) {
						dim = [
							Math.max(dim[0], Rect.r(this.ui[i1])),
							Math.max(dim[1], Rect.d(this.ui[i1]))
						];
					}
				};
				ctx.canvas.width = dim[0] + 1;
				ctx.canvas.height = dim[1] + 1;
				ctx.clearRect(0, 0, ...dim);
				ctx.font = "6px 'thick 4x4'";
				ctx.textBaseline = "middle";
				for(i1 in this.ui) {
					if(this.ui.hasOwnProperty(i1)) {
						let prefix = PreSuf.get(i1);
						let suffix = prefix[1];
						prefix = prefix[0];
						let rect = this.ui[i1];
						let selected = Number(
							(prefix === "tool" && this.control.tool === suffix)
						);
						let color = structuredClone(this.ui_color);
						ctx.strokeStyle = color[ posmod(- selected, color.length) ];
						if(suffix !== "heading") {
							ctx.fillStyle = color[ posmod(1 - selected, color.length) ];
							if(prefix === "color") {
								ctx.fillStyle = this.control[i1];
							}
							ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
							outlines[i1] = ctx.strokeStyle;
						}
						buttontext(
							null,
							// settings
							ctx, rect,
							(
								suffix === "heading" ? prefix :
								(prefix === "misc" && suffix === "canvas_w") ? ["canvas", "width"] :
								(prefix === "misc" && suffix === "canvas_h") ? ["canvas", "height"] :
								suffix
							),
							// text
							null,
							(
								suffix === "heading"
								||
								prefix === "color"
								||
								prefix === "misc"
							)
						);
					}
				}
				for(i1 in outlines) {
					if(outlines.hasOwnProperty(i1)) {
						ctx.strokeStyle = outlines[i1];
						let rect = this.ui[i1];
						ctx.strokeRect(rect.x + .5, rect.y + .5, rect.w, rect.h);
					}
				}
			},
			ui_action: function(button) {
				let prefix = PreSuf.get(button);
				let suffix = prefix[1];
				prefix = prefix[0];
				if(prefix === "tool") {
					this.control.tool = suffix;
				}
				else if(prefix === "color") {
					let color = prompt("enter a new " + suffix + " color.");
					if(color) {
						this.control[button] = color;
					};
				}
				else if(prefix === "misc") {
					if(suffix === "canvas_w" || suffix === "canvas_h") {
						let dim = suffix === "canvas_w" ? "width" : "height";
						let num = Number(prompt("enter a new " + dim + " for the drawing area."));
						if(Number.isInteger(num) && num > 0) {
							let _ctx = this.ctx;
							let imagetemp = _ctx.getImageData(0, 0, _ctx.canvas.width, _ctx.canvas.height);
							_ctx.canvas[dim] = num;
							_ctx.clearRect(0, 0, _ctx.canvas.width, _ctx.canvas.height);
							let filltemp = _ctx.fillStyle;
							_ctx.fillStyle = this.control.color_eraser;
							_ctx.fillRect(0, 0, _ctx.canvas.width, _ctx.canvas.height);
							_ctx.fillStyle = filltemp;
							_ctx.putImageData(imagetemp, 0, 0);
						};
					}
				};
				this.ui_refresh();
			},
		},
		initialize: function() {
			this.draw.initialize();
		}
	};
	bgm.initialize();
	//
	document.write(`<div name="hider" id="hider_facial_proportions_tool"></div>`);
	let fpt = {
	// lets you edit and visualize facial proportions by dragging markers along
	// axes.
	// - marker structure:
	//   - [part name]
	//     - x/y/z
	//       - parent: which other part its coordinates are relative to. (null
	//         means it isn't relative to anything, it starts at 0.)
	//       - start: the start coordinate of this part minus the end of the
	//         parent part. (or the start of the parent part, if it had no end.)
	//       - end: the coordinate of the end of this part, minus the start of
	//         this part.
	//       - dim: the distance from the center/start of the part to its edges.
	//         this is special in some ways.
	//         - first, a duplicate handle will be made. there will be a start +
	//           dim handle and a start - dim handle. both can be moved to scale
	//           the part.
	//         - second, if a parenting string ends with + or -, parts can be
	//           made relative to one of these edges. for example, nose.z's
	//           parent is cranium+. it will be positioned relative to the front
	//           edge of the cranium.
	//       - [any other string]: another reference point.
	//         - for example, the start of the nose is the top of the bridge,
	//           and the end of the nose is the bottom. this is true in all
	//           axes.
	//         - so the front or side points will be nose.front and nose.side.
	// cranium, jaw, nose, eye, brow, mouth, ears
		markers: {
			cranium: {
				x: {
					// the cranium can't be moved in the x axis, because it
					// doesn't mix well with the x/dim handle duplicates. it
					// isn't impossible or anything, but there's no reason to
					// move the cranium in the x axis anyway. (unlike the y or z
					// axis where you might move it to make room for the jaw or
					// nose, all x features are symmetrical.)
					dim: 16,
				},
				y: {
					start: 0,
					dim: 14,
				},
				z: {
					start: 0,
					dim: 16,
				},
			},
			jaw: {
				parent: "cranium",
				x: {
					dim: 12,
				},
				y: {
					parent: "cranium+",
					start: 14,
					end: -6,
				},
				z: {
					parent: "cranium+",
					start: -2,
					end: -22,
				},
			},
			ear: {
				parent: "cranium",
				x: {
					parent: "cranium+",
					start: -2,
					end: 4,
					skew: 3/2,
				},
				y: {
					parent: "cranium+",
					start: -6,
					dim: 6,
					middle: 1,
				},
				z: {
					start: 0,
					end: -7,
					middle: -5,
					skew: -1,
				},
			},
			nose: {
				parent: "cranium",
				x: {
					start: 2,
					side: 2,
					front: 0,
					end: 0,
				},
				y: {
					start: 2,
					side: 7,
					front: 6,
					end: 10,
				},
				z: {
					parent: "cranium+",
					start: 0,
					side: -2,
					front: 2,
					end: 0,
				},
			},
			mouth: {
				parent: "cranium",
				x: {
					dim: 9,
				},
				y: {
					parent: "nose",
					start: 5,
					end: 1,
				},
				z: {
					parent: "cranium+",
					start: -1,
					end: -9,
				},
			},
			brow: {
				parent: "eye",
				x: {
					start: -4,
					bend: 4,
					end: 9,
				},
				y: {
					start: -7,
					bend: -1,//-8/2,
					end: 1,//11/2,
				},
				z: {
					start: 4,
					bend: -3,
					end: -9,
				},
			},
			eye: {
				parent: "cranium",
				x: {
					start: 8,
					dim: 4,
					roll: .5,
				},
				y: {
					start: 6,
					dim: 4,
					upper: -3.5,
					lower: 2.5,
				},
				z: {
					start: 8,
					dim: 4,
					corner: -1,
				},
			},
		},
		handles: [],
		// an array of objects storing information related to the draggable
		// markers.
		// - x, y (of the center of the marker)
		// - prefix
		// - axis (the axis it represents, that is.)
		// - suffix
		settings: {
			cell_w: 64,
			cell_h: 64,
			barwidth: 8,
			fineness: 32,
			handleleeway: 2,
			disablelids: false,
		},
		/*
		color: {
			bg: "white",
			skin: "#6f9f9f",
			main: "#3f7f6f",
			nose: "cornflowerblue",
			eye: "red",
			brow: "brown",
			mouth: "cornflowerblue",
		},
		//*/
		color: {
			bg: "white",
			skin: "#6f9f9f",
			main: "#578f87",
			ear: "#3f7f6f",
			cranium: "#3f7f6f",
			jaw: "#3f7f6f",
			brow: "#5b674f",
			eye: "red",
		},
		control: {
			handle_index: -1,
			get handle() {
				return fpt.handles[fpt.control.handle_index] ?? null;
			},
			downclick: null,
			// coordinates of the mousedown
		},
		states: null,
		// a States object, for undo/redo
		ctx: null,
		element: (name) => document.getElementById(tohtmlid("fpt " + name)),
		initialize: function() {
			if(fpt.settings.disablelids) {
				delete fpt.markers.eye.y.upper;
				delete fpt.markers.eye.y.lower;
			}
			fpt.scale(2);
			fpt.markers.nose.z.end--;
			fpt.markers.mouth.z.start--;
			let manual = arraytoul([
				"this tool lets you edit the proportions of a face by moving \"markers\".",
				"you move them by clicking and dragging those little tick marks on those three lanes.",
				[
					"the left lane is x axis markers, the vertical lane is y axis markers, the right lane is z markers.",
					"each line represents a different part, and each marker controls a different aspect of the part."
				],
				"generally, there is a \"start\" marker for where a part is, and an \"end\" marker for where it ends, or a \"dim\" marker for what the dimensions of the part are.",
				[
					"dim is measured from the center to the edge. so, an x dim of 32 means the width is 64.",
					"start, end, and dim markers look bigger than the others."
				],
				"as for other kinds of markers...",
				[
					"brow \"bend\": the eyebrow is drawn by connecting the start, bend, and end. the start is connected to the bend by a straight line, but the bend is connected to the end by whatever circular arc the start-bend line can flow into. ...this also means you can make dumb insect antennae if you screw around with it. have fun i guess.",
					"ears: the ear is drawn by connecting two spheroids. a smaller one closer to the start, and a bigger one closer to the end.",
					[
						"start and end define the box these spheroids fit inside.",
						"y middle defines where the bottom edge of the top spheroid is.",
						"z middle is where the back edge of the bottom spheroid is.",
						"x/z skew adds skew between them. moving the skew marker to start makes the changes caused by start/end/middle a lot easier to understand.",
						"this is probably the most confusing part. sorry about that."
					],
					"nose",
					[
						"start is the top of the nose, end is the bottom, front is the outermost point, front is the tip of the nose.",
						"the nose is drawn by connecting start, front, and end to side and their mirrored counterpart."
					],
					"eyes",
					[
						"y upper and y lower are where the eyelids are.",
						"z corner is the z position of the outer corner of the eye, which is used to figure out how much the eye gets xz rotated.",
						"x roll is how much the eye is rotated. xy rotation. after the xz rotation. putting it in the center will avoid rotation entirely, putting it at the outer edge will rotate 90 degrees. the inner edge will rotate -90 degrees."
					]
				],
				"parts are positioned relative to each other, so moving one moves the others. most parts are positioned relative to the center of the cranium, but there's a few exceptions. it works about how you expect.",
				[
					"the eyebrows are positioned relative to the eyes.",
					"the x position of the ears is relative to the outer edge of the cranium, and the y position relative to the bottom.",
					"jaw y position is relative to the bottom of the cranium.",
					"mouth y position is relative to the bottom of the nose.",
					"for the jaw, nose, and mouth, the z position is relative to the front of the cranium."
				],
				"markers besides start are relative to the part's start marker.",
				"special edits",
				[
					"a text-based system for making precise edits, or random edits.",
					"a special edit command is three words: a target, an operation, and a number.",
					"for example, \"mouth.y.end + 8\" would make your face frown :(",
					"types of targets:",
					[
						"specific: one specific marker, like mouth.y.end. or you could write something like mouth.y to affect all mouth y markers, or just mouth to affect all mouth markers.",
						"any: one random marker.",
						"all: all markers.",
						"any and all can have conditions. write a parentheses after it, and put words like this in them, separated by commas.",
						[
							"x, y, z: must be a marker of that axis.",
							"rand_axis: has the same effect as x, y, or z. it picks one at random.",
							"the same kind of categories that work for specific. (ex: \"mouth\" means it must be a mouth marker.)",
							"position: must be a \"start\" marker, the markers that control the position of entire parts.",
							"dimension: must be an \"end\" or \"dim\" marker, the markers that control the size of parts.",
							"other: must be something besides a start, end, or dim.",
							"0 to 1 number: probability of the change actually happening. for each marker, a change is only made if a random 0 to 1 number is less than this. useful for making scaling edits look a little more organic.",
							"any of these can be inverted by putting ! before them. for example, \"!z\" means it'll be applied to anything that isn't a z marker.",
							"it'll only modify markers that fulfill all of these. or, for any, it'll edit only one random marker out of all the ones that fulfill the conditions."
						],
					],
					"types of operations:",
					[
						"+: the number is added to the marker.",
						"-: the number is subtracted from the marker.",
						"*: the marker is multiplied by the number.",
						"/: the marker is divided by the number.",
						"+-: the number is added or subtracted.",
						"*/: the marker is multiplied or divided by the number.",
						"=: the marker is set as the given number.",
						"in the cases of +- and */, although it's random which one it picks, it's consistent.",
						[
							"for every axis, it picks one randomly.",
							"so, for \"all(1/2) */ 3/4\", it's random whether x markers will be multiplied or divided, and whether y will multiplied or divided, etc. but all x markers will have the same operation, all y markers will have the same operation, etc."
						]
					],
					"numbers can be written as fractions. same for the numbers in probability conditions.",
					"you can execute multiple edits at once by separating them with & symbols."
				]
			]);
			let html = [
				`<details class="text">\n\t<summary>manual</summary>\n\t` + manual.replaceAll(`\n`, `\n\t`) + `\n</details>`,
				`<canvas id="fpt_canvas"></canvas>`,
				addhtml("fpt", "button", "undo") + ` ` + addhtml("fpt", "button", "redo"),
				addhtml("fpt", "input", "special edit input", `type="text" style="width: 30em" value=\"all(1/4, !z, !eye, !cranium) +- 1 & all(1/4, eye, other) +- 1\"`, null, "special edit:"),
				`<button id="fpt_special_edit_execute">execute</button>`,
				[
					addhtml("fpt", "input", "cell w", `type="number" style="width: 4em" step=2 value=` + fpt.settings.cell_w, null, "width"),
					addhtml("fpt", "input", "cell h", `type="number" style="width: 4em" step=2 value=` + fpt.settings.cell_h, null, "height"),
					addhtml("fpt", "button", "apply dimensions", null, "apply")
				].join(" "),
				[
					addhtml("fpt", "input", "scale", `style="width: 2em" value=2`),
					addhtml("fpt", "button", "multiply"),
					addhtml("fpt", "button", "divide")
				].join(" "),
				addhtml("fpt", "textarea", "data", null, null, "data text:"),
				addhtml("fpt", "button", "apply data", null, "apply changes")
			].join(`\n<br>`);
			document.getElementById("hider_facial_proportions_tool").innerHTML = html;
			let canvas = document.getElementById("fpt_canvas");
			fpt.ctx = canvas.getContext("2d");
			canvas.style["image-rendering"] = "crisp-edges";
			canvas.style["touch-action"] = "none";
			canvas.onpointerdown = fpt.mousedown;
			canvas.onpointermove = fpt.mousemove;
			canvas.onpointerup = fpt.mouseup;
			fpt.refresh("states");
			// no new state, since the States constructor will make one
			// automatically.
			fpt.states = new States(fpt, 32, (tool) => structuredClone(tool.markers), function(tool, state) {
				tool.markers = structuredClone(state);
				tool.refresh("states");
			});
			fpt.element("undo").onclick = function() { fpt.states.undo() };
			fpt.element("redo").onclick = function() { fpt.states.redo() };
			fpt.element("apply dimensions").onclick = function() {
				let w = Number(fpt.element("cell w").value);
				let h = Number(fpt.element("cell h").value);
				w = Number.isInteger(w) && w > 1 ? w : fpt.settings.cell_w;
				h = Number.isInteger(h) && h > 1 ? h : fpt.settings.cell_h;
				w = Math.floor(w/2)*2;
				h = Math.floor(h/2)*2;
				fpt.settings.cell_w = w;
				fpt.settings.cell_h = h;
				fpt.refresh(["states", "datatext"]);
			};
			fpt.element("multiply").onclick = function() {
				let scale = Math.abs(readnumber(fpt.element("scale").value) ?? 1);
				if(scale) {
					fpt.scale(scale);
					fpt.refresh();
				};
			};
			fpt.element("divide").onclick = function() {
				let scale = Math.abs(readnumber(fpt.element("scale").value) ?? 1);
				if(scale) {
					fpt.scale(1/scale);
					fpt.refresh();
				};
			};
			fpt.element("data").cols = 36;
			fpt.element("apply data").onclick = function() {
			// NOTE: the logic that unabsolutes coordinates won't work quite
			// right if the data is missing coordinates, like if it's missing
			// a part's start...
			// - i didn't fix that because there's no particular reason to
			//   expect that to happen. of course it'd glitch if you screw with
			//   the text. are you stupid?
			// - if a fix is ever needed, you could do that by iterating through
			//   the current state of fpt.markers and filling the missing values
			//   with fpt.abscoor.
				let data = basictexttoobj(fpt.element("data").value);
				if(data) {
					for(let i1 in data) {
						for(let i2 = 0; i2 < 3; i2++) {
							let axis = "xyz"[i2];
							let _data = data[i1][axis];
							let ref = fpt.markers[i1][axis];
							let parentend = (ref.parent ?? fpt.markers[i1].parent) ?? "";
							if(parentend) {
							// figure out the coordinates of the end of the
							// parent, since that'll be necessary no matter
							// what, at least to figure out the start's relative
							// coordinate.
								let sign = parentend.endsWith("-") ? -1 : parentend.endsWith("+") ? 1 : 0;
								let parent = data[ sign ? parentend.slice(0, -1) : parentend ][axis];
								parentend = "start" in parent ? parent["end" in parent ? "end" : "start"] : 0;
								parentend += sign*(parent.dim ?? 0);
								// parent start/end abscoor plus sign*dim
							}
							else {
								parentend = 0;
							};
							let parentcoor = parentend;
							if("start" in _data) {
							// if the part has a start, set it as the
							// abscoor minus parentend.
								parentcoor = _data.start;
								ref.start = parentcoor - parentend;
							};
							for(let i3 in _data) {
								if(_data.hasOwnProperty(i3) && i3 !== "parent" && i3 !== "start") {
									ref[i3] = _data[i3] - (i3 !== "dim")*parentcoor;
								}
							}
						}
					}
					fpt.refresh("states");
				}
				/*
				abscoor: function(prefix, axis, suffix) {
					let num = fpt.markers[prefix][axis][suffix];
					return (
						suffix === "dim" ? num :
						fpt.parentcoor(prefix, axis) + (suffix === "start" ? 0 : num)
					);
				},
				//*/
			};
			fpt.element("special edit execute").onclick = function() {
				fpt.special_edit(fpt.element("special edit input").value);
			};
			//element = fpt.element;
			//addhtml("fpt", "textarea", "data", "cols=32", null, "data text"),
			//addhtml("fpt", "button", "apply data")
		},
		scale: function(scale) {
			let w = scale*fpt.settings.cell_w;
			let h = scale*fpt.settings.cell_h;
			w = Math.floor(w/2)*2;
			h = Math.floor(h/2)*2;
			if(!(w > 0 && h > 0)) {
				return;
			}
			fpt.settings.cell_w = w;
			fpt.settings.cell_h = h;
			for(let i1 in fpt.markers) {
				for(let i2 = 0; i2 < 3; i2++) {
					let axis = "xyz"[i2];
					let ref = fpt.markers[i1][axis];
					for(let i3 in ref) {
						if(ref.hasOwnProperty(i3) && i3 !== "parent") {
							ref[i3] *= scale;
							ref[i3] = Math.trunc(ref[i3]);
						}
					}
				}
			}
		},
		parentcoor: function(prefix, axis) {
		// returns the absolute coordinate all markers of this prefix/axis start
		// from.
			let ref = fpt.markers[prefix];
			let num = ref[axis].start ?? 0;
			let parent = (ref[axis].parent ?? ref.parent) ?? "";
			let sign = parent.endsWith("-") ? -1 : parent.endsWith("+") ? 1 : 0;
			if(sign) {
				parent = parent.slice(0, -1);
			};
			if(parent) {
				let ref = fpt.markers[parent][axis];
				if("start" in ref) {
					num += fpt.abscoor(parent, axis, ("end" in ref ? "end" : "start"));
				};
				if("dim" in ref) {
					num += sign*Math.abs(ref.dim);
				};
			};
			return num;
		},
		abscoor: (prefix, axis, suffix) => (
			(suffix !== "dim")*fpt.parentcoor(prefix, axis) + (suffix !== "start")*fpt.markers[prefix][axis][suffix]
		),
		refresh: function(skip) {
		// - skip: an array of things to skip.
		//   - "handlechange": new handles will be drawn, but fpt.handles will
		//     not be redefined.
		//   - "states": it will not create a new state.
		//   - "datatext": it will not rewrite the data textarea.
			let i0 = 0;
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			skip = Array.isArray(skip) ? skip : typeof skip === "string" ? [skip] : [];
			for(i1 = 0; i1 < skip.length; i1++) {
				if(!["handlechange", "states", "datatext"].includes(skip[i1])) {
					console.log("unknown skip item: " + skip[i1]);
				};
			}
			//
			let x = {};
			let y = {};
			let z = {};
			let numofbars = 0;
			for(i1 in fpt.markers) {
				if(fpt.markers.hasOwnProperty(i1)) {
					numofbars++;
					for(i2 = 0; i2 < 3; i2++) {
						let axis = "xyz"[i2];
						let axis_obj = i2 === 0 ? x : i2 === 1 ? y : i2 === 2 ? z : null;
						if(fpt.markers[i1].hasOwnProperty(axis)) {
							let ref = fpt.markers[i1][axis];
							for(i3 in ref) {
								if(ref.hasOwnProperty(i3) && i3 !== "parent") {
									axis_obj[i1] ??= {};
									axis_obj[i1][i3] = fpt.abscoor(i1, axis, i3);
								}
							}
						}
					}
				}
			}
			//
			let jawcurve = [];
			let mouthcurve = [];
			let temp = Math.ceil(fpt.settings.fineness/4);
			for(i1 = 0; i1 <= temp; i1++) {
				let angle = 2*Math.PI*(1/8 + i1/(temp*4));
				let point = [Math.cos(angle), Math.sin(angle)];
				point[0] /= Math.SQRT1_2;
				point[1] -= Math.SQRT1_2;
				point[1] /= 1 - Math.SQRT1_2;
				// move and stretch it so it goes from -1 to 1 x and 0 to 1
				// y
				jawcurve.push([
					point[0]*x.jaw.dim,
					// -1 to 1 => -dim to dim
					y.jaw.end + point[1]*(y.jaw.start - y.jaw.end),
					z.jaw.end + point[1]*(z.jaw.start - z.jaw.end)
					// 0 to 1 => end to start
				]);
				mouthcurve.push([
					point[0]*x.mouth.dim,
					// -1 to 1 => -dim to dim
					y.mouth.end + point[1]*(y.mouth.start - y.mouth.end),
					z.mouth.end + point[1]*(z.mouth.start - z.mouth.end)
					// 0 to 1 => end to start
				]);
			}
			let ear = null;
			let box = {
				x: x.ear.start,
				y: y.ear.start - y.ear.dim,
				z: z.ear.start,
				w: x.ear.end - x.ear.start,
				h: 2*y.ear.dim,
				d: z.ear.end - z.ear.start,
			};
			if(box.w && box.h && box.d) {
				ear = [
					{x: x.ear.skew, y: box.y, z: z.ear.skew},
					// upper circle
					{x: box.x, y: box.y + box.h, z: box.z},
					// lower circle
				];
				ear[0].xr = box.w/2;
				ear[0].yr = (y.ear.middle - box.y)/2;
				ear[0].zr = box.d/2;
				ear[0].x += ear[0].xr;
				ear[0].y += ear[0].yr;
				ear[0].z += ear[0].zr;
				let temp = (z.ear.middle - box.z)/(box.d*2);
				ear[1].xr = temp*box.w;
				ear[1].yr = temp*Math.hypot(box.w, box.d);
				ear[1].zr = temp*box.d;
				ear[1].x += ear[1].xr;
				ear[1].y -= ear[1].yr;
				ear[1].z += ear[1].zr;
			};
			let eye = fpt.settings.disablelids ? null : {};
			for(i1 = 0; i1 < 2 && eye; i1++) {
				let temp = i1 ? "lower" : "upper";
				let num = (y.eye[temp] - y.eye.start)/y.eye.dim;
				if(num < -1 || num > 1) {
					eye = null;
				}
				else {
					eye[temp] = posmod(Math.PI/2 - Math.asin(num), 2*Math.PI);
					// yz means y takes the place of the x axis and z takes
					// the place of the y axis. this is +- the yz angle the
					// frontmost point of the eye would have, so... [0, 0,
					// 1] would be [0, 1] in yz, meaning a 90 degree angle.
					// and the sign of the asin should be inverted too. a
					// positive asin would be lower than the center of the
					// eye... in yz space that would mean a positive z,
					// which would mean the angle is lower than 90 yz.
				}
			}
			if(eye) {
				eye = {
					range: posmod(eye.upper - eye.lower, 2*Math.PI),
					yz: posmod(eye.lower, 2*Math.PI),
				};
				//console.log(Angle.convert(eye));
				let temp = -(z.eye.corner - z.eye.start)/Math.abs(z.eye.dim);
				temp = Math.max(-1, Math.min(temp, 1));
				temp = get2dangle(-Math.sqrt(1 - temp**2), temp, true) ?? 0;
				eye.xz = posmod(temp - Math.PI, 2*Math.PI);
				// eye.z.corner represents the z position of the outer corner of
				// the eye. so, how do you get a xz rotation angle from that?
				// - the left eye is the model, so without rotation, the corner
				//   is at [-1, 0, 0].
				// - but let's use an [x, z] system instead of [x, y, z]... [-1,
				//   0].
				// - z is obvious. x can be figured out. the hypotenuse of x and
				//   z has to be 1, and x should be negative. so, x is -sqrt(1 -
				//   z**2).
				// - convert the start and the destination to angles to get the
				//   relative angle that'll get you from one to the other.
				//   - [-1, 0] is 180 degrees, so pi
				//   - use get2dangle for the destination.
				temp = (x.eye.roll - x.eye.start)/Math.abs(x.eye.dim);
				temp *= -Math.PI/2;
				eye.xy = posmod(temp, 2*Math.PI);
			}
			//
			let ctx = fpt.ctx;
			let cell = [fpt.settings.cell_w, fpt.settings.cell_h];
			ctx.canvas.width = cell[0];
			ctx.canvas.height = cell[1];
			let images = [null, null];
			function colorchange(name) {
				//console.log(name);
				ctx.fillStyle = fpt.color[name] ?? fpt.color.main;
				ctx.strokeStyle = fpt.color[name] ?? fpt.color.main;
			};
			for(i0 = 0; i0 < 2; i0++) {
				//console.log("===\n" + (i0 ? "right" : "front") + "\n===");
				ctx.clearRect(0, 0, ...cell);
				ctx.fillStyle = fpt.color.bg;
				ctx.fillRect(0, 0, ...cell);
				ctx.translate(cell[0]/2, cell[1]/2);
				//
				if(ear) {
					colorchange("ear");
					//*
					let points = [];
					for(i1 = 0; i1 < 2; i1++) {
						let ref = ear[i1];
						let rect = [
							Math.abs(ref[i0 ? "zr" : "xr"]),
							Math.abs(ref.yr)
						];
						rect = Rect.new(
							ref[i0 ? "z" : "x"] - rect[0],
							ref.y - rect[1],
							2*rect[0] + 1,
							2*rect[1] + 1
						);
						let image = Raster.outline(Raster.fullellipse(rect.w, rect.h), rect.w);
						//console.log(Raster.totext(image, rect.w));
						for(i2 = 0; i2 < image.length; i2++) {
							if(image[i2]) {
								points.push(Raster.indextocoord(i2, rect));
							}
						}
					}
					points = _2dPoly.convexed(points);
					if(!i0) {
						_2dPoly.draw(ctx, points, "stroke");
					};
					for(i1 = 0; i1 < points.length; i1++) {
						points[i1][0] *= -1;
					};
					_2dPoly.draw(ctx, points, "stroke");
					//*/
					/*
					if(i0) {
						circledraw(ctx, -ear.core1.z, ear.core1.y, [ear.core1.zr, ear.core1.yr]);
						circledraw(ctx, -ear.core2.z, ear.core2.y, [ear.core2.zr, ear.core2.yr]);
					}
					else {
						circledraw(ctx, ear.core1.x, ear.core1.y, [ear.core1.xr, ear.core1.yr]);
						circledraw(ctx, -ear.core1.x, ear.core1.y, [ear.core1.xr, ear.core1.yr]);
						circledraw(ctx, ear.core2.x, ear.core2.y, [ear.core2.xr, ear.core2.yr]);
						circledraw(ctx, -ear.core2.x, ear.core2.y, [ear.core2.xr, ear.core2.yr]);
					};
					//*/
				}
				//
				colorchange("cranium");
				let head = [];
				for(i1 = 0; i1 < fpt.settings.fineness; i1++) {
					let angle = 2*Math.PI*i1/fpt.settings.fineness;
					head.push([
						(i0 ? -z.cranium.start : 0) + (i0 ? z : x).cranium.dim*Math.cos(angle),
						y.cranium.start + y.cranium.dim*Math.sin(angle)
					]);
				}
				//_2dPoly.draw(ctx, head, "stroke");
				//head = [];
				for(i1 = 0; i1 < jawcurve.length; i1++) {
					head.push([
						(i0 ? -jawcurve[i1][2] : jawcurve[i1][0]),
						jawcurve[i1][1]
					]);
				}
				//_2dPoly.draw(ctx, head, "stroke", null, null, "skiplaststroke");
				head = _2dPoly.convexed(head);
				ctx.fillStyle = fpt.color.skin;
				_2dPoly.draw(ctx, head, "stroke");
				//
				colorchange("nose");
				for(i1 = 0; i1 < (i0 ? 1 : 2); i1++) {
					let obj = (i0 ? z : x);
					let points = [
						[obj.nose.start, y.nose.start],
						[obj.nose.side, y.nose.side],
						[obj.nose.front, y.nose.front],
						[obj.nose.end, y.nose.end]
					];
					if(i0 || i1) {
						for(i2 = 0; i2 < points.length; i2++) {
							points[i2][0] *= -1;
						}
					};
					let center = [0, points[2][1]];
					// use front as the sl center
					for(i2 = 0; i2 < points.length; i2++) {
						for(i3 = i2 + 1; i3 < points.length; i3++) {
						// round robin all four nose points
							if(i2 === 0 && i3 === 3) {
							// except start to end.
							}
							else {
								linespecial(ctx, ...points[i2], ...points[i3], center);
							}
						}
						if(!i0 && !i1 && i2 !== 0 && i2 !== 1 && points[i2][0]) {
						// connect to symmetrical counterpart (except for the
						// start/side point)
							linespecial(ctx, points[i2][0], points[i2][1], -points[i2][0], points[i2][1], center);
						};
					}
				}
				//
				colorchange("eye");
				if(eye) {
					let dim = [
						Math.abs((i0 ? z : x).eye.dim),
						Math.abs(y.eye.dim)
					];
					let rect = Rect.new(
						-dim[0],
						-dim[1],
						2*dim[0] + 1,
						2*dim[1] + 1
					);
					let image = Raster.fullellipse(rect.w, rect.h);
					for(i1 = 0; i1 < image.length; i1++) {
						if(image[i1]) {
							let coor = Raster.indextocoord(i1, rect);
							let hypot = Math.hypot(...coor);
							if(hypot) {
								coor = Points.multiply(coor, Math.max(0, hypot - .5)/hypot);
							}
							// avoids the thing where only the peaks of the
							// curves meet the conditions. like how you have to
							// add .5 to the radius when drawing a circle.
							coor[0] /= dim[0];
							coor[1] /= dim[1];
							coor[2] = Math.sqrt(1 - coor[0]**2 - coor[1]**2);
							// x2 + y2 + z2 = 1
							if(i0) {
								coor = revolve(Math.PI/2, coor, null, "xz");
								coor[0] *= -1;
								// front view uses the left eyeball then mirrors
								// it, but right view uses just the right
								// eyeball. so, the rotation direction is the
								// opposite of what it should be, and the x
								// coordinate is inverted too.
							}
							//let angle = posmod(get2dangle(coor[1], coor[2], true) - eye.yz, 2*Math.PI);
							for(i2 = 0; i2 < 3; i2++) {
							// reverse the xy rotation, then the xz rotation,
							// then yz rotation. in that order. the opposite of
							// how the eye was oriented.
								let axis = "xyz".replace("zyx"[i2], "");
								if(axis in eye) {
									coor = revolve(-eye[axis], coor, null, axis);
								}
							}
							let angle = posmod(get2dangle(coor[1], coor[2], true), 2*Math.PI);
							image[i1] = angle < eye.range;
						};
					}
					image = Raster.outline(image, rect.w);
					//image = Raster.ellipse(image, rect.w, dim[0] - 2, dim[1] - 2, dim[0] + 1, dim[1] + 2);
					for(i1 = 0; i1 < image.length; i1++) {
						if(image[i1]) {
							let coor = Raster.indextocoord(i1, rect);
							coor[0] += (i0 ? z : x).eye.start;
							coor[1] += y.eye.start;
							if(!i0) {
								ctx.fillRect(coor[0], coor[1], 1, 1);
							}
							ctx.fillRect(-coor[0], coor[1], 1, 1);
						}
					}
				}
				else if(i0) {
					circledraw(ctx, -z.eye.start, y.eye.start, [z.eye.dim, y.eye.dim]);
				}
				else {
					circledraw(ctx, x.eye.start, y.eye.start, [x.eye.dim, y.eye.dim]);
					circledraw(ctx, -x.eye.start, y.eye.start, [x.eye.dim, y.eye.dim]);
				};
				//
				colorchange("brow");
				for(i1 = 0; i1 < (i0 ? 1 : 2); i1++) {
					//console.log("===");
					let obj = (i0 ? z : x);
					let _obj = (i0 ? x : z);
					let start = [
						obj.brow.start,
						y.brow.start,
						_obj.brow.start
					];
					let bend = [
						obj.brow.bend,
						y.brow.bend,
						_obj.brow.bend
					];
					let end = [
						obj.brow.end,
						y.brow.end,
						_obj.brow.end
					];
					if(i0 || i1) {
						start[0] *= -1;
						bend[0] *= -1;
						end[0] *= -1;
					};
					if(i0) {
						start[2] = Math.abs(start[2]);
						bend[2] = Math.abs(bend[2]);
						end[2] = Math.abs(end[2]);
					};
					// front: [x, y, z], [-x, y, z]
					// right: [-z, y, abs(x)]
					let basis = Basis.new();
					let _bend = Points.subtract(bend, start);
					let _end = Points.subtract(end, start);
					if(Points.zero(_bend) || Points.zero(_end) || Points.parallel(_bend, _end)) {
					// a straight line
						//console.log(_bend);
						//console.log(_end);
						linespecial(ctx, start[0], start[1], bend[0], bend[1]);
						linespecial(ctx, bend[0], bend[1], end[0], end[1]);
					}
					else {
						basis[2] = Points.cross(_bend, _end);
						basis[2] = Points.invert(basis[2]);
						// z axis is something perpendicular to the plane all three
						// points are on (the opposite angle is equally valid. the
						// uninverted cross doesn't work how the math below expects,
						// so use the inverted version.)
						basis[0] = structuredClone(_bend);
						// x axis is the start to bend angle
						basis[1] = Points.cross(basis[0], basis[2]);
						// y axis is whatever is perpendicular to those two
						basis = [
							Points.normalized(basis[0]),
							Points.normalized(basis[1]),
							Points.normalized(basis[2])
						];
						//console.log(basis);
						let _basis = Basis.invert(basis);
						_bend = Basis.apply(_basis, _bend);
						_end = Basis.apply(_basis, _end);
						_bend = _bend.slice(0, 2);
						_end = _end.slice(0, 2);
						// applying the inverted basis should make bend have
						// positive x, zero y, and zero z, and end should be
						// down-right of that.
						let temp = get2dangle(...Points.subtract(_end, _bend));
						// we need the position of a circle that will have both
						// _bend and _end on it, and tangent the origin to _bend
						// line so that the circular arc flows seamlessly into
						// it.
						// - that means it has to be directly below _bend, and
						//   it has to be equally far from _bend and _end.
						// - that forms an isosceles triangle.
						// - point A is bend, B is end, C is the circle.
						// - known angles: none
						// - known sides: AB
						let r = Math.hypot(...Points.subtract(_end, _bend));
						// side AB
						if(temp >= Math.PI) {
							console.log("this shouldn't happen");
							// the basis should be designed so _end is never
							// below _bend.
						}
						else if(temp > Math.PI/2) {
							temp = Math.PI - temp;
						};
						if(temp === Math.PI/2) {
						// perfect right angles require one of those weird
						// exceptions. math is a pain in the ass.
							r /= 2;
						}
						else {
							temp = Math.PI/2 - temp;
							// - angle A = 90 - [angle between A to B and the x axis]
							// - angle B is the same
							// - angle C is 180 - (angle A + angle B)
							// - law of sine: BC/sin(A) = AC/sin(B) = etc
							// - r/Math.sin(temp) = AB/Math.sin(Math.PI - 2*temp)
							r = Math.sin(temp)*r/Math.sin(Math.PI - 2*temp);
							// that logic is designed for acute angles only, but
							// obtuse is mostly the same. draw a diagram or
							// something. everything just gets flipped x ways.
						};
						let circ = [_bend[0], _bend[1] + r];
						let angle = get2dangle(_end[0] - circ[0], _end[1] - circ[1]);
						angle = posmod(angle - 3*Math.PI/2, 2*Math.PI);
						temp = Math.ceil(fpt.settings.fineness*angle/(2*Math.PI));
						let prev = [bend[0], bend[1]];
						linespecial(ctx, start[0], start[1], bend[0], bend[1]);
						for(i2 = 1; i2 < temp; i2++) {
							let _angle = posmod(3*Math.PI/2 + angle*i2/temp, 2*Math.PI);
							let point = Points.add(circ, Points.multiply([Math.cos(_angle), Math.sin(_angle)], r));
							point = Points.add(start, Basis.apply(basis, [...point, 0]));
							linespecial(ctx, ...prev, point[0], point[1]);
							prev = [point[0], point[1]];
						}
						linespecial(ctx, ...prev, end[0], end[1]);
					}
				}
				//
				colorchange("mouth");
				let temp = [];
				for(i1 = 0; i1 < mouthcurve.length; i1++) {
					temp.push([
						(i0 ? -mouthcurve[i1][2] : mouthcurve[i1][0]),
						mouthcurve[i1][1]
					]);
				}
				_2dPoly.draw(ctx, temp, "stroke", null, null, "skiplaststroke");
				// nose, ear
				//
				ctx.translate(-cell[0]/2, -cell[1]/2);
				images[i0] = ctx.getImageData(0, 0, ...cell);
			}
			let barsize = fpt.settings.barwidth*numofbars + 1;
			let w = 2*cell[0] + barsize;
			let h = cell[1] + barsize;
			ctx.canvas.width = w;
			ctx.canvas.height = h;
			ctx.clearRect(0, 0, w, h);
			ctx.fillStyle = "black";
			ctx.fillRect(0, 0, w, h);
			ctx.putImageData(images[0], 0, 0);
			ctx.putImageData(images[1], w - cell[0], 0);
			//
			let handles = null;
			if(skip.includes("handlechange")) {
				handles = [];
			}
			else {
				fpt.handles = [];
				handles = fpt.handles;
			};
			for(i0 = 0; i0 < 3; i0++) {
				let obj = i0 === 0 ? x : i0 === 1 ? y : i0 === 2 ? z : null;
				let axis1 = i0 === 1 ? 1 : 0;
				// long axis
				let axis2 = posmod(axis1 + 1, 2);
				// short axis
				let start = (
					i0 === 0 ? [0, cell[1]] :
					i0 === 1 ? [cell[0], 0] :
					i0 === 2 ? [cell[0] + barsize, cell[1]] :
					null
				);
				start[axis1] += cell[axis1]/2;
				start[axis2] += Math.floor(fpt.settings.barwidth/2);
				// this way, markers start from the center
				let bar = numofbars - 1;
				for(i1 in obj) {
					if(obj.hasOwnProperty(i1)) {
						//ctx.fillStyle = "white";
						colorchange(i1);
						let line = Rect.new(...start, 1, 1);
						line["xy"[axis1]] -= cell[axis1]/2;
						line["xy"[axis2]] += fpt.settings.barwidth*bar;
						line["wh"[axis1]] = cell[axis1];
						ctx.fillRect(line.x, line.y, line.w, line.h);
						for(i2 in obj[i1]) {
							if(obj[i1].hasOwnProperty(i2)) {
								let num = (i0 === 2 ? -1 : 1)*obj[i1][i2];
								if(i2 === "dim") {
									let parent = (i0 === 2 ? -1 : 1)*fpt.parentcoor(i1, "xyz"[i0]);
									num = (
										i0 === 0 ?
										[
											-parent - num,
											-parent + num,
											parent - num,
											parent + num
										]
										:
										[
											parent - num,
											parent + num
										]
									);
								}
								else {
									num = i0 === 0 ? [-num, num] : [num];
								};
								// x markers get symmetrical duplicates, and dim
								// markers get symmetrical duplicates. there can
								// be one, two, or four numbers.
								for(i3 = 0; i3 < num.length; i3++) {
									let position = structuredClone(start);
									position[axis1] += num[i3];
									position[axis2] += fpt.settings.barwidth*bar;
									handles.push({
										x: position[0], y: position[1],
										prefix: i1,
										axis: "xyz"[i0],
										suffix: i2,
										invert: !(num.length%2) && !(i3%2),
									});
									if(num[i3] >= -cell[axis1]/2 && num[i3] < cell[axis1]/2) {
										let dim = fpt.settings.barwidth - (i2 === "start" || i2 === "end" || i2 === "dim" ? 1 : 3);
										let line = Rect.new(...position, 1, 1);
										line["wh"[axis2]] = dim;
										line["xy"[axis2]] -= Math.floor(dim/2);
										ctx.fillRect(line.x, line.y, line.w, line.h);
										//let temp = ctx.fillStyle;
										//ctx.fillStyle = "white";
										//ctx.fillRect(...position, 1, 1);
										//ctx.fillStyle = temp;
									};
								}
							}
						}
						bar--;
					}
				}
			}
			//
			if(!skip.includes("states")) {
			// save a state
				fpt.states.save();
			};
			if(!skip.includes("datatext")) {
			// rewrite the data text
				let obj = {};
				for(i0 = 0; i0 < 3; i0++) {
				// for every axis...
				// - in case of future changes to the parenting structure, i'd
				//   like it to save absolute coordinates.
				// - but unlike the x/y/z objects, i want it the order to be
				//   prefix, axis, suffix. easier to understand.
					let _obj = i0 === 0 ? x : i0 === 1 ? y : i0 === 2 ? z : null;
					let axis = "xyz"[i0];
					for(i1 in _obj) {
						if(_obj.hasOwnProperty(i1)) {
						// for every prefix...
							obj[i1] ??= {};
							obj[i1][axis] = {};
							for(i2 in _obj[i1]) {
								if(_obj[i1].hasOwnProperty(i2) && i2 !== "parent") {
								// for every suffix...
									obj[i1][axis][i2] = _obj[i1][i2];
									// copy the absolute coordinate.
								}
							}
						}
					}
				}
				let text = basicobjtotext(obj);
				fpt.element("data").value = text;
				fpt.element("data").rows = text.split("\n").length;
			};
		},
		mousedown: function(e) {
			let click = clickxy(e, "fpt");
			let index = -1;
			let dist = fpt.settings.handleleeway + 1;
			//console.log("=");
			for(let i1 = 0; i1 < fpt.handles.length; i1++) {
				let handle = fpt.handles[i1];
				let axis1 = Number(handle.axis === "y");
				let axis2 = posmod(axis1 + 1, 2);
				// long axis, short axis
				let diff1 = Math.abs(Math.floor(click[axis1]) - handle["xy"[axis1]]);
				let diff2 = click[axis2] - handle["xy"[axis2]];
				if(
					diff1 <= fpt.settings.handleleeway
					&&
					diff2 >= -(fpt.settings.barwidth/2 - 1) && diff2 < fpt.settings.barwidth/2
					&&
					(diff1 < dist || (diff1 === dist && fpt.handles[index].suffix === "start"))
				) {
					//console.log([handle.prefix, handle.axis, handle.suffix].join("."));
					//console.log(diff1);
					//console.log(diff2);
					//console.log("-");
					index = i1;
					dist = diff1;
				};
			}
			if(index !== -1) {
				fpt.control.handle_index = index;
				fpt.control.downclick = structuredClone(click);
				let handle = fpt.control.handle;
				//console.log([handle.prefix, handle.axis, handle.suffix].join("."));
			};
		},
		mousemove: function(e, finish) {
			let handle = fpt.control.handle;
			if(!fpt.control.downclick || !handle) {
				return;
			};
			let click = clickxy(e, "fpt");
			let min = null;
			let max = null;
			if(handle.axis === "x") {
				min = 0;
				max = fpt.settings.cell_w;
			}
			else if(handle.axis === "y") {
				min = 0;
				max = fpt.settings.cell_h;
			}
			else if(handle.axis === "z") {
				max = fpt.ctx.canvas.width;
				min = max - fpt.settings.cell_w;
			};
			let axis1 = Number(handle.axis === "y");
			let move = click[axis1];
			if(move < min || move >= max) {
			// return if out of range
				//console.log("oopes");
				return;
			}
			move = Math.trunc(move - fpt.control.downclick[axis1]);
			if(handle.axis === "z") {
				move *= -1;
			};
			if(handle.invert) {
				move *= -1;
			};
			let ref = fpt.markers[ handle.prefix ][ handle.axis ];
			let before = ref[ handle.suffix ];
			let after = before + move;
			if(handle.suffix === "dim") {
				after = Math.abs(after);
			};
			ref[ handle.suffix ] = after;
			fpt.refresh(finish ? [] : ["handlechange", "states", "datatext"]);
			if(finish) {
				fpt.control.handle_index = -1;
				fpt.control.downclick = null;
				//console.log(fpt.handles);
			}
			else {
				ref[ handle.suffix ] = before;
			}
		},
		mouseup: function(e) {
			fpt.mousemove(e, true);
		},
		special_edit: function(script) {
		// executes a special edit.
			let i0 = 0;
			let i1 = 0;
			let i2 = 0;
			script = script.split("&");
			let all = [];
			function addtoall(obj, chain) {
				obj ??= fpt.markers;
				chain ??= [];
				for(let i1 in obj) {
					if(obj.hasOwnProperty(i1)) {
						let _chain = structuredClone(chain);
						_chain.push(i1);
						if(typeof obj[i1] === "number") {
							all.push(_chain.join("."));
						}
						else if(obj[i1] && typeof obj[i1] === "object" && !Array.isArray(obj[i1])) {
							addtoall(obj[i1], _chain);
						}
					}
				}
			}
			addtoall();
			let newstate = false;
			for(i0 = 0; i0 < script.length; i0++) {
				let command = trimunspecial(script[i0]);
				while(command.includes(", ")) {
					command = command.replaceAll(", ", ",");
				};
				command = command.split(" ");
				if(command.length >= 3) {
					let target = command[0];
					let operator = command[1];
					let number = readnumber(command[2]);
					for(i1 = 0; i1 < operator.length; i1++) {
						if(!"+-*/=".includes(operator[i1])) {
							operator = operator.slice(0, i1) + operator.slice(i1 + 1);
							i1--;
						};
					}
					if(target === "any" || target === "all") {
						target += "()";
					};
					//
					if(!operator || number === null) {
						target = [];
					}
					else if((target.startsWith("any(") || target.startsWith("all(")) && target.endsWith(")")) {
						const any = target.startsWith("any");
						let conditions = target.slice(4, -1);
						conditions = conditions ? conditions.split(",") : [];
						target = structuredClone(all);
						for(i1 = 0; i1 < conditions.length; i1++) {
							let invert = conditions[i1].startsWith("!");
							let cond = invert ? conditions[i1].slice(1) : conditions[i1];
							if(cond === "rand_axis") {
								cond = "xyz"[Math.floor(Math.random()*3)];
							};
							//
							for(i2 = 0; i2 < target.length && cond; i2++) {
								let matches = invert;
								let chance = readnumber(cond);
								//
								if(cond === "x" || cond === "y" || cond === "z") {
									if(target[i2].split(".")[1] === cond) {
										matches = !matches;
									}
								}
								else if(chance !== null) {
									if(Math.random() < chance) {
										matches = !matches;
									}
								}
								else if(cond === "position" || cond === "dimension" || cond === "other") {
									let type = (
										target[i2].endsWith(".start") ? "position" :
										(target[i2].endsWith(".end") || target[i2].endsWith(".dim")) ? "dimension" :
										"other"
									);
									if(cond === type) {
										matches = !matches;
									}
								}
								else if(cond) {
									if(target[i2] === cond || target[i2].startsWith(cond + ".")) {
										matches = !matches;
									};
								}
								//
								if(!matches) {
									target.splice(i2, 1);
									i2--;
								};
							}
						}
						if(any && target.length) {
							target = [ target[Math.floor(Math.random()*target.length)] ];
						};
					}
					else if(target) {
						if(all.includes(target)) {
							target = [target];
						}
						else {
							let prefix = target + ".";
							target = [];
							for(i1 = 0; i1 < all.length; i1++) {
								if(all[i1].startsWith(prefix)) {
									target.push(all[i1]);
								}
							}
						}
					}
					else {
						target = [];
					};
					//
					if(operator.length >= 2) {
					// pick a random operator for each axis.
						let temp = operator;
						operator = "";
						for(i1 = 0; i1 < 3; i1++) {
							operator += temp[Math.floor(Math.random()*temp.length)];
						};
					};
					for(i1 = 0; i1 < target.length; i1++) {
						let chain = target[i1].split(".");
						let op = operator.length === 1 ? operator : operator["xyz".indexOf(chain[1])];
						let place = fpt.markers;
						for(i2 = 0; i2 < chain.length - 1; i2++) {
							place = place[chain[i2]];
						}
						let name = chain[chain.length - 1];
						let old = place[name];
						place[name] = Math.trunc(
							(op === "/" && number === 0) ? place[name] :
							op === "+" ? (place[name] + number) :
							op === "-" ? (place[name] - number) :
							op === "*" ? (place[name] * number) :
							op === "/" ? (place[name] / number) :
							op === "=" ? number :
							place[name]
						);
						if(name === "dim") {
							place[name] = Math.abs(place[name]);
						};
						//console.log([target[i1] + ":", old, op, number, "=", place[name]].join(" "));
						newstate = newstate || place[name] !== old;
					}
				}
			}
			if(newstate) {
				fpt.refresh();
			};
		},
	};
	fpt.initialize();
	//
	document.write(`<div name="hider" id="hider_cell_toy">a cellular automata toy, like conway's game of life. but with extra features, because most ports of that are surprisingly barebones.\n` + arraytoul([
		`use this at your own risk if you have photosensitivity issues. depending on the rules, there might be a lot of flashing.`,
		`in conway's game of life, cells become "alive" if they have exactly 3 living neighbors, and they "die" if they have anything but 2 or 3 living neighbors.`,
		`that's what that "rules" field is about. you can change what numbers cause birth and what numbers allow survival.`
	]) + `\n<div id="cell_div"></div></div>`);
	let cell = new CellToy(document.getElementById("cell_div"));
	//
	document.write(`<div name="hider" id="hider_pixel_art">\n<div id="px_div"></div>\n</div>`);
	let px = new PixelArt(document.getElementById("px_div"));
	//
	document.write("<div name=\"hider\" id=\"hider_palette_generator\"></div>");
	let pg = {
		initialize: function() {
			let html = [
				"used to generate character palettes.",
				"<br><br>process:",
				arraytoul([
					"picks a random number of main colors, 1-5",
					"picks a color scheme rule (ex: complimentary, analogous, triadic, etc)",
					"picks the main colors from the named web colors. (ex: sea green and stuff like that. recognized colors, not digital do-anything colors) non-neutral colors that have the right hues.",
					"for each main color, it picks two more colors from the same category. for example, if the main color is an orange, it randomly picks other named web colors that are oranges.",
					"and it can also insert neutral colors in places. as main colors, or variant colors.",
					"the idea is to better match how colors should work in a character design. or my approach, anyway.",
					[
						"it's better to use paint-like colors than digital colors, since clothing relies on dyes and pigments.",
						"vibrant colors will contrast unless they both fit into about the same slot of the rainbow.",
						"clothing avoids that as much as possible, since it's hard to fit a red and blue jacket or whatever into an outfit. it limits your freedom. individual clothing items usually only have multiple shades of one color, or a vibrant color and a neutral color.",
						"it's fine to have lots of contrast, but \"colorful\" palettes can look weirdly boring if it feels random. the color scheme rules help avoid that."
					]
				]),
				"<button name=\"generate\">generate</button>",
				"<br><canvas></canvas>",
				"<br><textarea name=\"palette text\" cols=23></textarea>",
				"<br><button name=\"save\">save</button>"
			].join("\n");
			let container = document.getElementById("hider_palette_generator");
			container.innerHTML = html;
			this.html = {};
			this.html.container = container;
			let desc = htmldescendants(container);
			for(let i1 = 0; i1 < desc.length; i1++) {
				let ref = desc[i1];
				let name = "name" in ref ? ref.name : "";
				if(name) {
					this.html[name] = ref;
				}
			}
			this.html.canvas = container.querySelector("canvas");
			this.html.canvas.style["image-rendering"] = "crisp-edges";
			this.ctx = this.html.canvas.getContext("2d");
			//
			let _this = this;
			this.html.generate.onclick = function(e) { _this.generate() };
			this.html["palette text"].onkeydown = textarea_autosize;
			this.html["palette text"].onchange = function(e) {
				let palette = Color.split(e.target.value);
				if(palette.length) {
					_this.refresh(palette);
				};
			};
			this.html.save.onclick = function(e) {
				savecanvas(_this.ctx.canvas, "pg " + _this.html["palette text"].value.replaceAll("\n", " & ") + ".png");
			}
			this.generate();
		},
		generate: function(_this) {
			_this ??= this;
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			//
			let main = [];
			let length = Number(weightedselect([0, 2, 4, 4, 2, 1]));
			// pick how big the palette is, between 1 and 5 colors
			//console.log(length);
			let neutral = Color.named.neutral;
			let vibrant = Color.named.vibrant;
			while(Math.random() < 1/3 && main.length < length && neutral.length) {
				let index = Math.floor(Math.random()*neutral.length);
				main.push(structuredClone(neutral[index]));
				neutral.splice(index, 1);
			};
			// add a random amount of neutral colors
			let pattern = [];
			let num = length - main.length;
			if(num) {
				let pattern = (
					num === 1 ? [[0]] :
					num === 2 ? [[0, 6], [0, 5]] :
					num === 3 ? [[0, 4, 8], [0, 5, 7]] :
					num === 4 ? [[0, 3, 6, 9], [0, 2, 6, 8]] :
					num === 5 ? [[0, 2, 5, 7, 9]] :
					[]
				);
				let temp = Math.random()*(pattern.length + .5);
				if(temp >= pattern.length) {
					pattern = [];
					for(i1 = 0; i1 < num; i1++) {
						pattern.push(i1);
					}
				}
				else {
					pattern = pattern[Math.floor(temp)];
				};
				if(!pattern.length) {
					console.log("this shouldn't happen");
				}
				// for the remaining vibrant color slots, pick a color scheme.
				// - 2: complimentary, side complimentary
				// - 3: triadic, split complimentary
				// - 4: square, rectangle
				// - 5: pentagonal
				// - all: analogous
				let start = Math.random();
				for(i1 = 0; i1 < pattern.length; i1++) {
					let hue = posmod(start + pattern[i1]/12, 1);
					let choices = [];
					for(i2 = 0; i2 < vibrant.length; i2++) {
						let _hue = posmod(vibrant[i2].hue - hue, 1);
						if(_hue < 1/24 || _hue >= 23/24) {
							choices.push(i2);
						};
					}
					let index = null;
					if(choices.length) {
						index = choices[Math.floor(Math.random()*choices.length)];
					}
					else {
					// if there's nothing close enough, pick whatever's closest.
						choices = [];
						for(i2 = 0; i2 < vibrant.length; i2++) {
							choices.push(i2);
						}
						choices.sort(function(a, b) {
							let hue_a = posmod(Color.named[a].hue - hue, 1);
							let hue_b = posmod(Color.named[b].hue - hue, 1);
							hue_a = hue_a >= .5 ? 1 - hue_a : hue_a;
							hue_b = hue_b >= .5 ? 1 - hue_b : hue_b;
							return hue_a - hue_b;
						});
						if(!choices.length) {
							console.log("this shouldn't happen");
						};
						index = choices[0];
					}
					main.push(structuredClone(vibrant[index]));
					vibrant.splice(index, 1);
				}
				// for each slot, find colors within 15 degrees of the ideal hue. pick one at random.
			}
			//
			let palette = [];
			for(i1 = 0; i1 < main.length; i1++) {
				palette.push(main[i1].short_code);
				let category = main[i1].category;
				let ref = (category === "white" || category === "gray&black" || category === "brown") ? neutral : vibrant;
				let choices = [];
				for(i2 = 0; i2 < ref.length; i2++) {
					if(ref[i2].category === main[i1].category) {
						choices.push(i2);
					};
				}
				for(i2 = 0; i2 < 2; i2++) {
					let brownlike = Color.named.neutral_categories.includes(category) || category === "red" || category === "orange" || category === "yellow";
					if(Math.random() < 1/4 && neutral.length && (!brownlike || neutral.some((element) => element.category !== "brown"))) {
					// pick a random neutral color, since that can look interesting and it doesn't clash
						let index = null;
						if(brownlike) {
						// don't pick brown if it would clash with the main color.
							let _choices = [];
							for(i3 = 0; i3 < neutral.length; i3++) {
								if(neutral[i3].category !== "brown") {
									_choices.push(i3);
								};
							}
							index = _choices[ Math.floor(Math.random()*_choices.length) ];
						}
						else {
							index = Math.floor(Math.random()*neutral.length);
						}
						palette.push(neutral[index].short_code);
						neutral.splice(index, 1);
					}
					else if(choices.length) {
						let temp = Math.floor(Math.random()*choices.length);
						let index = choices[temp];
						choices.splice(temp, 1);
						if(!ref[index]) {
							console.log(ref);
							console.log(index);
						}
						palette.push(ref[index].short_code);
						ref.splice(index, 1);
						for(i3 = 0; i3 < choices.length; i3++) {
							if(choices[i3] === index) {
								choices.splice(i3, 1);
								i3--;
							}
							else if(choices[i3] > index) {
								choices[i3]--;
							}
						}
					}
					else {
						palette.push("#0000");
					};
				}
			}
			//console.log(palette);
			// for each main color, choose two alts in the same category. (1/4 chance of using a neutral instead)
			_this.refresh(palette);
			let string = "";
			for(i1 = 0; i1 < palette.length; i1++) {
				string += (i1 ? (i1%3 ? " " : "\n") : "") + palette[i1];
			}
			_this.html["palette text"].value = string;
			textarea_autosize(_this.html["palette text"]);
			// refresh canvas and textarea
		},
		refresh: function(palette) {
		// refreshes the palette image.
			Color.palette_canvas(this.ctx, palette, 3);
		},
	};
	pg.initialize();
	//
	let tips = {
		"drawing app": [
			"the smear and spray brushes can be used to make a different texture if you tap repeatedly instead of making full strokes.",
			"there's two separate brush sizes, pen, and paint/eraser. for brushes like smear and spray, the range dots can appear in is as wide as the paint/eraser size, while the dots themselves are the pen size.",
			"WASD cycles through subtools, E switches tools, R and F change size.",
			"try combining dithers, that's always fun. (pythagorean has some interesting combinations.)",
			"if you change tools/subtools with a right click or while holding shift, you'll select the inverted version.",
			"inverses of pens are alternative versions. for example, the smear brush will create a more dense smear.",
			"inverses of paints are inversions of the dither pattern. that's why there's no dithers that cover more than 50% of pixels.",
			"inverses of erasers are... well i don't really make erasers, so.",
			"there's other menu actions that can be modified with this, too. for size up/down, it'll modify the other size. (paint size if you're using a pen, pen size if you're using paint/eraser) for color changes, it'll change the other color.",
			"pens sometimes incorporate the size of the paint/eraser. for example, spray/smear will distribute points around an area of that size, but pen size will determine how big the dots are.",
			"sunset pen - this draws ellipses that are as tall as the pen size and as wide as the paint size, with the ellipses at the end of the stroke being a little smaller.",
			"stroke pen - this draws a line as wide as the paint size in the erase color, with a pen-size outline around it in the draw color.",
			"if you have any cool pen or dither ideas, let me know. i'll credit you in here, i guess.",
			"when using the palette changing button, if one of your colors has no specified index, it'll use whatever index comes after the last one it used. (or zero, if it's the first color you inputted.)"
		],
		"sprite arranger": [
			"the most useful thing here is the import increment system. it's sorta hard to explain, but each pair of numbers is a grid arrangement. 1, 2, 3, 2 will import 1x2x3x2 blocks at once, and paste them as 1x2 pieces in a 3x2 formation. if you can figure out the right pattern, it'll save tons of time."
		],
	};
	//tips[tips.length] = `for any color change setting, use <a href="developer.mozilla.org/en-US/docs/Web/CSS/CSS_colors/Applying_color">this</a> as an overview of what formats you can use. basically: #rrggbb, #rrggbbaa, rgb(r, g, b), rgba(r, g, b, a), hsl(h, s, l), hsla(h, s, l, a), some others, and there's also a few named colors like "black", "white", "cornflowerblue", etc.`;
	//tips[tips.length] = `armature artist: `
	//tips[tips.length] = ``
	// making sure there's commas between each one is a pain so fuck it
	let tipsindex = -1;
	let hider_id_to_name = (id) => id.split("_").slice(1).join(" ");
	let hider_section = () => hider_id_to_name(document.getElementById("hider_select").value);
	function hider_init() {
		let i1 = 0;
		let divs = document.getElementsByName("hider");
		let html = ``;
		for(i1 = 0; i1 < divs.length; i1++) {
			divs[i1].hidden = true;
			let name = hider_id_to_name(divs[i1].id);
			if(!["face tool", "fighting game tester", "interactive animation", "procanim", "background maker"].includes(name)) {
				html += `<option value="` + divs[i1].id + `"` + (name === "pixel art" ? ` selected` : ``) + `>` + name + `</option>`;
			};
		}
		let ref = document.getElementById("hider_select");
		ref.innerHTML = html;
		ref.onchange = function() {
			let i1 = 0;
			let choice = document.getElementById("hider_select").value;
			let _choice = choice.slice("hider_".length).replaceAll("_", " ");
			if(_choice === "pixel art") {
				userfocus = "px";
			};
			let divs = document.getElementsByName("hider");
			for(i1 = 0; i1 < divs.length; i1++) {
				divs[i1].hidden = divs[i1].id !== choice;
			};
			let temp = hider_section();
			tipsindex = (
				tips.hasOwnProperty(temp) && tips[temp].length
				?
				Math.floor(Math.random()*tips[temp].length) - 1
				:
				-1
			);
			document.getElementById("tipsbutton").onclick();
		}
		ref.onchange();
	};
	document.write("<br>".repeat(2) + "<button id='tipsbutton'>tips</button><br><div id='tipstext'></div>");
	document.getElementById("tipsbutton").onclick = function() {
		let tipstext = document.getElementById("tipstext");
		let name = hider_section();
		if(tips.hasOwnProperty(name) && tips[name].length) {
			let array = tips[name];
			tipsindex++;
			if(tipsindex < 0 || tipsindex >= array.length) {
				tipsindex = 0;
			};
			tipstext.innerHTML = array[tipsindex];
		}
		else {
			tipstext.innerHTML = "&#160;";
		};
	};
	hider_init();
	//
	//
	//
	//
	</script>
	</body>
</html>
