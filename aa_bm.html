<!DOCTYPE html>
<html lang="en">
	<script src="script/barky_main.js"></script>
	<script src="script/site.js"></script>
	<script src="script/barky_strings.js"></script>
	<script src="script/barky_graphics.js"></script>
	<script>
		document.write(head);
		//document.write(header);
		document.write(nav + "\n<br>");
		document.querySelector("title").innerHTML = "armature artist";
	</script>
	<head>
		<style>
			body {
				background: #fffae3;
				color: black;
			}
		</style>
	</head>
	<body>
	<script>
	document.onkeydown = function(e) {
		if(["textarea", "input"].includes(document.activeElement.tagName.toLowerCase())) {
			return;
		};
		let key = keyinterpreter(e.key);
		if(userfocus === "aa") {
			let keymap = (aa.control.editmode ? aa.pa.ui.keymap : aa.ui.keymap);
			if(keymap.hasOwnProperty(key)) {
				let action = keymap[key];
				if(typeof action !== "string") {
					if(action.length > 2) {
						action = (
							e.ctrlKey
							?
							action.slice(2)
							:
							action.slice(0, 2)
						);
					};
					if(action.length === 1) {
						action = action[0];
					}
					else if(action.length === 2) {
						action = action[Number(e.shiftKey)];
					}
					else {
						console.log("this shouldn't happen");
					};
				};
				if(action) {
					e.preventDefault();
					if(aa.control.editmode) {
						aa.pa.ui.action(action, e.shiftKey, e.ctrlKey);
					}
					else {
						aa.ui.action(action, e.shiftKey, e.ctrlKey);
					}
				};
			};
		}
		else if(userfocus === "bm") {
			let prevent = true;
			if(e.ctrlKey && e.shiftKey) {
				if(key === "z") {
					e.preventDefault();
					bm.states.redo();
				}
				else {
					prevent = false;
				};
			}
			else if(e.ctrlKey) {
				if(key === "z") {
					bm.states.undo();
				}
				else if(key === "s") {
					bm.save();
				}
				else if(key === "o") {
					bm.load();
				}
				else {
					prevent = false;
				};
			}
			else if(e.shiftKey) {
				prevent = false;
			}
			else if(key.length === 1 && "wasd".includes(key)) {
				let array = bm.valid.tools;
				let index = array.indexOf(bm.control.tool);
				index += (
					key === "w" ? -1 :
					key === "a" ? -3 :
					key === "s" ? 1 :
					key === "d" ? 3 :
					0
				);
				bm.control.tool = array[posmod(index, array.length)]
				let skip = structuredClone(bm.valid.refresh);
				skip.splice(skip.indexOf("ui"), 1);
				bm.refresh(skip);
			}
			else if(key.length === 1 && "tfgh".includes(key)) {
			// family selection
				let name = bm.control.partname;
				let parent = bm.control.body_part.parent;
				let siblings = AAX.getchildren(bm.body, parent);
				let select = (
					key === "t" ? (parent === "standpoint" ? "" : parent) :
					key === "f" ? (siblings.length <= 1 ? "" : siblings[posmod(siblings.indexOf(name) - 1, siblings.length)]) :
					key === "g" ? (AAX.getchildren(bm.body, name)[0] ?? "") :
					key === "h" ? (siblings.length <= 1 ? "" : siblings[posmod(siblings.indexOf(name) + 1, siblings.length)]) :
					""
				);
				if(select) {
					bm.control.partname = select;
					let skip = structuredClone(bm.valid.refresh);
					skip.splice(skip.indexOf("ui"), 1);
					skip.splice(skip.indexOf("states"), 1);
					bm.refresh(skip);
				};
			}
			else {
				prevent = false;
			};
			//
			if(prevent) {
				e.preventDefault();
			};
		}
		else if(userfocus === "px") {
			px.keydown(e);
		};
	};
	//
	document.write(`<label><input type="radio" name="userfocus" value="aa">armature artist</label>`);
	document.write(`\n<br><label><input type="radio" name="userfocus" value="bm">body maker</label>`);
	document.write(`\n<br><label><input type="radio" name="userfocus" value="px">pixel art</label>`);
	document.write(`\n<br hidden><label hidden><input type="radio" name="userfocus" value="se">shape examiner</label>`);
	document.write(`\n<br hidden><label hidden><input type="radio" name="userfocus" value="bg">paper background maker</label>`);
	document.write("<details id=\"changelog\" class=\"text\">\n\t<summary>changelog</summary>\n\t" + arraytoul([
		/*
		"???: v1.4",
		[
			"initial release of the shape examiner",
			"the default bodytext now has 3d shapes for the hands, not 2d images.",
		],
		//*/
		"18jul25: v1.5 (77h51m48s of development since the last update.)",
		[
			"added the posescript system. read the manual section for that. the bulk of this update was spent on that.",
			"minor changes to the text shown while using pose tools.",
			[
				"move italicizes the third coordinate.",
				"coordinates have a plus sign if they're positive.",
				"coordinates are indented so their decimal points line up."
			],
			"fixes",
			[
				"the pixel art tool wouldn't let you drag the sliders on mobile, since swipes were interpreted as page scrolling.",
				"for that and other elements where touch scrolling is disabled, touch zooming is now allowed. (for elements that disable touch scrolling and zooming, you can end up softlocked if you zoom in enough for it to cover the whole screen. if that happens, all you can do is hit back, wiping away everything you did.)",
				"an issue with yz local rotate for symmetrical counterparts",
				"sometimes the tweening screwed up orientation. (the quaternion interpolation was flawed.)"
			],
			"\"STANDARD\" BODYTEXT CHANGES:",
			[
				"the manubrium is now split between left and right, so that it's easier to move the shoulders.",
				"added more detail to the toes, so that rotating them actually does something.",
				"the positions of the shoulder, elbow, and hand are modified to be more realistic.",
				"the elbow and hand are rotated a little by default, mostly for the sake of local rotate."
			],
			"\"HAND\" BODYTEXT CHANGES:",
			[
				"thumb_1, thumb_2, and thumb_3 are rotated a little by default, for the sake of local rotate."
			],
			"added posing tips to the manual.",
			"font improvements.",
			"parts can now be rotated in bodytext, using the tilt() command. (used to give local rotations more accurate axes, mostly.)",
			"spheroids and bodytext tilt() can now be oriented with local rotations, using the \"local\" keyword.",
			"body maker",
			[
				"the buttons that let you insert shape templates while editing image text now add the shape as a new group rather than just inserting it where your cursor is.",
				"added fatscript, a small scripting system that makes it easier to expand a lot of parts at once."
			],
			"added to-do."
		],
		"26mar25: v1.4.1",
		[
			"added the select tool to armature artist and body maker.",
			[
				"selects whatever part is closest to where you clicked.",
				"the stuff i did to make it easier to select parts was not nearly enough for mobile devices. it's just that hard to get precise on a touchscreen.",
				"inverted perspective works the same way."
			]
		],
		"25mar25: v1.4",
		[
			"initial release of the pixel art tool, which armature artist and body maker can send images to. it also has an animation tester.",
			"on the armature artist page, tools do not initialize until they're first opened, which makes the page load faster",
			"it's much easier to select parts, especially on mobile.",
			[
				"the clickable radius is a little bigger, to account for the inaccuracy of touch clicks,",
				"but more importantly, there's enough visual feedback to be as precise as with a mouse. tools that can select parts can now select them by ending a click on them, not just starting a click on them, and when you're close enough for this to happen, it'll highlight the node to show you."
			],
			"rotate/tilt pose tools",
			[
				"they no longer save a new state if the magnitude is zero.",
				"xz now always uses the same radius, which is pretty much as big as it can be while still having access to the full range of rotation.",
				"cosmetic changes to the displayed angle. now it ranges from -180 to 180 degrees, not 0 to 360 degrees"
			],
			"added changelog.",
			"edited the manual to warn about cases where tweening sucks.",
			"renamed invert buttons to \"mirror\". they also depress properly now. (before, they'd be colored to show the signs of the part's relative coordinates. that made sense for what it did before, but not what it does now.)",
			"after creating inbetweens, it now switches to the end key frame, not the first tween frame. (better for making tweens between every frame, and other actions like that.)",
			"rewrote the class i use for animation, adding new features.",
			[
				"previous frame and next frame buttons",
				"being able to switch the axes of the animation (which axis is time, and which is direction)",
				"number input for editing how many rows/columns are in the spritesheet (takes effect instantly, without you having to update the animation again)"
			],
			"one view animation updates are much faster than before",
			"added curl to the rotate settings.",
			"BODYTEXT FORMAT CHANGE: silhouettes work much differently now.",
			[
				"the commands used to be like:",
				[
					"silhouette(): sets the group/subgroup",
					"generation(), capsule(): the two kinds of connection. (must be one or the other.)",
					[
						"generation: tangents the part's image to some of its ancestors and/or descendants",
						"capsule: just adds a capsule shape from the part to its parent, and avoids the convexing"
					]
				],
				"now:",
				[
					"group(): sets the group/subgroup",
					"it's possible to use multiple types of connection at once.",
					[
						"generation()",
						"core(): new type of connection, makes a sphere, for convexing",
						"bone(): new name for capsule"
					],
					"concave(): avoids convexing for the part's main image, and bone() connections if applicable"
				],
				"the object structure has changed, too.",
				[
					"then:",
					[
						".silhouette: array of the group and subgroup",
						".connection: {type, value} object"
					],
					"now:",
					[
						".silhouette: object of all silhouette-related data",
						[
							"group",
							"subgroup",
							"anc",
							"desc",
							"core",
							"bone",
							"concave"
						]
					]
				]
			],
			"\"STANDARD\" BODYTEXT CHANGES:",
			[
				"got rid of the split between wrist and hand, because that was stupid. (the point was to show orientation, like a vague idea of where the fingers are. but orientation is visualized, and the shape is subject to orientation too.)",
				"changed the silhouettes, to match the changes to the silhouette system. the hands are the only parts whose silhouettes are actually changed.",
				"minor changes to the elbow and wrist coordinates.",
				"changes the hand's images to look less vague and more like the pose a hand takes in a typical standing pose."
			],
			"body maker: you can enter fractions in the scale button now. (ex: instead of doing *5 then /4, you can do *5/4. makes it easier to use. it's visualized as a fraction too, to avoid long decimals that are hard to read.)",
			"you can automatically insert the current date in the project name, by typing an asterisk.",
			"bug fixes",
			[
				"buttons like undo/redo didn't depress properly.",
				"filenames sucked.",
				[
					"this is a browser tool, so it can't overwrite your files, just save new files.",
					"when you load a new file, it takes note of the name, to use it if you save it again later",
					"since it matches the name of the file you loaded, your file system probably names it something like \"animation(1).txt\"",
					"which is only okay the first time, because the second time you load and save it, it becomes \"animation(1)(1).txt\", and the third time it becomes \"animation(1)(1)(1).txt\", you get the idea, it's fucking awful",
					"after the changes i made, it should be \"animation(2).txt\", \"animation(3).txt\", etc. changing the number, not adding new numbers",
					"if that's not how your file system handles duplicate names, or it otherwise sucks for you, let me know! i can probably fix it once i understand the rename scheme."
				],
				"loading a project with less animations than the index of the selected animation would cause an error.",
				"duplicating an animation while it had redo states would cause an error.",
				"the tab key didn't work in bodytext."
			]
		],
		"07feb25: v1.3",
		[
			"body maker changes",
			[
				"making the child/sibling tools copy the parent's image text",
				"family selection keys, just like armature artist",
				"adding more options to the scale button",
				[
					"only scaling certain axes",
					"only scaling position, or only scaling dimensions",
					"making it scale a branch rather than all parts",
					"letting it scale only one part"
				]
			],
			"quaternion flipping (allows parts and shapes to be mirrored properly. before, the mirroring of symmetry parts and the invert buttons would not affect the orientation of shape spheroids.)",
			"ui adjustments",
			"rotate settings",
			[
				"rounding",
				"rotating on local axes",
				"rotating on custom axes",
				"tools for setting and modifying custom axes"
			],
			"adding oddness switching to rotation",
			[
				"originally, parts always kept the same oddness before and after rotation.",
				"but that isn't necessarily what the user expects. like if you rotated [-2, 6.5] by 90, it should be [-6.5, -2]. meaning, the oddness should switch.",
				"the rule is, if the magnitude is closer to 90 or 270 than 0 or 360, and the axis is closer to one axis than the others, the oddness of the other two axes are switched.",
				"an axis angle can be understood as a 3d point that's 1 away from zero, right.",
				"the switch axis is whichever of those three coordinates has the highest absolute value.",
				"if there's a tie, there's no switching at all."
			],
			"migrating armature artist and body maker to a separate page",
			"capsule silhouettes are no longer convexed. (ie if the head has horns, the silhouette will look fine if it's capsule. whereas generations would make it look like there's skin stretched over the horns.)",
			"invert buttons work differently",
			[
				"before, they would invert the coordinates of a part and all its descendants. now, they invert the shape of the part and its descendants, and the coordinates of descendants but not the part.",
				"basically, it works more like the rotate pose tool."
			]
		],
		"22dec24: v1.2",
		[
			"initial release of body maker",
			"reset part and reset branch buttons",
			"pose to shape button",
			"rework of how symmetrical parts work in bodytext",
			"new stem-based color system:",
			[
				"the part fill color and silhouette fill color have been combined into one",
				"you can specify multiple colors, which it'll use to differentiate parts that belong to different bodies. (that is, they don't share any common ancestor)"
			],
			"when changing cell dimensions, the standpoint now moves to match it.",
			"scaled up the template bodytexts by 1.5x, tweaked them a bit.",
			"parts with no shape or image, when being incorporated into a silhouette, will act as if they have one point, at the center.",
			"capsule connections look better",
			"more efficient spheroid system. also, fineness now measures the number of sides of a quarter-circle, not a full circle.",
			"fixes",
			[
				"problems with changing interface/buttons colors",
				"problem with multi-stem bodies",
				"problem where, the first time the page loads and before any ui refreshes, the ui is drawn in Default Who Gives A Shit Font",
				"issue in bodytext where unsquarish image dimensions would cause errors"
			]
		],
		"22nov24: v1.1.1",
		[
			"writing the manual",
			"html changes",
			"fixing issues with bodytext changes"
		],
		"28oct24: v1.1",
		[
			"reordering pose tools",
			"fixing issue where inbetweening would make shapes like the head shrink",
			"better ui layout",
			"invert is applied to the whole branch",
			"changed draw settings ratio to range"
		],
		"10oct24: v1.0.1",
		[
			"minor fixes",
			"adding a description",
			"making it so entering an empty string for a color change resets the color to default"
		],
		"07oct24: v1.0"
	]).replaceAll("\n", "\n\t") + "\n</details>");
	document.write(manualhtml({
		// 23may25
		"high priority": [
			"issues",
			[
				"mirror clears images.",
				"rotate oddity",
				[
					"custom axis: [1, 3, 1]",
					"rotate. do it slowly enough to notice that the basis' axes are moving weirdly."
				],
				"the midsection is all wobbly during the walk cycle, and only when it sways to the left.",
				[
					"points are being left out in the convexing, somehow."
				],
				"spheroids centered on odd coordinates look wrong. the dimensions are off, and sometimes coordinates have to be larger than they should be to move them.",
				"i'd like to replace the hand images with shapes, but when i try, there's a one-pixel offset between left and right, for some reason. there's a problem somewhere in my image system.",
				// 17jul25
				[
					"realized this is especially important because, when a first-time user rotates the body just to feel out what the tool is, and the head and torso rotate but the hands don't, and they didn't read the manual to know why... it just looks like a bug."
				],
				"bodytext changes don't account for if a part's default orientation is different between the old body and the new body."
			],
			// 17jul25
			"sizing shapes with perspective, and/or applying perspective to individual points. (this will be optional, through the draw settings.)",
			"add a scale input in the bodytext changing. (you could use body maker, but that's way too much trouble.)"
			//"posescript",
			//[
			//],
		],
		"medium priority": [
			"posescript",
			[
				// 17jul25
				"adding a sample run cycle.",
				"adding more samples in general. just for the novelty of it.",
				[
					"an animation like they're throwing a baseball (you can modify that to look like a punch, or swinging a one-handed weapon. versatile.)",
					"a finger snap",
					"jump",
					"backflip",
					"thinking"
				],
				"adding sorta boring and easy hand pose samples that are nevertheless useful",
				[
					"pointing",
					"spread but not tense",
					"narrow but not tense",
					"thumbs up",
					"blocking the sun (the kind of pose you make when you raise your hand to your forehead to look at something far away)",
					"peace sign",
					"holding various objects",
					[
						"apple-sized round thing",
						"pole",
						"pen",
						"mug",
						"glass"
					]
				],
				"automatic perspective correction is sorta incomplete. there might be more cases that need correction than the ones it currently accommodates.",
				"adding hide and perspective adjustment to \"time\".",
				"\"every scene\" target that's like scene, but applies changes to every frame?",
				"selective apply tweening",
				// 17jul25
				"saving/loading files",
				[
					"not everyone uses text editors and stuff all the time and has a place to store these scripts.",
					"it'd be especially useful to save/load files that contain multiple posescripts..."
				]
			],
			"make it so stretch/widen affects the shape of spheroids, not just their position",
			"make posetext use basicobjtotext? (makes it more compact.)",
			"make perspective coordinates pose-exclusive",
			[
				"it's confusing to be able to reset it to default <i>and</i> be able to automate it, when 99% of the time they do exactly the same thing. why would you even need to specify non-automatic default coordinates, to make sure an anime pompadour points in the right direction? that's fucking stupid.",
				"technically, the point of perspective coordinates isn't just to conform to perspective, but to allow 2d adjustment independent of the real 3d positions. construction drawing is not all there is to art. that's why 2d images are possible, too.",
				"but i'm having trouble picturing a real need to keep it how it is, and even if there's cases i haven't thought of, you could always use posescript. (make a script that applies the perspective coordinates you want to always start with, and run that when you start an animation or make a blank frame.)",
				// 17jul25
				"i'll replace the \"automate perspective coordinates\" button with being able to reset perspective coordinates in posescript."
			],
			"arc bones",
			[
				"you know, for spines.",
				"requires a lot of planning to know how the hell it works. specifically, what direction it curves in."
			],
			"body maker",
			[
				"make it so you can select and apply different template bodytexts in body maker, like you can for armature artist",
				// 17jul25
				"make a fatscript that shows up by default and works ok."
			],
			// 17jul25
			"make it so stretch/widen is applied <i>after</i> orientation, maybe. (it should probably be optional. a draw settings checkbox or w/e.)",
			"make it so apply tweening asks the user what to omit, rather than using hide?",
			"misc buttons",
			[
				"correct autoperspective (already exists in posescript, but it should exist outside it.)"
			],
			"saving/loading \"preference\" files",
			[
				"stores draw settings, certain default values, that kind of thing... maybe you can use a custom set of posescripts, bodytext templates, or shape templates?",
				"they'd be tedious to input one by one. to make it optimally not-tedious, you have to gather everything like this into one file."
			],
			"visualizing \"invisible\" properties",
			[
				"whether perspective is automatic",
				"whether a part image is 2d rather than being created from a shape"
			]
		],
		"low priority": [
			"issues",
			[
				// 10jun25
				"rarely, words will be blurry horizontally just a little in the ui canvases. not sure if i can even fix that, i'm 100% my coordinates are always integers, and if the bitmap font's scale was wrong, it wouldn't be nearly this rare. it doesn't hinder readability either, it just looks ugly."
			],
			"posescript",
			[
				"scene rotation",
				[
					"keep the same floats for stem position",
					"position_only addendum",
					"make it possible to specify a point or part as a fulcrum",
					"make it possible to rotate only one stem (name or number)"
				],
				// 17jul25
				"true/local/custom addendums clash with local axis names a bit.",
				[
					"you can only create or use local axis names if local is on, right.",
					"but using the \"local\" addendum won't help you there, even though it's supposed to switch you to local axes temporarily.",
					"sorta inconsistent, but low priority on account of it being a rare scenario and slightly counter to the reason axis names are strictly local to begin with."
				]
			],
			"have it wait a second before it clears the coordinate text? so it's easier to understand what numbers to use in posescript to do the same thing.",
			"shape examiner",
			[
				"a tool that lets you visualize the depth and form of armature artist's 3d shapes, and probably edit them too.",
				"it's already written, but it doesn't work yet."
			]
			// 17jul25
			// "separate camera rotation from perspective_coor"
		],
	}, "to-do"));
	//document.write("\n<br>");
	document.write("<ul id=\"desc\" style=\"width: 40em\"></ul>");
	//
	document.write(`\n<div id="aa_div"></div>`);
	//document.write(`<div id="aa_preface"></div>\n<div id="aapa"></div><div id="aa"></div>`);
	let aa = {
	// "armature artist", a simpler version of what i wanted from the posing
	// interface.
	// - a lot of the code for this is in the AAX object in my graphics script.
	//   basically, anything i was gonna use in other armature-related tools
	//   went there. you'll have to read that too to get a lot of this.
		pa: {
			part: {
			// all the data that will be sent to the rest of aa
				front: [],
				// data for the front view of the part. it's like ImageData, an
				// array of what value each pixel has, left to right, top to
				// bottom. 0 is unfilled, 1 is filled, 2 is filled in color2.
				// - color1 pixels are only drawn on the armature if they're on
				//   the outside, color2 are drawn regardless.
				// - color2 can be used for guides and stuff.
				right: [],
				// counterpart for the side
				size: 8,
				oddness: [false, false, false],
				get box() {
					return aa.box(this.size, this.oddness);
				},
				dim: function(right) {
					const box = this.box;
					return [box[right ? "d" : "w"], box.h];
				},
				// this will create an object like: {x: -4, y: -4, z: 4, w: 9,
				// h: 9, d: 9}
				// - the pixels of the part are mapped to relative coordinates
				//   of the part's placement on the canvas.
				// - the coordinates represent the corner of the box that's the
				//   lowest in each axis. (ie the leftmost, topmost, backmost.)
				rect: function(right) {
					const dim = this.dim(right);
					return {
						x: (dim[0] - 1)*(-1/2),
						y: (dim[1] - 1)*(-1/2),
						w: dim[0],
						h: dim[1],
					};
				},
				color1: AAX.Color.template.parts[1],
				color2: AAX.Color.template.parts[0],
				fill: AAX.Color.template.part_fill[0],
				//"#ef007f", // violet red
				//"#bfef1f", // lime
				//"#007fef", // azure
				//"#7f00ef" // purple
			},
			ctx: {
				front: null,
				right: null,
				ui: null,
			},
			// canvas contexts
			grid_color: "silver",
			// color used for grid lines and empty pixels. this isn't really
			// important, it's only changeable so you can fix it if it blends in
			// with the part color.
			empty_color: "gray",
			grid_w: 1,
			block_w: 7,
			editright: false,
			// boolean for whether actions done in the ui like the doubleclick
			// ellipse should be done on the front view or the right view. this
			// is set as false when you click the front view, true when you
			// click the right view.
			// - it's also used as a faster way of checking which canvas was
			//   clicked to trigger the function.
			tool: "pen1",
			// string for what to use when the canvas is clicked.
			strokedata: null,
			// stores data used within the action of a mousedown and mouseup.
			clicktype: null,
			// string for the canvas you're currently clicking
			editactions: [
				"changedimensions",
				"ellipse",
				"rotate",
				"rotate90",
				"clear",
				"xmirror",
				"ymirror",
				"move_l",
				"move_r",
				"move_u",
				"move_d",
				"fullellipse",
				"swap"
			],
			redraw: function() {
				let i0 = 0;
				let i1 = 0;
				for(i0 = 0; i0 < 2; i0++) {
					let ctx = this.ctx[i0 ? "right" : "front"];
					let image = this.part[i0 ? "right" : "front"];
					let w = this.part.rect(i0).w;
					// screen width, not box.w.
					if(true) {
						image = AAX.sq_raster.fill(image, w);
					};
					ctx.canvas.width = (this.grid_w + this.block_w)*w;
					ctx.canvas.height = (this.grid_w + this.block_w)*this.part.rect(i0).h;
					ctx.fillStyle = this.grid_color;
					ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
					//
					let coor = [
						-this.part.rect(i0).x,
						-this.part.rect(i0).y
					];
					coor = [
						(coor[0] * (this.grid_w + this.block_w)) + this.grid_w + Math.floor(this.block_w/2 - this.grid_w/2),
						(coor[1] * (this.grid_w + this.block_w)) + this.grid_w + Math.floor(this.block_w/2 - this.grid_w/2),
					];
					ctx.fillStyle = this.empty_color;
					ctx.fillRect(0, coor[1], ctx.canvas.width, this.grid_w);
					ctx.fillRect(coor[0], 0, this.grid_w, ctx.canvas.height);
					// draw lines at the zeroes.
					for(i1 = 0; i1 < image.length; i1++) {
						let coor = [
							i1 % w,
							Math.floor(i1/w)
						];
						// column and row
						coor = [
							(coor[0] * (this.grid_w + this.block_w)) + this.grid_w,
							(coor[1] * (this.grid_w + this.block_w)) + this.grid_w,
						];
						// x and y, in pixels
						if(image[i1] === 0) {
							ctx.fillStyle = this.empty_color;
						}
						else if([1, 2].includes(image[i1])) {
							ctx.fillStyle = this.part["color" + image[i1]];
						}
						else if(image[i1] === "fill") {
							ctx.fillStyle = aa.pa.part.fill;
						}
						else {
							console.log("invalid aa.pa.part pixel data.");
							return;
						};
						ctx.fillRect(...coor, this.block_w, this.block_w);
					}
				}
			},
			clickrowcol: function(x, y, giveindex) {
			// converts canvas coordinates to block coordinates on the thing.
			// - returns null if it's off the canvas.
			// - giveindex: returns the number index instead
				const right = this.clicktype === "right";
				let ctx = this.ctx[right ? "right" : "front"];
				if(x < 0 || x >= ctx.canvas.width || y < 0 || y >= ctx.canvas.height) {
					return null;
				};
				const block = (this.grid_w + this.block_w);
				let coor = [
					Math.floor(x/block),
					Math.floor(y/block)
				];
				return (
					giveindex
					?
					coor[1]*this.part.rect(right).w + coor[0]
					:
					coor
				);
			},
			ui: {
			// PART ARTIST
			// functions/variables related to the buttons
				scale: 1,
				buttons: {},
				// object of buttons.
				// - each button is just a rectangle object. x, y, w, h
				create: function() {
					let i1 = 0;
					let i2 = 0;
					let block = AAX.ui.block;
					let ref = this.buttons;
					let area = {x: 0, y: 0, w: 6*block, h: 4*block};
					ref.switch = structuredClone(area);
					ref.switch_no_export = structuredClone(area);
					ref.switch_no_export.x += area.w;
					area.y += area.h + block;
					area.w = 8*block;
					area.h = 2*block;
					let array = ["clear", "fullellipse", "xmirror", "ymirror", "rotate90", "swap"];
					for(i1 = 0; i1 < array.length; i1++) {
						if(i1 === 2) {
							area.h = 1*block;
						};
						ref[ array[i1] ] = structuredClone(area);
						area.y += area.h;
					}
					area.x += area.w;
					area.w = 4*block;
					area.h = 4*block;
					area.y -= area.h;
					ref.move = structuredClone(area);
					area.y -= 4*block;
					area.x += 1*block;
					area.w = 3*block;
					area.h = 1.5*block;
					array = ["grid_color", "empty_color"];
					for(i1 = 0; i1 < array.length; i1++) {
						ref[ array[i1] ] = structuredClone(area);
						area.y += area.h;
					}
					area = {
						x: area.x + area.w + block,
						y: 0,
						w: 7*block,
						h: 1*block,
					};
					array = ["heading", "pen1", "pen2", "ellipse", "rotate"];
					for(i1 = 0; i1 < array.length; i1++) {
						ref[ "tool_" +  array[i1] ] = structuredClone(area);
						area.y += area.h;
					}
					area.y += area.h;
					area.h = 3*block;
					ref.changedimensions = structuredClone(area);
					// - switch, switch without export (same place it is in the main ui)
					// - tools (ie, buttons that change what clicks do)
					//   - pen1, pen2 (3)
					//   - ellipse (5)
					//   - rotate (4)
					// - edits (buttons that apply changes by themselves)
					//   - clear (4)
					//   - full ellipse (8)
					//   - move (special case)
					//   - x mirror (6)
					//   - y mirror (6)
					//   - rotate 90
					//   - swap (3)
					// - settings changes
					//   - grid_color, empty_color (special cases)
					//   - change dimensions (7 x 2)
				},
				keymap: {
					q: ["switch", "switch_no_export"],
					w: "move_u",
					a: "move_l",
					s: "move_d",
					d: "move_r",
					"1": "tool_pen1",
					"2": "tool_pen2",
				},
				draw: function() {
				// for now this is going to be stunningly half-assed.
				// - this also acts as a "reset graphics" function, and it changes
				//   the ui canvas dimensions too.
					let i1 = 0;
					let i2 = 0;
					let color = aa.color.buttons;
					let ctx = aa.pa.ctx.ui;
					let ranges = [0, 0];
					for (i1 in this.buttons) {
						if (this.buttons.hasOwnProperty(i1)) {
							let ref = this.buttons[i1];
							ranges[0] = Math.max(ranges[0], ref.x, ref.x + ref.w);
							ranges[1] = Math.max(ranges[1], ref.y, ref.y + ref.h);
						};
					}
					ranges[0]++;
					ranges[1]++;
					ctx.canvas.width = ranges[0];
					ctx.canvas.height = ranges[1];
					ctx.clearRect(0, 0, ...ranges);
					ctx.font = AAX.ui.font;
					ctx.textAlign = "center";
					ctx.textBaseline = "middle";
					const margin = AAX.ui.margin;
					const spacednames = [
						"full ellipse",
						"x mirror",
						"y mirror",
						"rotate 90",
						"change dimensions"
					];
					for (i1 in this.buttons) {
						if (this.buttons.hasOwnProperty(i1)) {
							let ref = this.buttons[i1];
							let text = (i1.startsWith("tool_") ? i1.slice("tool_".length) : i1).replaceAll("_", " ");
							if(i1 === "tool_heading") {
								text = "tools";
							}
							else if(i1 === "switch_no_export") {
								text = "switch without export";
							}
							else {
								for(i2 = 0; i2 < spacednames.length; i2++) {
									if(spacednames[i2].replaceAll(" ", "") === text) {
										text = spacednames[i2];
										i2 += spacednames.length;
									};
								}
							};
							let align = (i1.startsWith("tool_") && i1 !== "tool_heading") ? "left" : "center";
							let selected = Number(i1.startsWith("tool_") && aa.pa.tool === i1.slice("tool_".length));
							ctx.strokeStyle = color[ posmod(- selected, color.length) ];
							ctx.fillStyle = color[ posmod(1 - selected, color.length) ];
							if(i1 !== "tool_heading") {
								ctx.fillRect(ref.x, ref.y, ref.w, ref.h);
								Rect.fauxstroke(ref, ctx);
							};
							if(["color1", "color2", "grid_color", "empty_color"].includes(i1)) {
								ctx.fillStyle = ["grid_color", "empty_color"].includes(i1) ? aa.pa[i1] : aa.pa.part[i1];
								ctx.fillRect(ref.x, ref.y, ref.w, ref.h);
								Rect.fauxstroke(ref, ctx);
							}
							else if(i1 === "move") {
								linespecial(ctx, ref.x, ref.y, ref.x + ref.w, ref.y + ref.h);
								linespecial(ctx, ref.x + ref.w, ref.y, ref.x, ref.y + ref.h);
								// x
								linespecial(ctx,
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*1/8),
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*2/8)
								);
								linespecial(ctx,
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*6/8),
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*7/8)
								);
								linespecial(ctx,
								Math.floor(ref.x + ref.w*1/8),
								Math.floor(ref.y + ref.h/2),
								Math.floor(ref.x + ref.w*2/8),
								Math.floor(ref.y + ref.h/2)
								);
								linespecial(ctx,
								Math.floor(ref.x + ref.w*6/8),
								Math.floor(ref.y + ref.h/2),
								Math.floor(ref.x + ref.w*7/8),
								Math.floor(ref.y + ref.h/2)
								);
							}
							else {
								if((2*margin[0] + 5*text.length - 1) > ref.w) {
									text = text.split(" ");
								};
								if(!Array.isArray(text)) {
									text = [text];
								};
								ctx.textAlign = align;
								ctx.fillStyle = ctx.strokeStyle;
								for(i2 = 0; i2 < text.length; i2++) {
									ctx.fillText(
										text[i2],
										Math.floor(ref.x + (align === "center")*(ref.w/2) + margin[0]) - (text[i2].length%2 && align === "center")/2,
										Math.floor(ref.y + ref.h/2 + margin[1] + 8*(-(text.length - 1)/2 + i2))
									);
								};
							};
						};
					}
				},
				action: function(action, shift, ctrl) {
					let i1 = 0;
					if(action.endsWith("heading")) {
					}
					else if(shift && action === "ellipse") {
						aa.pa.edit("fullellipse");
					}
					else if(action === "switch") {
						const part = aa.control.part;
						const view = aa.control.view;
						const ref = aa.pa.part;
						const prompttext = "the current part image doesn't have the same oddness as the part you're trying to apply it to. the center rows/columns might be collapsed or expanded.";
						let no_export = false;
						if(aa.control.perspectived) {
						// - save the aa.pa oddness
						// - if it's different:
						//   - prompt confirmation
						//   - changeoddness
						// - then crop it with imagefunc.crop
							const right = !!(view%2);
							let image = structuredClone(ref[right ? "right" : "front"]);
							const pa_oddness = [ref.oddness[right ? 2 : 0], ref.oddness[1]];
							const new_oddness = part.image_oddness(view);
							no_export = (
								pa_oddness[0] !== new_oddness[0]
								||
								pa_oddness[1] !== new_oddness[1]
							);
							if(no_export && confirm(prompttext)) {
							// if the oddness is different, confirm that oddness
							// edits are ok
								no_export = false;
								image = AAX.sq_raster.changeoddness(image, pa_oddness, new_oddness);
								// oddness differences change the image
							};
							if(!no_export) {
								part._perspective[view] = AAX.sq_raster.autocrop(image, new_oddness);
								// autocrop it so all the pixels just barely fit
								// inside
							};
						}
						else {
							let image = [
								structuredClone(ref.front),
								structuredClone(ref.right)
							];
							const new_oddness = [
								part.image_oddness("front"),
								part.image_oddness("right")
							];
							no_export = (
								ref.oddness[0] !== new_oddness[0][0]
								||
								ref.oddness[1] !== new_oddness[0][1]
								||
								ref.oddness[1] !== new_oddness[1][1]
								||
								ref.oddness[2] !== new_oddness[1][0]
							);
							// ref.oddness is 3d, new_oddness [0] and [1] are
							// 2d.
							if(no_export && confirm(prompttext)) {
							// correct for oddness
								no_export = false;
								image = [
									AAX.sq_raster.changeoddness(image[0], [ref.oddness[0], ref.oddness[1]], new_oddness[0]),
									AAX.sq_raster.changeoddness(image[1], [ref.oddness[2], ref.oddness[1]], new_oddness[1])
								];
								// oddness differences change the image
							};
							if(!no_export) {
								part._image.front = AAX.sq_raster.autocrop(image[0], new_oddness[0]);
								part._image.right = AAX.sq_raster.autocrop(image[1], new_oddness[1]);
								// autocrop
							};
						};
						// i'm not using the size setters because it has to edit
						// the image for oddness anyway.
						aa.refresh(no_export ? "states" : null);
						aa.editmodetoggle();
					}
					else if(action === "switch_no_export") {
						aa.editmodetoggle();
					}
					else if(action.startsWith("tool_")) {
						aa.pa.tool = action.slice("tool_".length);
						// so that it knows what to do with the next canvas click
						aa.pa.ui.draw();
						// so that graphics changes take effect
					}
					else if(action.startsWith("move_") && ["l", "r", "u", "d", "ul", "ur", "dl", "dr"].includes(action.slice("move_".length))) {
						aa.pa.edit(action);
					}
					else if(aa.pa.editactions.includes(action) && !["ellipse", "move"].includes(action)) {
						aa.pa.edit(action);
					}
					else if(["color1", "color2", "grid_color", "empty_color"].includes(action)) {
						aa.pa.changecolor(action);
					};
				},
				mousedown: function(e, doubleclick) {
					let i1 = 0;
					let click = clickxy(e, "aa");
					let _this = aa.pa.ui;
					let action = null;
					for (i1 in _this.buttons) {
						if (_this.buttons.hasOwnProperty(i1) && Rect.inside(_this.buttons[i1], click[0], click[1])) {
							if(i1 === "move") {
								let angle = get2dangle(
									click[0] - (_this.buttons[i1].x + _this.buttons[i1].w/2),
									click[1] - (_this.buttons[i1].y + _this.buttons[i1].h/2),
									true
								) ?? 0;
								angle = posmod(angle + 2*Math.PI/8, 2*Math.PI);
								angle = "rdlu"[Math.floor(angle/(2*Math.PI/4))];
								action = i1 + "_" + angle;
							}
							else {
								action = i1;
							}
						};
					}
					if(action !== null) {
						_this.action(action, doubleclick);
					};
				},
			},
			mousedown: function(e) {
				let click = clickxy(e, "aa");
				let _this = aa.pa;
				if(e.target.id === "aapa_front") {
					_this.editright = false;
					_this.clicktype = "front";
				}
				else if(e.target.id === "aapa_right") {
					_this.editright = true;
					_this.clicktype = "right";
				}
				else {
					console.log("this shouldn't happen");
					console.log(e.target.id);
				};
				if(["pen1", "pen2"].includes(_this.tool)) {
					_this.penaction(...click);
					_this.pen(...click);
				}
				else if(_this.tool === "ellipse") {
					_this.strokedata = {
						start: _this.clickrowcol(...click),
						image: structuredClone(_this.part[_this.clicktype]),
					};
				}
				else if(_this.tool === "rotate") {
					let canvas = _this.ctx[_this.clicktype].canvas;
					_this.strokedata = {
						start: get2dangle(
							click[0] - canvas.width/2,
							click[1] - canvas.height/2,
							true
						) ?? 0,
						image: structuredClone(_this.part[_this.clicktype]),
					};
					// save the starting angle
				}
			},
			mousemove: function(e, finish) {
				if(e.target.id !== "aapa_" + aa.pa.clicktype) {
					return;
				};
				let click = clickxy(e);
				let _this = aa.pa;
				if(["pen1", "pen2"].includes(_this.tool)) {
					if(!finish) {
						_this.pen(...click);
					};
				}
				else if(_this.tool === "ellipse" && _this.strokedata.start !== null) {
				// reset it to how it was before the click, and create an
				// ellipse
					let temp = _this.clickrowcol(...click);
					if(temp !== null) {
						_this.edit("ellipse", _this.strokedata.start.concat(temp));
						// redraws too
					};
					if(!finish) {
						_this.part[_this.clicktype] = structuredClone(_this.strokedata.image);
					};
				}
				else if(_this.tool === "rotate") {
				// same thing, but rotate
					let canvas = _this.ctx[_this.clicktype].canvas;
					let angle = get2dangle(
						click[0] - canvas.width/2,
						click[1] - canvas.height/2,
						true
					) ?? 0;
					angle = posmod(angle - _this.strokedata.start, 2*Math.PI);
					_this.edit("rotate", [angle]);
					if(!finish) {
						_this.part[_this.clicktype] = structuredClone(_this.strokedata.image);
					};
				};
				if(finish) {
					_this.strokedata = null;
					_this.clicktype = null;
				};
			},
			mouseup: function(e) {
				if(e.target.id !== "aapa_" + aa.pa.clicktype) {
					return;
				};
				aa.pa.mousemove(e, true);
			},
			// functions below this line are what happens when you click the
			// buttons.
			penaction: function(x, y) {
			// sets this.strokedata as the action this stroke will take. (that
			// is, whether to fill or erase. this depends on the value of the
			// pixel you clicked.)
				let value = this.part[this.clicktype][ this.clickrowcol(x, y, true) ];
				// value of the pixel being clicked on
				if(this.tool === "pen1") {
					this.strokedata = (value === 0 ? 1 : 0);
				}
				else if(this.tool === "pen2") {
					this.strokedata = (value === 2 ? "2 to 1" : 2);
				}
				else {
					console.log("this shouldn't happen");
				};
			},
			pen: function(x, y) {
				let action = this.strokedata;
				let index = this.clickrowcol(x, y, true);
				if(index === null) {
					return;
				};
				let image = this.part[this.clicktype];
				if([0, 1, 2].includes(action)) {
					image[index] = action;
				}
				else if(action === "2 to 1") {
					if(image[index] === 2) {
						image[index] = 1;
					};
				}
				else {
					console.log("this shouldn't happen");
				};
				this.redraw();
			},
			changecolor: function(type) {
			// prompts the user and changes color accordingly.
				let text = {
					color1: "main color.",
					color2: "secondary color.",
					grid_color: "color for the grid.",
					empty_color: "color for unfilled blocks.",
				};
				if(!text.hasOwnProperty(type)) {
					console.log("this shouldn't happen");
					return;
				};
				text = "type the " + text[type];
				const color = prompt(text);
				if(!color) {
					return;
				};
				if(["color1", "color2"].includes(type)) {
					this.part[type] = color;
				}
				else {
					this[type] = color;
				}
				this.ui.draw();
				this.redraw();
			},
			edit: function(action, args) {
			// all-purpose function for most editing tools.
			// - action: the string of the function in Raster you plan
			//   to use
			//   - there's also fullellipse and switch. those aren't imagefunc
			//     functions, but there's code for those.
			//   - go to aa.pa.editactions for the full list of actions.
			// - args: an array of arguments to pass on. (not counting image and
			//   w. it can figure those out on its own.)
			//   - ellipse: x1, y1, x2, y2
			//   - move is figured out from the direction suffix.
				args ??= [];
				const box = structuredClone(this.part.box);
				let rect = this.part.rect(this.editright);
				let image = this.part[this.editright ? "right" : "front"];
				const w = rect.w;
				if(action.startsWith("move_")) {
					action = action.split("_");
					args = {
						l: [-1, 0],
						r: [1, 0],
						u: [0, -1],
						d: [0, 1],
						ul: [-1, -1],
						ur: [1, -1],
						dl: [-1, 1],
						dr: [1, 1],
					}[action[1]];
					action = action[0];
				};
				//
				if(action === "changedimensions") {
				// changedimensions only thinks in 2d. this prompts the user to
				// create a changes object, then applies edits to both front and
				// right.
					let text = prompt([
						`type dimension changes here to expand the canvas.`,
						`dimensions and coordinates are created with an overall size number, and "oddness" booleans for each axis.`,
						`the box the part is within will always center on [0, 0, 0] and all its dimensions will be mostly equal.`,
						`but depending on the axis' oddness, dimensions might be size + 1.`,
						`type "size:" and a number to change size, and an axis letter with a colon and boolean to change oddness. use commas to separate multiple commands.`,
					].join(String.fromCharCode(10).repeat(2)));
					if(!text) {
						return;
					};
					text = text.split(",");
					for(i1 = 0; i1 < text.length; i1++) {
						let value = text[i1].split(":");
						let name = value[0].trim();
						value = (
							name === "size"
							?
							Number(value[1])
							:
							value[1].trim()
						);
						if(name === "size" && Number.isInteger(value) && value >= 0) {
							this.part.size = value;
						}
						else if("xyz".includes(name) && name.length === 1 && ["true", "false"].includes(value)) {
							this.part.oddness["xyz".indexOf(name)] = value === "true";
						};
					}
					const new_box = structuredClone(this.part.box);
					this.part.front = Raster.redimension(this.part.front, box.w, new_box.w, new_box.h);
					this.part.right = Raster.redimension(this.part.right, box.d, new_box.d, new_box.h);
				}
				else if(["ellipse", "rotate", "clear", "xmirror", "ymirror", "move"].includes(action)) {
					this.part[this.editright ? "right" : "front"] = Raster[action](image, w, ...args);
				}
				else if(action === "fullellipse") {
					this.edit("ellipse", [0, 0, rect.w - 1, rect.h - 1]);
					return;
					// avoids .redraw since this new running of .edit will do
					// that
				}
				else if(action === "swap") {
					let temp = Raster.redimension(this.part.front, box.w, box.d, box.h);
					this.part.front = Raster.redimension(this.part.right, box.d, box.w, box.h);
					this.part.right = structuredClone(temp);
					// dimensions might be different, because of oddness and all
					// that.
				}
				else if(action === "rotate90") {
					this.part[this.editright ? "right" : "front"] = Raster.rotate(image, w, Math.PI/2);
				};
				this.redraw();
			},
		},
		drawsettings: new AAX.DrawSettings,
		// stuff is here if it's data that only affects how things are
		// visualized, not stuff that affects processing like which tool is
		// selected.
		// - NOTE color doesn't count. that's separate.
		color: new AAX.Color,
		// object storing the colors of various things.
		ctx: {
			main: null,
			ui: null,
		},
		div: {
			editmodetrue: null,
			editmodefalse: null,
			coor: null,
		},
		version: "",
		partinfo_is_default: function(part, view, suffix) {
			let _default = false;
			if(suffix in AAX.part_properties && ["body_exclusive", "pose_exclusive"].includes(AAX.part_properties[suffix].type)) {
				_default = true;
			}
			else if(suffix === "shape") {
				//_default = part["_" + suffix] === "default";
				_default = part.getwithoutredirects(suffix) === "default";
			}
			else if(["name", "colors"].includes(suffix)) {
				_default = true;
			}
			else if(suffix === "hide") {
				_default = part.bodyref[suffix] === part[suffix];
			}
			else if(suffix === "coor") {
				_default = compareobject(AAX.relcoor(part.bodyref), part.relcoor);
			}
			else if(suffix === "image") {
				_default = (
					part._image.front === "default"
					&&
					part._image.right === "default"
				);
			}
			else if(suffix === "perspective_coor") {
				_default = part._perspective.coor[view] === "default";
			}
			else if(suffix === "perspective_image") {
				_default = part._perspective[view] === "default";
			}
			else if(suffix === "shape_settings") {
				let quat = part.body[part.name].mirror ? Quat.mirror.x() : Quat.new();
				_default = part.stretch === 1 && part.widen === 1 && compareobject(part.orient, quat);
			}
			else {
				console.log("there are partinfo properties the logic doesn't account for. (" + suffix + ")");
			};
			return _default;
		},
		hidelist: function(partname, suffix) {
		// makes an array of parts based on the partname and the type of hide.
		// for example, making an array of the body the part is part of, or the
		// branch made from it.
			let i1 = 0;
			let loop = new Loop("aa.hidelist");
			let array = [];
			let minus = null;
			if(suffix.includes("_minus_")) {
				suffix = suffix.split("_minus_");
				minus = suffix[1];
				suffix = suffix[0];
			};
			if(suffix === "part") {
				array = [partname];
			}
			else if(suffix === "group") {
				let num = aa.currpose[partname].silhouette.group;
				let bodylist = aa.hidelist(partname, "body");
				// group basically means "same set of limbs", so it should
				// omit parts that aren't in the same body.
				for(i1 = 0; i1 < bodylist.length; i1++) {
					let _i1 = bodylist[i1];
					if(aa.currpose[_i1].silhouette.group === num) {
						array.push(_i1);
					}
				}
			}
			else if(suffix === "branch" || suffix === "body") {
				let start = suffix === "body" ? AAX.getstem(aa.currpose, partname) : partname;
				array = AAX.getdesc(aa.currpose, start);
				array.splice(0, 0, start);
			}
			else if(suffix === "all") {
				for(i1 in aa.currpose) {
					loop.tick(1);
					if(aa.currpose.hasOwnProperty(i1)) {
						array[array.length] = i1;
					}
				}
				loop.end();
			}
			else {
				console.log("this shouldn't happen");
			};
			if(minus) {
				minus = aa.hidelist(partname, minus);
				for(i1 = 0; i1 < minus.length; i1++) {
					loop.tick(1);
					let temp = array.indexOf(minus[i1]);
					if(temp !== -1) {
						array.splice(temp, 1);
					}
				}
				loop.end();
			}
			return array;
		},
		ishidden: function(partname, suffix) {
		// used with the hide/show buttons, to tell whether the button should be
		// highlighted, and whether clicking it should show or hide the parts
		// involved.
			let i1 = 0;
			let loop = new Loop("aa.");
			let array = aa.hidelist(partname, suffix);
			for(i1 = 0; i1 < array.length; i1++) {
				loop.tick(1);
				if(!aa.currpose[ array[i1] ].hide) {
					return false;
				};
			}
			loop.end();
			return true;
		},
		inbetweenvalues: function(num, curve, easeA, easeB, randomize) {
		// used by the inbetween visual and creation.
		// - one of those things that's only a function because it bothers me to
		//   write the same code twice.
			let array = [];
			let ease = (
				easeA
				?
				(easeB ? "out" : "out/in")
				:
				(easeB ? "in/out" : "in")
			);
			let _array = null;
			if(randomize) {
			// makes it look sorta wonky and random.
				_array = [];
				for(let i1 = 0; i1 < num; i1++) {
					_array.push( (Math.random() + (i1 + 1)/(num + 1))/2 );
				}
				_array.sort((a, b) => a - b);
			}
			for(let i1 = 0; i1 < num; i1++) {
				array[i1] = easing(_array ? _array[i1] : (i1 + 1)/(num + 1), ease, curve);
			}
			return array;
		},
		ui: {
		// ARMATURE ARTIST
		// functions/data specific to ui, like what creates/draws buttons. and
		// some other stuff, like arrays of valid values for string properties
			buttons: {},
			create: function() {
				let i1 = 0;
				let i2 = 0;
				let loop = new Loop("aa.ui.create");
				let temp = structuredClone(AAX.ui.color_area);
				temp.direction = "r";
	            temp.adjust = 3;
				let areas = [
					{
						prefix: "states",
						first: {
							suffix: "undo redo".split(" "),
							w: 4, h: 2,
							horizontal: true,
						},
						actions: [
							["expand", "limit", "d", 2]
						],
					},
					{
						prefix: "frame",
						first: {
							suffix: "display",
							w: 3, h: 3,
						},
						actions: [
							["expand", "prev", "l", 2],
							["expand", "next", "r", 2],
							["subtract", "prev", "u", 1],
							["subtract", "next", "u", 1],
							["column", "blank duplicate delete move_up move_down".split(" "), "d", 7, 1]
						],
					},
					{
						prefix: "inbetween",
						first: {
							suffix: "curve",
							w: 6, h: 1,
						},
						actions: [
							["expand", "easeA easeB".split(" "), "d", 1, true],
							["expand", "visual", "d", 1],
							["expand", "add number subtract".split(" "), "r", 2],
							["expand", "create", "d", 3],
							["expand", "apply", "d", 3],
						],
					},
					{
						prefix: "hide",
						first: {
							suffix: [],
							w: 8, h: 1,
						},
					},
					{
						prefix: "misc",
						first: {
							suffix: "autoperspective",
							w: 10, h: 4,
						},
						actions: [
							["expand", "clearimage editshape".split(" "), "d", 2, true],
							["expand", "stretch_widen refreshshape".split(" "), "d", 2, true],
							["expand", "reset_part reset_branch".split(" "), "d", 2, true],
							["expand", "posetoshape", "d", 1],
							["expand", "posescript", "d", 2]
						],
					},
					{
						prefix: "view",
						first: {
							suffix: "0 1 2 3".split(" "),
							w: 1.5, h: 1,
							horizontal: true,
						},
					},
					{
						prefix: "oddify",
						direction: "d",
						first: {
							suffix: "x y z".split(" "),
							w: 2, h: 1,
							horizontal: true,
						},
					},
					{
						prefix: "mirror",
						gap: 0,
						first: {
							suffix: "x y z".split(" "),
							w: 2, h: 1,
							horizontal: true,
						},
					},
					{
						prefix: "switch",
						first: {
							suffix: " no_export".split(" "),
							w: 6, h: 3,
						},
						heading: 2,
					},
					{
						prefix: "px",
						actions: [
							["column", "paste replace".split(" "), "d", 6, 2],
							["column", AAX.valid.px_export, "d", 6, 1],
							["column", "one_view vertical".split(" "), "d", 6, 1]
						],
						heading: 2,
					},
					{
						prefix: "posetool",
						previous: 0,
						direction: "d",
						first: {
							suffix: AAX.valid.posetools,
							w: 8, h: 1,
						},
					},
					{
						prefix: "rotate",
						actions: [
							["column", "round type curl".split(" "), "d", 6.5, 1],
							["expand", "display", "r", 4],
						],
					},
					{
						prefix: "rotate",
						gap: 0,
						actions: [
							["column", "invert", "d", 4.5, 1],
							["expand", "invert_x invert_y invert_z".split(" "), "d", 1, true],
							["expand", "switch", "d", 1],
							["expand", "switch_x_y switch_y_z switch_z_x".split(" "), "d", 2, true]
						],
						heading: false,
					},
					{
						prefix: "rotate",
						gap: 0,
						direction: "r",
						actions: [
							["column", AAX.valid.rotate_axis_setters, "d", 6, 1],
							["expand", "select_x select_y select_z".split(" "), "u", 1, true]
						],
						heading: false,
					},
					{
						prefix: "drawsettings",
						previous: -3,
						direction: "r",
						adjust: -2,
						first: {
							suffix: "grid standpoint range".split(" "),
							w: 12, h: 1,
						},
						actions: [
							["expand", "cell vp camera".split(" "), "d", 3, true],
							["expand", "fineness", "d", 1]
						],
					},
					temp,
					{
						prefix: "partinfo",
						//previous: -2,
						//direction: "d",
						previous: -4,
						direction: "d",
						gap: 3,
						first: {
							suffix: "name",
							w: 20,
							h: 1,
						},
						actions: [],
					},
					{
						prefix: "",
						previous: 0,
						direction: "u",
						gap: 1,
						first: {
							suffix: "save load".split(" "),
							w: 4, h: 2,
							horizontal: true,
						},
					},
					{
						prefix: "",
						direction: "u",
						gap: 0,
						first: {
							suffix: "title",
							w: Math.ceil(((AAX.ui.charwidth + 1)*("armature artist " + aa.version).length - 1 + 3)/AAX.ui.block), h: 1,
						},
						actions: [
							["expand", "projectname", "r", 1],
							["align", "projectname", "r"],
						],
					},
					{
						prefix: "anim",
						previous: -2,
						direction: "r",
						gap: 0,
						first: {
							suffix: "menu",
							w: 16, h: 1,
							horizontal: true,
						},
						actions: [
							["row", "blank duplicate delete".split(" "), "d", 6, 1],
							["align", "menu", "r"],
						],
					}
				];
				for(i1 = 0; i1 < areas.length; i1++) {
					let prefix = areas[i1].prefix;
					if(prefix && prefix !== "anim" && prefix !== "color") {
						areas[i1].heading ??= 1;
					}
				}
				// add heading
				temp = "zxcvbnm";
				for(i1 = 0; i1 < AAX.valid.posetools.length; i1++) {
					this.keymap[ temp[i1] ] ??= [];
					this.keymap[ temp[i1] ][0] = "posetool_" + AAX.valid.posetools[i1];
				};
				// pose tools keymap
				let array = [
					"part",
					"branch",
					"group",
					"body_minus_part",
					"body_minus_branch",
					"body_minus_group",
					"all",
					"body",
					"all_minus_body"
				];
				temp = areas.find((element) => element.prefix === "hide");
				temp.first.suffix = structuredClone(array);
				for(i1 = 0; i1 < array.length; i1++) {
					this.keymap[(i1 + 1).toString()] ??= [null];
					this.keymap[(i1 + 1).toString()][1] = "hide_" + array[i1];
					// add 1 so it doesn't start at 0
				}
				// hide keymap
				array = [];
				for(i1 in AAX.DrawSettings.template) {
					if(AAX.DrawSettings.template.hasOwnProperty(i1) && (typeof AAX.DrawSettings.template[i1] === "boolean" || AAX.valid.hasOwnProperty(i1))) {
						array[array.length] = i1;
					};
				}
				temp = areas.find((element) => element.prefix === "drawsettings");
				temp.actions[temp.actions.length] = ["column", array, "l", 7.5, 1];
				for(i1 = 0; i1 < array.length; i1++) {
					this.keymap[(i1 + 1).toString()] ??= [];
					this.keymap[(i1 + 1).toString()][0] = "drawsettings_" + array[i1];
				}
				// finish drawsettings
				array = [
					"colors",
					"coor",
					"perspective_coor",
					"shape",
					"image",
					"perspective_image",
					"shape_settings",
					"hide",
					"silhouette"
				];
				temp = areas.find((element) => element.prefix === "partinfo");
				for(i1 = 0; i1 < array.length; i1++) {
					let h = (
						array[i1] === "coor" ? 6 :
						array[i1] === "shape_settings" ? 2 :
						array[i1] === "silhouette" ? 3 :
						1
					);
					temp.actions.push(["expand", array[i1], "d", h]);
					// - relative coordinates title and numbers on
					//   two lines, absolute coordinates on two
					//   lines, and the current and original
					//   hypotenuse on two lines.
					// - connections need a line for the type, and a
					//   line for the value
					// - stretch and widen both get their own lines
				}
				// finish partinfo
				aa.ui.buttons = Rect.ui(areas);
				//
				let ref = aa.ui.buttons;
				for(i1 in ref) {
					if(ref.hasOwnProperty(i1)) {
						ref[i1].x *= AAX.ui.block;
						ref[i1].y *= AAX.ui.block;
						ref[i1].w *= AAX.ui.block;
						ref[i1].h *= AAX.ui.block;
					};
				}
			},
			keymap: {
			// property names are keys, the values are which button is supposed
			// to trigger.
			// - keys should be named the same as they are in KeyboardEvent.key,
			//   except single letters should be lowercase.
			// - if they're arrays:
			//   - 1: action when shift is held
			//   - 2: action when ctrl is held
			//   - 3: action when both are held
				w: ["posetool_prev", null],
				a: ["frame_prev", "view_prev"],
				s: ["posetool_next", null, "save"],
				d: ["frame_next", "view_next"],
				//
				q: ["switch", "switch_no_export"],
				e: "posetool_invert",
				//
				t: "select_parent",
				f: "select_prevsibling",
				g: "select_child",
				h: "select_nextsibling",
				//
				j: "frame_blank",
				i: "frame_duplicate",
				k: "frame_delete",
				o: "frame_move_up",
				l: "frame_move_down",
				//
				z: [null, null, "states_undo", "states_redo"],
				o: [null, null, "load"],
				//
				"\\": "misc_posescript",
			},
			// keys added automatically:
			// - the number keys are drawsettings toggles, and hide toggles when
			//   shift is held
			// - zxcvbnm is pose tools
			get buttons_w() {
				let loop = new Loop("aa.ui.buttons_w");
				let w = 0;
				let buttons = aa.ui.buttons;
				for(let i1 in buttons) {
					loop.tick(1);
					if(buttons.hasOwnProperty(i1)) {
						w = Math.max(w, buttons[i1].x + buttons[i1].w);
					}
				};
				loop.end();
				return w;
			},
			get buttons_h() {
				let loop = new Loop("aa.ui.buttons_h");
				let h = 0;
				let buttons = aa.ui.buttons;
				for(let i1 in buttons) {
					loop.tick(1);
					if(buttons.hasOwnProperty(i1)) {
						h = Math.max(h, buttons[i1].y + buttons[i1].h);
					}
				};
				loop.end();
				return h;
			},
			animtabwidth: 8,
			// measured in blocks
			draw: function(depress) {
			// draws the buttons. this needs to be run every time...
			// - the current part changes
			// - the oddness of the current part changes
			// - the selected posetool changes
			// =
			// - depress: argument for which button is currently being animated
			//   as having been pressed.
				let i1 = 0;
				let i2 = 0;
				let i3 = 0;
				let loop = new Loop("aa.ui.draw");
				loop.tick(1);
				loop.tick(2);
				loop.end();
				let w = aa.ui.buttons_w;
				let h = aa.ui.buttons_h;
				w++;
				h++;
				// add 1 so there's room for the bottom/right edges of buttons
				let buttons = aa.ui.buttons;
				let ctx = aa.ctx.ui;
				ctx.canvas.width = w;
				ctx.canvas.height = h;
				ctx.font = AAX.ui.font;
				ctx.textBaseline = "middle";
				// these get reset if the canvas dimensions change. fuck if i know
				// why. ask mozilla.
				let color = aa.color.buttons;
				//ctx.fillStyle = color[1];
				//ctx.fillRect(0, 0, w, h);
				ctx.clearRect(0, 0, w, h);
				const part = aa.control.part;
				const view = aa.control.view;
				const oddness = part.oddness;
				const image_oddness = AAX.image_oddness(aa.currpose, part.name, view);
				let relcoor = part.relcoor;
				const margin = AAX.ui.margin;
				const lineheight = AAX.ui.lineheight;
				const charwidth = AAX.ui.charwidth;
				let text_x = (button, align, text) => Math.floor(button.x + (
					align === "center" ? button.w/2 :
					align === "right" ? button.w - margin[0] :
					margin[0]
				)) + (align === "center" && !((text.length*(AAX.ui.charwidth + 1) - 1)%2) ? .5 : 0);
				ctx.font = AAX.ui.font;
				ctx.textAlign = "left";
				ctx.textBaseline = "middle";
				for(i1 in buttons) {
					loop.tick(1);
					if(buttons.hasOwnProperty(i1)) {
						let prefix = PreSuf.get(i1);
						let suffix = prefix[1];
						prefix = prefix[0];
						//let prefix = i1.includes("_") ? i1.slice(0, i1.indexOf("_")) : i1;
						//let suffix = i1.slice(prefix.length + 1);
						let text = (
							suffix === "heading" ? (
								prefix === "posetool" ? "pose tools" :
								prefix === "hide" ? "hide/show" :
								prefix === "switch" ? "part artist".split(" ") :
								prefix === "px" ? ["pixel art", "transfer"] :
								prefix === "frame" ? "frames" :
								prefix === "partinfo" ? "part information" :
								prefix === "drawsettings" ? "draw settings" :
								prefix === "rotate" ? "rotate settings" :
								prefix
							) :
							prefix === "misc" ? (
								suffix === "autoperspective" ? "automate perspective coordinates".split(" ") :
								suffix === "clearimage" ? "clear image".split(" ") :
								suffix === "editshape" ? "edit shape".split(" ") :
								suffix === "stretch_widen" ? "stretch /widen".split(" ") :
								suffix === "refreshshape" ? "refresh shape".split(" ") :
								suffix === "reset_part" || suffix === "reset_branch" ? suffix.split("_") :
								suffix === "posetoshape" ? ["pose to shape"] :
								null
							) :
							(prefix === "hide" && suffix.includes("_minus_")) ? suffix.replaceAll("_minus_", "-") :
							i1 === "switch" ? " switch ".split(" ") :
							i1 === "switch_no_export" ? "switch without export".split(" ") :
							/*
							prefix === "drawsettings" ? (
								suffix === "background" ? aa.drawsettings[suffix] :
								suffix === "cell" ? "cell w: h:".split(" ") :
								(suffix === "grid" || suffix === "standpoint" || suffix === "range" || suffix === "fineness") ? suffix + ":" :
								suffix === "vp" ? "vp x: y:".split(" ") :
								suffix === "camera" ? "camera xz: yz:".split(" ") :
								null
							) :
							//*/
							i1 === "title" ? ("armature artist " + aa.version) :
							i1 === "projectname" ? aa.control.projectname :
							i1 === "states_limit" ? "limit: truncator:".split(" ") :
							prefix === "rotate" ? (
								suffix === "round" ? suffix + ":" :
								suffix === "type" ? aa.control[prefix][suffix] :
								suffix === "display" ? "" :
								suffix.startsWith("switch_") ? suffix.slice("switch_".length).split("_") :
								(suffix.startsWith("invert_") || suffix.startsWith("select_")) ? suffix.slice(suffix.indexOf("_") + 1) :
								null
							) :
							null
						);
						text ??= (!suffix ? prefix : suffix).replaceAll("_", " ");
						let right_text = (
							/*
							prefix === "drawsettings" ? (
								suffix === "cell" ? ["", aa.drawsettings.cell.w, aa.drawsettings.cell.h] :
								suffix === "grid" ? aa.drawsettings.grid.join(",") :
								suffix === "standpoint" ? [
									(aa.drawsettings.standpoint.x - aa.drawsettings.cell.w/2),
									(aa.drawsettings.standpoint.y - aa.drawsettings.cell.h/2)
								].join(", ") :
								suffix === "vp" ? [
									"",
									(aa.drawsettings.vp.x - aa.drawsettings.standpoint.x),
									(aa.drawsettings.vp.y - aa.drawsettings.standpoint.y)
								] :
								suffix === "range" ? aa.drawsettings.range :
								suffix === "camera" ? [
									"",
									Math.round(Angle.convert(aa.drawsettings.camera.xz)),
									Math.round(Angle.convert(aa.drawsettings.camera.yz))
								] :
								suffix === "fineness" ? aa.drawsettings[suffix] :
								null
							) :
							//*/
							i1 === "states_limit" ? [aa.states_limit, aa.states_truncator] :
							i1 === "rotate_round" ? aa.control.rotate.round :
							null
						);
						right_text ??= "";
						if(prefix === "inbetween") {
							let ref = aa.control.inbetween;
							text = (
								suffix === "heading" ? "inbetweens" :
								suffix === "add" ? "+" :
								suffix === "subtract" ? "-" :
								suffix === "number" ? ref.number :
								suffix === "curve" ? "^" + roundspecial(Math.abs(ref.curve), -5) :
								suffix === "easeA" || suffix === "easeB" ? (
									suffix === "easeB" && ref.easeA === ref.easeB ? "" :
									ref[suffix] ? "out" : "in"
								) :
								suffix === "create" ? "create inbetweens".split(" ") :
								suffix === "apply" ? "apply tweening".split(" ") :
								""
							);
							if(!text && suffix !== "visual" && suffix !== "easeB") {
								console.log("this shouldn't happen");
							}
						}
						if(Array.isArray(text)) {
							for(i2 = 0; i2 < text.length; i2++) {
								text[i2] += "";
							}
						}
						else {
							text += "";
						};
						// make sure it isn't a number, so it can use .length
						let checkbox = (
							prefix === "px" ? (suffix === "one_view" || suffix === "vertical") :
							prefix === "rotate" ? suffix === "curl" :
							false
						);
						let radio = (
							prefix === "px" ? AAX.valid.px_export.includes(suffix) :
							false
						);
						let heading = (
							suffix === "heading"
							||
							(prefix === "rotate" && (suffix === "invert" || suffix === "switch"))
							||
							checkbox || radio
						);
						let selected = Number(
							(prefix === "posetool" && suffix === aa.control.posetool)
							||
							(prefix === "oddify" && (
									aa.control.perspectived
									?
									["x", "y"].includes(suffix) && image_oddness["xy".indexOf(suffix)]
									:
									["x", "y", "z"].includes(suffix) && oddness["xyz".indexOf(suffix)]
								)
							)
							||
							(prefix === "view" && aa.control.view === Number(suffix))
							||
							(
								prefix === "drawsettings"
								&&
								aa.drawsettings.hasOwnProperty(suffix)
								&&
								typeof aa.drawsettings[suffix] === "boolean"
								&&
								aa.drawsettings[suffix]
							)
							||
							(prefix === "hide" && suffix !== "heading" && aa.ishidden(aa.control.partname, suffix))
							||
							(
								prefix === "inbetween"
								&&
								(suffix === "easeA" || suffix === "easeB")
								&&
								aa.control.inbetween[suffix]
							)
							||
							(prefix === "rotate" && (
								suffix === "curl" ? aa.control.rotate.curl :
								suffix.startsWith("select_") && suffix.slice("select_".length) === "xyz"[aa.control.rotate.select]
							))
							||
							(prefix === "px" && (
								checkbox ? aa.animator.html[suffix].checked :
								radio ? suffix === aa.control.px_export :
								false
							))
							//||
							//i1 === "projectname"
						);
						if(prefix === "drawsettings" && AAX.valid.hasOwnProperty(suffix)) {
							selected = AAX.valid[suffix].indexOf(aa.drawsettings[suffix]);
						}
						else if(heading) {
						}
						else if(
							(prefix === "posetool" && selected && aa.control.posetool_inversion)
							||
							(aa.control.perspectived && prefix === "oddify" && suffix === "z")
							// 2 in this instance means "not applicable"
							||
							(prefix === "hide" && aa.hidelist(aa.control.partname, suffix).length === 0)
							//||
							//(prefix === "inbetween" && suffix === "easeB" && aa.control.inbetween.easeA === aa.control.inbetween.easeB)
							||
							i1 === "title"
							||
							(
								prefix === "rotate" && aa.control.rotate.type !== "custom"
								&&
								!heading
								&&
								suffix !== "type"
								&&
								suffix !== "round"
								&&
								suffix !== "curl"
								&&
								suffix !== "display"
							)
							||
							(
								prefix === "rotate"
								&&
								AAX.valid.rotate_axis_setters.includes(suffix)
								&&
								AAX.ui.rotate_axis_setter_disabled(aa.currpose, part.name, aa.control.rotate.basis, aa.control.rotate.select, suffix)
							)
						) {
							selected = 2;
						}
						else if(i1 === "rotate_type") {
							selected = AAX.valid[i1].indexOf(aa.control[prefix][suffix]);
						}
						if(depress && i1 === depress) {
							selected = posmod(selected + 1, 3);
						};
						let rect = structuredClone(buttons[i1]);
						let center = [Math.floor(rect.x + rect.w/2) + .5, Math.floor(rect.y + rect.h/2)];
						ctx.strokeStyle = color[ posmod(- selected, color.length) ];
						ctx.fillStyle = color[ posmod(1 - selected, color.length) ];
						if(prefix !== "color" && !heading && i1 !== "anim_menu") {
							ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
							Rect.fauxstroke(rect, ctx);
						};
						//console.log([prefix, suffix]);
						let align = (
							(Array.isArray(text) && prefix !== "drawsettings" && prefix !== "states")
							||
							(heading && prefix !== "partinfo")
							||
							(prefix === "states" && (suffix === "undo" || suffix === "redo"))
							||
							["view", "save", "load"].includes(prefix)
							||
							(prefix === "inbetween" && (suffix === "add" || suffix === "subtract" || suffix === "number"))
							||
							(prefix === "rotate" && (suffix.startsWith("select") || suffix.startsWith("invert") || suffix.startsWith("switch") || suffix === "type"))
							||
							prefix === "px"
							||
							prefix === "misc"
						);
						align = align ? "center" : "left";
						if(prefix === "partinfo" && !heading) {
							ctx.fillStyle = ctx.strokeStyle;
							const nondefault = "!";
							// character to use for these
							// - everything gets an space before it if it's
							//   "default", or an exclamation point if it isn't.
							let _default = aa.partinfo_is_default(part, view, suffix);
							const digits = 5;
							function convertnumber(num, addsign) {
								let text = "" + num;
								if(addsign && Math.sign(num) === 1) {
									text = "+" + text;
								};
								text += ".0".repeat(!text.includes("."));
								let index = text.indexOf(".");
								if(index > digits) {
									text = text.slice(index - digits);
								}
								else if(index < digits) {
									text = " ".repeat(digits - index) + text;
								};
								return text;
							};
							// numbers always have .0 or .5, and if the left
							// digits plus sign are longer than 5, they get
							// cut off. spaces are added if it's shorter, so
							// it's always the same length.
							if(suffix === "coor") {
								text = [
									(_default ? " " : nondefault) + "relative coordinates",
									null,
									" absolute coordinates",
									null,
									" hypotenuse:",
									" default:"
								];
								let relcoor = part.relcoor;
								let abscoor = part.abscoor;
								for(i2 = 0; i2 < 3; i2++) {
									loop.tick(2);
									relcoor[i2] = convertnumber(relcoor[i2], true);
									abscoor[i2] = convertnumber(abscoor[i2], false);
								}
								loop.end();
								text[1] = relcoor.join(" ");
								text[3] = abscoor.join(" ");
								for(i2 = 0; i2 < text.length; i2++) {
									loop.tick(2);
									ctx.textAlign = ([1, 3].includes(i2) ? "center" : "left");
									const x = (ctx.textAlign === "center" ? center[0] : rect.x + margin[0]);
									const y = Math.floor(rect.y + rect.h*(i2 + .5)/text.length + margin[1]);
									ctx.fillText(text[i2], x, y);
									if([4, 5].includes(i2)) {
										ctx.textAlign = "right";
										let string = "" + (i2 === 4 ? Math.hypot(...part.relcoor) : AAX.hypot(part.body, part.pose, part.name));
										if(!string.includes(".")) {
											string += " ".repeat(1 + 2);
										}
										else {
											let num = string.length - (string.indexOf(".") + 1);
											// number of decimal places
											num = 2 - num;
											// -1 is one too many, +1 is one too
											// few
											if(num > 0) {
												string += " ".repeat(num);
											}
											else if(num < 0) {
												string = string.slice(0, num);
											};
										}
										ctx.fillText(
											string,
											rect.x + rect.w - margin[0],
											y
										);
									};
								};
								loop.end();
								ctx.textAlign = "left";
							}
							else if(suffix === "silhouette") {
								let sil = part[suffix];
								for(i2 = 0; i2 < 3; i2++) {
									let _text = (
										i2 === 0 ? ["silhouette: group " + sil.group + sil.subgroup] :
										i2 === 1 ? ["ancestors: " + sil.anc, "descendants: " + sil.desc] :
										i2 === 2 ? [(sil.core ? ("core: " + sil.core) : ""), (sil.bone ? ("bone: " + sil.bone) : ""), (sil.concave ? "concave" : "")] :
										[]
									);
									let y = Math.floor(rect.y + rect.h*(i2 + .5)/3 + margin[1]);
									for(i3 = 0; i3 < _text.length; i3++) {
										let x = margin[0] + charwidth + 1;
										x += Math.floor((rect.w - x)*i3/_text.length);
										let line = _text[i3];
										if(!i2 && !i3) {
											line = (_default ? " " : nondefault) + line;
											x -= charwidth + 1;
										};
										ctx.fillText(line, x, y);
									}
								}
							}
							else if(suffix === "shape_settings") {
							// two lines, and a circle on the right showing the
							// orient.
								text = [
									(_default ? " " : nondefault) + "stretch:",
									" widen:"
								];
								let r = Math.floor((Math.min(rect.w, rect.h) - margin[0])/2);
								let x = rect.x + rect.w - (r + margin[0]);
								let y = Math.floor(rect.y + rect.h/2);
					            if(part.orient.flip) {
					            // draw a tiny x under the axes if it's
					            // flipped.
					                ctx.strokeStyle = aa.color.buttons[2];
					                linespecial(ctx, x - 2, y - 2, x + 2, y + 2);
					                linespecial(ctx, x + 2, y - 2, x - 2, y + 2);
					            };
								AAX.ui.basis(ctx, x, y, r, Quat.basis(part.orient));
								// draw orient sphere
								ctx.textAlign = "right";
								for(i2 = 0; i2 < 2; i2++) {
									loop.tick(2);
									ctx.fillText(
										convertnumber(part[i2 ? "widen" : "stretch"]),
										rect.x + rect.w - 2*(r + margin[0]),
										// make room for the orient sphere
										Math.floor(rect.y + rect.h*(i2 + .5)/2 + margin[1])
									);
								}
								loop.end();
								ctx.textAlign = "left";
								for(i2 = 0; i2 < text.length; i2++) {
									loop.tick(2);
									ctx.fillText(
										text[i2],
										rect.x + margin[0],
										Math.floor(rect.y + rect.h*(i2 + .5)/text.length + margin[1])
									);
								};
								loop.end();
							}
							else {
							// properties that aren't too complex for a simple
							// text + ":" + value structure...
								let value = null;
								if(suffix === "name") {
									text = part[suffix];
									value = "";
								}
								else if(suffix === "colors") {
									value = [part.bodyref.color1, part.bodyref.color2].join(", ");
								}
								else if(suffix === "image") {
									let temp = [
										(_default ? part.bodyref.image.front : part._image.front) !== null,
										(_default ? part.bodyref.image.right : part._image.right) !== null,
									]
									value = (
										temp[0]
										?
										// front exists
										(temp[1] ? "both" : "front")
										:
										// right exists
										(temp[1] ? "right" : "none")
									);
								}
								else if(suffix === "perspective_coor") {
									value = part["perspective_coor_" + view].join(", ");
									if((_default ? part.bodyref.perspective.coor[view] : part._perspective.coor[view]) === "auto") {
										value = "(auto) " + value;
									};
								}
								else if(suffix === "perspective_image") {
									text += " " + view;
									value = (
										(_default ? part.bodyref.perspective[view] : part._perspective[view]) === null
										?
										"absent"
										:
										""
									);
								}
								else if(suffix === "hide") {
									value = part[suffix] ? "on" : "off";
								}
								else if(suffix === "shape") {
									value = "";
								}
								else {
									console.log("there are partinfo properties the logic doesn't account for. (" + suffix + ")");
								};
								if(!["name", "shape", "perspective_image"].includes(suffix) || (suffix === "perspective_image" && value)) {
									text += ":";
								};
								// coor, connection: special code
								// name
								// - omit suffix + ":"
								// - center the value
								// colors
								// - needs to use integer colors, which requires bodyref
								// - needs to be be joined with a space
								// image
								// - no value
								// - no colon
								// perspective coor
								// - need to add the view number
								// - need to check if it's auto
								// perspective image
								// - no value unless it's null
								// - no colon unless it's null
								ctx.fillText((_default ? " " : nondefault) + text, rect.x + margin[0], center[1] + margin[1]);
								ctx.textAlign = "right";
								ctx.fillText(value, rect.x + rect.w - margin[0], center[1] + margin[1]);
								ctx.textAlign = "left";
							};
						}
						else if(prefix === "frame" && ["prev", "next"].includes(suffix)) {
							const w = (suffix === "prev" ? -1 : 1)*rect.w/2;
							const h = rect.h*1/2;
							const points = [
								[
									center[0] - w/2,
									center[1] - h/2,
								],
								[
									center[0] + w/2,
									center[1],
								],
								[
									center[0] - w/2,
									center[1] + h/2,
								]
							];
							_2dPoly.linespecial(ctx, points, center);
						}
						else if(prefix === "frame" && suffix === "display") {
							linespecial(ctx,
								center[0] - rect.w*3/8,
								center[1],
								center[0] + rect.w*3/8,
								center[1],
							center);
							ctx.fillStyle = ctx.strokeStyle;
							const coor = [
								center[0] - 1,
								Math.floor(rect.y + rect.h/4 + margin[1])
							];
							ctx.fillText(aa.currframe + 1, ...coor);
							coor[1] = Math.floor(coor[1] + rect.h/2);
							ctx.fillText(aa.frames.length, ...coor);
						}
						else if(prefix === "drawsettings" && !heading) {
							AAX.ui.draw.drawsettings(ctx, rect, aa.drawsettings, suffix);
						}
						else if(prefix === "color" && !heading) {
							AAX.ui.draw.color(ctx, rect, aa.color, suffix);
						}
						else if(!heading && ["oddify", "mirror", "image"].includes(prefix)) {
							ctx.fillStyle = ctx.strokeStyle;
							ctx.textAlign = "center";
							ctx.fillText(suffix, center[0], center[1] + margin[1]);
							ctx.textAlign = "left";
						}
						else if(prefix === "inbetween" && suffix === "visual") {
							let start = rect.x + rect.h/2;
							let end = rect.x + rect.w - rect.h/2;
							ctx.strokeStyle = color[2];
							linespecial(ctx, start, center[1], end, center[1], center);
							for(i2 = 0; i2 <= 1; i2 += 1/4) {
								let x = start + i2*(end - start);
								let tick = i2 === 0 || i2 === 1 ? 3 : i2 === .5 ? 2 : 1;
								linespecial(ctx, x, center[1] - tick, x, center[1] + tick, center);
							}
							ctx.fillStyle = color[0];
							let ref = aa.control.inbetween;
							let values = aa.inbetweenvalues(ref.number, ref.curve, ref.easeA, ref.easeB);
							circledraw(ctx, start + .5, center[1] + .5, 2.5, true);
							for(i2 = -1; i2 <= values.length; i2++) {
								circledraw(ctx, start + values[i2]*(end - start) + .5, center[1] + .5, 2.5, true);
							}
							circledraw(ctx, end + .5, center[1] + .5, 2.5, true);
						}
						else if(i1 === "title") {
							ctx.fillStyle = color[0];
							for(i2 = -1; i2 <= 1; i2++) {
								for(i3 = -1; i3 <= 1; i3++) {
									ctx.fillText(text, rect.x + margin[0] + i2, center[1] + margin[1] + i3);
								}
							}
							ctx.fillStyle = color[1];
							ctx.fillText(text, rect.x + margin[0], center[1] + margin[1]);
						}
						else if(prefix === "anim" && suffix === "menu") {
							ctx.fillStyle = color[2];
							ctx.fillRect(rect.x, rect.y + Math.floor(rect.h/2), rect.w, 1);
							let tabwidth = Math.min(aa.ui.animtabwidth*AAX.ui.block, rect.w/aa.anims.length);
							let divides = [];
							for(i2 = 0; i2 <= aa.anims.length; i2++) {
								divides[i2] = Math.floor(i2*tabwidth);
							}
							for(i2 = 0; i2 <= aa.anims.length; i2++) {
								if(i2 !== aa.anim_index) {
									let index = i2 === aa.anims.length ? aa.anim_index : i2;
									// make sure the selected tab is drawn last
									let _rect = [rect.x + divides[index], rect.y, divides[index + 1] - divides[index], rect.h];
									let style = i2 === aa.anims.length ? 2 : 0;
									style = [
										color[posmod(style + 0, 3)],
										color[posmod(style + 2, 3)]
									];
									ctx.fillStyle = style[0];
									ctx.strokeStyle = style[1];
									ctx.fillRect(..._rect);
									Rect.fauxstroke(Rect.new(..._rect), ctx);
									let name = aa.getanimname(index);
									let width = margin[0] + (charwidth + 1)*name.length;
									// how wide the tab has to be to fit the
									// name
									let ellipses = false;
									// whether to draw an ellipses after it
									if(width > tabwidth) {
										if(margin[0] + 6 > tabwidth) {
										// even an ellipse wouldn't fit, just
										// make it blank.
											name = "";
										}
										else {
										// cut it off with an ellipses
											name = name.slice(0, Math.floor((tabwidth - (margin[0] + 6))/(charwidth + 1)));
											width = margin[0] + (charwidth + 1)*name.length;
											ellipses = true;
										}
									}
									ctx.fillStyle = style[1];
									ctx.fillText(name, rect.x + divides[index] + margin[0], center[1] + margin[1]);
									if(ellipses) {
										for(i3 = 0; i3 < 3; i3++) {
											ctx.fillRect(rect.x + divides[index] + width + 2*i3, center[1] + 0*margin[1], 1, 1);
											// adding margin would put it right
											// at the level of a normal period
											// but i like it better in the
											// middle. i think dragon quest 3
											// drew them like that, and it makes
											// it look less like text.
										}
									}
								}
							}
						}
						else if(prefix === "rotate" && suffix === "display") {
							let basis = aa.control.rotate.type;
							if(basis === "local") {
								basis = Quat.basis(part.orient);
								if(part.mirror) {
									basis[0] = Points.invert(basis[0]);
								};
							}
							else {
								basis = basis === "custom" ? aa.control.rotate.basis : Basis.new();
							};
							AAX.ui.basis(
								ctx,
								Math.floor(rect.x + rect.w/2), Math.floor(rect.y + rect.h/2),
								Math.min(rect.w, rect.h)/2 - 2,
								basis
							);
						}
						else {
							if(checkbox || radio) {
								AAX.ui.checkbox(ctx, color, rect.x, rect.y, checkbox ? !!selected : selected ? "radio on" : "radio off");
								ctx.strokeStyle = color[0];
								rect.x += AAX.ui.block;
								rect.w -= AAX.ui.block;
								align = "left";
							}
							ctx.fillStyle = ctx.strokeStyle;
							ctx.textAlign = align;
							if(Array.isArray(text)) {
								const start_y = Math.floor(center[1] - lineheight*(text.length - 1)/2 + margin[1]);
								for(i2 = 0; i2 < text.length; i2++) {
									const start_x = text_x(rect, align, text[i2]);
									const right_edge = text_x(rect, "right", right_text[i2]);
									loop.tick(2);
									const coor = [
										start_x,
										start_y + i2*lineheight
									];
									ctx.fillText(
										text[i2],
										...coor
									);
									if(right_text || right_text === 0) {
										ctx.textAlign = "right";
										ctx.fillText(
											right_text[i2],
											right_edge,
											coor[1]
										);
										ctx.textAlign = align;
									};
								};
								loop.end();
							}
							else {
								ctx.fillText(text, text_x(rect, align, text), center[1] + margin[1]);
								if(right_text || right_text === 0) {
									ctx.textAlign = "right";
									ctx.fillText(
										right_text,
										text_x(rect, "right", right_text),
										center[1] + margin[1]
									);
								};
							};
							ctx.textAlign = "left";
						};
					}
				};
				loop.end();
			},
			action: function(button, shift, ctrl, click) {
			// do whatever action the indicated button name does. can run both
			// from clicks or keys.
			// - shift: indicates that the shift key was held, or the click was
			//   a doubleclick.
			// - ctrl: indicates that ctrl was held. not sure if i'll use this
			//   though.
			// - click: coordinates of the click. (relative to the canvas, not
			//   the button.)
				let i1 = 0;
				let i2 = 0;
				let i3 = 0;
				let prefix = PreSuf.get(button);
				let suffix = prefix[1];
				prefix = prefix[0];
				//let prefix = button.includes("_") ? button.slice(0, button.indexOf("_")) : button;
				//let suffix = button.slice(prefix.length + 1);
				let refresh = {};
				let loop = new Loop("aa.ui.action");
				for(i1 = 0; i1 < AAX.valid.refresh.length; i1++) {
					loop.tick(1);
					refresh[AAX.valid.refresh[i1]] = true;
				}
				loop.end();
				refresh.states = false;
				// an object of booleans for which refresh actions to perform.
				// by default, it's everything but states.
				// - switch, switch without export: skip draw and ui (unless the switch is
				//   happening in the part artist.)
				// - frame actions: don't skip states
				//   - previous/next
				//   - duplicate
				//   - delete
				//   - move up
				//   - move down
				//   =
				//   - move up/down could skip draw
				//   - previous/next could skip states
				// - view buttons, family selection keys, partinfo_name: skip draw
				// - pose tool switches (including up/down): skip draw (unless if the new
				//   tool or old tool is perspective.)
				// - oddify, mirror, other partinfo, automate perspective coordinates:
				//   don't skip states
				let no_refresh = (
					(prefix === "states" && (suffix === "undo" || suffix === "redo"))
					||
					["switch", "save", "load"].includes(prefix)
					||
					suffix === "heading"
					||
					["misc_editshape", "inbetween_visual", "title"].includes(button)
				);
				// switch means changing to the part artist, so a refresh
				// wouldn't be seen. (and the switch button over there runs
				// refresh, so you're fine.) undo/redo/save/load either don't
				// need a refresh or run it in their respective functions. and
				// headings and displays don't do anything.
				// - misc_editshape just opens a <dialog>, and the buttons in
				//   there are what cause edits.
				const part = aa.control.part;
				const view = aa.control.view;
				if(!aa.ui.buttons.hasOwnProperty(button)) {
				// it's not like these have to be separate, i just wanna group
				// all key-only actions in the same place.
					if(["prev", "next"].includes(suffix)) {
						let index = null;
						let remainder = null;
						if(prefix === "posetool") {
							index = AAX.valid.posetools.indexOf(aa.control.posetool);
							remainder = AAX.valid.posetools.length;
						}
						else if(prefix === "view") {
							index = aa.control.view;
							remainder = 4;
						};
						if(index === null || remainder === null) {
							console.log("this shouldn't happen, or there's button-only actions i forgot to write.");
						};
						if(suffix === "next") {
							index++;
						}
						else if(suffix === "prev") {
							index--;
						};
						index = posmod(index, remainder);
						if(prefix === "posetool") {
							refresh.draw = (aa.control.posetool === "perspective") !== (AAX.valid.posetools[index] === "perspective");
							aa.control.posetool = AAX.valid.posetools[index];
						}
						else if(prefix === "view") {
							aa.control.view = index;
							refresh.draw = false;
						}
						else {
							no_refresh = true;
						};
					}
					else if(prefix === "select") {
					// lets you select the parent of the current part, the first
					// child, or cycle through siblings.
						if(suffix === "parent") {
							if(part.parent !== "standpoint") {
								aa.control.partname = part.parent;
							};
						}
						else if(suffix === "child") {
							let array = AAX.getchildren(aa.currpose, part.name);
							if(array.length >= 1) {
								aa.control.partname = array[0];
							};
						}
						else {
							let array = AAX.getchildren(aa.currpose, part.parent);
							let index = array.indexOf(part.name);
							if(suffix === "prevsibling") {
								index--;
							}
							else if(suffix === "nextsibling") {
								index++;
							}
							else {
								console.log("this shouldn't happen");
								return;
							};
							aa.control.partname = array[posmod(index, array.length)];
						};
						refresh.draw = false;
					}
					else if(button === "posetool_invert") {
						aa.control.posetool_inversion = !aa.control.posetool_inversion;
						refresh.draw = false;
					}
					else {
						no_refresh = true;
						console.log("this shouldn't happen, or there's button-only actions i forgot to write.");
					};
				}
				else if(suffix === "heading") {
				}
				else if(prefix === "posetool") {
					refresh.draw = (aa.control.posetool === "perspective") !== (suffix === "perspective");
					if(aa.control.posetool === suffix) {
						aa.control.posetool_inversion = !aa.control.posetool_inversion;
					}
					else {
						aa.control.posetool = suffix;
					};
				}
				else if(button === "switch") {
					const ref = aa.pa.part;
					ref.color1 = part.color1;
					ref.color2 = part.color2;
					ref.fill = AAX.getfill(aa.color, aa.currpose, part.name);
					if(aa.control.perspectived) {
					// export only the image of the view you have selected.
						const right = !!(view%2);
						const _old_w = ref.dim(!right)[0];
						// width of the image not being replaced. (need to
						// remember it for changedimensions later.)
						let new_image = structuredClone(part["perspective_" + view]);
						let oddness = part.image_oddness(view);
						ref.size = Math.max(
							AAX.sq_raster.cropsize(ref[!right ? "right" : "front"], [ref.oddness[!right ? 2 : 0], ref.oddness[1]], true),
							// image not being replaced
							AAX.sq_raster.cropsize(new_image, oddness, true)
							// new image
						);
						// expand the size if it's too small for both images to
						// fit and rotate freely
						ref.oddness[right ? 2 : 0] = oddness[0];
						ref.oddness[1] = oddness[1];
						// apply changes to .oddness
						// - NOTE since oddness can be different per view,
						//   exporting multiple perspective views at once could
						//   cause dimensional inconsistencies.
						ref[right ? "right" : "front"] = Raster.redimension(
							new_image,
							//part.dim(view)[0],
							part.dim(view, new_image.length)[0],
							...ref.dim(right)
						);
						ref[!right ? "right" : "front"] = Raster.redimension(
							ref[!right ? "right" : "front"],
							_old_w,
							...ref.dim(!right)
						);
						// make sure both images conform to the new dimensions.
					}
					else {
					// export both unperspectiveds
						ref.front = part.image_front;
						ref.right = part.image_right;
						const old_w = [
							part.dim("front", ref.front.length)[0],
							part.dim("right", ref.right.length)[0]
						];
						ref.oddness = structuredClone(part.oddness);
						ref.size = Math.max(
							AAX.sq_raster.cropsize(ref.front, [ref.oddness[0], ref.oddness[1]], true),
							AAX.sq_raster.cropsize(ref.right, [ref.oddness[2], ref.oddness[1]], true)
						);
						ref.front = Raster.redimension(
							ref.front,
							old_w[0],
							...ref.dim(false)
						);
						ref.right = Raster.redimension(
							ref.right,
							old_w[1],
							...ref.dim(true)
						);
					};
					aa.pa.redraw();
					aa.editmodetoggle();
				}
				else if(button === "switch_no_export") {
					aa.editmodetoggle();
				}
				else if(prefix === "oddify") {
					let part = aa.control.part;
					let axis = suffix;
					if(aa.control.perspectived) {
						if(axis !== "z") {
							const view = aa.control.view;
							let temp = structuredClone(part["perspective_coor_" + view]);
							const index = "xy".indexOf(axis);
							temp[index] = Math.floor(temp[index]) + !(temp[index]%1)*.5;
							// change the oddness of that axis
							part["perspective_coor_" + view] = structuredClone(temp);
							// you have to set both at once, or the setter won't
							// run.
							refresh.states = true;
						};
					}
					else {
						let oddify = part.oddify(axis);
						// new relative coordinates.
						// - looks at the current relative coordinates, changes the
						//   oddness of the specified axis, and returns whatever
						//   relative coordinates are within 1 in each axis to how it
						//   was before, while still fitting in the hypotenuse.
						part.x = oddify[0];
						part.y = oddify[1];
						part.z = oddify[2];
						refresh.states = true;
					}
				}
				else if(prefix === "mirror") {
					refresh.states = true;
					aa.posescript_dry(null, "mirror", {axis: "xyz".indexOf(suffix)});
				}
				else if(prefix === "frame") {
					refresh.states = true;
					let success = (
						suffix === "display" ? aa.posescript_dry("frame", "jump", {input: prompt(`which frame do you want to switch to?`)}) :
						aa.posescript_dry("frame", suffix.replaceAll("_", " "))
					);
					if(success) {
						if(suffix === "prev" || suffix === "next" || suffix === "display") {
							refresh.states = false;
						}
						else if(suffix === "move_up" || suffix === "move_down") {
							refresh.draw = false;
						};
					}
					else {
						no_refresh = true;
					};
				}
				else if(prefix === "view") {
					aa.control.view = Number(suffix);
					refresh.draw = false;
				}
				else if(prefix === "misc") {
					if(suffix === "autoperspective") {
						let choice = prompt(`automate perspective for the part, frame, or all frames? (add "(one view)" to only do this for one view.)`);
						if(choice) {
							const one_view = choice.includes("(one view)");
							if(one_view) {
								choice = choice.replace("(one view)", "");
							};
							choice = choice.trim();
							function automate(frame, part, view) {
								if(one_view) {
									aa.frames[frame][part]._perspective.coor[aa.control.view] = "auto";
								}
								else {
									let loop = new Loop("aa.ui.action automate");
									for(let i1 = 0; i1 < 4; i1++) {
										loop.tick(1);
										aa.frames[frame][part]._perspective.coor[i1] = "auto";
									}
									loop.end();
								};
							};
							refresh.states = true;
							if(choice === "part") {
								automate(aa.currframe, aa.control.partname);
							}
							else if(["frame", "all frames"].includes(choice)) {
								for(i1 = 0; i1 < aa.frames.length; i1++) {
									loop.tick(1);
									if(choice === "all frames" || i1 === aa.currframe) {
										for(i2 in aa.currpose) {
											loop.tick(2);
											if(aa.currpose.hasOwnProperty(i2)) {
												automate(i1, i2);
											};
										}
										loop.end();
									};
								}
								loop.end();
							}
							else {
								alert(`invalid choice. it must be "part", "frame", or "all frames".`);
								refresh.states = false;
							};
						}
					}
					else if(suffix === "clearimage") {
						refresh.states = true;
						if(aa.control.perspectived) {
							part._perspective[view] = null;
						}
						else {
							part._image.front = null;
							part._image.right = null;
						};
					}
					else if(suffix === "editshape" || suffix === "posescript") {
						let textarea = document.getElementById("aa_" + suffix + "_input");
						if(suffix === "editshape") {
							textarea.value = AAX.Shape.string(part.shape);
						};
						textarea_autosize(textarea);
						document.getElementById("aa_" + suffix + "_dialog").showModal();
						setTimeout(function() {
							textarea.focus({focusVisible: true});
						}, 0);
						// i have no idea why it doesn't work without this.
					}
					else if(suffix === "stretch_widen") {
						refresh.states = true;
						let input = prompt([
							`enter two numbers for stretch/widen, separated by a comma.`,
							`stretch stretches the 3d shape along the line to the part's parent, widen expands it in the other directions.`,
							`enter a single number to set both at once.`,
							`enter a single number with a comma after to only change the stretch, and a number with a comma before to only change widen.`
						].join("\n\n"));
						let valid = input !== null;
						if(valid) {
							input = input.trim();
							if(input.includes(",")) {
								input = input.split(",");
								input = [
									readnumber(input[0]),
									readnumber(input[1])
								];
								if(input[0] === null && input[1] === null) {
									valid = false;
								}
								else {
									if(input[0] !== null) {
										part.stretch = input[0];
									};
									if(input[1] !== null) {
										part.widen = input[1];
									};
								};
							}
							else {
								input = readnumber(input);
								if(input === null) {
									valid = false;
								}
								else {
									part.stretch = input;
									part.widen = input;
								};
							};
						};
						if(!valid) {
							refresh.states = false;
						};
					}
					else if(suffix === "refreshshape") {
						part.clearcache("orientedshape");
						refresh.ui = false;
					}
					else if(suffix === "reset_part" || suffix === "reset_branch") {
						aa.posescript_dry(null, "reset", {desc: suffix === "reset_branch"});
						refresh.states = true;
					}
					else if(suffix === "posetoshape") {
						no_refresh = true;
						// all this does is open a <dialog> showing you shape
						// text.
						let scale = prompt("enter a scale factor for the shape. (it can be a fraction.)");
						if(typeof scale === "string") {
							scale = readnumber(scale) ?? 1;
							let shape = AAX.posetoshape(aa.currpose);
							if(scale !== 1) {
								for(i1 = 0; i1 < shape.points.length; i1++) {
									let group = shape.points[i1];
									for(i2 = 0; i2 < group.length; i2++) {
										for(i3 = 0; i3 < Math.min(group[i2].length, 6); i3++) {
											group[i2][i3] *= scale;
										}
									}
								}
							}
							document.getElementById("aa_posetoshape_text").value = AAX.Shape.string(shape);
							document.getElementById("aa_posetoshape_dialog").showModal();
						}
					};
				}
				else if(prefix === "partinfo" && suffix === "name") {
					let hidden = [];
					for(i1 in aa.currpose) {
						loop.tick(1);
						if(aa.currpose.hasOwnProperty(i1) && aa.currpose[i1].hide) {
							hidden[hidden.length] = i1;
						}
					}
					loop.end();
					let select = prompt("enter a part name to select." + (hidden.length ? " (hidden parts: " + hidden.join(", ") + ")" : ""));
					if(aa.currpose.hasOwnProperty(select)) {
						aa.control.partname = select;
						refresh.draw = false;
					}
					else if(select) {
						alert("invalid part name.");
					};
				}
				else if(prefix === "partinfo") {
					const part = aa.control.part;
					const view = aa.control.view;
					let temp = suffix.replaceAll("_", " ");
					if(temp.endsWith("coor")) {
						temp += "dinates";
					};
					if(!aa.partinfo_is_default(part, view, suffix) && confirm("reset " + temp + " to default?")) {
					// reset to default
						if(["hide", "shape"].includes(suffix)) {
							part[suffix] = "default";
						}
						else if(suffix === "coor") {
							part.x = "default";
							part.y = "default";
							part.z = "default";
						}
						else if(suffix === "image") {
							part[suffix + "_front"] = "default";
							part[suffix + "_right"] = "default";
						}
						else if(suffix === "perspective_coor") {
							part["perspective_coor_" + view] = "default";
						}
						else if(suffix === "perspective_image") {
							part["perspective_" + view] = "default";
						}
						else if(suffix === "shape_settings") {
							part.orient = structuredClone(part.bodyref.orient);
							part.stretch = 1;
							part.widen = 1;
						}
						else if(!["name", "colors", "silhouette"].includes(suffix)) {
							console.log("this button is unaccounted for in the ui.action partinfo logic.")
						};
						refresh.states = true;
					};
				}
				else if(prefix === "drawsettings") {
					no_refresh = AAX.ui.action.drawsettings(aa.drawsettings, suffix);
					if(!no_refresh && ["fineness", "vp", "range", "camera"].includes(suffix)) {
					// clear the cache
					// - fineness affects the shape, the rest affect
					//   perspective.
						let type = (
							suffix === "fineness"
							?
							"orientedshape"
							// clear .oriented and .rasterize
							:
							"rasterize perspective"
							// clear .rasterize, but only the perspective
							// views.
						);
						for(let i0 = 0; i0 <= aa.states.length; i0++) {
						// for every state,
							let ref = i0 === aa.states.length ? aa.frames : aa.states[i0].poseobjs;
							for(i1 = 0; i1 < ref.length; i1++) {
							// for every frame,
								for(i2 in ref[i1]) {
									if(ref[i1].hasOwnProperty(i2)) {
									// for every body part.
										AAX.clearcache(ref[i1], i2, type);
										// this isn't an AAX.Part, so we
										// can't use the method.
									}
								}
							}
						}
					};
				}
				else if(prefix === "color") {
					no_refresh = AAX.ui.action.color(aa.color, suffix, click, aa.ui.buttons[button]);
				}
				else if(prefix === "states") {
					if(suffix === "undo" || suffix === "redo") {
						// aa.undo();
						// aa.redo();
						aa[suffix]();
					}
					else if(suffix === "limit") {
						no_refresh = true;
						refresh.ui = true;
						let value = prompt([
							`enter new numbers for the states limit and the states truncator, separated by a comma.`,
							`the state limit is how many undo/redo states it can store before it starts deleting the oldest states. you can undo that many times before you hit a wall.`,
							`the state truncator is applied when you switch away from an animation. it trims the states so that this number is the maximum undos and maximum redos kept. (ex: if the truncator is 12, it'll keep a maximum of 12 past states and a maximum of 12 future states, so up to 25 states.)`,
							`if you're having performance issues, lowering these numbers might help. for every animation, there's states, and for every state, there's frames. if you had 3 animations, 8 frames each, and with a limit of 25 and a truncator of 12, that could be 600 poses it has to store.`
						].join(`\n\n`));
						if(value) {
							value = value.split(",");
							for(i1 = 0; i1 < 2; i1++) {
								if(i1 < value.length && value[i1].trim()) {
									let num = Number(value[i1]);
									if(Number.isInteger(num) && num >= Number(!i1)) {
									// needs to be 1 or more if it's the limit,
									// 0 or more if it's the truncator. (can't
									// let the number of states be less than 1.)
										aa["states_" + (i1 ? "truncator" : "limit")] = num;
										no_refresh = false;
									}
								}
							}
						}
					}
					else {
						console.log("this shouldn't happen");
					}
				}
				else if(prefix === "save" || prefix === "load") {
					// aa.save();
					// aa.load();
					aa[prefix]();
				}
				else if(prefix === "hide") {
					const value = !aa.ishidden(aa.control.partname, suffix);
					const array = aa.hidelist(aa.control.partname, suffix);
					for(i1 = 0; i1 < array.length; i1++) {
						loop.tick(1);
						aa.currpose[ array[i1] ].hide = value;
					};
					loop.end();
					refresh.states = true;
				}
				else if(prefix === "inbetween") {
					refresh.draw = false;
					// only create affects the pose, and nothing else affects
					// the visuals like drawsettings.
					let ref = aa.control.inbetween;
					if(suffix === "add") {
						ref.number++;
					}
					else if(suffix === "subtract") {
						if(ref.number >= 2) {
							ref.number--;
						}
						else {
							no_refresh = true;
						}
					}
					else if(suffix === "number") {
						let input = prompt(`enter how many inbetweens to make.`);
						if(input) {
							no_refresh = !aa.posescript_dry("tween", "number", {input});
							if(no_refresh) {
								alert(`invalid number. must be an integer greater than zero.`);
							};
						}
					}
					else if(suffix === "curve") {
						let input = prompt(`enter the curve factor. (2 is like square easing, 3 is like cubic, etc. look up stuff about easing. leaving it as the default value or writing "sine" makes it use the square root of 3, which is very close to a sine curve.)`);
						if(input) {
							no_refresh = !aa.posescript_dry("tween", "curve", {input});
							if(no_refresh) {
								alert(`invalid number.`);
							};
						}
					}
					else if(suffix === "easeA" || suffix === "easeB") {
						ref[suffix] = !ref[suffix];
						if(suffix === "easeA") {
						// this makes a weird sort of sense.
							ref.easeB = !ref.easeB;
						}
					}
					else if(suffix === "create" || suffix === "apply") {
						refresh.draw = true;
						refresh.states = true;
						no_refresh = !aa.posescript_dry("tween", suffix);
						if(no_refresh) {
							alert(`not counting the start and end frame, there's ` + (aa.frames.length - 2) + ` frames, but you're trying to apply tweening to ` + values.length + ` frames.`);
						};
					}
					else {
						no_refresh = true;
					};
				}
				else if(button === "projectname") {
					let name = prompt(`enter a name for the project.\n\nif you type an asterisk anywhere, it'll be replaced by the current date.`);
					if(name) {
						aa.control.projectname = name.replaceAll("*", filedate());
					}
					else {
						no_refresh = true;
					};
				}
				else if(prefix === "anim") {
					if(suffix === "menu") {
						let ref = aa.ui.buttons[button];
						let tabwidth = Math.min(aa.ui.animtabwidth*AAX.ui.block, ref.w/aa.anims.length);
						let index = Math.floor((click[0] - ref.x)/tabwidth);
						if(index === aa.anim_index) {
						// rename the animation
							let name = prompt(`enter a name for the animation.`);
							if(name === null) {
								no_refresh = true;
							}
							else {
								aa.curranim.name = name;
							};
						}
						else if(index >= 0 && index < aa.anims.length) {
							aa.anim_index = index;
						}
						else {
							no_refresh = true;
						};
					}
					else if(suffix === "blank") {
						aa.anims.splice(aa.anim_index + 1, 0, aa.newanim());
						aa.anim_index++;
					}
					else if(suffix === "duplicate") {
						aa.anims.splice(aa.anim_index + 1, 0, structuredClone(aa.curranim));
						let prevanim = aa.curranim;
						aa.anim_index++;
						aa.curranim.name = prevanim.name ? prevanim.name + " - copy" : "";
						// it's fine if names are shared.
						aa.curranim.states = [structuredClone(prevanim.states[prevanim.state_index])];
						aa.curranim.state_index = 0;
						// keep only the current state
					}
					else if(suffix === "delete") {
						if(aa.anims.length > 1 && confirm(`deleting animations cannot be undone/redone. are you sure?`)) {
							let old = aa.anim_index;
							let islast = old === aa.anims.length - 1;
							aa.anim_index = islast ? aa.anims.length - 2 : aa.anim_index + 1;
							// trigger the setter
							aa.anims.splice(old, 1);
							// delete the old animation
							if(old <= aa.anim_index) {
							// decrement the index, but be sneaky about it.
								aa._anim_index--;
							}
						}
						else {
							no_refresh = true;
						}
					}
				}
				else if(prefix === "rotate") {
					if(suffix === "invert" || suffix === "switch" || suffix === "display") {
					// headings/visuals
						no_refresh = true;
					}
					else if(suffix === "round") {
						let num = prompt("enter a new rounding factor for the rotate and tilt pose tools.\n\nif it's 72, angle magnitudes will be rounded to the nearest 360/72 degrees.\n\n0 will make it so there's no rounding at all.") ?? "";
						no_refresh = true;
						if(num) {
							num = Number(num);
							if(Number.isInteger(num) && num >= 0) {
								aa.control[prefix][suffix] = num;
								no_refresh = false;
							};
						};
					}
					else if(suffix === "type") {
						let array = AAX.valid[button];
						aa.control[prefix][suffix] = array[(array.indexOf(aa.control[prefix][suffix]) + 1)%array.length];
					}
					else if(suffix === "curl") {
						aa.control[prefix][suffix] = !aa.control[prefix][suffix];
					}
					else if(aa.control[prefix].type === "custom") {
						let basis = aa.control.rotate.basis;
						if(suffix.startsWith("select_")) {
							aa.control[prefix].select = "xyz".indexOf(suffix.slice("select_".length));
						}
						else if(suffix.startsWith("invert_")) {
							let axis = "xyz".indexOf(suffix.slice("invert_".length));
							aa.posescript_dry("rotate", "invert", {axis});
						}
						else if(suffix.startsWith("switch_")) {
							let temp = suffix.slice("switch_".length).split("_");
							let axis1 = "xyz".indexOf(temp[0]);
							let axis2 = "xyz".indexOf(temp[1]);
							aa.posescript_dry("rotate", "switch", {axis1, axis2});
						}
						else if(
							AAX.valid.rotate_axis_setters.includes(suffix)
							&&
							!AAX.ui.rotate_axis_setter_disabled(aa.currpose, part.name, basis, aa.control.rotate.select, suffix)
						) {
							let args = {axis: aa.control.rotate.select};
							if(suffix === "parent" || suffix === "child" || suffix === "local") {
								args.partname = part.name;
							}
							else if(suffix === "written") {
								args.input = prompt("enter a new axis. three coordinates, separated by commas or spaces. it'll use the angle that has, relative to (0, 0, 0).\n\ncurrent:\n\t" + basis[args.axis].join(",\n\t")) ?? "";
							};
							no_refresh = !aa.posescript_dry("rotate", suffix, args);
							if(no_refresh) {
								if(suffix !== "written") {
									console.log("this shouldn't happen");
								};
								no_refresh = true;
							}
							else {
								aa.control.rotate.select = posmod(aa.control.rotate.select + 1, 3);
							};
						};
					}
					else {
						no_refresh = true;
					}
				}
				else if(prefix === "px") {
					if(AAX.valid.px_export.includes(suffix)) {
						aa.control.px_export = suffix;
					}
					else if(suffix === "one_view" || suffix === "vertical") {
					// duplicates of the animator checkboxes.
						aa.animator.html[suffix].click();
					}
					else {
						changefocus("px");
						// switch first, to make sure it's initialized
						let type = aa.control.px_export;
						let replace = suffix === "replace";
						let ds = aa.drawsettings;
						let cell = ds.cell;
						let sheet = aa.animator.sheet_ctx;
						let images = [];
						// each item is an ImageData, representing an animation.
						let canvas = document.createElement("canvas");
						let ctx = canvas.getContext("2d");
						if(type === "frame") {
						// export the canvas
							let one = aa.animator.html.one_view.checked;
							if(one || aa.animator.html.vertical.checked) {
								images.push(aa.ctx.main.getImageData((one ? aa.control.view : 0)*cell.w, 0, (one ? 1 : 4)*cell.w, cell.h));
							}
							else {
							// line up the views vertically
								canvas.width = cell.w;
								canvas.height = 4*cell.h;
								for(i2 = 0; i2 < 4; i2++) {
									ctx.putImageData(
										aa.ctx.main.getImageData(i2*cell.w, 0, cell.w, cell.h),
										0, i2*cell.h
									);
								}
								images.push(ctx.getImageData(0, 0, cell.w, 4*cell.h));
							}
						}
						else if(type === "anim") {
						// update the animation sheet, and export that
							aa.updateanimation(true);
							images.push(sheet.getImageData(0, 0, sheet.canvas.width, sheet.canvas.height));
						}
						else if(type === "all_x" || type === "all_y") {
						// export every animation, with borders and names.
						// - the borders and names are drawn in whatever px'
						//   current forecolor is.
						// - the borders and names stay outside the frames
						// - the margins and the gaps between animations match
						//   whatever px.grid currently is. that way, there's
						//   clear separation between them, and if the user uses
						//   grid snap with the paste tool, the top left corners
						//   of the canvases will be placed right on the grid.
						//   - unless if the cell dimensions aren't divisible by
						//     the grid dimensions, but that's weird anyway.
						// - there's little gaps in the border that show the
						//   boundaries between views or frames.
							for(i1 = 0; i1 < aa.anims.length; i1++) {
								images.push(null);
							}
							let truncator = aa.states_truncator;
							aa.states_truncator = Infinity;
							// this should avoid truncating the current
							// animation's states.
							let anim_index = aa.anim_index;
							let posetool = aa.control._posetool;
				            for(i1 = 0; i1 < aa.anims.length; i1++) {
								let _i1 = posmod(anim_index + 1 + i1, aa.anims.length);
								// end with the animation it was at before. that
								// way there's no wasteful updateanimation
								// runnings.
								aa.anim_index = _i1;
								aa.control._posetool = posetool;
								// the anim_index setter loads the animation's
								// current state, which includes what pose tool
								// was selected. that sounds completely
								// unrelated, except, perspective.
								aa.updateanimation(true);
								images[_i1] = sheet.getImageData(0, 0, sheet.canvas.width, sheet.canvas.height);
							}
							aa.states_truncator = truncator;
						};
						// gather up the images
						const grid = 8;
						let dim = [0, 0];
						let axis1 = Number(type === "all_y");
						let axis2 = posmod(axis1 + 1, 2);
						for(i1 = 0; i1 < images.length; i1++) {
							let _dim = [images[i1].width, images[i1].height];
							_dim = [
								Math.ceil(_dim[0]/grid)*grid,
								Math.ceil(_dim[1]/grid)*grid
							];
							dim[axis1] += _dim[axis1];
							dim[axis2] = Math.max(dim[axis2], _dim[axis2]);
						};
						dim[axis1] += (1 + images.length)*grid;
						dim[axis2] += 2*grid;
						canvas.width = dim[0];
						canvas.height = dim[1];
						ctx.clearRect(0, 0, ...dim);
						if(replace) {
							ctx.fillStyle = px.backcolor;
							ctx.fillRect(0, 0, ...dim);
						}
						ctx.fillStyle = px.forecolor;
						ctx.textBaseline = "alphabetic";
						ctx.font = "16px 'barkyfont'";
						let pos = [grid, grid];
						let standpoint = aa.control.perspectived ? ds.perspectived_standpoint : ds.standpoint;
						for(i1 = 0; i1 < images.length; i1++) {
							let _dim = [images[i1].width, images[i1].height];
							let rect = Rect.new(...pos, ..._dim);
							_dim = [
								Math.ceil(_dim[0]/grid)*grid,
								Math.ceil(_dim[1]/grid)*grid
							];
							ctx.putImageData(images[i1], ...pos);
							for(i2 = rect.x; i2 + cell.w <= rect.x + rect.w; i2 += cell.w) {
								ctx.fillRect(i2 + 1, rect.y - 1, cell.w - 2, 1);
								ctx.fillRect(i2 + 1, rect.y + rect.h, cell.w - 2, 1);
								// draw top and bottom borders
								ctx.fillRect(i2 + standpoint.x, rect.y - 1 - 1, 1, 1);
								ctx.fillRect(i2 + standpoint.x, rect.y + rect.h + 1, 1, 1);
								// mark standpoint x
							}
							for(i2 = rect.y; i2 + cell.h <= rect.y + rect.h; i2 += cell.h) {
								ctx.fillRect(rect.x - 1, i2 + 1, 1, cell.h - 2);
								ctx.fillRect(rect.x + rect.w, i2 + 1, 1, cell.h - 2);
								// draw left and right borders
								ctx.fillRect(rect.x - 1 - 1, i2 + standpoint.y, 1, 1);
								ctx.fillRect(rect.x + rect.w + 1, i2 + standpoint.y, 1, 1);
								// mark standpoint y
							}
							if(type.startsWith("all") && aa.anims[i1].name) {
							// write the name
								ctx.fillText(aa.anims[i1].name, rect.x, rect.y - 2);
							}
							pos[axis1] += _dim[axis1] + grid;
						};
						// form it into a spritesheet
						px.transfer(ctx, replace);
						if(replace) {
							px.select = Rect.new(grid, grid, cell.w, cell.h);
						};
						px.html.anim_fps.value = aa.animator.fps;
						px.html.anim_duration.value = aa.animator.frames.length;
						px.html.anim_loop.checked = aa.animator.loop;
						px.html.anim_wrap.value = aa.animator.sheet.wrap.value;
						px.html.anim_vertical.checked = aa.animator.html.vertical.checked;
						no_refresh = true;
						// send it, edit px' select and animation settings to
						// match it
					}
				};
				let depress = (
					suffix === "heading" ? false :
					prefix === "states" ? (suffix === "undo" || suffix === "redo") :
					prefix === "px" ? !AAX.valid.px_export.includes(suffix) :
					no_refresh ? false :
					prefix === "switch" ? true :
					prefix === "frame" ? suffix !== "display" :
					prefix === "inbetween" ? (suffix === "add" || suffix === "subtract" || suffix === "create" || suffix === "apply") :
					(button === "save" || button === "load") ? true :
					prefix === "misc" ? (suffix !== "autoperspective" && suffix !== "stretch_widen") :
					prefix === "anim" ? (suffix === "blank" || suffix === "duplicate" || suffix === "delete") :
					prefix === "rotate" ? (
						(AAX.valid.rotate_axis_setters.includes(suffix) && suffix !== "written")
						||
						suffix.startsWith("invert_")
						||
						suffix.startsWith("switch_")
					) :
					prefix === "mirror" ? true :
					false
				);
				// boolean for whether to animate it being depressed.
				// - there aren't actually a lot of buttons worth depressing.
				//   most buttons are toggles, prompts, stuff like that.
				if(depress) {
				// it'll get redrawn for the depressing, so the other refresh
				// would just be redundant.
					refresh.ui = false;
				}
				let temp = [];
				for(i1 in refresh) {
					loop.tick(1);
					if(refresh.hasOwnProperty(i1) && !refresh[i1]) {
						temp[temp.length] = i1;
					}
				}
				loop.end();
				// now it's an array of what to skip.
				if(!no_refresh) {
					aa.refresh(temp);
				}
				if(depress) {
					aa.ui.draw(button);
					// draw the button depressed
					setTimeout(function() {aa.ui.draw()}, 1000*AAX.ui.depress);
					// draw it undepressed after a little bit.
				}
			},
			mousedown: function(e, doubleclick) {
			// searches the buttons for where your click was, and runs .action.
				let i1 = 0;
				let click = clickxy(e, "aa");
				aa.control.clicktype = "ui";
				let buttons = aa.ui.buttons;
				for(i1 in buttons) {
					if(buttons.hasOwnProperty(i1)) {
						let ref = buttons[i1];
						if(
							click[0] >= ref.x
							&&
							click[0] < ref.x + ref.w
							&&
							click[1] >= ref.y
							&&
							click[1] < ref.y + ref.h
						) {
							aa.ui.action(i1, doubleclick, false, click);
							aa.control.clicktype = null;
							return;
						};
					};
				}
				aa.control.clicktype = null;
			},
		},
		control: {
		// stores various data that changes based on what you're trying to do,
		// like which node you have selected and which posing tool you're using.
			view: 0,
			partname: "",
			// this CANNOT be left empty, everything in the interactivity and
			// part-editing buttons uses it. .initialize will set it.
			get part() {
				return aa.currpose[this.partname];
			},
			get node() {
				return aa.getnode(this.view, this.partname);
			},
			// don't use this too much, obviously. run it at the start of the
			// function, don't use it multiple times in one expression
			get perspectived() {
				return aa.control.posetool === "perspective";
			},
			// boolean for whether .draw should draw it perspectived or
			// unperspectived.
			// - a getter is easier to edit. i don't know when i might change
			//   the conditions of perspectived imaging.
			_posetool: "rotate",
			posetool_inversion: false,
			// a boolean for an alternate mode for each pose tool. selecting the
			// pose tool you already have selected toggles this, and switching
			// pose tools turns it off.
			// - it used to be a double-click, but those don't work on mobile.
			//   or maybe they do and it's just a pain in the ass.
			get posetool() {
				return this._posetool;
			},
			set posetool(value) {
				if(this._posetool === value) {
					this.posetool_inversion = false;
					return;
				};
				if(!AAX.valid.posetools.includes(value)) {
					console.log("this shouldn't happen");
					value = AAX.valid.posetools[0];
				};
				this._posetool = value;
				this.posetool_inversion = false;
			},
			moveaway: false,
			// boolean for if the third axis should be whatever sign moves
			// things away from the screen rather than towards it.
			partclicked: false,
			// boolean for whether the user's mousedown actually clicked a part
			// or not
			// - i can't just check if the node is null, because the last
			//   clicked node is stored between clicks so the buttons know what
			//   to edit.
			strokedata: null,
			// stores mid-stroke data, like the starting angle for rotate.
			clicktype: null,
			// used to tell if mouse events should trigger. (it's like a boolean
			// for whether they're in the middle of a click. except i have to
			// specify whether it's the main area or the ui, or ui clicks could
			// register for main and vice versa.)
			all_frames_posetext: false,
			// boolean for whether pose text input and output shows all frames.
			activeonly_cache: true,
			// boolean that makes it clear the part caches in an animation when
			// switching away from it.
			editmode: false,
			// boolean for whether the part artist should be visible instead of
			// the multiview.
			strokecache: null,
			// stores images for each part/view. this is filled at mousedown and
			// cleared at mouseup.
			// - this wouldn't actually be necessary if not for shapes.
			//   Part.rasterize is too slow to run every mousemove.
			// =
			// - [parts]
			//   - front, right (or 0-3 numbers if it's in perspective mode):
			//     images
			inbetween: {
				number: 3,
				curve: Math.sqrt(3),
				// a good approximation of a sine curve.
				easeA: false,
				easeB: false,
				// false means in, true means out.
			},
			projectname: "untitled",
			rotate: {
				round: 72,
				type: "true",
				curl: false,
				select: 0,
				basis: Basis.new(),
			},
			px_export: AAX.valid.px_export[0],
		},
		get oddify_deform() {
			return aa.control.posetool === "deform";
		},
		// used in AAX.oddify.
		nodes: [[], [], [], []],
		// screen positions and names of all the parts, divided up by view.
		// they're ordered by z, with the further parts being first.
		// - structure:
		//   - x, y, z: screen coordinates. x includes view offset, and x and y
		//     include perspective offset if the multiview was drawn in
		//     perspective.
		//   - name: part name string
		//   - parent: reference to the parent's node, or if it's standpoint,
		//     just a "standpoint" string.
		// - iterate in order when drawing parts using this, iterate backward
		//   when checking which node the user clicked.
		images: null,
		// an object of ImageDatas, which the interface uses to correct overflow
		// or reverse the changes it made.
		pasteimages: function(invert, view) {
		// - invert === false: paste the image for the specified view.
		//   (reverses changes.)
		// - invert === true: paste all images except the one for the specified
		//   view. (corrects overflow.)
			view ??= aa.control.view;
			const ctx = aa.ctx.main;
			const cell = aa.drawsettings.cell;
			let i1 = 0;
			let loop = new Loop("aa.pasteimages");
			for(i1 = 0; i1 < 4; i1++) {
				loop.tick(1);
				if(invertboolean(i1 === view, invert)) {
					ctx.putImageData(aa.images[i1], cell.w*i1, 0);
				};
			}
			loop.end();
		},
		sample_posescripts: {
			humanoid: {
				header:
`all: reset
rotate:
 local
 in/out = -xy(..l_manubrium, ..l_hip) +xy(..r_manubrium, ..r_hip)
 raise/lower = -yz(all) +yz(..l_manubrium, ..r_manubrium) except(.pelvis, .midsection, ..l_hip, ..r_hip) +yz(.l_ankle, .r_ankle)
 forward/back = +yz(.l_hip, .r_hip)
 open/close = +yz(.l_knee, .r_knee) +xy(.l_elbow) -xy(.r_elbow)
 pronate/supinate = -xz(.l_hand) +xz(.r_hand)
 twist-in/twist-out = +xz(.r_hip) -xz(.l_hip)
 bend/unbend = +yz(.l_toe, .r_toe)
 windup/pitch = +xz(.l_manubrium, .l_shoulder) -xz(.r_manubrium, .r_shoulder)
 tilt-l/tilt-r = -xy(.torso, ..neckbase)
 turn-l/turn-r = +xz(.torso, ..neckbase)
//
`,
				// this or the multi-frame header will be added to all other samples during
				// initialize
				"multi-frame header": ``,
				// this will be made from the standard header during initialize
				walk:
`.l_hip, .r_hip: 5 in
.l_hip: 15 forward
.l_knee: 50 close
//
frame: blank
.pelvis: +10 xz exc(l_knee, r_knee, neckbase)
.l_hip, .r_hip: tilt -10 xz
.l_hip, .r_hip: 5 in
//.l_hip: 5 in
.l_hip: 35 forward
.l_knee: 20 close
.l_ankle: 15 raise
.r_hip: 15 back
.r_knee: 25 close
.r_ankle: 10 lower
.pelvis: [0, 2, 0]
//
frame: blank
.l_hip, .r_hip: 5 in
.r_hip: 15 forward
.r_knee: 50 close
//
frame: blank
.pelvis: -10 xz exc(l_knee, r_knee, neckbase)
.l_hip, .r_hip: tilt +10 xz
.l_hip, .r_hip: 5 in
//.r_hip: 5 in
.r_hip: 35 forward
.r_knee: 20 close
.r_ankle: 15 raise
.l_hip: 15 back
.l_knee: 25 close
.l_ankle: 10 lower
.pelvis: [0, 2, 0]
//
frame: 1
tween: 1, create out, create in, create out, create in`,
			},
			hand: {
				header:
`all: reset
rotate:
 local
 point/bend = +yz(..thumb_2, ..index_1, ..middle_1, ..ring_1, ..pinkie_1) except(.thumb_4, .index_4, .middle_4, .ring_4, .pinkie_4)
 spread/narrow = -xy(.thumb_1, .index_1, .middle_1) +xy(.ring_1, .pinkie_1)
 forward/back = -xz(.thumb_1)
//
`,
				"multi-frame header": ``,
				// same deal
				hanging:
`.wrist: +10 yz
.index_1, .middle_1, .ring_1, .pinkie_1: 45 bend curl
.index_2, .middle_2, .ring_2, .pinkie_2: 15 bend curl
.index_2, .middle_2, .ring_2: 10 bend curl
.ring_1: 5 spread
.index_1: 5 point curl, 5 point
.thumb_1: 30 forward
.wrist: +5 yz, -90 xz, -10 xy//, +180 xy
//
// this pose was used to generate the default hand shape for humanoids, using pose to shape.`,
				"tense and narrow":
`.index_1, .ring_1: 5 narrow
.pinkie_1: 10 narrow
// narrow the fingers
.wrist: -15 yz
.index_1, .middle_1, .ring_1, .pinkie_1: 20 point
.index_2, .middle_2, .ring_2, .pinkie_2: 10 point curl
// curve the hand and fingers
.thumb_1: 20 back
.thumb_2: 15 point curl
// curve the thumb too`,
				"tense and spread":
`.index_1: 15 spread
.ring_1: 15 spread
.pinkie_1: 30 spread
// spread the fingers
.wrist: -15 yz
.index_1, .middle_1, .ring_1, .pinkie_1: 20 point
.index_2, .middle_2, .ring_2, .pinkie_2: 10 point curl
// curve the hand and fingers
.thumb_2: 40 point curl
.thumb_1: 15 spread
// curve the thumb too`,
				fist:
`.index_1, .middle_1, .ring_1, .pinkie_1: 100 bend
.index_2, .middle_2, .ring_2, .pinkie_2: 100 bend
.index_3: 80 bend
.middle_3: 100 bend
.ring_3: 90 bend
.pinkie_3: 90 bend
// curl fingers in
.thumb_1: 50 forward
.thumb_2: 45 bend
.thumb_3: 45 bend
// move the thumb over the fingers`,
				"horn sign":
`.middle_1, .ring_1: 100 bend
.middle_2, .ring_2: 100 bend
.middle_3: 30 bend
.ring_3: 30 bend
// curl fingers in
.thumb_1: 105 forward
.thumb_2: 15 bend
// move the thumb over the fingers
.index_2, .pinkie_2: 10 point curl
.index_1: 10 spread
.pinkie_1: 20 spread
// banana the index and pinkie backward a bit, and spread them (they can't angle backward as far when some of them are curling forward. the fingers can't spread as much, either.)`,
				"open thumb horn sign":
`.middle_1, .ring_1: 100 bend
.middle_2, .ring_2: 100 bend
.middle_3: 30 bend
.ring_3: 30 bend
// curl fingers in
.thumb_2: 40 point curl
.thumb_1: 15 spread
// point the thumb out, with some tension to it
.index_2, .pinkie_2: 10 point curl
.index_1: 10 spread
.pinkie_1: 20 spread
// banana the index and pinkie backward a bit, and spread them (they can't angle backward as far when some of them are curling forward. the fingers can't spread as much, either.)`,
			},
		},
		get noderadius() {
			return (aa.control.posetool === "select" || (aa.control.posetool === "perspective" && aa.control.posetool_inversion)) ? Infinity : AAX.noderadius;
		},
		nodecheck: function(click, view) {
			let node = null;
			let hypot = aa.noderadius + .5;
			for(let i1 = aa.nodes[view].length - 1; i1 >= 0; i1--) {
			// search backwards, so it finds the closer nodes first.
				let _node = aa.nodes[view][i1];
				let _hypot = Math.hypot(
					_node.x - click[0],
					_node.y - click[1]
				);
				if(_hypot < hypot && (!aa.currpose[_node.name].hide || !aa.drawsettings.total_hide)) {
				// if the part is hidden and total hide is on, don't allow the
				// node to be selected or clicked.
					node = _node;
					hypot = _hypot;
				};
			}
			return node;
		},
		getnode: (view, name) => AAX.getnode(aa.nodes, view, name),
		xz_radius: () => Math.floor((aa.drawsettings.cell.w - 2*AAX.noderadius)/4),
		// returns the radius used to calculate angle in inverted rotate mode.
		// (ie xz rotation)
		xz_angle: function(click, view) {
		// used in the xz rotate mode.
			const r = aa.xz_radius();
			let acos = (cos) => (
				false
				?
				Math.acos(cos)
				:
				(1 - cos)*Math.PI/2
			);
			// make it true, and it'll do the acos stuff. make it false, and
			// it'll be a linear relationship between x position and angle. the
			// former is harder to control in practice.
			if(r) {
				const center = aa.control.node.x;
				let cos = (click[0] - center)/r;
				// Math.cos of the angle.
				if(view === 1 || view === 2) {
					//cos *= -1;
				};
				// 4-3-2-1-0-1-2-3-4
				// d r u l d r u l d
				cos = posmod(cos + 1, 4) - 1;
				// 1-0-1-2-3
				// l d r u l
				if(cos >= 1) {
					cos = (cos - 1)*(-1) + 1;
					cos = 2*Math.PI - acos(cos);
				}
				else {
					cos = acos(cos);
				};
				return cos;
			}
			else {
				return 0;
				// always return the same angle, so that the relative angle is
				// always 0 too.
			}
		},
		mousedown: function(e) {
			let i1 = 0;
			let i2 = 0;
			let click = clickxy(e, "aa");
			const cell = aa.drawsettings.cell;
			const view = Math.floor(click[0]/cell.w);
			aa.control.view = view;
			let node = aa.nodecheck(click, view, aa.control.posetool === "select" ? Infinity : null);
			aa.control.partclicked = node !== null;
			if(aa.control.partclicked) {
				aa.control.partname = node.name;
			}
			else {
				node = aa.control.node;
			};
			if((aa.control.posetool === "tilt" || aa.control.posetool === "rotate") && !aa.control.partclicked) {
			// if it's rotate mode and they didn't click a part, save the angle.
			// (when you click a part, it acts like select mode. otherwise, it
			// rotates based on the start and end angle.)
				let angle = null;
				if(aa.control.posetool_inversion) {
					let r = aa.xz_radius();
					let center = node.x;
					const ctx = aa.ctx.main;
					ctx.strokeStyle = aa.color.interface[0];
					linespecial(
						ctx,
						center - r,
						0,
						center - r,
						ctx.canvas.height,
						[node.x, node.y]
					);
					linespecial(
						ctx,
						center + r,
						0,
						center + r,
						ctx.canvas.height,
						[node.x, node.y]
					);
					angle = aa.xz_angle(click, view);
				}
				else {
					angle = get2dangle(([2, 3].includes(view) ? -1 : 1)*(click[0] - node.x), click[1] - node.y, true) ?? 0;
				}
				aa.control.strokedata = angle;
			};
			aa.control.strokecache = {};
			for(i1 in aa.currpose) {
				if(aa.currpose.hasOwnProperty(i1)) {
					let _part = aa.currpose[i1];
					aa.control.strokecache[i1] = (
						aa.control.perspectived
						?
						{
							0: _part.perspective_0,
							1: _part.perspective_1,
							2: _part.perspective_2,
							3: _part.perspective_3,
						}
						:
						{
							front: _part.image_front,
							right: _part.image_right,
						}
					);
					let ref = aa.control.strokecache[i1];
					for(i2 in ref) {
						if(ref.hasOwnProperty(i2)) {
							ref[i2] = AAX.sq_raster.fill(ref[i2], _part.dim(i2, ref[i2].length)[0]);
							//ref[i2] = AAX.sq_raster.fill(ref[i2], _part.dim(i2, ref[i2].length)[0]);
						}
					}
				}
			}
			// fill strokecache (lets it reuse images so it doesn't run rasterize
			// every mousemove)
			aa.control.clicktype = "main";
		},
		mousemove: function(e, finish) {
		// - finish: boolean used in mouseup. means it should enact the changes
		//   it's calculating. that happens here because it already has to do a
		//   lot of the math to visualize things.
			let i1 = 0;
			let i2 = 0;
			let click = clickxy(e);
			let no_refresh = false;
			const ctx = aa.ctx.main;
			const cell = aa.drawsettings.cell;
			const view = (aa.control.clicktype === "main" ? aa.control.view : Math.floor(click[0]/cell.w));
			if(![0, 1, 2, 3].includes(view)) {
				return;
			};
			const coor = aa.coorfromcanvas(click[0], click[1], view);
			let part_select = (
				(
					aa.control.posetool === "tilt"
					||
					aa.control.posetool === "rotate"
					||
					(aa.control.posetool === "perspective" && aa.control.posetool_inversion)
					||
					aa.control.posetool === "select"
				)
				?
				aa.nodecheck(click, view)
				:
				null
			);
			part_select = part_select && part_select.name !== aa.control.partname ? part_select.name : null;
			if([0, 1, 2, 3].includes(view)) {
			// draw coordinates
			// - unless it's perspectived, ie coorfromcanvas doesn't really make
			//   sense
			// - or code for move, deform, or perspective will be run, which
			//   draws relative coordinates instead
			// - the conditional is here for really dumb reasons. if you hover
			//   over the right edges, the view can be calculated as 4.
				let text = [
					"",
					"xz"[view%2] + ": " + coor["xz"[view%2]],
					"y: " + coor.y
				];
				if(aa.control.perspectived) {
					text[1] = "";
					text[2] = "";
				};
				// coorfromcanvas doesn't work for perspective mode, and that
				// wouldn't make sense anyway.
				if(aa.control.clicktype !== "main" || part_select) {
					let node = aa.nodecheck(click, view);
					aa.pasteimages(false);
					aa.pasteimages(true);
					if(node !== null) {
						//aa.control.view = view;
						//aa.ui.draw();
						text[0] = node.name;
						// display the name
						node = AAX.noderect(node.x, node.y);
						ctx.strokeStyle = aa.color.interface[0];
						ctx.fillStyle = aa.color.interface[1];
						ctx.strokeRect(node.x - .5, node.y - .5, node.w + 1, node.h + 1);
						ctx.fillRect(node.x, node.y, node.w, node.h);
						aa.pasteimages(true, view);
					}
					// you can make this slightly less wasteful at the cost of
					// making it select nodes, by deleting the
					// aa.pasteimages(true) command and un-commenting the lines
					// that set aa.control.view and run aa.ui.draw.
					// - actually, running aa.ui.draw needlessly is more
					//   wasteful. whatever.
				};
				aa.writecoordinates(text);
			};
			if(aa.control.clicktype !== "main") {
				return;
			};
			//
			if(part_select) {
			// tilt/rotate should allow node selection on mouseup, and visualize
			// it. that gives much more visual feedback, and therefore
			// precision.
				if(finish) {
					aa.control.partname = part_select;
					//
					aa.control.strokecache = null;
					aa.control.clicktype = null;
					aa.control.strokedata = null;
					aa.refresh(["draw", "states"]);
					aa.writecoordinates(null);
				};
				return;
			};
			//
			aa.pasteimages(false);
			aa.writecoordinates(null);
			ctx.strokeStyle = aa.color.interface[0];
			ctx.fillStyle = aa.color.interface[1];
			const mode = (
				aa.control.posetool === "move" && aa.control.part.parent === "standpoint"
				?
				"deform"
				:
				aa.control.posetool
			);
			const inversion = aa.control.posetool_inversion;
			const node = aa.control.node;
			const part = aa.control.part;
			let parent_node = node.parent;
			if(node.parent === "standpoint") {
				parent_node = aa.coortocanvas([0, 0, 0], view, true, true);
				parent_node = {
					x: parent_node[0],
					y: parent_node[1],
					name: parent,
				};
			};
			// a node-like object for standpoint, or the .parent reference.
			const parent_part = (node.parent === "standpoint" ? null : aa.currpose[ parent_node.name ]);
			if(aa.control.partclicked) {
			// don't do anything if this is false
				const parent_abs = (
					node.parent === "standpoint"
					?
					[0, 0, 0]
					:
					parent_part.abscoor
				);
				const oddness = part.oddness;
				let relcoor = part.relcoor;
				const floats = [
					posmod(relcoor[0], 1),
					posmod(relcoor[1], 1),
					posmod(relcoor[2], 1)
				];
				if(view%2) {
					relcoor[2] = coor.z + oddness[2]/2 - parent_abs[2];
				}
				else {
					relcoor[0] = coor.x + oddness[0]/2 - parent_abs[0];
				}
				relcoor[1] = coor.y + oddness[1]/2 - parent_abs[1];
				// add oddness so it retains the same floats, subtract parent.
				relcoor = [
					Math.round(relcoor[0]*2)/2,
					Math.round(relcoor[1]*2)/2,
					Math.round(relcoor[2]*2)/2
				];
				// make sure nothing's infinitesimally close to a .0/.5
				const float_check = [
					posmod(relcoor[0], 1) === floats[0],
					posmod(relcoor[1], 1) === floats[1],
					posmod(relcoor[2], 1) === floats[2]
				];
				if(float_check.includes(false)) {
					console.log([
						"new oddness doesn't match old oddness.",
						floats,
						[
							posmod(relcoor[0], 1),
							posmod(relcoor[1], 1),
							posmod(relcoor[2], 1)
						]
					].join(String.fromCharCode(10)));
					if(finish) {
						aa.control.clicktype = null;
						aa.control.strokedata = null;
						aa.pasteimages(false);
						aa.writecoordinates(null);
					};
					return;
				};
				const hypot = aa.hypot(part.name, mode === "move" && inversion);
				// use the altered hypotenuse in inverted move mode.
				if(["move", "deform"].includes(mode)) {
				// draw circles, to show its range and where the fulcrum is
					circledraw(ctx, parent_node.x, parent_node.y, Math.floor(hypot));
					let temp = ctx.fillStyle;
					ctx.fillStyle = ctx.strokeStyle;
					circledraw(ctx, parent_node.x, parent_node.y, AAX.noderadius, true);
					ctx.fillStyle = temp;
				};
				if(mode === "deform") {
					let rect = {
						x: Math[([1, 2].includes(view) ? "ceil" : "floor")](parent_node.x) + .5,
						y: Math[([1, 2].includes(view) ? "ceil" : "floor")](parent_node.y) + .5,
						// floor/ceil it so it's what the coortocanvas would be
						// without floats, and add .5 so it's in the center of
						// the pixels.
						w: ([1, 2].includes(view) ? -1 : 1)*Math.trunc(relcoor[view%2 ? 2 : 0]),
						h: Math.trunc(relcoor[1]),
					};
					ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
					aa.writecoordinates(relcoor);
				}
				else if(mode === "move") {
					aa.nodeline(
						ctx,
						parent_node.x, parent_node.y,
						click[0] + ([1, 2].includes(view) ? -1 : 1)*floats[0], click[1] + floats[1],
						view,
						true
					);
					//
					let axis1 = view%2 ? 2 : 0;
					let axis2 = 1;
					let axis3 = view%2 ? 0 : 2;
					let temp = aa.movecoor(relcoor[axis1], relcoor[axis2], hypot, !!floats[axis3]);
					if(invertboolean([2, 3].includes(view), aa.control.moveaway)) {
						temp[2] *= -1;
					};
					relcoor[axis1] = temp[0];
					relcoor[axis2] = temp[1];
					relcoor[axis3] = temp[2];
					//
					let text = AAX.coortext(relcoor);
					text[axis3] = "<i>" + text[axis3] + "</i>";
					// italicize the third coordinate, to distinguish it (makes
					// it easier to know how to write a posescript action that
					// does the same thing. the user knows to replace the
					// italicized coordinate with just a sign.)
					aa.writecoordinates(text);
				}
				else if(mode === "perspective" && !inversion) {
					const unperspective_coor = aa.coortocanvas(part.abscoor, view, true, true);
					// unperspectived canvas coordinates.
					const rotated_coor = aa.coortocanvas(
						AAX.camerarotations(part.abscoor, null, aa.drawsettings.camera.xz, aa.drawsettings.camera.yz, "same floats"),
						view, true, true
					);
					// perspective lines are drawn from the rotated coordinates,
					// so that it resembles a line to the vanishing point.
					// - view is null because coortocanvas doesn't expect the
					//   view number rotation.
					const old_coor = part["perspective_coor_" + view];
					relcoor = [
						click[0] - unperspective_coor[0] + posmod(unperspective_coor[0] + old_coor[0], 1),
						click[1] - unperspective_coor[1] + posmod(unperspective_coor[1] + old_coor[1], 1)
					];
					ctx.strokeStyle = aa.color.perspective;
					aa.nodeline(ctx, ...rotated_coor, ...click, view, true);
					let text = AAX.coortext(relcoor);
					aa.writecoordinates([
						part.name,
						"screen " + text[0],
						"screen " + text[1]
					]);
				};
				// no logic for select mode because it doesn't do anything.
				// (rotate mode acts like select mode if a part was clicked.)
				if(finish) {
					if(mode === "move" || mode === "deform") {
						aa.posescript_dry(null, "deform", {x: relcoor[0], y: relcoor[1], z: relcoor[2]}, mode === "deform" && inversion ? ["disjointed"] : []);
					}
					else if(mode === "perspective" && !inversion) {
						aa.posescript_dry(null, "perspective", {view, x: relcoor[0], y: relcoor[1]});
					};
				};
			}
			else if(mode === "tilt" || mode === "rotate") {
				let angle = null;
				let axis = view%2 ? 0 : 2;
				// yz = x axis
				// xy = z axis
				if(inversion) {
					axis = 1;
					// inverted = y axis
					angle = aa.xz_angle(click, view);
				}
				else {
					angle = get2dangle(([2, 3].includes(view) ? -1 : 1)*(click[0] - node.x), click[1] - node.y, true) ?? 0;
				};
				angle = posmod(angle - aa.control.strokedata, 2*Math.PI);
				// now it's a relative angle instead of absolute
				const round = aa.control.rotate.round;
				if(round) {
					angle /= 2*Math.PI;
					angle = Math.round(angle*round)/round;
					angle *= 2*Math.PI;
				}
				let _angle = roundspecial(Angle.convert(angle));
				_angle -= _angle > 180 ? 360 : 0;
				_angle = {
					sign: _angle < 0 ? "-" : _angle > 0 ? "+" : "&#160;",
					num: Math.abs(_angle),
				};
				_angle = _angle.sign + "&#160;".repeat(3 - (_angle.num + "").length) + _angle.num;
				aa.writecoordinates(_angle + " " + ["yz", "xz", "xy"][axis]);
				//
				if(inversion) {
				// i equate xy rotation to the z axis and yz to the x axis, but
				// xz is different. since the coordinate order is reversed, the
				// magnitude has to be inverted to reach the same results.
				// - that was confusing, wasn't it.
				// - 30 degrees xz rotation equals *negative* 30 degrees
				//   rotation around the y axis.
				// - but i don't wanna make it so the "true" axis for y is [0,
				//   -1, 0]. that's confusing and inconsistent.
					angle *= -1;
				};
				if(aa.control.rotate.type === "local") {
					//axis = Quat.basis(part.mirror ? Quat.mirror.x(part.orient) : part.orient)[axis];
					axis = Points.multiply(Quat.basis(part.orient)[axis], ((part.mirror && axis === 0) ? -1 : 1));
					// the flipping is sorta inconsistent, but more intuitive.
					// this way, a totally unaltered part's locals will always
					// align with the true axes, like the user expects.
				}
				else if(aa.control.rotate.type === "custom") {
					axis = structuredClone(aa.control.rotate.basis[axis]);
				}
				else {
					let temp = axis;
					axis = [0, 0, 0];
					axis[temp] = 1;
				};
				axis = Angle.get(...axis);
				let partname = aa.control.partname;
				let rotatecoor = mode === "tilt" ? null : aa.rotatecoor(partname, axis, angle);
				let quat = Quat.rotate(part.orient, axis, (part.orient.flip ? -1 : 1)*angle);
				// if flip is on, rotations have the opposite effect of what
				// they're supposed to. (on the quaternion, anyway.)
				let basis = Quat.basis(quat);
				// basis to display
				let check = Basis.check(basis);
				if(Basis.check(basis)) {
					console.log(check);
					console.log(basis);
				};
				no_refresh = !angle;
				if(finish) {
				// apply the new relative coordinates in rotatecoor
					if(!no_refresh) {
						if(mode !== "tilt") {
							for(i1 in rotatecoor) {
								if(rotatecoor.hasOwnProperty(i1)) {
									let _part = aa.currpose[i1];
									_part.x = rotatecoor[i1][0];
									_part.y = rotatecoor[i1][1];
									_part.z = rotatecoor[i1][2];
								}
							}
						}
						aa.posescript_dry(
							[partname].concat(mode === "tilt" ? [] : AAX.getdesc(aa.body, partname)),
							"tilt", {axis, angle}
						);
					}
				}
				else {
				// use rotatecoor with aa.draw (only the parts not being rotated
				// are drawn, then the rotated parts are drawn as nodes/skeleton
				// in the colors of the interface.)
					aa.draw_background();
					aa.draw(null, rotatecoor, {[partname]: basis});
				}
			};
			if((mode !== "tilt" && mode !== "rotate") || aa.control.partclicked) {
			// get rid of overflow
				aa.pasteimages(true);
			};
			if(finish) {
				aa.control.strokecache = null;
				aa.control.clicktype = null;
				aa.control.strokedata = null;
				if(!no_refresh) {
					aa.refresh( (
						mode === "select"
						||
						((mode === "tilt" || mode === "rotate") && aa.control.partclicked)
						||
						(mode === "perspective" && inversion)
					) ? "states" : null );
				}
				// don't edit datatext or states if all you did was select
				// something.
				aa.writecoordinates(null);
			};
		},
		mouseup: function(e) {
			if(aa.control.clicktype !== "main") {
				return;
			};
			aa.mousemove(e, true);
		},
		writecoordinates: function(text) {
			AAX.writecoordinates(aa.div.coor, text);
		},
		nodeline: function(ctx, x1, y1, x2, y2, view, viewoffset) {
			let temp = aa.coortocanvas([0, 0, 0], view, true, viewoffset);
			temp[0] += .5;
			temp[1] += .5;
			// center of the standpoint pixel
			linespecial(ctx, x1, y1, x2, y2, temp);
		},
		body: null,
		bodytext: null,
		anims: [],
		// anims and states:
		// - each item of anims represents a different animation.
		//   - for example, a walking animation, jumping animation
		//   - they're all based on the same body, but they're distinct in the
		//     undo/redo system.
		// - structure of an anim:
		//   - name: the name displayed for it. it can be a number or string. if
		//     it's invalid, it'll use the index of the animation within
		//     aa.anims.
		//   - states: an array of states for it to undo/redo between.
		//   - state_index: which index of states is the one to use right now.
		//     (undo/redo move this up and down.)
		// - structure of a state:
		//   - states are what the undo/redo system saves/loads. they store the
		//     state of a single animation. all of its frames, and some data
		//     about aa.control stuff at the time. (like what frame you were on,
		//     or what pose tool you were using)
		//   - newer states come earlier in a states array.
		//   - state arrays never get longer than aa.states_limit.
		//   =
		//   - poseobjs: an array of AAX.poseobjs for each frame.
		//     - a poseobj is an armature of partobjs, and partobjs are trimmed
		//       versions of AAX.s. partobjs have no getters/setters or
		//       methods, and properties that are "default" are omitted entirely.
		//     - generally, not even functions like AAX.dim work on them. some of
		//       them might, like AAX.abscoor, but in general they written with
		//       the assumption of being used on aa.body or AAX.s/aa.frames.
		//   - currframe: what frame you were on when this state was saved
		//   - view, partname, posetool_inversion, _posetool: aa.control values
		//     at the time this state was saved
		// - various properties like aa.currframe, aa.states, aa.state_index are
		//   getters/setters for the properties of the animation.
		// - however, AA.FRAMES IS NOT. aa.frames is a copy of the current state
		//   the current animation, where every part is a genuine AAX.
		//   instead of just using AAX.poseobj.
		//   - every time states are saved during aa.refresh, it makes sure the
		//     current state's poseobjs match the changes made.
		_anim_index: 0,
		get anim_index() {
			return aa._anim_index;
		},
		set anim_index(value) {
			let ref = aa.curranim;
			if(value !== aa._anim_index) {
				//ref.states = ref.states.slice(ref.state_index, ref.state_index + aa.states_truncator);
				//ref.state_index = 0;
				ref.states = ref.states.slice(ref.state_index - aa.states_truncator, ref.state_index + 1 + aa.states_truncator);
				ref.state_index = Math.min(ref.state_index, aa.states_truncator);
				// apply states_truncator
				// - if state_index is higher than the truncator, it should become
				//   the truncator, since it can only store that many redos. if it's
				//   lower, don't change it at all, since only undos would be
				//   deleted.
				if(aa.control.activeonly_cache) {
					// clear the cache for inactive animations.
					for(let i1 = 0; i1 < ref.states.length; i1++) {
						// for every state,
						let _ref = ref.states[i1].poseobjs;
						for(let i2 = 0; i2 < _ref.length; i2++) {
							// frame,
							for(let i3 in _ref[i2]) {
								if(_ref[i2].hasOwnProperty(i3)) {
									// part.
									let __ref = _ref[i2][i3];
									__ref.cache = structuredClone(AAX.cache_init);
								}
							}
						}
					}
				}
			};
			aa._anim_index = value;
			aa.loadstate(aa.state_index, true);
			// apply those changes to aa.frames.
			// - skip refresh. this is only set in .initialize and buttons for
			//   changing it, so refresh will run anyway.
		},
		newstate: function() {
			return {
				poseobjs: [],
				currframe: 0,
				view: aa.control.view,
				partname: aa.control.partname,
				posetool_inversion: aa.control.posetool_inversion,
				_posetool: aa.control._posetool,
			};
		},
		newanim: function() {
			let anim = {
				name: "",
				states: [aa.newstate()],
				state_index: 0,
			};
			anim.states[0].poseobjs = [AAX.poseobj(aa.newpose())];
			return anim;
		},
		get curranim() {
			return aa.anims[aa.anim_index];
		},
		getanimname: (index) => aa.anims[index].name ? aa.anims[index].name : "anim " + index,
		// use this whenever an animation name is displayed.
		frames: [],
		// an array of posed armatures. the structure is as follows:
		get states() {
			return aa.curranim.states;
		},
		set states(value) {
			if(Array.isArray(value)) {
				aa.curranim.states = value;
			}
			else {
				console.log("this shouldn't happen");
			}
		},
		get state_index() {
			return aa.curranim.state_index;
		},
		set state_index(value) {
			if(Number.isInteger(value) && value >= 0 && value < aa.states.length) {
				aa.curranim.state_index = value;
			}
			else {
				console.log("this shouldn't happen");
			}
		},
		get currstate() {
			return aa.states[aa.state_index];
		},
		get currframe() {
			return aa.currstate.currframe;
		},
		/*
		set currframe(value) {
			if(!Number.isInteger(value)) {
				console.log("this shouldn't happen (" + value + ")");
			}
			//else if(value >= 0 && value < aa.frames.length) {
			//	aa.currstate.currframe = value;
			//}
			else {
				aa.currstate.currframe = Math.max(0, Math.min(value, aa.currstate.poseobjs.length - 1));
			}
		},
		//*/
		set currframe(value) {
			if(Number.isInteger(value) && value >= 0 && value < aa.frames.length) {
				aa.currstate.currframe = value;
			}
			else {
				//console.log("this shouldn't happen (" + value + ")");
				// this runs when it shouldn't. specifically, if undo/redoing
				// takes you to a state where there's less frames than makes
				// sense for what currframe is. it's fine because loadstate runs
				// clampframe, so i don't want this error showing up.
			}
		},
		get poseobjs() {
			return aa.currstate.poseobjs;
		},
		get currpose() {
			return aa.frames[aa.currframe];
		},
		get currposeobj() {
			return aa.poseobjs[aa.currframe];
		},
		states_limit: 32,
		// poses aren't very big, but i really don't want it to swell
		// infinitely. having to start over because it crashed or whatever would
		// suck.
		states_truncator: 4,
		// when it switches away from an animation, it truncates it so only this
		// many undos/redos are kept.
		clampframe: function() {
			aa.currframe = Math.min(aa.frames.length - 1, Math.max(aa.currframe, 0));
		},
		savestate: function() {
			let loop = new Loop("aa.savestate");
			let currframe = aa.currframe;
			if(aa.state_index > 0) {
			// clear redo
				aa.states.splice(0, aa.state_index);
				aa.state_index = 0;
			};
			aa.states.splice(0, 0, aa.newstate());
			aa.currframe = currframe;
			let ref = aa.poseobjs;
			for(let i1 = 0; i1 < aa.frames.length; i1++) {
				loop.tick(1);
				ref[i1] = AAX.poseobj(aa.frames[i1]);
			}
			loop.end();
			if(aa.states.length > aa.states_limit) {
			// keep it within states_limit
				aa.states.splice(aa.states_limit, aa.states.length - aa.states_limit);
			};
		},
		loadstate: function(index, skiprefresh) {
		// using in undo/redo, and the anim_index setter. applies the changes
		// stored in a state.
			let i1 = 0;
			let loop = new Loop("aa.loadstate");
			let ref = aa.states[index];
			for(i1 in ref) {
				loop.tick(1);
				if(ref.hasOwnProperty(i1) && i1 !== "poseobjs" && i1 !== "currframe") {
					if(i1 === "_posetool" && (ref[i1] === "perspective") !== (aa.control[i1] === "perspective")) {
					// only do posetool changes if it changes whether it's
					// perspectived or not (since some things are only visible
					// in one mode or another.)
						aa.control[i1] = ref[i1];
						// move this outside the conditional to apply changes to
						// view and partname.
						// - it sounds more intuitive, but it isn't. so it's in
						//   here.
						aa.control.posetool_inversion = ref.posetool_inversion;
						if(ref[i1] === "perspective") {
							aa.control.view = ref.view;
						};
					};
				};
			}
			loop.end();
			aa.frames = [];
			// clearing this prevents problems with length differences
			for(i1 = 0; i1 < ref.poseobjs.length; i1++) {
				loop.tick(1);
				aa.frames[i1] = aa.posefromobj(ref.poseobjs[i1]);
			}
			loop.end();
			aa.currframe = ref.currframe;
			// this comes after the changes to aa.frames, since the currframe
			// setter doesn't accept values outside the current aa.frames
			// length.
			aa.clampframe();
			if(!skiprefresh) {
				aa.refresh("states");
			}
			aa.filldatatext();
		},
		undo: function() {
			if(aa.state_index < aa.states.length - 1) {
				aa.state_index++;
				aa.loadstate(aa.state_index);
			};
		},
		redo: function() {
			if(aa.state_index > 0) {
				aa.state_index--;
				aa.loadstate(aa.state_index);
			};
		},
		anim: null,
		updateanimation: function(no_shortcut) {
		// updates the animation.
		// - this is to be used sparingly, with a button. to avoid drawsettings
		//   inconsistency, it needs to draw every frame again to save it.
		// - no_shortcut
		//   - to save time, it skips the drawing for whatever the current frame
		//     is. it just copies aa.ctx, instead.
		//   - this is usually fine, because between switching animations and
		//     clicking the updateanimation button, there's guaranteed to be a
		//     refresh.
		//   - but in the case of the pixel art multianimation export, that
		//     isn't true.
			let ref = aa.animator;
			let view = ref.html.one_view.checked ? aa.control.view : -1;
			let viewtype = view === -1 ? "multi4" : view;
			let ctx = aa.ctx.main;
			let vertical = ref.html.vertical.checked;
			let cell = aa.drawsettings.cell;
			ref.w = (view === -1 && vertical ? 4 : 1)*cell.w;
			ref.h = (view === -1 && !vertical ? 4 : 1)*cell.h;
			// if it's a multiview and the time direction is vertical, the four
			// views should be lined up horizontally. if it's a multiview and
			// time is horizontal, they should be lined up vertically.
			ref.frames = [];
			let currframe = aa.currframe;
			// this is going to change, so save what it is right now
			for(let i1 = 0; i1 < aa.frames.length; i1++) {
				let _i1 = posmod(currframe + i1, aa.frames.length);
				aa.currframe = _i1;
				if(!(i1 && view !== -1 && !no_shortcut)) {
				// if it's the first drawing and it isn't a one-view update, you
				// can skip one drawing by taking whatever's already on the
				// canvas. (unless no_shortcut is on to prevent it.)
					aa.draw_background(viewtype);
					// (viewtype, side_tint_invert)
					// - _i1%2 would make the side tint have like a checker
					//   pattern, to differentiate cells in both axes, not just
					//   one..
					// - but, well. it's kind of stupid to make the whole
					//   background change color every other frame.
					aa.draw(viewtype);
					// (viewtype, rotatecoor, basis)
				};
				if(view === -1 && !vertical) {
				// if it's a horizontal multiview, the views should be lined up
				// vertically.
					let canvas = document.createElement("canvas");
					let _ctx = canvas.getContext("2d");
					canvas.width = cell.w;
					canvas.height = 4*cell.h;
					for(i2 = 0; i2 < 4; i2++) {
						_ctx.putImageData(ctx.getImageData(i2*cell.w, 0, cell.w, cell.h), 0, i2*cell.h);
					}
					ref.frames[_i1] = _ctx.getImageData(0, 0, cell.w, 4*cell.h);
				}
				else {
					ref.frames[_i1] = ctx.getImageData(0, 0, ref.w, ref.h);
				}
			}
			aa.currframe = currframe;
			if(view === -1) {
				ctx.putImageData(ref.frames[currframe], 0, 0);
			}
			else {
				aa.draw_background();
				aa.draw();
			}
			// put the canvas back how it was
			ref.frame = 0;
			ref.sheet.vertical.checked = ref.html.vertical.checked;
			ref.updatesheet();
		},
		initialize: function() {//yyyaai
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let i4 = 0;
			let loop = new Loop("aa.initialize");
			//
			//aa.drawsettings.silhouette = "overlap";
			//aa.drawsettings.parts = "off";
			if(typeof aa.bodytext !== "string") {
				aa.bodytext = AAX.Body.templates.standard;
				aa.body = AAX.Body.new(aa.bodytext);
			};
			if(typeof aa.body !== "object" || aa.body === null) {
				console.log("this shouldn't happen" + (typeof aa.body === "string" ? " (error is \"" + aa.body + "\")" : ""));
				return;
			};
			//console.log(aa.body);
			// make sure a body exists
			//
			let string = manualhtml({
				"pose tools": [
					`the deform pose tool lets you move parts anywhere, even if it changes how far the part is from their parent. (useful for body parts connected by a spine instead of a bone.)`,
					`the move pose tool lets you move parts, but keeps it as far away from the parent as it is in the default pose. (the third axis will be whatever positivity/negativity brings it closer to the camera for that view. if you're on the front view, it will move forward, if it's the back view it will move backward.)`,
					`if you click a part in the rotate pose tool, it will select that part. if you click anywhere else, you can rotate the selected part and its descendants.`,
					[
						`tilt is similar, but doesn't affect descendants.`,
						`you can select parts by starting <i>or</i> ending your click on them.`
					],
					`the perspective pose tool lets you create an offset for each view, letting you make 2d adjustments or position things around a vanishing point.`,
					`certain graphical changes only apply in perspective mode, namely the perspective offsets, and camera angle. this is because perspective mode is for visualizing what the pose/animation will look like at the end, while the other modes are meant to be easy to understand and edit, like an engineering multiview.`,
					`the select pose tool selects whatever part is closest to where you click. useful for mobile devices, where it's hard to click close enough.`,
					`selecting the pose tool you already have selected "inverts" it, making it work differently.`,
					[
						`inverted move will use the current hypotenuse of the part, rather than the hypotenuse it has in the default pose. (useful if you used deform to lengthen limbs or something.)`,
						`inverted deform will move the part without moving its descendants.`,
						`inverted tilt/rotate does xz rotation.`,
						`inverted perspective selects parts without editing them. (useful while editing different perspective images)`
					]
				],
				"editing/switching bodies": [
					`open the "bodytext" thing.`,
					`by editing the content in that text area and clicking "apply changes", you can edit or replace the body. some part properties can only be changed in here.`,
					`there's also a dropdown with some example bodytexts to use or start from, like a hand.`,
					`you can write these manually, but the "body maker" tool makes it much easier.`,
					`structure of a bodytext`,
					[
						`the first area defines parts, their names, parent structure, and coordinates.`,
						[
							`if you lift the knee, the foot should be lifted too, right? that's "parenting". when a part moves, its children move too.`,
							`the coordinates here are "relative", meaning they represent how far away the part is from its parent.`
						],
						`the second area is images.`,
						[
							`type a bracketed part name to make lines after that part of that part's shapes/images.`,
							`use "||" lines to transition from a part's shape to its unperspectived images, or from that to its perspectived images.`,
							`read the "shape system" and "image system" sections for more about how shapes/images work and how to write them.`
						],
						`the third area is other properties. enter a part name and colon, then...`,
						[
							`symmetry(): creates horizontally mirrored duplicates of the part and all its descendants.`,
							[
								`the original branch will get a "l_" prefix, and the duplicate branch will have "r_" prefixes. (you can also choose your own prefixes by putting them in the parentheses, separated by a comma.)`,
								`coordinates, shapes, and images are x-mirrored.`
							],
							`color1(), color2(): enter numbers in the parentheses to set first and second colors for the part and all its descendants.`,
							[
								`these numbers represent items of the list of part colors. (you can edit that list by clicking that rainbowy button.)`,
								`you can enter multiple numbers, separated by commas. this will make colors alternate between generations. (ex: "color1(1, 2)" will make the part's color1 the first color in the part colors list, and make all its children use the second color in that list. then the grandchildren use the first color, great-grandchildren use the second, etc.)`,
								`if you use "color1*()" or "color2*()" instead, descendants won't be affected.`
							],
							`group(), generation(), core(), bone(), concave(): these affect the silhouette/connection system.`,
							[
								`when the silhouettes toggle in draw settings is on, it draws an approximation of the armature's silhouette, using these properties.`,
								`generally, silhouette images are combinations of the part's image and other parts' images, turned into a convex shape.`,
								`group(): enter a number, and maybe follow it with letters. this defines the "silhouette group", which helps differentiate different limbs.`,
								[
									`if parts have the same number <i>and</i> letters, they're drawn together, with no outlines between their silhouette shapes.`,
									`if parts have the same number but different letters, they're drawn like separate shapes, but in the same color.`,
									`the number is used to select one of the silhouette colors. there's a color button that lets you edit those. the dark blue/green/red one.`,
									`if a mirrored part has no letters in their silhouette group, when it gets a symmetrical counterpart, the left one will get "l" and the right one will get "r".`,
									[
										`this doesn't happen if the silhouette group was 0. (the assumption is that if it's 0, you didn't want these limbs differentiated from the rest of the body anyway.)`
									],
									`just like color1 and color2, group has a "group*()" counterpart that doesn't affect descendants.`
								],
								`generation(): enter two numbers in the parentheses to add the images of the part's ancestors and/or descendants. for example, "generation(1, 2)" makes it combine the part's image, its parent's image, all of its childrens' images, and all of its grandchildrens' images.`,
								[
									`<b>by default, it's (1, 0), meaning it adds the parent's image. if you don't want that, you have to override it with an empty generation() command.</b>`
								],
								`core(): enter a number. using that as the diameter, it will add a circle centered on the part. this is used for the hands.`,
								`bone(): enter a number. using that as the diameter, it will add a capsule shape, that begins at the part's parent and ends at the part. used for the neck.`,
								`concave(): if you enter this, the silhouette image will be turned into a convex shape <i>before</i> the part's main image is added. use this for concave shapes, like if the head has horns, or you just don't want it convexed to its parent.`,
								[
									`this affects bone(), too, if you have one. the bone will be added after convexing.`,
								]
							],
							`hide(): the part is hidden by default.`,
							`perspective(): lets you predefine perspective offset? this isn't very useful, but it's there.`,
							[
								`enter view 0's x, view 0's y, view 1's x, etc.`,
								`you can also enter "auto". that counts for two coordinates, since it applies to a whole view`,
								`by default, all views have automatic perspective.`
							],
							`tilt(): lets you rotate the part.`,
							[
								`mostly this is useful for local rotate.`,
								`for example, the open/close axis of the elbow doesn't quite match the xy axis, and the forearm-twist axis of the hand should line up with the angle from the elbow to the hand, not the xz axis. that can be fixed by rotating the xy/xz axis of those parts to where they should be.`,
								`naturally, it will also rotate the shape, so make sure to account for that.`,
								`the syntax is the same as it is for rotating spheroids in shapes, so check the "shape system" section for that.`
							]
						]
					],
					`writing // anywhere in a bodytext makes a comment, ie the rest of that line is ignored.`,
					`poses can survive bodytext changes, for the most part. if a part with the same name exists in both the old and new body, it'll adopt changes in coordinates and the like, while accounting for the angle/hypotenuse difference the part has in the default pose.`
				],
				"shape system": [
					`parts usually use 3d shapes to generate 2d images.`,
					`these shapes are defined in bodytext, but you can also redefine them with the "edit shape" button.`,
					`shapes are lists of points, broken up into groups. each line is a point, and a "|" line starts a new group.`,
					`every group is drawn as a convex shape. you can make simple convex shapes like pyramids/cubes/etc by just placing all the points. the order of the points doesn't matter.`,
					`concave shapes are impossible with just that, so that's what point groups are for. you can form concave shapes by breaking it up into multiple convex parts.`,
					`points can be made into spheres/spheroids by writing more than three numbers. if there's four, the fourth is used as the diameter of a sphere. if there's six, the last three numbers are used for width, height, and depth.`,
					`you can rotate spheroids, too. anything past the sixth number is used for that, either through xy/yz/xz rotations (axis, colon, 0 to 1 number, ex: "xy: 1/4, xz: .37") or a quaternion. (ex: "w: .707, x: 0, y: 0, z: .707")`,
					[
						`you can write "x mirror", "y mirror", or "z mirror" to mirror the quaternion.`,
						`you can write "local" to make subsequent rotations local rotations, and "true" to change it back. (check the "rotate settings" section if you don't know what local rotation is.)`
					],
					`you can type a point that's nothing but axis letters to copy the previous point with those axes inverted in the coordinates and orientation. useful for designing symmetrical shapes.`,
					`if you type axis letters and a point index, you can make copies of other points. (the first point is 0. negative indexes will start from the most recent points, so -1 means "the point before this one".)`,
					`the "orient" part property rotates the shape. the rotate and tilt pose tools can edit this. the part information window visualizes it by showing the directions of the x/y/z axes of the shape.`,
					`"stretch" and "widen" scale the shape. stretch scales it along the line from the part to its parent, and widen scales it in other directions.`,
					`orient flipping`,
					[
						`this is a technical detail that, 90% of the time, is not important. skip this if you don't care.`,
						`for symmetry parts and tools like the mirror buttons, parts get mirrored across some axis, right? including even the orientation of the shape.`,
						`that's impossible with traditional quaternions. you can invert two axes by rotating it 180 degrees, but inverting one or all axes is impossible.`,
						`my orient quaternions get around that by having a "flip" property. that makes it so, whenever the quaternion is used to orient a point or set of axes, every coordinate of those points will be inverted.`,
						`combined with 180 rotations, this makes it possible to mirror quaternions.`,
						`when the part information orientation visual has a little X at the center, that means the quaternion is currently flipped.`,
						`you cannot specify whether flip is on in the point quaternions. since those quaternions are only applied to spheroids, and spheroids are symmetrical in all three axes, inverting the directions of all of those axes does nothing. i guess if you really wanted to, you could write "x mirror, y mirror, z mirror".`,
						[
							`things only change if a spheroid axis points in a different direction that isn't exactly the opposite direction of what it was. one or two x/y/z mirrors can cause that, but three mirrors won't.`
						]
					],
					`extra notes`,
					[
						`// comments are especially useful in shapes, to remember how the shape is structured.`
					]
				],
				"image system": [
					`shapes are generally more useful than 2d images. things are designed around them more than they're designed around 2d images.`,
					`but 2d images are useful for things like hands, that are important but can't be drawn with shapes. that's what "part artist" is for, creating 2d images manually.`,
					`a part can have a shape, unperspectived images, and perspectived images. if it has multiple, unperspectived is used over shapes, and perspectived is used over unperspectived.`,
					`there can be two unperspectived images per part. a front view, and right view. (it's mirrored for the other two views.)`,
					`there can be four perspectived images. one per view. this is only shown when the selected pose tool is perspective.`,
					`structure of images, in bodytext:`,
					[
						`make a rectangle of characters. any dimensions are fine.`,
						`- for empty pixels, % for the first color, * for the second color.`,
						`use a | line to switch to the next image.`,
					],
					`the "switch" button in armature artist copies the current part's 2d image to part artist and switches over to part artist so you can edit it.`,
					`the "switch" button in part artist applies your changes to the part in armature artist and switches back to it.`,
					`extra notes`,
					[
						`the "switch without export" buttons switch between the two without doing any image import/export.`,
						`when the pose tool is "perspective", switching to/from part artist will import/export the perspective image of the current part, in the current selected view. (the selected view is whatever view you last clicked to edit. there's view buttons to indicate/change the view.)`,
						`when the pose tool is anything else, switching to/from part artist will import/export both the front and right unperspectived images.`,
						`the "clear image" button follows the same rules.`,
						`if said 2d image doesn't exist, part artist imports/exports the image it uses the 3d shape to generate.`,
						`if you ever get mixed up which images exist and don't exist, check the part information window.`,
						`the difference between the first and second color is that for the first color, any interior pixels will use the "part fill" color, with only the edges being the part's color. this isn't true for the second color.`,
						[
							`the first color is meant to define the shape, the second marks reference points or whatever.`
						]
					]
				],
				"hide/show": [
					`"part" hide/show: hides/shows the selected part.`,
					`"branch" hide/show: hides/shows the selected part and its descendants.`,
					`"group" hide/show: hides/shows all parts with the same silhouette group number.`,
					`"body" hide/show: hides/shows all parts in the same body. (if you have parts that are unconnected objects or even separate characters, those won't be affected.)`,
					`"body-branch" hide/show: short for "body minus branch". hides all parts part of the same body but not the same branch.`,
					`hide/shows with similar names work the same way. hiding/showing everything that fits into the first type but not the second.`,
					`hidden parts aren't selectable, unless the "total hide" setting is off. it's useful for animating complex bodies or multiple characters at once, without irrelevant characters/parts getting in the way.`
				],
				"other part properties": [
					`relative coordinates are the part's coordinates relative to the part's parent.`,
					`perspective coor is the offset the perspective pose tool creates. it's only shown in perspective mode. if it's set to "auto", it'll be calculated automatically, based on the draw settings' vanishing point and range.`,
				],
				"draw settings": [
					`grid: increments for the grid lines. "2, 2, 4" would mean lines are drawn every 2 pixels in the first grid color, then every 2*2 pixels in the second grid color, then every 2*2*4 pixels in the third grid color. putting a 0 anywhere makes it draw lines at the standpoint and only the standpoint.`,
					`standpoint: parts that are at (0, 0, 0) will appear at this position in the cell, relative to the cell's center.`,
					`range: used in automatic perspective. when a point has perspective applied, no matter where it is, it's placed within this radius from the vanishing point. lower numbers mean more curvature, higher numbers mean less.`,
					`cell: cell dimensions.`,
					`vp: "vanishing point". used in the automatic perspective. the coordinates are relative to the standpoint.`,
					`camera: an xz and yz angle. when it's in perspective mode, everything is rotated by these.`,
					`fineness: used in shape spheroids. spheroids are drawn as if a circle has (4 * this) sides. higher numbers are a bit more taxing, but if you're making shapes big enough to see flat sides in your spheroids, increasing this will fix that.`,
					`toggles`,
					[
						`grid: between the background being a grid, color but no grid, or totally transparent. useful when generating images from your animation.`,
						`silhouette: connects parts' images to form a somewhat realistic-looking silhouette. switches between them being shown, shown with different silhouette groups being distinguished, or no silhouettes at all.`,
						[
							`differentiating different limbs is the whole point of silhouette groups, but they only clutter up the image unless you actually need to see those interior outlines at the moment.`
						],
						`parts: toggles whether parts' images are drawn. (the pink setting makes it so all images' outlines are visible, even if they would normally be covered up by another image's fill.)`,
						`vertices: when it generates 2d images from the part's shape, it draws the points that make up the shape in the part's second color. this is a toggle for that.`,
						`skeleton: lines between parts and their parents`,
						`perspective: draws lines between where parts are in and out of perspective mode.`,
						`nodes: highlights the center of each part`,
						`total hide: when this is off, some things are still drawn even for hidden parts. just enough to know where they are and edit them. (the nodes are visible, and so is their skeleton if they have unhidden descendants.)`
					],
					`colors`,
					[
						`the left set of colors affects the grid.`,
						`the middle set of colors affects the elements of an armature. (in about the same order as the draw settings toggles for those elements, and the order they're layered.)`,
						`the right set of colors is interface stuff. stuff used in pose tool graphics, and the ui.`,
						`but if you forget which is which, the button prompts will tell you what they are.`,
						`you can enter multiple part/silhouette fill colors to differentiate parts that belong to different bodies. (that is, parts that don't share a common ancestor.) this is useful for animating multiple characters.`,
						[
							`it loops around. if you have two colors and five bodies, the first, third, and fifth body will use the first color, and the second and fourth bodies will use the second color.`
						]
					],
					`extra notes`,
					[
						`if you use a bodytext with a part named "head", the vanishing point's y will automatically be set as the y that part has in the default pose. like placing the camera at eye level.`,
						`hitting "cancel" on a color prompt will keep it as it is, but hitting "ok" without typing anything will reset the color to default.`,
						`the standpoint grid lines move while in perspective mode, but that only represents where a [0, 0, 0] point would be perspectived to. it's not like it changes which pixels are what coordinates or anything.`
					]
				],
				"inbetweens": [
					`what tweening is`,
					[
						`if you have a start pose and an end pose, and you simplify the differences between them into a "difference" object of rotations and length multipliers...`,
						`start pose + difference = end pose.`,
						`start pose + difference*1/4 = a pose that's sort of like the start pose, but 1/4 of the way to being like the end pose.`,
						`so if you insert a 1/4, 1/2, and 3/4 pose between the start and end pose, you can animate a smooth transition between the start and end pose, without even doing anything.`
					],
					`when you click "create inbetweens", it creates inbetweens between the current frame and the next frame.`,
					`"apply inbetweens" does something similar, but assumes these frames already exist. so the end frame is assumed to be start frame + [number of inbetweens] + 1, and the frames between that are made to transition between the two.`,
					`the rest of these buttons just control easing stuff. most motion is eased.`,
					[
						`the number you can tick up/down is how many inbetweens to make.`,
						`the ^ number is the curve, used for exponenting. the higher the number it is, the more severe the easing is. 1 will make all the frames equally spaced. 2 would place the inbetweens at (1/4)^2, (1/2)^2, (3/4)^2, etc.`,
						`the two buttons beneath that control if it's ease in, ease out, ease in/out, or ease out/in.`,
						`the area under that visualizes what the inbetweens will be like. the closer a circle is to the left end, the more it'll be like the start pose, and the closer it is to the right, the more it'll be like the end pose.`
					],
					`<i>when using apply inbetweening, it won't tween parts that are hidden in the starting frame.</i> this lets you control what inbetweening is applied to, like only tweening certain characters or limbs.`,
					`<b>there are two cases where tweening looks weird.</b> if your tweening looks weird, it's probably one of these cases.`,
					[
						`one is when the angles a part points in in the start and end pose are perfect opposites.`,
						[
							`it figures out how to get from here to there by finding the shortest rotation that would do that, but... if the angles are perfectly opposite, there's an infinite number of angles it could be.`,
							`instead it just tweens position rather than angle. which doesn't really make sense.`
						],
						`two is when in the start or end pose, the part's orient quaternion is "flipped", but not in both.`,
						[
							`read the "orient flipping" part of the shape system section. generally, orientation only flips or unflips when you use the mirror buttons.`,
							`this just isn't a very tweenable property, and it's impactful enough for the lack of smooth change to look super weird.`,
							`as i said earlier, check the orientation visual in the part information area to tell if it's flipped. it should have an X at the center if it is.`,
							`one common example is walk cycles.`,
							[
								`the standard, beautifully half-assed walk cycle is as follows:`,
								[
									`default pose`,
									`stepping pose`,
									`default pose`,
									`stepping pose, but x mirrored`,
								],
								`if you try to tween that, it'll look creepy. x mirroring all parts in the last frame creates a skew between that frame and the other 3.`,
								`instead, it should be like:`,
								[
									`default pose`,
									`stepping pose`,
									`default pose, but x mirrored`,
									`stepping pose, but x mirrored`,
								],
								`basically, avoid tweening between mirrored and unmirrored frames.`,
								[
									`create and duplicate key frames`,
									[
										`1: default pose`,
										`2: stepping pose`,
										`3: default pose`,
										`4: stepping pose`
									],
									`create tweens between key 1 and 2 (ease out)`,
									`create tweens between key 2 and 3 (ease in)`,
									`x mirror keys 3, 4, and 1`,
									`create tweens between key 3 and 4 (ease out)`,
									`create tweens between key 4 and 1 (ease in)`,
									`x mirror key 1 to put it back how it was`
								]
							]
						]
					]
				],
				"rotate settings": [
					`various settings related to the rotate and tilt pose tools.`,
					`round: affects how angles are rounded. the default, ` + aa.control.rotate.round + `, makes sure angles are always rounded to the nearest ` + (360/aa.control.rotate.round) + ` degrees.`,
					[
						`it sounds unnecessary, but having it off is pretty annoying.`,
						`changing it to 0 will disable it.`
					],
					`curl: when this is on, rotations will be multiplied along a branch of parts.`,
					[
						`like if you rotate a finger 10 degrees, the first segment will rotate 10 degrees, the second will rotate 20 degrees, the third will rotate 30 degrees. it has a sort of curving effect.`,
						`useful for curling fingers, and...`,
						`uhh... doing a bicep flex? just curling fingers, pretty much.`,
						`indispensable for hand posing.`
					],
					`true/local/custom: refers to what kind of axes it rotates around.`,
					[
						`true: the axes you'd expect. xy, xz, yz.`,
						`local: the axes of the part's current orientation.`,
						[
							`you can think of orientation as what direction right is for the part, what direction down is, what direction forward is... rotations move those directions, right?`,
							`local makes it so it rotates around those directions.`,
							`another way to think of it is that it's like the part is completely unoriented, like how it is in the default pose.`,
							`this is useful for things like jaws, or elbows. jaw movement is just a yz rotation. but <i>only</i> a yz rotation. and that's impossible to do if you already did xy rotation or something on the head.`,
							`but if you switch to local, yz rotation still matches the jaw's proper rotation axis.`,
							`unimportant technical detail: for mirrored symmetry parts, (ex: r_shoulder, but not l_shoulder) the x axis is inverted to point in the opposite direction, cancelling out how their orientations start out x-mirrored. technically that's sorta inconsistent, but it's more intuitive.`
						],
						`custom: custom rotation axes, set with the bottom two columns of buttons.`
					],
					`axis setting buttons (bottom right column)`,
					[
						`x, y, z: sets which axis the buttons change.`,
						`parent: the selected axis imitates the angle from the selected part to its parent.`,
						`child: it imitates the angle to the selected part's first child.`,
						`cross: an angle perpendicular to the other two axes. (can't be used if the other two axes are identical or point in perfectly opposite directions.)`,
						`true: the true axis.`,
						`local: the local axis of the selected part.`,
						`written: prompts you to enter an angle yourself.`
					],
					`invert: makes the selected axis point in the opposite direction.`,
					`switch: switches two of the axes.`,
					`invert, switch, and the axis setting buttons only apply to the custom axes.`,
					`using an axis setting button makes it select the next axis. this way, you can quickly set all three axes by just clicking three times.`,
					`parent, child, and cross are especially useful for increasing or decreasing angles between parts. like for an elbow, or a knuckle.`,
					[
						`local axes can do this too, but that's dependent on orientation matching their position. (maybe you don't bother always using rotate/tilt if the part is just a sphere or whatever.)`,
						`select the part, choose custom, select the x axis, then...`,
						`click parent, child, and cross.`,
						`the z axis will be made into something that opens or closes the elbow/knuckle.`
					]
				],
				"posescript": [
					`lets you edit poses through text, for precision. breaking down the steps helps you understand a pose better too, or modify it.`,
					`there are also a few actions that can only be done with posescript. somewhat niche actions, or actions that require too much user input.`,
					`there are targets, and actions done to those targets.`,
					`lines with a colon set the target. other lines and content after the colon are actions done to it.`,
					`list of targets, and the actions that can be used on them: (actions that can only be done with posescript are marked with stars.)`,
					[
						`"part " + part name: used for actions done to a part. mostly, the same things the pose tools do.`,
						[
							`details about targeting`,
							[
								`you can edit multiple parts at once by using "branch" instead of "part", or any other word there's a hide button for, like "body" or "body-branch".`,
								`you can write "." + [part name] as shorthand for "part " + [part name], and ".." + [part name] as shorthand for "branch " + [part name].`,
								[
									`there can be space between the periods and the part name, or there can be none. i'll work either way. so, if for some reason a part name starts with a period, add a space to keep that period from turning it into a branch selection.`
								],
								`you can combine multiple part selections by separating them with commas. (ex: ".l_shoulder, .r_shoulder: +90 yz" will raise both arms.)`
							],
							`angle + " " + axis: rotate or tilt`,
							[
								`the angle should be measured in degrees.`,
								`axis should be "xy", "xz", or "yz".`,
								`write "tilt " at the beginning to make it tilt instead of rotate.`,
								`if you write these words after the axis, it'll cause the following changes: (you can write multiple.)`,
								[
									`true: uses the true axes, even if rotate settings is currently set to use local or custom.`,
									`local: uses the local axes, even if rotate settings is currently set to use true or custom.`,
									`custom: uses the custom axes, even if rotate settings is currently set to use true or local.`,
									`curl: uses curl, even if that's turned off in rotate settings.`,
									`!curl: doesn't use curl, even if that's turned on in rotate settings.`,
									9734,
									`inc(): list parts in the parentheses. only those parts and their descendants will have their position and shape rotated.`,
									9734,
									[
										`for example, ".manubrium: +30 xy inc(l_shoulder)" will only rotate the left arm and shoulder, with the right being unaffected.`,
										`short for "include".`
									],
									9734,
									`exc(): list parts in the parentheses. those parts and their descendants won't have their position or shape rotated.`,
									9734,
									[
										`for example, ".pelvis: -90 yz exc(l_hip, r_hip)" would make the armature bow, without moving the legs.`,
										`short for "exclude".`
									]
								]
							],
							`"[" + [three coordinates, separated by commas] + "]": move or deform`,
							[
								`write "+" or "-" in place of one of the coordinates to use move instead of deform.`,
								`if you put a % directly after the closing bracket, the coordinates are multiplied by the hypotenuse of the part.`,
								[
									`for example, "[0, -1/2, +]%". the resulting x coordinate will be zero, the y coordinate will be the part's hypotenuse times -1/2, and the z coordinate will be whatever positive amount keeps the hypotenuse about the same.`,
									`the point is that if you use this system, the operation has similar effects between different bodies.`,
									`as usual, it uses the hypotenuse in the default pose.`,
									`the oddness is kept the same as it was before. if you double the %, it snaps to the nearest .5 instead.`
								],
								`deform operations are assumed to be a relative change, meaning the coordinates are added to the coordinates it already has.`,
								`move operations are assumed to be an absolute change, meaning the coordinates <i>replace</i> whatever coordinates it already has.`,
								`add these words to the end to cause the following changes:`,
								[
									`move operations`,
									[
										`rel: makes it relative instead of absolute.`,
										`currlength: does the same thing as the inverted move pose tool, meaning it uses the part's current distance from its parent, rather than the distance they have in the default pose.`,
										[
											`this also applies to the % modifier.`
										]
									],
									`deform operations`,
									[
										`abs: makes it absolute instead of relative.`,
										`disjointed: does the same thing as the inverted deform pose tool, meaning the part's descendants stay where they are instead of following.`
									]
								]
							],
							`[view number] + " [" + [two coordinates, separated by a comma] + "]": perspective`,
							[
								`just like move/deform, it's assumed to be adding to the existing coordinates, not replacing them. write "abs" after the coordinates to make it an absolute change.`,
							],
							`"stretch " + [number]: changes stretch`,
							`"widen " + [number]: changes widen`,
							`"reset": resets the part.`,
							[
								`if "branch" is written after, it'll reset the part and all its descendants.`,
								9734,
								`if "desc" is written, it'll reset only its descendants.`,
								9734,
								`if "coor" and/or "orient" is written after, parts will have just their coordinates and/or orientation reset, instead of resetting all properties.`
							],
							`"mirror x", "mirror y", "mirror z"`,
							`"hide", "show"`
						],
						`"all": allows the same actions as part, except they're applied to all parts.`,
						`"rotate": used for actions that edit the rotate settings.`,
						[
							`"true", "local", "custom": changes which axes rotate/tilt uses`,
							`"curl", "no curl": turns curl on/off`,
							`axis + " = " + something: edits custom axes`,
							[
								`just like the buttons, there's "parent", "child", "cross", "true", "local", and "written".`,
								`"parent", "child", and "local" require writing a part name after.`,
								`"written" requires writing coordinates after. (bracketed and separated by commas, like move/deform coordinates.)`,
							],
							`"invert " + axis: custom axis inverting`,
							`"switch " + [axis 1] + " " + [axis 2]: custom axis switching`,
							9734,
							`axis naming`,
							9734,
							[
								`this is a feature exclusive to local rotate. it only works while local rotate is on.`,
								`conceptualizing body movement as xy/yz/xz rotations is difficult because without visual feedback, it's hard to understand what each axis does for each part, and which direction is positive and which direction is negative.`,
								`this system fixes that by letting you assign names to parts' axes, and an opposite name that will inverse the rotation.`,
								`here's an example action: "rotate: open/close = +xy(.l_elbow) -xy(.r_elbow) +yz(.l_knee, .r_knee)"`,
								[
									`"open" is the name being assigned.`,
									`those sets of parentheses assign it to specific parts and axes.`,
									[
										`"-xy(.l_elbow)" means that a rotation like ".l_elbow: 30 open" means to rotate +30 degrees xy.`,
										`"+xy(.r_elbow)" is the same. the sign is opposite of l_elbow's sign because it's the mirrored counterpart, so the direction for opening is the opposite of what it is for l_elbow.`,
										`"+yz(.l_knee, .r_knee)"... you get the idea. positive yz rotations open the knee.`,
									],
									`the contents of parentheses follow the same syntax as part-targeting.`,
									`"close" is the opposite name. if this name is used, the angle is inverted. "30 close" would be equivalent to "-30 open".`,
									`you can also write an "except()" set of parentheses. any parts listed inside, effects previous parentheses had on them will be reversed. (for example, "raise/lower = -yz(all) except(.pelvis, .midsection) +yz(..manubrium, ..l_hip, ..r_hip)".)`
								],
								`ideally, you should try to have a name for every axis of every part, unless rotating in that axis is rare or impossible.`,
								[
									`it help you understand what your rotations are doing,`,
									`it marks unnamed axes as abnormalities. for example, elbows should pretty much only do xy rotations. elbows are a hinge, not a ball-and-socket joint. if you try to perform a yz rotation on the elbow, that's likely a mistake, so it should stick out from conventions to make it easier to notice.`,
									`i also leave the pelvis and midsections' axes unnamed. rotation of the pelvis is rotation of the whole body, so it should be thought of geometrically. and the same is true for the midsection, since rotation doesn't represent actual muscle movement, just "based on the position and direction of the pelvis and torso, it should be something like this".`
								],
								`only one name can be assigned to a given part-axis combination. (one name and one opposite-direction name, i mean.) if a new name is assigned to the elbow's xy axis, open/close will be overwritten.`,
								`axis naming can make scripts a little shorter, too. for example, if you write "in/out = -xy(..l_shoulder, ..l_hip) +xy(..r_shoulder, ..r_hip)" to define inward xy rotations as "in" and outward xy rotations as "out", you can write ".l_hip, .r_hip: 10 in" would rotate both legs inward, whereas normally you'd need to write ".l_hip: -10 xy" and ".r_hip +10 xy".`,
								`defining axis names doesn't prevent you from using the typical xy/yz/xz names.`
							]
						],
						`"frame": used for actions involving the frame system. does the same things the frame buttons do.`,
						[
							`"prev", "next"`,
							`"blank", "duplicate", "delete", "move up", "move down"`,
							`[any number]: jumps to that frame.`,
							9734,
							`if you enter a number after any of these except clear or the frame jump, the action is done multiple times. for example, "frame: duplicate 3" is like clicking the duplicate button three times.`
						],
						`"tween": used for actions involving inbetweens.`,
						[
							`"curve " + number: changes the curve.`,
							[
								`if you write "sine" instead of a number, it'll set it as the square root of 3.`
							],
							`"ease in", "ease out", "ease in-out", "ease out-in": sets the ease type.`,
							`[any number]: sets the number of inbetweens.`,
							`"create", "apply"`,
							[
								`if you write an ease type and/or a number after it, it'll use that ease type and/or number of inbetweens, without changing the settings. (for ease types, don't include the word "ease". write "in", not "ease in".)`,
								9734,
								`if you write a bracketed list of numbers, you can set your own inbetween values.`,
								9734,
								[
									`like "tween: create [1/8, 1/4, 1/2]", if you prefer that over "perfect" computer ease numbers`,
									`numbers below 0 or above 1 are accepted. "frame: 1", "tween: create [9/8]", "frame: prev 2", "tween: create" would add some overshoot.`
								]
							]
						],
						9734,
						`"scene": used for actions that involve all parts.`,
						9734,
						[
							`any use of "stem" here means parts that don't have any parent. like the pelvis. every body is built around a stem.`,
							/*
							`"rotate " + angle + " " + axis: rotates all bodies.`,
							[
								`equivalent to doing part rotation for every stem, and also rotating the stems' positions.`,
								`by default, the fulcrum is [0, 0, 0], but you can choose your own fulcrum by writing a three-coordinate point in brackets, after the axis. you can also write a part name to use that part's absolute position.`
							],
							//*/
							`"[" + [three coordinates, separated by commas] + "]": shifts the scene. moves all bodies.`,
							`"mirror " + axis: mirrors all bodies.`,
							[
								`equivalent to using the part mirror for every stem, and also mirroring the stems' positions.`,
								`by default, it mirrors around 0 x/y/z, but you can choose your own mirror line by writing a number after the axis. you can also write a part name to use that part's absolute coordinate for the given axis.`
							]
						],
						9734,
						`"time": used for actions that involve all frames.`,
						9734,
						[
							`"clear": deletes all frames, leaving just one blank frame.`,
							`"hide(" + [list of parts] + ")": hides parts on all frames. (the list syntax is the same as part targeting's syntax.)`,
							[
								`if no parenthesed list is included, it'll hide all parts.`
							],
							`"show(" + [list of parts] + ")": shows parts on all frames. works just like hide.`,
							`"correct ap": deals with a certain flaw of autoperspective.`,
							[
								`a part's position in 3d space affects the autoperspective offset it's given.`,
								`but in rare cases, these changes can come at very awkward and ugly timing. (and "rare" isn't that rare considering a humanoid armature has 22 parts, there's four views, and there's who knows how many frames.)`,
								`for example, a walk has the legs swinging forward and back. the forward and back movement could easily cause changes in the x perspective coordinate, even though the parts aren't moving in the x axis at all. that makes visual sense if it changes right in the <i>middle</i> of the movement... but what if you're unlucky and it only crosses the threshold on the frame where it's as close to the camera as it gets? that doesn't look like perspective. that just looks like it's tweaking out for no reason.`,
								`basically, if an animation looks weird, but only when perspective is on, the flaw is likely something along those lines. this can fix it.`,
								`as for the technical details of what it does... (this is probably only worth reading if you're trying to figure something out.)`,
								[
									`for both axes of every view, for every part, for every frame...`,
									`it looks at the version of it on the previous frame and the next frame.`,
									`if all three use autoperspective, and before that's applied, all of them have the same coordinate for the given axis...`,
									`<i>but</i> after autoperspective is applied, both neighboring frame's coordinate are different from the frame in question, one pixel off in the same direction...`,
									`then it concludes that this is one of those weird coordinates that looks janky, and that's fixed by having it imitate the neighboring frames.`
								],
								`add "unlooping" if the animation doesn't represent any kind of looping motion like walking. it'll avoid running this process for the first and last frame.`
							]
						]
					],
					`for all rotate-related commands, you can use one letter or two. (ex: "xy" and "z" both refer to the same axis.)`,
					`you can write multiple actions in one line by separating them with commas. (ex: "l_hip: reset branch, -5 xy")`,
					`you can write comments with //. everything after a // is ignored.`,
					`no matter what rotate settings and the inbetween settings are like before the script is run, it assumes they're how they are by default. that way, scripts always do the same thing.`,
					`frame and tween actions change which frame it's on the same way the buttons do. if you make a new frame, it'll go to that frame. if you do "frame: prev" on the first frame, it'll go to the last frame. if you make or apply tweens, it'll go to the end key.`
				],
				"animation and exporting": [
					`below the ui buttons is the animation system.`,
					[
						`this lets you convert animations into spritesheets, play them, and save the spritesheet or individual frames.`,
						`click the "update" button to update the animation images.`,
						`the "one view\" checkbox lets you send just the currently selected view, instead of the full multiview.`,
						`if the "vertical" checkbox is checked, the spritesheet is set up so y is the time axis and x is the direction axis. if it's unchecked, it's the opposite.`,
						`generally, multiview spritesheets look better with vertical on, and one-view spritesheets look better with it off. so, checking/unchecking one view will check/uncheck vertical as well. (checking/unchecking vertical will not check/uncheck one view.)`
					],
					`closely related to this is the "pixel art transfer" area of the ui. this lets you send images to the pixel art tool.`,
					[
						`you can send a frame, an animation, or all animations.`,
						[
							`"all x" lines up the animations in a row. "all y" lines them up in a column.`
						],
						`the "one view" and "vertical" checkboxes are linked to the checkboxes in the animation system. checking or unchecking them is the same as checking/unchecking the checkboxes down there.`,
						`the animations are updated before they're sent.`,
						`they can be sent through "paste" or "replace".`,
						[
							`"paste" saves it to the pixel art tool's paste tool, meaning you can place the image anywhere you want.`,
							`"replace" replaces the pixel art image entirely.`,
						],
						`all exports have borders drawn around them, marking the borders between frames, and where standpoint is.`,
						[
							`it uses whatever the "forecolor" and "backcolor" currently are in the pixel art tool.`
						],
						`for "all x" and "all y", the names of the animations are written as well.`
					]
				],
				"keymap": [
					`w, a, s, d: lets you switch pose tools and frames.`,
					`shift+a, shift+d: change which view you have selected. (relevant to buttons that edit perspective images or perspective coordinates, and the "update animation" button.)`,
					`e: inverts or uninverts the pose tool.`,
					`q, shift+q: switches to/from the image editor, with or without exporting.`,
					`t, f, g, h: selects parts by moving through the family structure. t selects the parent of the current part, g selects the first child of the part, and f and h cycle through siblings.`,
					`j, i, k, o, l: frame actions (blank, duplicate, delete, etc)`,
					`ctrl+z, ctrl+shift+z: undo, redo`,
					`ctrl+s, ctrl+o: save, load`,
					`z, x, c, v, b, n: pose tools`,
					`\\: posescript`,
					`the number keys are draw settings toggles. when shifted, they're hide toggles.`
				],
				"etc": [
					`the part information window shows which properties are different from the default pose by marking them with a !. click that line of the window to reset that property to default.`,
					`oddify makes it so the part is centered on a .5 coordinate instead of a .0 coordinate, and vice versa. the images are edited to match, so the center row/column(s) might be deleted or expanded. it can also be used in perspective mode, to affect perspective offset.`,
					`when changing something like the cell dimensions or vanishing point, you can leave a spot empty to leave it how it is. (for example, entering "72," for the cell dimensions would set the width as 72 and leave the height unchanged.)`,
					`you can load files by drag-and-dropping them onto the multiview canvas, or with ctrl+o.`,
					`if multiple nodes are on the same screen position, clicking it will select whichever one is closest to the camera. the text below the multiview shows the name of the part you're about to click.`,
					//`"refresh shape": if images based on 3d shapes aren't updating properly, this might fix it? (by clearing the image cache.) but that really shouldn't happen, so let me know if it does!`,
					`in the part information and rotate settings axis displays, if an axis line looks "incomplete", that means the axis points backward.`,
					`"pose to shape" converts a pose into a shape, with the option to scale it up/down. this is very useful for hands. (in another tab, use the hand bodytext and pose it, then use pose to shape to get a shape that can be used for the humanoid pose's hands.) silhouette properties decide how the shapes are combined.`,
					`if there are performance issues:`,
					[
						`lower the state limit and truncator. (every state stores every frame's pose, and depending on how many animations you have, it can store a lot of states. the maximum amount it could be storing is limit + (number of animations - 1) * (2*truncator + 1).)`,
						`turn off silhouettes`,
						`create perspectived/unperspectived images so it doesn't have to convert shapes. (i went through a lot of caching hell to avoid this process slowing things down, but it still runs every time orientation or anything like that changes.)`,
						`lower fineness`
					],
					/*
					//`if you switch to the image editor while using the perspective pose tool, you'll only edit how it looks in the current view, while perspectived. you can use this to make a part bigger or smaller depending on how far it is from the camera.`,
					//`if you write a part name at the beginning of a shape point group, or a part name + a colon before a point, that group/point will follow the orientation and scaling of the named part, instead of the part the shape is part of. (this is useful for certain anatomy, like elbows.)`,
					//`if you type a negative number for the inbetween curve factor, the positions will be somewhat random.`,
					`"create inbetweens" creates new frames between the current frame and the next frame that act as a bridge between the two. "apply tweening" modifies existing frames instead. (ex: if you're on frame 2 and you "create" 5 inbetweens, it'll insert 5 inbetweens that start like frame 2 and end like frame 3. if you "apply" instead, existing frames 3-7 will be made into inbetweens for frames 2 and 8.)`,
					`when you use create or apply tweening, it doesn't do anything for parts that are hidden on the starting pose. for "create", those parts will stay like how they are in the starting pose the whole way through. for "apply", they'll stay how they were before. this is what makes "apply" tweening useful: you can keep the poses mostly the same while only tweening one character, one limb, etc.`
					*/
					`if there's anything you don't get after reading this, <a href="mailto:barky11111@gmail.com">email</a> me about it. i'll try to explain it, and incorporate that explanation into the manual.`,
					`same for bug reports. check the to-do thing first though, i might know about it already.`,
					`feature requests are also welcome.`
				],
				"posing tips": [
					`local rotation is a little difficult to understand at times, but if you want complex poses, you should almost always use it. particularly in posescript.`,
					[
						`let's say you have a hand pose where the fingers are spread out, the fingers sorta banana backward to convey tension, and the thumb is moved to match.`,
						`if you stick to local rotation, those three tenets of the pose can happen in any order, and will achieve about the same result.`,
						`this makes it very easy to stitch together new poses from pieces of old poses, or make small changes without having to rewrite much. for example, switching out the finger spread with rotations that close the fingers instead.`,
						[
							`when you have the freedom to switch out components like "reaching arm back as if to throw something or punch", posing gets faster the more poses you've done.`
						],
						`local rotation also keeps the orientation from looking wrong.`,
						`both of these are because local rotation is the closest to how joints operate in real life. they rotate on axes that, themselves, are rotated by previous rotations from parent/ancestor parts, or their own rotations. the xy axis of the shoulder's rotation only aligns with the true xy axis if the shoulder itself hasn't been affected by rotations. an ideal, perfectly rigid rotation system would only allow local rotation, with no move or deform either.`
					],
					`posescript tips`,
					[
						`during the trial-and-error process of posing through posescript, it helps to put "all: reset" at the top of the script. that way, you don't have to hit undo between tries, and you can look at the results of previous tries through undo/redo.`,
						[
							`or for animations, "time: clear".`,
							`the "header" samples include this.`
						],
						`make use of the axis-naming system, starting from the names the "header" samples give you. it makes script actions much easier to understand.`,
						`use comments to label what each chunk of your script does. it makes it easier to reuse those chunks in other poses.`,
						`use empty comment lines for important divisions of the script, like the divide between the header and the rest of the script, before you switch frames and start editing a new pose, or before you start making tweens of all the frames at the end.`
					],
					`non-technical tips`,
					[
						`if a pose looks stiff, that means not enough parts are moving.`,
						[
							`the shoulders aren't moved. shoulders don't just rotate, they move. a lot of movements start at the manubrium, not the shoulder.`,
							`the torso is oriented the same way as the pelvis. for energetic poses, there's usually at least a little bit of twist between them.`,
							`the pelvis, and by extension, the position of the hips, has no xy or xz rotation. if either foot leaves the ground or either leg is moving forward or backward, there should probably be a little rotation.`,
							`for expressive poses, the head should move. rotating xy a little, looking up/down, looking to the side.`
						],
						`for poses that involve the legs, try rotating them inward a little.`,
						[
							`".l_hip: -5 xy", ".r_hip: +5 xy"`,
							`whether they're lifted or moved forward/backward, moving either leg from a typical standing position makes the pose less stable, so they naturally move inward a little to compensate.`
						],
						`try to avoid completely horizontal or completely vertical lines in the skeleton. it looks less interesting, and it can also be a sign of parts that should be moving but aren't.`
					]
				],
			}, "manual");
			string += [
				`<details>`,
				`\t<summary>bodytext</summary>`,
				`\t<button id="aa_bodychanges">apply changes</button> <select id="aa_bodychoices"></select>`,
				`\t<br><textarea id="aa_bodytext" cols=48></textarea>`,
				`</details>`
			].join(`\n`);
			string += [
				`<details>`,
				`\t<summary>posetext</summary>`,
				`\t<button id="aa_allframes">show ` + (aa.control.all_frames_posetext ? `one frame` : `all frames`) + `</button>`,
				`\t<br><button id="aa_posechanges">apply changes</button>`,
				`\t<br><textarea id="aa_posetext" cols=48></textarea>`,
				`</details>`
			].join(`\n`);
			string += `\n<div id="aa_editmodetrue">`;
			string += `\n<div id="aa_editmodetrue_active">`;
			let ref = aa.pa.ctx;
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aapa_" + i1;
					if(["front", "ui"].includes(i1)) {
						string += `<br>`;
					}
					else if(i1 === "right") {
						string += ` `;
					};
					string += `<canvas id="` + id + `"></canvas>`;
					if(i1 === "right") {
						string += `</div>`;
						// end active area
					};
				}
			};
			loop.end();
			string += `\n</div>`;
			// end editmodetrue div
			//
			string += `\n<div id="aa_editmodefalse">`;
			string += `\n<div id="aa_editmodefalse_active">`;
			ref = aa.ctx;
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aa_" + i1;
					string += `\n`;
					if(i1 !== "ui") {
						string += `<br>`;
					};
					string += `<canvas id="` + id + `"></canvas>`;
					if(i1 === "main") {
						string += `<div id="aa_div_coor"></div>`;
						string += `</div>`;
						// end of active div
					}
				}
			};
			loop.end();
			string += `</div>`;
			// end of editmodefalse div
			string += `<br>`;
			// data text
			string += "\n" + [
				`<dialog id="aa_editshape_dialog" autofocus>`,
				`enter new text to define the shape.`,
				`<br><textarea id="aa_editshape_input" cols=32></textarea>`,
				`<br><button id="aa_editshape_enter">enter</button>`,
				`<button id="aa_editshape_close">close</button>`,
				`</dialog>`
			].join("\n");
			ref = aa.sample_posescripts;
			let temp = "";
			for(i1 in ref) {
				if(ref.hasOwnProperty(i1)) {
					temp += temp ? "\n" : "";
					temp += "<details id=\"aa_posescript_samples_" + i1 + "\">";
					temp += "\n\t<summary>samples (" + i1 + ")</summary>";
					temp += "\n\t<ul>";
					if(ref[i1].hasOwnProperty("multi-frame header")) {
						ref[i1]["multi-frame header"] = ref[i1].header.replace("all: reset", "time: clear");
					};
					let bool = false;
					for(i2 in ref[i1]) {
						if(ref[i1].hasOwnProperty(i2)) {
							temp += "\n\t" + (bool ? "<br>" : "") + "<button>" + i2 + "</button>";
							bool = true;
							//
							if(!i2.endsWith("header")) {
								let headername = i1 === "humanoid" ? i2 === "walk" : false;
								headername = (headername ? "multi-frame " : "") + "header";
								if(ref[i1].hasOwnProperty(headername)) {
									ref[i1][i2] = ref[i1][headername] + ref[i1][i2];
								};
							}
						}
					}
					temp += "\n\t</ul>";
					temp += "\n</details>";
				}
			}
			string += "\n" + [
				`<dialog id="aa_posescript_dialog" autofocus>`,
				`enter posescript code and click enter to execute it.`,
				temp,
				`<br><textarea id="aa_posescript_input" cols=64></textarea>`,
				`<br><button id="aa_posescript_enter">enter</button>`,
				`<button id="aa_posescript_close">close</button>`,
				`</dialog>`
			].join("\n");
			string += "\n" + [
				`<dialog id="aa_posetoshape_dialog" autofocus>`,
				`<textarea id="aa_posetoshape_text" cols=32></textarea>`,
				`<br><button id="aa_posetoshape_close">close</button>`,
				`</dialog>`
			].join("\n");
			string += `\n<div id="aa_animator_div"></div>`;
			//
			document.getElementById("aa_div").innerHTML = string;
			//
			aa.div.editmodetrue_active = document.getElementById("aa_editmodetrue_active");
			// the _active divs are used to make sure the height of
			// the active area is always the same, so the ui doesn't
			// jump around when you switch modes.
			aa.div.editmodetrue = document.getElementById("aa_editmodetrue");
			// hide everything in the part artist inside a div.
			aa.div.editmodetrue.hidden = true;
			ref = aa.pa.ctx;
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aapa_" + i1;
					let canvas = document.getElementById(id);
					canvas.style["image-rendering"] = "crisp-edges";
					ref[i1] = canvas.getContext("2d");
					if(i1 === "ui") {
						//canvas.addEventListener("mousedown", aa.pa.ui.mousedown);
						canvas.onpointerdown = aa.pa.ui.mousedown;
					}
					else {
						//canvas.addEventListener("mousedown", aa.pa.mousedown);
						//canvas.addEventListener("mousemove", aa.pa.mousemove);
						//canvas.addEventListener("mouseup", aa.pa.mouseup);
						canvas.onpointerdown = aa.pa.mousedown;
						canvas.onpointermove = aa.pa.mousemove;
						canvas.onpointerup = aa.pa.mouseup;
					}
				}
			};
			loop.end();
			//
			for(i1 = 0; i1 < 2; i1++) {
				loop.tick(1);
				let ref = aa.pa.part[i1 ? "right" : "front"];
				let temp = aa.pa.part.rect(i1);
				temp = temp.w*temp.h;
				for(i2 = 0; i2 < temp; i2++) {
					loop.tick(2);
					ref[i2] = 0;
				};
				loop.end();
			}
			loop.end();
			// the initial defining has the image as an empty array. this
			// multiplies the right dimensions to create an array of zeroes, of
			// the right length
			aa.pa.redraw();
			aa.pa.ui.create();
			aa.pa.ui.draw();
			// aa.pa initialized.
			//
			ref = aa.ctx;
			aa.div.editmodefalse = document.getElementById("aa_editmodefalse");
			// enclose it all in another div, so it can switch which one is
			// hidden.
			aa.div.editmodefalse_active = document.getElementById("aa_editmodefalse_active");
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aa_" + i1;
					let canvas = document.getElementById(id);
					canvas.style["image-rendering"] = "crisp-edges";
					ref[i1] = canvas.getContext("2d");
					if(i1 === "ui") {
						//canvas.addEventListener("mousedown", aa.ui.mousedown);
						canvas.onpointerdown = aa.ui.mousedown;
					}
					else {
						//canvas.addEventListener("mousedown", aa.mousedown);
						//canvas.addEventListener("mousemove", aa.mousemove);
						//canvas.addEventListener("mouseup", aa.mouseup);
						canvas.onpointerdown = aa.mousedown;
						canvas.onpointermove = aa.mousemove;
						canvas.onpointerup = aa.mouseup;
						canvas.onpointerleave = function(e) {
							aa.pasteimages(true);
							aa.pasteimages(false);
							aa.writecoordinates(null);
						};
						// like mouse events, except they work for phones and
						// drawing tablets.
						canvas.style["touch-action"] = "pinch-zoom";
						// this keeps it from sliding around when you're using a
						// phone.
						AAX.dragndrop(canvas, aa.readfile);
						// lets you load things by dropping files onto the
						// canvas.
					}
				}
			};
			loop.end();
			aa.div.coor = document.getElementById("aa_div_coor");
			aa.div.coor.style["text-shadow"] = "silver .5px .5px";
			aa.div.coor.style["font-size"] = "8px";
			aa.writecoordinates(null);
			temp = document.getElementById("aa_bodytext");
			temp.value = aa.bodytext;
			textarea_autosize(temp);
			temp.onkeydown = function(e) {
				textarea_tab(e);
				textarea_autosize(e);
			};
			temp.rows = temp.value.split("\n").length;
			temp.style["-moz-tab-size"] = 4;
			temp.style["vertical-align"] = "top";
			temp = document.getElementById("aa_posetext");
			temp.rows = temp.value.split("\n").length;
			temp.style["-moz-tab-size"] = 4;
			temp.style["vertical-align"] = "top";
			string = [];
			for(i1 in AAX.Body.templates) {
				if(AAX.Body.templates.hasOwnProperty(i1)) {
					string[string.length] = `<option value="` + i1 + `">` + i1 + `</option>`;
				}
			}
			string = [
				`<option value="current">current</option>`,
				`<hr>`
			].concat(string).concat([
				`<hr>`,
				`<option value="custom">custom</option>`
			]);
			temp = document.getElementById("aa_bodychoices");
			temp.innerHTML += `\n\t` + string.join(`\n\t`) + `\n`;
			temp.onchange = function() {
				let name = document.getElementById("aa_bodychoices").value;
				let ref = document.getElementById("aa_bodytext");
				if(name === "current") {
					ref.value = aa.bodytext;
					textarea_autosize(ref);
				}
				else if(AAX.Body.templates.hasOwnProperty(name)) {
					ref.value = AAX.Body.templates[name];
					textarea_autosize(ref);
				}
				else if(name !== "custom") {
					console.log("this shouldn't happen");
				}
			};
			document.getElementById("aa_bodytext").onkeyup = function() {
			// using keyup instead of change, since this changes the bodychoices
			// selection, and the bodychoices selection edits the body textarea.
			// that could cause an infinite loop.
				let value = document.getElementById("aa_bodytext").value;
				let options = document.getElementById("aa_bodychoices").options;
				let bool = false;
				let select = "custom";
				if(value === aa.bodytext) {
					select = "current";
				}
				else {
					for(let i1 = 0; i1 < options.length && select === "custom"; i1++) {
						let name = options[i1].innerHTML;
						if(name !== "custom" && name !== "current" && value === AAX.Body.templates[name]) {
							// if the body textarea matches the value of an option,
							// select that option.
							select = name;
						}
					}
				}
				document.getElementById("aa_bodychoices").value = select;
			}
			document.getElementById("aa_bodychanges").addEventListener("pointerdown", function() {
				let text = document.getElementById("aa_bodytext").value;
				let body = AAX.Body.new(text);
				if(typeof body !== "object") {
				// errors from invalid input
					alert(body);
				}
				else if(confirm([
					`if you change the body text, the poses will be edited to fit the new body.`,
					`- ALL UNDO/REDO HISTORY will be cleared.`,
					`- all poses will be converted to a blank pose, carrying over whatever it can from the old version of itself. (properties, what the coordinates' length and angle are relative to how they are in the default pose)`,
					`continue?`
				].join(`\n\n`))) {
					let i1 = 0;
					let i2 = 0;
					let i3 = 0;
					let old_rel = AAX.all_rel(aa.body);
					let old_abs = AAX.all_abs(aa.body);
					// the coordinates every part had in the old body's default
					// pose
					let old_body = aa.body;
					aa.bodytext = text;
					aa.body = body;
					if(aa.body.hasOwnProperty("head")) {
						aa.drawsettings.vp.y = aa.drawsettings.standpoint.y + AAX.abscoor(aa.body, "head")[1];
					};
					// set the camera at eye level
					for(i1 = 0; i1 < aa.anims.length; i1++) {
					// for every frame of every animation, edit the coordinates
					// to be like they're derivative of the new body instead of
					// the old body.
					// - don't use the anim_index setter. it'd be convenient in
					//   some ways, but that makes it use AAX.posefromobj with
					//   the new body instead of the old. that causes errors if
					//   the structure is different.
						let anim = aa.anims[i1];
						anim.states = [ anim.states[ anim.state_index ] ];
						anim.state_index = 0;
						// delete undo/redo history (i don't think it'd cause
						// problems if i converted it like everything else, but
						// it's wasteful to bother with every state when most of
						// them won't be used.)
						// - most importantly, the body change itself doesn't
						//   fit in the undo/redo system at all, so... there's
						//   not much point in previous states if they still
						//   have the biggest possible change applied despite
						//   being before it.
						let poseobjs = anim.states[ anim.state_index ].poseobjs;
						for(i2 = 0; i2 < poseobjs.length; i2++) {
							let pose = AAX.posefromobj(aa, old_body, poseobjs[i2]);
							// they have to be AAX.Parts at the time, or
							// coordinate setters and stuff like abscoor won't
							// run.
							let old_odd = AAX.all_abs(pose);
							for(i3 in old_odd) {
								if(old_odd.hasOwnProperty(i3)) {
									old_odd[i3] = [
										!!(old_odd[i3][0]%1) !== !!(old_abs[i3][0]%1),
										!!(old_odd[i3][1]%1) !== !!(old_abs[i3][1]%1),
										!!(old_odd[i3][2]%1) !== !!(old_abs[i3][2]%1)
									];
								}
							}
							let old_pose_rel = AAX.all_rel(pose);
							//
							let oldpose = AAX.poseobj(pose);
							// non-default stuff in the old pose
							let newpose = AAX.poseobj(aa.newpose());
							// default pose of the new body
							for(i3 in oldpose) {
								if(oldpose.hasOwnProperty(i3) && newpose.hasOwnProperty(i3)) {
								// copy properties, but only for parts shared
								// between old and new
									delete oldpose[i3].cache;
									// cache is obsolete after the body change
									let relcoor = AAX.relcoor(newpose[i3]);
									delete oldpose[i3].x;
									delete oldpose[i3].y;
									delete oldpose[i3].z;
									// these would overwrite the relative
									// coordinates. it needs to start from the
									// new body's default pose. the coordinates
									// part of the pose will be done in
									// AAX.bodychange.
									newpose[i3] = structuredClone(oldpose[i3]);
									newpose[i3].x = relcoor[0];
									newpose[i3].y = relcoor[1];
									newpose[i3].z = relcoor[2];
								}
							}
							poseobjs[i2] = AAX.bodychange(aa, aa.body, newpose, old_rel, old_pose_rel, old_odd);
							// copy the coordinate parts of the pose
							//console.log(objectdifference(logging, AAX.poseobj(pose)));
							if(i1 === aa.anim_index) {
								aa.frames[i2] = aa.posefromobj(poseobjs[i2]);
							};
						}
					}
					//aa.loadstate(aa.state_index, true);
					if(!aa.body.hasOwnProperty(aa.control.partname)) {
					// can't have partname be a part that doesn't exist anymore.
						let done = false;
						for(i1 in aa.body) {
							if(aa.body.hasOwnProperty(i1) && !done && aa.body[i1].parent === "standpoint") {
								aa.control.partname = i1;
								done = true;
							}
						}
						if(!done) {
							console.log("this shouldn't happen");
						}
					}
					aa.refresh("states");
					// it'd be redundant to make a new state.
				};
			});
			document.getElementById("aa_posechanges").addEventListener("pointerdown", function() {
				let text = document.getElementById("aa_posetext").value;
				if(aa.control.all_frames_posetext) {
					text = text.split("\n***\n");
					aa.frames = [];
					for(let i1 = 0; i1 < text.length; i1++) {
						aa.frames[i1] = aa.texttopose(text[i1]);
					};
					aa.clampframe();
				}
				else {
					aa.frames[aa.currframe] = aa.texttopose(text);
					// can't use currpose because that's just a getter.
				};
				aa.refresh();
			});
			document.getElementById("aa_allframes").addEventListener("pointerdown", function(e) {
				aa.control.all_frames_posetext = !aa.control.all_frames_posetext;
				e.target.innerHTML = `show ` + (aa.control.all_frames_posetext ? `one frame` : `all frames`);
				aa.refresh(["draw", "ui", "states"]);
				aa.filldatatext();
			});
			// div creation, non-canvas buttons
			document.getElementById("aa_editshape_input").onkeydown = textarea_autosize;
			document.getElementById("aa_editshape_input").onchange = textarea_autosize;
			document.getElementById("aa_editshape_enter").onpointerdown = function(e) {
				let shape = AAX.Shape.new(document.getElementById("aa_editshape_input").value, aa.currpose, aa.control.partname);
				if(shape) {
					aa.control.part.shape = structuredClone(shape);
					aa.refresh();
					// don't skip anything
				}
				else {
					alert(`invalid shape input.`);
				};
				document.getElementById("aa_editshape_input").value = "";
				document.getElementById("aa_editshape_dialog").close();
			};
			document.getElementById("aa_posescript_input").onkeydown = textarea_autosize;
			document.getElementById("aa_posescript_input").onchange = textarea_autosize;
			document.getElementById("aa_posescript_enter").onpointerdown = function(e) {
				let script = document.getElementById("aa_posescript_input").value;
				let error = aa.posescript(script);
				if(error === "no refresh") {
				}
				else if(error) {
				// show the error and reverse changes
					alert(error);
					aa.loadstate(aa.state_index, true);
				}
				else {
				// refresh and save a new state
					aa.refresh();
				};
				document.getElementById("aa_posescript_dialog").close();
			};
			ref = aa.sample_posescripts;
			for(i1 in ref) {
				if(ref.hasOwnProperty(i1)) {
					let details = document.getElementById("aa_posescript_samples_" + i1);
					let list = htmldescendants(details);
					let obj = {};
					for(i2 = 0; i2 < list.length; i2++) {
						if(list[i2].tagName.toLowerCase() === "button") {
							let value = ref[i1][ list[i2].innerHTML ];
							list[i2].onclick = function(e) {
								let input = document.getElementById("aa_posescript_input");
								input.value = value;
								textarea_autosize(input);
							};
						}
					}
				}
			}
			document.getElementById("aa_editshape_close").onpointerdown = function(e) {
				document.getElementById("aa_editshape_input").value = "";
				document.getElementById("aa_editshape_dialog").close();
			};
			document.getElementById("aa_posescript_close").onpointerdown = function(e) {
				document.getElementById("aa_posescript_dialog").close();
			};
			document.getElementById("aa_posetoshape_close").onpointerdown = function(e) {
				document.getElementById("aa_posetoshape_text").value = "";
				document.getElementById("aa_posetoshape_dialog").close();
			};
			let body = aa.body;
			if(typeof body !== "object") {
				alert(body);
				return;
			};
			for(i1 in body) {
				loop.tick(1);
				if(body.hasOwnProperty(i1) && body[i1].parent === "standpoint") {
					aa.control.partname = i1;
				}
			}
			loop.end();
			if((aa.control.partname ?? null) === null) {
				console.log("invalid initial body text.");
				return;
			};
			aa.drawsettings.vp.x = aa.drawsettings.standpoint.x;
			if(aa.body.hasOwnProperty("head")) {
				aa.drawsettings.vp.y = aa.drawsettings.standpoint.y + AAX.abscoor(aa.body, "head")[1];
			}
			else {
				aa.drawsettings.vp.y = Math.floor(aa.drawsettings.vp.y/2);
			}
			// this has to be done here so that head is fully defined
			let version = document.getElementById("changelog").querySelector("li").innerHTML;
			version = even_blocks_only(version, block_ranges(version, false, "(", ")"));
			version = trimunspecial(version.join(""));
			temp = version.indexOf(":");
			if(temp !== -1 && datechecker(version.slice(0, temp))) {
				version = version.slice(temp + 1).trim();
				let valid = version.startsWith("v");
				for(let i1 = 1; valid && i1 < version.length; i1++) {
					let char = version[i1];
					valid = char.toLowerCase() !== char.toUpperCase() || "0123456789.".includes(char);
				}
				if(valid) {
					aa.version = version;
				}
				else {
					console.log("this shouldn't happen");
				}
			}
			else {
				console.log("this shouldn't happen (invalid date in changelog, can't retrieve the version name)");
			}
			// define aa.version before the ui is created
			aa.anims[0] = aa.newanim();
			let canvas = aa.ctx.main.canvas;
			canvas.addEventListener("mousedown", aa.mousedown);
			canvas.addEventListener("mousemove", aa.mousemove);
			canvas.addEventListener("mouseup", aa.mouseup);
			aa.ui.create();
			aa.control.projectname = "aa " + filedate() + " " + aa.control.projectname;
			aa.control.default_rotate = structuredClone(aa.control.rotate);
			aa.control.default_inbetween = structuredClone(aa.control.inbetween);
			// need to save the defaults for these. posescript resets them, then
			// restores them at the end.
			aa.anim_index = 0;
			// it was already 0, but the setter will fill aa.frames.
			temp = {
				html: structuredClone(Animator.template_html),
			};
			temp.index = temp.html.indexOf("#save_frame");
			temp.index = temp.html.findLastIndex((element, index) => element.trim() === "<br>" && index < temp.index);
			temp.index = temp.index === -1 ? temp.html.length : temp.index;
			temp.html.splice(temp.index, 0, [
				"\n<br><button name=\"update\">update</button>",
				"<label><input type=\"checkbox\" name=\"one view\"> one view</label>",
				"<label><input type=\"checkbox\" name=\"vertical\"> vertical</label>",
			].join("\n"));
			aa.animator = new Animator(document.getElementById("aa_animator_div"), temp.html);
			ref = aa.animator;
			ref.html.update.onclick = function(e) {
				aa.updateanimation();
				if(ref.sheet.vertical.checked !== ref.html.vertical.checked) {
					ref.sheet.vertical.click();
				};
			};
			ref.html.one_view.oninput = function(e) {
				ref.html.vertical.click();
			};
			ref.html.vertical.oninput = function(e) {
				let skip = structuredClone(AAX.valid.refresh);
				skip.splice(skip.indexOf("ui"), 1);
				aa.refresh(skip);
			};
			// - changing one view almost always means changing the axis
			// - both of these have counterpart buttons in the px export area of
			//   the ui canvas, so trigger a ui refresh.
			ref.sheet.vertical.parentElement.hidden = true;
			ref.html.vertical.checked = true;
			ref.sheet.vertical.checked = true;
			// why am i making such a weird and stupid split, you ask?
			// - well, the vertical checkbox that comes preloaded with Animator
			//   automatically rearranges the sheet. wow, so nifty. EXCEPT.
			// - if the user updates the animation with one view and vertical
			//   off... that's an animation where multiviews are lined up
			//   horizontally.
			// - so that means a stupidly long and confusingly organized
			//   spritesheet. fuck that! to fix that, the views should be lined
			//   up vertically in that case.
			// - updateanimation does this. but updateanimation does not run for
			//   every time sheet.vertical is clicked. so, if your last update
			//   was a multiview, clicking sheet.vertical after that is
			//   guaranteed to make a stupidly long or tall spritesheet, making
			//   all of that foresight pointless.
			// - so the relationship these two boxes have is that html.vertical
			//   is a less dynamic substitute for sheet.vertical. this way, the
			//   user has to update the animation to change the axes of the
			//   spritesheet.
			ref.loop = true;
			ref.sheet.wrap.value = 0;
			for(i1 = 0; i1 < 2; i1++) {
				let canvas = i1 ? ref.sheet.canvas : ref.canvas;
				canvas.style["image-rendering"] = "crisp-edges";
				canvas.ondragover = function(e) {
					e.preventDefault();
				};
				canvas.ondrop = function(e) {
					e.preventDefault();
				};
				// it's easy to mistake these canvases for the main canvas. for
				// me, it opens the txt in the browser, ie i have to hit back to
				// return to where i was. depending on your browser, that might
				// be the same as refreshing the page and wiping everything you
				// did.
			}
			//
			aa.refresh("states");
			aa.updateanimation();
		},
		editmodetoggle: function() {
			let div = [
				aa.div.editmodefalse,
				aa.div.editmodetrue
			];
			let activediv = [
				aa.div.editmodefalse_active,
				aa.div.editmodetrue_active
			];
			activediv[0].height = undefined;
			activediv[1].height = undefined;
			const h = Math.max(activediv[0].getBoundingClientRect().height, activediv[1].getBoundingClientRect().height);
			aa.control.editmode = !aa.control.editmode;
			div[Number(!aa.control.editmode)].hidden = true;
			div[Number(aa.control.editmode)].hidden = false;
			//activediv[Number(aa.control.editmode)].style.height = h;
			// i went to the trouble of creating separate "active area" divs,
			// and this doesn't even work. oh well.
			// - the problem is that .height is not how you change heights. i
			//   don't know how you do this.
		},
		filldatatext: function() {
			document.getElementById("aa_bodychoices").value = "current";
			let textarea = document.getElementById("aa_bodytext");
			textarea.value = aa.bodytext;
			// you'd think the event listener would do this, but it seems like
			// onchange doesn't fire just from .value being changed.
			textarea.rows = aa.bodytext.split("\n").length;
			// the body textarea should generally be aa.bodytext, but i don't
			// want to reset it to that in the "apply body changes" event
			// listener because that's a really bad time to clear their input...
			// (the two instances where it doesn't use the body text are when
			// the body text has a syntax error, and when the user changes their
			// mind so they don't clear the frames. in neither case should their
			// input be wiped.)
			let text = "";
			if(aa.control.all_frames_posetext) {
				text = [];
				for(let i1 = 0; i1 < aa.poseobjs.length; i1++) {
					text[i1] = aa.poseobjtotext(aa.poseobjs[i1]);
				}
				text = text.join("\n***\n");
				// it isn't super efficient to calculate every one of them
				// but..! tragically..! i can't give a shit about that!
				// - i'd have to create a second array that has to be spliced
				//   with the main array, or create a {pose, text} structure
				//   that's annoying and dumb in its own right. especially since
				//   there's nothing guaranteeing that the text stay accurate.
				// - maybe i'll do it if i ever have a third thing to store per
				//   frame. i'll make sure to have a getter structure, where
				//   _text gets set as null every refresh, and the getter
				//   generates it again if it's null
			}
			else {
				text = aa.poseobjtotext(aa.currposeobj);
			};
			textarea = document.getElementById("aa_posetext");
			textarea.value = text;
			textarea.rows = text.split("\n").length;
		},
		refresh: function(skip) {
		// refreshes everything to account for changes.
		// - multiview
		// - ui graphics
		// - pose text textarea
		// - .images
		// =
		// - i should add arguments for specifying which changes there were. or
		//   which there weren't, probably.
		//   - pose
		//   - ui graphics
		//   - pose text
		// - skip: string or array of strings for specifying steps that should
		//   be skipped. it should be one of the strings in .valid.refresh.
		//   - "draw": .draw, and saving aa.images
		//   - "ui": ui.draw
		//   - "states": updating bodytext/posetext, and adding to the .states
		//     array that undo/redo use. (this one's used the most often. lots
		//     of actions cause .refresh, but not all of those are worth being
		//     undo-able.)
		//     - datatext used to be a separate skip thing, but 90% of the time,
		//       it's skipped when states are. use aa.filldatatext for the
		//       remaining 10%.
			let starttime = new Date().valueOf();
			let i1 = 0;
			let loop = new Loop("aa.refresh");
			if(typeof skip === "string") {
				skip = [skip];
			}
			else if(!Array.isArray(skip)) {
				skip = [];
			}
			if(!skip.includes("draw")) {
				aa.draw_background();
				aa.draw();
				const ctx = aa.ctx.main;
				const cell = aa.drawsettings.cell;
				aa.images = [];
				for(i1 = 0; i1 < 4; i1++) {
					loop.tick(1);
					aa.images[i1] = ctx.getImageData(cell.w*i1, 0, cell.w, cell.h);
				}
				loop.end();
				// save images, which are used to reverse graphical changes in
				// the clickable interface
			};
			if(!skip.includes("ui")) {
				aa.ui.draw();
			};
			if(!skip.includes("states")) {
				aa.savestate();
				aa.filldatatext();
			};
			//console.log("aa.refresh() took " + (new Date().valueOf() - starttime)/1000 + " seconds.");
		},
		box: function(size, oddness) {
		// uses size and oddness to return a box centered on [0, 0, 0], with the
		// right dimension changes from oddness.
		// - even number sizes get +1 if the dimension is odd, odd numbers get
		//   -1 if the dimension is odd.
			let dim = [
				AAX.onedim(size, oddness[0]),
				AAX.onedim(size, oddness[1]),
				AAX.onedim(size, oddness[2])
			];
			return {
				x: -(dim[0] - 1)/2,
				y: -(dim[1] - 1)/2,
				z: -(dim[2] - 1)/2,
				w: dim[0],
				h: dim[1],
				d: dim[2],
			};
		},
		rect: function(size, oddness, right) {
			if(oddness.length === 3) {
				oddness = [oddness[0], oddness[right ? 2 : 1]];
			};
			let rect = aa.box(size, oddness);
			delete rect.z;
			delete rect.d;
			return rect;
		},
		hypot: (partname, deform) => AAX.hypot(aa.body, aa.currpose, partname, deform),
		//AAX.image_oddness(body, name, view);
		//AAX.onedim(size, odd)
		//aa.box(size, oddness)
		//AAX.l_dim(length, oddness, right)
		//AAX.dim(body, part, view, length, size)
		//aa._rect(size, oddness, right)
		//aa.hypot(partname, deform)
		movecoor: function(x, y, hypot, z_oddness) {
		// used in the move pose tool and the move posescript action.
		// - x, y: the coordinates that are already figured out. if the third
		//   axis is actually x or something, switch them around before and
		//   after running this function.
		// - hypot: the hypotenuse of x, y, and z will be around this much.
		// - z_oddness: the oddness z should have. if it's nullish, it'll go
		//   with whatever's closest.
		// =
		// - remember to switch around the coordinates before/after, and
		//   remember to invert z if it should be inverted.
			hypot += .5;
			z_oddness ??= null;
			z_oddness = z_oddness === null ? null : z_oddness ? true : false;
			let temp = hypot**2 - (x**2 + y**2);
			if(temp <= 0) {
			// x and y are too big.
				let multiply = hypot/Math.hypot(x, y, z_oddness ? .5 : 0);
				return [
					x + Math.trunc(multiply*x - x),
					y + Math.trunc(multiply*y - y),
					z_oddness ? .5 : 0
				];
			}
			else {
				z = Math.trunc(Math.sqrt(temp)*2)/2;
				z = z_oddness === null ? z : Math.trunc(z) + (z_oddness ? .5 : 0);
				return [x, y, z];
			};
		},
		rotatecoor: function(fulcrum, axis, magnitude) {
		// returns new relative coordinates for all parts involved in a
		// rotation. (like .movecoor and .oddify, it does not modify the pose,
		// just shows how it should be modified.)
		// - fulcrum: name of the part that acts as a fulcrum, with all
		//   descendants rotating around it
		// - axis, magnitude: 3d angle to revolve them around, and how much to
		//   revolve it by.
			let i1 = 0;
			const curl = aa.control.rotate.curl;
			let basis = Quat.basis(Quat.new(axis, magnitude));
			let temp = Angle.numbers(axis);
			let zeroaxis = -1;
			// which axis should have no change, if any
			let switchaxis = -1;
			// used for float switching.
			for(i1 = 0; i1 < 3; i1++) {
				temp[i1] = roundspecial(temp[i1]);
			}
			for(i1 = 0; i1 < 3; i1++) {
				if(
					zeroaxis === -1
					&&
					temp[i1]
					&&
					!temp[(i1 + 1)%3] && !temp[(i1 + 2)%3]
				) {
					zeroaxis = i1;
				};
				if(
					switchaxis === -1
					&&
					Math.abs(temp[i1]) > Math.abs(temp[(i1 + 1)%3])
					&&
					Math.abs(temp[i1]) > Math.abs(temp[(i1 + 2)%3])
				) {
					switchaxis = i1;
				};
			}
			if(!(Math.floor(4*posmod(magnitude/(2*Math.PI) + 1/8, 1))%2)) {
			// closer to 0 or 180 than 90 or 270
				switchaxis = -1;
			}
			else if(switchaxis !== -1) {
				let perfectaxis = [0, 0, 0];
				perfectaxis[switchaxis] = Math.sign(temp[switchaxis]);
				// +x axis, -x axis, +y axis, etc. whatever perfectly 2d axis
				// the axis is closest to.
				if(Angle.compare(axis, Angle.get(...perfectaxis)) >= 2*Math.PI/8) {
				// Angle.compare is the 2d angle difference between the perfect
				// axis and the axis it's rotating by.
				// - picture a sphere, picture six circles being painted on the
				//   surface, starting from each axis and negative axis angle.
				//   they stop expanding just before they meet.
				// - if the axis isn't in any of those circles, it gives up on
				//   float switching.
					switchaxis = -1;
				};
			};
			//console.log("magnitude: " + Angle.convert(magnitude) + "\nswitchaxis: " + switchaxis);
			// switchaxis and float switching
			// - rotated coordinates keep the same oddness they had before.
			// - but if the coordinates of a part are, say, [7, 3.5], and you
			//   rotate it 90, you expect it to become [-3.5, 7], right.
			// - so, if the axis only affects two coordinates, and the magnitude
			//   is closer to 90 or 270 than 0 or 180... for the "make sure it
			//   has these floats" process, the targeted floats should be
			//   switched, right?
			//   - of course, the math for that "closer to 90/270" process is
			//     freakishly obtuse.
			//     - the result of that posmod should be 0 to .25 if it's
			//       closest to 0 degrees, .25 to .5 if it's closest to 90, etc
			//     - the +1/8 centers it. 0 degrees becomes the middle of the
			//       "closest to 0 degrees" quadrant
			//     - it's always weird when you come across this kind of math.
			//       problems that don't require any kind of advanced
			//       understanding, but require really incomprehensible logic
			//       just because... i dunno... it's a blind spot in our typical
			//       math operations, i guess. i'd make a function, but i can't
			//       even picture myself needing this again.
			// - but hell, that should apply even if it isn't a perfectly 2d
			//   axis. all rotate/tilt axes are equated to x, y, or z, after
			//   all. and most of the time, it's gonna be pretty close.
			// - so, whichever 2d axis it's closest to... for the purposes of
			//   this float switching, it'll pretend it's that perfectly 2d
			//   axis.
			temp = AAX.getdesc(aa.currpose, fulcrum);
			if(!temp.length) {
			// there's no parts to rotate.
				return {};
			};
			let body = {};
			for(i1 = 0; i1 < temp.length; i1++) {
				body[ temp[i1] ] = aa.currpose[ temp[i1] ].relcoor;
			}
			// all that matters is the relative coordinates of the fulcrum's
			// descendants.
			for(let part in body) {
				if(body.hasOwnProperty(part)) {
					body[part] = [
						Math.trunc(body[part][0]*2)/2,
						Math.trunc(body[part][1]*2)/2,
						Math.trunc(body[part][2]*2)/2
					];
					let hypot = aa.hypot(part, true);
					let float = [
						posmod(body[part][0], 1),
						posmod(body[part][1], 1),
						posmod(body[part][2], 1)
					];
					if(switchaxis !== -1) {
						let temp = float[(switchaxis + 1)%3];
						float[(switchaxis + 1)%3] = float[(switchaxis + 2)%3];
						float[(switchaxis + 2)%3] = temp;
					};
					let point = Basis.apply(basis, body[part]);
					if(curl) {
						let _part = aa.currpose[part].parent;
						while(_part && _part !== fulcrum && _part !== "standpoint") {
							point = Basis.apply(basis, point);
							_part = aa.currpose[_part].parent;
						}
					}
					let array = AAX.fixfloats(point, float, hypot, true);
					point = null;
					if(zeroaxis !== -1) {
						for(i1 = 0; point === null && i1 < array.length; i1++) {
							if(array[i1][zeroaxis] === body[part][zeroaxis]) {
								point = structuredClone(array[i1]);
							}
						}
					}
					point ??= array[0];
					// if none of them matched the zeroaxis thing, just pick the
					// the first one.
					body[part] = structuredClone(point);
				}
			};
			return body;
		},
		coortocanvas: (point, view, nonulls, viewoffset) => AAX.coortocanvas(aa.drawsettings.cell, aa.drawsettings.standpoint, point, view, nonulls, viewoffset),
		coorfromcanvas: (x, y, view) => AAX.coorfromcanvas(aa.drawsettings.cell, aa.drawsettings.standpoint, x, y, view),
		newpose: () => AAX.newpose(aa, aa.body),
		frameclone: (frame) => AAX.poseclone(aa, aa.body, aa.frames[frame]),
		posefromobj: (obj) => AAX.posefromobj(aa, aa.body, obj),
		posetext: function(frame, anim_index) {
		// converts a pose to text.
		// - use the poseobj so it only keeps the data worth keeping
		// - convert images to text
		// - objtotext
			anim_index ??= aa.anim_index;
			let anim = aa.anims[anim_index];
			let state = anim.states[anim.state_index];
			frame ??= state.currframe;
			return aa.poseobjtotext(state[frame]);
		},
		poseobjtotext: function(_obj, basic) {
			_obj ??= aa.currposeobj;
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let loop = new Loop("aa.posetext");
			let obj = structuredClone(_obj);
			// clone it, since it'll be edited
			for(i1 in obj) {
				loop.tick(1);
				if(obj.hasOwnProperty(i1)) {
					delete obj[i1].cache;
					// by definition, cache does not save anything worth saving.
					// it'd clutter up the posetext too.
					for(i2 = 0; i2 < 2; i2++) {
					// stringify all images.
					// - remember, AAX.poseobj omits "default"s, empty objects,
					//   and objects with nothing but "default"s, so the logic
					//   has to account for that weird structure.
						loop.tick(2);
						let temp = i2 ? "perspective" : "image";
						if(obj[i1].hasOwnProperty(temp) && typeof obj[i1] === "object" && obj[i1]) {
							const imageobj = obj[i1][temp];
							for(i3 in imageobj) {
								loop.tick(3);
								if(imageobj.hasOwnProperty(i3)) {
									let view = Number(i3);
									view = isNaN(i3) ? i3 : view;
									if(AAX.valid.view.includes(view) && !["default", null].includes(imageobj[view])) {
									// without the help of AAX..dim, it is a
									// bitch to get the right dimensions.
										const w = AAX.l_dim(imageobj[view].length, AAX.partobj_image_oddness(aa.body, i1, obj[i1], view))[0];
										imageobj[view] = "\n" + Raster.totext(imageobj[view], w) + "\n";
										// add line breaks so it doesn't have an
										// awkward indentation skew at the first
										// line. (fromtext uses .trim(), so it's
										// fine.)
									}
								}
							}
							loop.end();
						}
					}
					loop.end();
				}
			};
			loop.end();
			return basic ? basicobjtotext(obj) : objtotext(obj);
			// bracketindent JSON.stringify-s when used with an object
		},
		texttopose: function(text) {
			let i1 = 0;
			let loop = new Loop("aa.texttopose");
			let obj = texttoobj(text);
			// this should be the same as a poseobj object, except the images
			// are text.
			for(i1 in obj) {
				loop.tick(1);
				if(obj.hasOwnProperty(i1)) {
					obj[i1].cache = structuredClone(AAX.cache_init);
					// the text omitted the cache, so recreate it.
					for(i2 = 0; i2 < 2; i2++) {
					// unstringify all images.
						loop.tick(2);
						let temp = i2 ? "perspective" : "image";
						if(obj[i1].hasOwnProperty(temp) && typeof obj[i1] === "object" && obj[i1]) {
							const imageobj = obj[i1][temp];
							for(i3 in imageobj) {
								loop.tick(3);
								if(imageobj.hasOwnProperty(i3)) {
									let view = Number(i3);
									view = isNaN(i3) ? i3 : view;
									if(AAX.valid.view.includes(view) && !["default", null].includes(imageobj[view])) {
										const w = pose[i1].dim(view)[0];
										imageobj[view] = Raster.fromtext(imageobj[view]).raster;
									}
								}
							}
							loop.end();
						}
					}
					loop.end();
				}
			};
			loop.end();
			return aa.posefromobj(obj);
		},
		draw_background: function(viewtype, side_tint_invert) {
			AAX.draw_background(aa.ctx.main, aa.drawsettings, aa.color, aa.control.perspectived, viewtype ?? "multi4", side_tint_invert);
		},
		draw: function(viewtype, rotatecoor, basis) {
			viewtype ??= "multi4";
			AAX.draw(
				aa.ctx.main, aa.drawsettings, aa.color, aa.control.perspectived, viewtype,
				aa.currpose, viewtype === "multi4" ? aa.nodes : null, aa.control.strokecache, rotatecoor, basis
			);
		},
		save: function() {
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let obj = {
				version: aa.version,
				// doesn't do anything, but it's useful information.
				anim_index: aa.anim_index,
				bodytext: aa.bodytext,
				drawsettings: structuredClone(aa.drawsettings),
				color: structuredClone(aa.color),
				states_limit: aa.states_limit,
				states_truncator: aa.states_truncator,
				// you can't save settings/preferences on a web tool, so i'd
				// like to get as close as i can.
			};
			// then, integer properties are animations.
			delete obj.drawsettings.viewer;
			// this is a getter.
			for(i1 = 0; i1 < aa.anims.length; i1++) {
				let ref = aa.anims[i1];
				obj[i1] = {name: ref.name};
				ref = ref.states[ref.state_index];
				for(i2 in ref) {
					if(ref.hasOwnProperty(i2)) {
					// copy every aspect of the state
						obj[i1][i2] = structuredClone(ref[i2]);
					}
				}
				// keep only the name and the current state.
				// - make sure the name is the first property
				ref = ref.poseobjs;
				for(i2 = 0; i2 < ref.length; i2++) {
				// for every frame,
					for(i3 in ref[i2]) {
						if(ref[i2].hasOwnProperty(i3)) {
						// every part,
							delete obj[i1].poseobjs[i2][i3].cache;
							// delete cache.
						}
					}
				}
			};
			AAX.save(aa.control.projectname + ".txt", objtotext(obj));
		},
		load: function() {
			AAX.load(aa.readfile);
		},
		readfile: function(file) {
		// run by load and the drag-and-drop event listener.
			if(!file) {
				console.log("this shouldn't happen");
				return;
			};
			aa.control.projectname = filename_handler(file.name);
			let reader = new FileReader();
			reader.onload = function() {
				file = texttoobj(reader.result);
				if(file) {
					let i1 = 0;
					let i2 = 0;
					let i3 = 0;
					let body = AAX.Body.new(file.bodytext);
					if(typeof body === "object") {
					// errors from invalid input
						aa.bodytext = file.bodytext;
						aa.body = body;
					}
					else {
						alert("invalid bodytext: " + body);
					};
					aa.anims = [];
					for(i1 = 0; file.hasOwnProperty(i1); i1++) {
						aa.anims[i1] = aa.newanim();
						let ref = aa.anims[i1];
						ref.name = file[i1].name;
						ref.states = [structuredClone(file[i1])];
						delete ref.states[0].name;
						ref.state_index = 0;
						ref = ref.states[0].poseobjs;
						for(i2 = 0; i2 < ref.length; i2++) {
							for(i3 in ref[i2]) {
								if(ref[i2].hasOwnProperty(i3)) {
									ref[i2][i3].cache = structuredClone(AAX.cache_init);
								}
							}
						}
						// restore cache
					}
					aa._anim_index = file.anim_index;
					aa.loadstate(aa.state_index, true);
					// the anim_index setter can cause errors in rare cases.
					// specifically, if the anim_index was higher than the
					// number of animations the newly loaded project has. it'll
					// try to truncate the states of an animation that doesn't
					// exist.
					for(i1 in aa.drawsettings) {
						if(file.drawsettings.hasOwnProperty(i1)) {
							aa.drawsettings[i1] = structuredClone(file.drawsettings[i1]);
						};
					}
					for(i1 in aa.color) {
						if(file.color.hasOwnProperty(i1)) {
							aa.color[i1] = structuredClone(file.color[i1]);
						};
					}
					// you have to copy these property by property. if you
					// use structuredClone outright, it won't be the AAX
					// DrawSettings/Color class anymore.
					let temp = file.states_limit ?? null;
					if(Number.isInteger(temp) && temp >= 1) {
						aa.states_limit = temp;
					};
					temp = file.states_truncator ?? null;
					if(Number.isInteger(temp) && temp >= 0) {
						aa.states_truncator = temp;
					};
					aa.refresh();
				}
			};
			reader.readAsText(file);
		},
		randompose: function(parts) {
		// poses the given parts by a random rotation quaternion. NOTE this
		// isn't actually used anywhere, at the moment.
		// - parts can also be a number. that makes it choose random parts.
		// - i don't intend to make this a button anytime soon. randomization
		//   fits better with a more playful, toylike tool that armature artist
		//   is not... it'd look out of place.
		//   - maybe misc buttons that are like "select random part" and "create
		//     random rotation"? that's better, but it's still kinda weird.
		// - full random poses are nearly impossible. difficult to balance, and
		//   even more difficult to avoid them just being nonsense.
			let pose = aa.currpose;
			let order = AAX.getdesc(pose);
			parts = typeof parts === "string" ? [parts] : (Array.isArray(parts) || (Number.isInteger(parts) && parts >= 0)) ? parts : 1;
			if(typeof parts === "number") {
				let temp = structuredClone(order);
				let num = parts;
				parts = [];
				for(let i1 = 0; i1 < num && temp.length; i1++) {
					let index = Math.floor(Math.random()*temp.length);
					parts.push(temp[index]);
					temp.splice(index, 1);
				}
			};
			parts.sort((a, b) => order.indexOf(a) - order.indexOf(b));
			for(let i1 = 0; i1 < parts.length; i1++) {
				let part = pose[parts[i1]];
				let axis = Angle.rand();
				let magnitude = Math.random()**2;
				magnitude = posmod((Math.random() < .5 ? -1 : 1)*Math.PI*magnitude, 2*Math.PI);
				part.orient = Quat.rotate(part.orient, axis, magnitude);
				let desc = AAX.getdesc(pose, parts[i1]);
				let quat = Quat.new(axis, magnitude);
				for(let i2 = 0; i2 < desc.length; i2++) {
					let _part = pose[desc[i2]];
					_part.orient = Quat.rotate(_part.orient, axis, magnitude);
					let relcoor = Quat.apply(quat, _part.relcoor);
					for(let i3 = 0; i3 < 3; i3++) {
						_part["xyz"[i3]] += Math.trunc(relcoor[i3] - _part["xyz"[i3]]);
					}
				}
			};
			aa.refresh();
			return parts;
		},
		posescript_dry: function(target, action, args) {
		// dry stands for "don't repeat yourself", a programming principle. if
		// something can be done through posescript, but also buttons or pose
		// tools, it'll be in here. this exists to avoid redundant code.
		// - target: same format as posescript.
		//   - array of partnames: the action edits parts
		//   - "rotate": action affects rotate settings
		//   - "frame": action affects frame system
		//   - "tween": action affects inbetween system
		// - action: a string for what you're doing to the target
		// - args: an object of arguments for the given action, like which frame
		//   to jump to.
		// - returns a boolean for whether the action was successful or not.
		//   (for example, if you try to jump to a nonexistent frame, nothing
		//   happens, so you should skip refresh and stuff like that.)
			target ??= [aa.control.partname];
			args ??= {};
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let success = true;
			let num = (
				typeof args.num === "number" ? args.num :
				typeof args.input === "string" ? (
					(target === "tween" && action === "curve") ?
					readnumber(args.input) : Number(args.input)
				) :
				null
			);
			if(Array.isArray(target)) {
				function targetbranch() {
					let branch = [];
					for(i1 = 0; i1 < target.length; i1++) {
						let desc = aa.currpose[ target[i1] ].descendants;
						for(i2 = -1; i2 < desc.length; i2++) {
							let _i2 = i2 === -1 ? target[i1] : desc[i2];
							if(!branch.includes(_i2)) {
								branch.push(_i2);
							};
						}
					}
					return branch;
				};
				//
				if(action === "tilt") {
					args.omit = Array.isArray(args.omit) ? args.omit : [];
					for(i1 = 0; i1 < target.length; i1++) {
						let _i1 = target[i1];
						if(!args.omit.includes(_i1)) {
							let part = aa.currpose[_i1];
							part.orient = Quat.rotate(part.orient, args.axis, (part.orient.flip ? -1 : 1)*args.angle);
						};
					}
				}
				else if(action === "deform") {
					let coor = Points.convert(args);
					coor = Points.divide(Points.trunc(Points.multiply(coor, 2)), 2);
					// make sure it's .0 or .5
					for(i1 = 0; i1 < target.length; i1++) {
						let part = aa.currpose[ target[i1] ];
						let before = Points.convert(part);
						if(args.rel ?? false) {
						// rel should be on by default for posescript, but off
						// by default for other uses of posescript_dry.
							coor = Points.add(before, coor);
						};
						part.x = coor[0];
						part.y = coor[1];
						part.z = coor[2];
						// descendants will follow, since it's relative.
						args.disjointed ??= false;
						if(args.disjointed ?? false) {
						// apply an inverse change to all children, so that they
						// stay in place.
							let change = Points.subtract(coor, before);
							let children = AAX.getchildren(aa.currpose, target[i1]);
							for(i2 = 0; i2 < children.length; i2++) {
								let child = aa.currpose[ children[i2] ];
								child.x -= change[0];
								child.y -= change[1];
								child.z -= change[2];
							};
						};
					}
				}
				else if(action === "perspective") {
					let coor = [args.x, args.y];
					for(i1 = 0; i1 < target.length; i1++) {
						let part = aa.currpose[ target[i1] ];
						let _coor = (args.rel ?? false) ? Points.add(part["perspective_coor_" + args.view], coor) : coor;
						part["perspective_coor_" + args.view] = structuredClone(_coor);
					}
				}
				else if(action === "reset") {
					let list = (
						(args.desc ?? false)
						?
						((args.omit_self ?? false) ? targetbranch().filter((element) => !target.includes(element)) : targetbranch())
						:
						((args.omit_self ?? false) ? [] : target)
					);
					for(i1 = 0; i1 < list.length; i1++) {
						let part = aa.currpose[ list[i1] ];
						if(args.coor ?? false) {
							part.x = part.bodyref.x;
							part.y = part.bodyref.y;
							part.z = part.bodyref.z;
						};
						if(args.orient ?? false) {
							part.orient = structuredClone(part.bodyref.orient);
						};
						if(!(args.coor ?? false) && !(args.orient ?? false)) {
							aa.currpose[ list[i1] ] = new AAX.Part(aa, aa.body, aa.currpose, list[i1]);
						};
					}
				}
				else if(action === "mirror") {
					let branch = targetbranch();
					let axis = "xyz"[args.axis];
					for(i1 = 0; i1 < branch.length; i1++) {
						let part = aa.currpose[ branch[i1] ];
						if(branch.includes(part.parent)) {
							part[axis] *= -1;
						};
						part.orient = Quat.mirror[axis]( part.orient );
						for(i2 = 0; i2 < AAX.valid.view.length; i2++) {
						// mirror the images.
							if(args.axis === 1 || args.axis === (i2%2 ? 2 : 0)) {
							// x mirror: x mirror front and back images
							// y mirror: y mirror all images
							// z mirror: x mirror left and right images
								let view = AAX.valid.view[i2];
								let source = typeof view === "number" ? "perspective" : "image";
								let property = source + "_" + view;
								let value = part.getwithoutredirects(property);
								let isdefault = value === "default";
								value = isdefault ? part.bodyref[source][view] : value;
								// image is real: mirror it
								// image is "default", body image it refers to is real: create a mirrored copy of that
								// image is "default", body image is null: do nothing
								// image is null: do nothing
								if(value !== null) {
									let w = part.dim(view, value.length);
									//part[property] = args.axis === 1 ? Raster.ymirror(value, w) : Raster.xmirror(value, w);
									part["_" + source][view] = args.axis === 1 ? Raster.ymirror(value, w) : Raster.xmirror(value, w);
								};
							}
						}
					}
				}
			}
			else if(target === "rotate") {
				let basis = aa.control.rotate.basis;
				if(action === "invert") {
					basis[args.axis] = Points.invert(basis[args.axis]);
				}
				else if(action === "switch") {
					if(args.axis1 === args.axis2) {
						success = false;
					}
					else {
						temp = structuredClone(basis[args.axis1]);
						basis[args.axis1] = structuredClone(basis[args.axis2]);
						basis[args.axis2] = structuredClone(temp);
					};
				}
				else if(AAX.valid.rotate_axis_setters.includes(action)) {
				// required args properties:
				// - axis
				// - partname: for parent, child, or local
				// - input: for written
					let point = [0, 0, 0];
					let part = typeof args.partname === "string" ? (aa.currpose[args.partname] ?? null) : null;
					if(AAX.ui.rotate_axis_setter_disabled(aa.currpose, (args.partname ?? ""), basis, args.axis, action)) {
						success = false;
					}
					else if(action === "parent") {
						point = Points.normalized(Points.invert(part.relcoor));
					}
					else if(action === "child") {
						let child = AAX.getchildren(aa.currpose, part.name)[0] ?? null;
						point = child ? Points.normalized(aa.currpose[child].relcoor) : null;
					}
					else if(action === "cross") {
						point = Points.normalized(Points.cross(
							basis[posmod(args.axis + 1, 3)],
							basis[posmod(args.axis + 2, 3)]
						));
					}
					else if(action === "true") {
						point[args.axis] = 1;
					}
					else if(action === "local") {
						point[args.axis] = (part.bodyref.mirror && args.axis === 0) ? -1 : 1;
						// the -1 thing mimics how the local mode of the
						// rotate tool works.
						point = Quat.apply(part.orient, point);
					}
					else if(action === "written") {
						point = trimunspecial(args.input.replaceAll(",", " ")).split(" ");
						if(point.length >= 3) {
							for(i1 = 0; i1 < 3; i1++) {
								point[i1] = Number(point[i1]);
								if(isNaN(point[i1]) || point[i1] === Infinity || point[i1] === -Infinity) {
									point[i1] = 0;
								};
							}
							point = Points.normalized(point.slice(0, 3));
						}
						else {
							point = null;
						};
					}
					//
					success = success && point && Math.hypot(...point);
					if(success) {
						basis[args.axis] = structuredClone(point);
					};
				};
			}
			else if(target === "frame") {
				if(action === "prev" || action === "next") {
					aa.currframe = posmod(aa.currframe + (action === "prev" ? -1 : action === "next" ? 1 : 0), aa.frames.length);
				}
				else if(action === "jump") {
					num--;
					if(Number.isInteger(num) && num >= 0 && num < aa.frames.length) {
						aa.currframe = num;
					}
					else {
						success = false;
					};
				}
				else if(action === "blank" || action === "duplicate") {
					aa.frames.splice(aa.currframe + 1, 0, (action === "duplicate" ? aa.frameclone(aa.currframe) : aa.newpose()));
					aa.currframe++;
					// splice it into the position after this one, and
					// switch to it.
				}
				else if(action === "delete") {
					if(aa.frames.length === 1) {
					// clear the pose instead
						aa.frames.splice(aa.currframe, 1, aa.newpose());
					}
					else {
						aa.frames.splice(aa.currframe, 1);
						aa.currframe--;
					};
				}
				else if(action === "move up" || action === "move down") {
					let newframe = aa.currframe + (action === "move up" ? 1 : action === "move down" ? -1 : 0);
					if(newframe >= 0 && newframe < aa.frames.length) {
						let temp = aa.frames[aa.currframe];
						aa.frames.splice(aa.currframe, 1);
						aa.frames.splice(newframe, 0, temp);
						aa.currframe = newframe;
					}
					else {
						success = false;
					};
				};
				aa.clampframe();
			}
			else if(target === "tween") {
				let ref = aa.control.inbetween;
				if(action === "number") {
					if(Number.isInteger(num) && num >= 1) {
						ref.number = num;
					}
					else {
						success = false;
					};
				}
				else if(action === "curve") {
					if("input" in args && args.input.trim() === "sine") {
						ref.curve = Math.sqrt(3);
					}
					else if(Number.isInteger(Math.round(num)) && num >= 0) {
						ref.curve = num;
					}
					else {
						success = false;
					};
				}
				else if(action === "create" || action === "apply") {
					const apply = action === "apply";
					let values = args.values ?? aa.inbetweenvalues(ref.number, ref.curve, ref.easeA, ref.easeB);
					if(apply && aa.frames.length < values.length + 2) {
						success = false;
					}
					else {
						AAX.inbetweening(aa, aa.body, aa.frames, aa.currframe, values, apply);
						//aa.currframe++;
						// switch to the first inbetween.
						aa.currframe = posmod(aa.currframe + values.length + 1, aa.frames.length);
						// switch to the end pose.
					}
				}
				else {
					success = false;
				};
			};
			return success;
		},
		posescript: function(script) {
		// interprets the scripts given in the posescript button.
		// - if there's something wrong with the input, it returns a string
		//   explaining the problem.
		// - otherwise, it returns an empty string, or "no refresh" if there
		//   were no actions in the script.
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let i4 = 0;
			let restore = {
				rotate: structuredClone(aa.control.rotate),
				inbetween: structuredClone(aa.control.inbetween),
			};
			aa.control.rotate = structuredClone(aa.control.default_rotate);
			aa.control.inbetween = structuredClone(aa.control.default_inbetween);
			// reset these to default
			function end() {
				aa.control.rotate = structuredClone(restore.rotate);
				aa.control.inbetween = structuredClone(restore.inbetween);
				// restore these to how they were
			};
			script = AAX.body_read.uncomment(script).split("\n");
			let array = [];
			// array of {target, actions} objects.
			// - target is an array of part names, or a string if it's "frame"
			//   or something like that.
			// - actions is an array of the lines of code representing actions.
			let parttarget = function(string) {
				string = string.trim();
				if(!string) {
					return [];
				};
				let list = string.split(",");
				let target = [];
				for(let i1 = 0; i1 < list.length; i1++) {
					let text = list[i1].trim();
					if(text === "all") {
						return aa.hidelist("", text);
					};
					let unprefixed = aa.currpose.hasOwnProperty(text);
					let dot = 0;
					while(text.startsWith(".")) {
						text = text.slice(1);
						dot++;
					};
					text = text.trimStart();
					text = (dot === 2 ? "branch " : dot === 1 ? "part " : "") + text;
					if(text.includes(" ")) {
						let _text = text;
						let _target = [];
						let index = text.indexOf(" ");
						let type = text.slice(0, index);
						text = text.slice(index + 1).trim();
						if(!aa.body.hasOwnProperty(text)) {
							return "invalid part name: " + text;
						};
						if(AAX.valid.hidelist.includes(type)) {
							_target = aa.hidelist(text, type);
						}
						else {
							index = type.indexOf("-");
							if(index === -1) {
								return "invalid target: " + _text;
							}
							else {
								let plus = type.slice(0, index);
								let minus = type.slice(index + 1);
								if(!AAX.valid.hidelist.includes(plus) || !AAX.valid.hidelist.includes(minus)) {
									return "invalid target: " + _text;
								};
								type = plus + "_minus_" + minus;
								_target = aa.hidelist(text, type);
							};
						};
						for(let i2 = 0; i2 < _target.length; i2++) {
							let _i2 = _target[i2];
							if(!target.includes(_i2)) {
								target.push(_i2);
							};
						}
					}
					else {
						return "invalid target: " + text + (unprefixed ? "\n\n(remember to add a prefix. \"" + AAX.valid.hidelist.join("\", \"") + "\", or . or .. as shorthand for \"part\" or \"branch\".)" : "");
					};
				}
				return target;
			};
			for(i1 = 0; i1 < script.length; i1++) {
				let line = script[i1].trim();
				if(line) {
					let colon = line.indexOf(":");
					if(colon !== -1) {
					// target change
						while(line.slice(colon).startsWith("::") && colon !== -1) {
						// account for double colons
							colon = line.indexOf(":", colon + 2);
						};
						if(colon !== -1) {
						// if colon === -1, that means there were double colons
						// but no single colons.
							let target = line.slice(0, colon).trim().replaceAll("::", ":");
							line = line.slice(colon + 1);
							if(target !== "rotate" && target !== "frame" && target !== "tween" && target !== "scene" && target !== "time") {
							// convert it to a list of parts.
								target = parttarget(target);
								if(typeof target === "string") {
								// error
									end();
									return target;
								};
							};
							array.push({target, actions: []});
						}
					}
					if(line) {
					// after the target stuff, line might be empty.
						if(!array.length) {
							end();
							return "the first meaningful line of the script doesn't specify a target. you need to specify a target for actions to be used.";
						};
						let actions = even_block_split(line, block_ranges(line, false, "[(", "])"), ",");
						// split it up by comma
						for(i2 = 0; i2 < actions.length; i2++) {
							let temp = actions[i2].trim();
							if(temp) {
								array[array.length - 1].actions.push(temp);
							}
						}
					}
				};
			}
			let convertaxis = (axis) => (
				(axis === "yz" || axis === "x") ? 0 :
				(axis === "xz" || axis === "y") ? 1 :
				(axis === "xy" || axis === "z") ? 2 :
				axis
			);
			let convertpoint = function(input, no_rounding) {
				if(!input.startsWith("[") || !input.endsWith("]")) {
					return null;
				};
				let point = input.slice(1, -1).split(",");
				for(let i1 = 0; i1 < point.length; i1++) {
					let num = point[i1].trim();
					num = readnumber(point[i1]) ?? 0;
					num = no_rounding ? num : Math.trunc(num*2)/2;
					point[i1] = num;
				}
				return point;
			};
			let removewords = function(action, words, num) {
			// pretty much the same as words.slice(num).join(" "). it's just
			// that i don't want there to be problems if part names have
			// whitespace that's consecutive, or isn't a space. even if that's
			// pretty unlikely.
				action = action.trimStart();
				for(let i1 = 0; i1 < num; i1++) {
					if(!action.startsWith(words[i1])) {
						console.log("this shouldn't happen");
					};
					action = action.slice(words[i1].length).trimStart();
				}
				return action;
			};
			let no_refresh = true;
			// i'm not gonna go to super huge lengths for this, but i'll at
			// least make sure this is true if there were no actions.
			let localnaming = {};
			for(i1 in aa.currpose) {
				if(aa.currpose.hasOwnProperty(i1)) {
					localnaming[i1] = ["", "", "", "", "", ""];
					// [-xz, +xz, -yz, +yz, -xy, +xy] (an empty string means it
					// has no name.)
				}
			}
			// used for the local axis naming system.
			for(i1 = 0; i1 < array.length; i1++) {
				let target = array[i1].target;
				//console.log("target: " + JSON.stringify(target));
				let actions = array[i1].actions;
				let localnames = [];
				if(Array.isArray(target) && aa.control.rotate.type === "local") {
				// an array of axis names applicable to the parts currently
				// selected.
					for(i2 = 0; i2 < target.length; i2++) {
						localnaming[ target[i2] ].forEach(function(element) {
							if(element && !localnames.includes(element)) {
								localnames.push(element);
							};
						});
					}
				};
				for(i2 = 0; i2 < actions.length; i2++) {
					no_refresh = false;
					let action = actions[i2];
					//console.log("\t" + action);
					//let words = trimunspecial(action).split(" ");
					let words = block_word_split(action, odd_block_expand(action, block_ranges(action, false, "[(", "])")));
					if(Array.isArray(target)) {
						const tilt = words[0] === "tilt" && words.length >= 2;
						// the second condition is because everything is written
						// under the assumption that there's always at least one
						// word.
						if(tilt) {
							words = words.slice(1);
							action = words.join(" ");
						};
						let angle = words[0].startsWith("+") ? words[0].slice(1) : words[0];
						angle = angle ? Number(angle) : NaN;
						let axis = -1;
						if(words.length >= 2) {
							axis = convertaxis(words[1]);
							axis = typeof axis === "string" ? (localnames.includes(axis) ? axis : -1) : axis;
							// 0, 1, 2: it was written as xy, yz, xz, x, y, or z
							// [string]: used a local axis name
							// -1: it isn't an axis at all
						};
						let percent = words[0];
						while(percent.endsWith("%")) {
							percent = percent.slice(0, -1);
						};
						percent = words[0].length - percent.length;
						// tilt, angle, and axis are only used in tilt/rotate.
						// percent is only used in move/deform. but for logic
						// reasons, they have to be created no matter what.
						//
						if(Number.isInteger(Math.round(angle)) && axis !== -1) {
						// tilt/rotate
							angle = posmod(angle*Math.PI/180, 2*Math.PI);
							let ref = aa.control.rotate;
							let type = ref.type;
							let curl = ref.curl;
							let allow = AAX.getdesc(aa.currpose);
							for(i3 = 2; i3 < words.length; i3++) {
							// apply temporary changes
								if(words[i3] === "curl") {
									ref.curl = true;
								}
								else if(words[i3] === "!curl") {
									ref.curl = false;
								}
								else if(AAX.valid.rotate_type.includes(words[i3])) {
									ref.type = words[i3];
								}
								else if((words[i3].startsWith("inc(") || words[i3].startsWith("exc(")) && words[i3].endsWith(")")) {
									let parts = words[i3].slice(words[i3].indexOf("(") + 1, -")".length).trim().replaceAll("::", ":");
									let is_exc = words[i3].startsWith("exc");
									if(parts) {
										parts = parts.split(",");
										parts.forEach(function(element, index, array) {
											array[index] = element.trim();
										});
										let temp = parts.find((element) => !aa.currpose.hasOwnProperty(element));
										if(temp !== undefined) {
											end();
											return "invalid part name in an " + (is_exc ? "exc" : "inc") + "(): " + temp;
										};
										if(!is_exc) {
											allow = [];
										};
										let branches = [];
										parts.forEach(function(element) {
											let branch = [element].concat(AAX.getdesc(aa.currpose, element));
											branch.forEach(function(element) {
												if(!branches.includes(element)) {
													branches.push(element);
												};
											});
										});
										allow = is_exc ? allow.filter((element) => !branches.includes(element)) : structuredClone(branches);
									}
								};
							}
							let omit = AAX.getdesc(aa.currpose).filter((element) => !allow.includes(element));
							//
							let axis_num = -1;
							if(typeof axis === "string") {
								if(ref.type !== "local") {
									console.log("this shouldn't happen");
								};
							}
							else {
								axis_num = axis;
								if(axis_num === 1) {
									// if it's xz rotation, invert it for the same
									// reasons that happens in the rotate pose tool.
									angle = posmod(-angle, 2*Math.PI);
								};
								axis = (ref.type === "custom" ? ref.basis : Basis.new())[axis_num];
								axis = Angle.get(...axis);
							};
							//
							if(tilt) {
								if(ref.type === "local") {
									target.forEach(function(element) {
										let basis = Quat.basis(aa.currpose[element].orient);
										let _axis = null;
										let neg = false;
										if(typeof axis === "string") {
											axis_num = localnaming[element].indexOf(axis);
											if(axis_num !== -1) {
												neg = xor(neg, !(axis_num%2));
												axis_num = Math.floor(axis_num/2);
												_axis = basis[axis_num];
												neg = xor(neg, axis_num === 1);
												// if local axis names are used,
												// it skips over the xz
												// inversion from earlier, so it
												// has to be done here too.
											};
										}
										else {
											_axis = basis[axis_num];
										};
										if(_axis) {
											if(aa.currpose[element].mirror && axis_num === 0) {
												// happens for the same reasons it
												// happens in the pose tool.
												_axis = Points.invert(_axis);
											};
											_axis = Angle.get(..._axis);
											aa.posescript_dry([element], "tilt", {axis: _axis, angle: neg ? posmod(-angle, 2*Math.PI) : angle, omit});
										};
									});
								}
								else {
									aa.posescript_dry(target, "tilt", {axis, angle, omit});
								}
							}
							else {
								for(i3 = 0; i3 < target.length; i3++) {
									let name = target[i3];
									let _axis = axis;
									let neg = false;
									if(ref.type === "local") {
										let basis = Quat.basis(aa.currpose[name].orient);
										if(typeof axis === "string") {
											axis_num = localnaming[name].indexOf(axis);
											if(axis_num === -1) {
												_axis = null;
											}
											else {
												neg = xor(neg, !(axis_num%2));
												axis_num = Math.floor(axis_num/2);
												_axis = basis[axis_num];
												neg = xor(neg, axis_num === 1);
												// if local axis names are used,
												// it skips over the xz
												// inversion from earlier, so it
												// has to be done here too.
											};
										}
										else {
											_axis = basis[axis_num];
										};
										if(_axis) {
											if(aa.currpose[name].mirror && axis_num === 0) {
												_axis = Points.invert(_axis);
											};
											_axis = Angle.get(..._axis);
										};
									};
									if(_axis) {
										let _angle = neg ? posmod(-angle, 2*Math.PI) : angle;
										let rotatecoor = aa.rotatecoor(name, _axis, _angle);
										for(i4 in rotatecoor) {
											if(rotatecoor.hasOwnProperty(i4) && !omit.includes(i4)) {
												let part = aa.currpose[i4];
												part.x = rotatecoor[i4][0];
												part.y = rotatecoor[i4][1];
												part.z = rotatecoor[i4][2];
											}
										}
										aa.posescript_dry([name].concat(AAX.getdesc(aa.body, name)), "tilt", {axis: _axis, angle: _angle, omit});
									};
								}
							}
							//
							ref.type = type;
							ref.curl = curl;
							// reverse changes
						}
						else if(words[0].charAt(0) === "[" && words[0].charAt( words[0].length - 1 - percent ) === "]") {
						// move/deform
							let input = percent ? words[0].slice(0, -percent) : words[0];
							words = words.slice(1);
							let point = convertpoint(input, true);
							if(point.length !== 3) {
								end();
								return "a move or deform action should have 3 coordinates, not " + point.length + ".";
							};
							input = input.slice(1, -1).split(",");
							let move_axis = -1;
							let move_neg = false;
							for(i3 = 0; i3 < input.length; i3++) {
								let value = input[i3].trim();
								if(value === "+" || value === "-") {
									if(move_axis !== -1) {
										end();
										return "a move action should leave only one axis ambiguous, not multiple.";
									};
									move_axis = i3;
									move_neg = value === "-";
									value = 0;
								}
							}
							const rel = move_axis !== -1 ? words.includes("rel") : !words.includes("abs");
							// move is absolute by default, deform is relative
							// by default
							function finishpoint(partname) {
							// - if percent is being used, multiply by the part
							//   length
							// - if it's relative, add the current coordinates
							// - snap to a proper .0 or .5
								let _point = structuredClone(point);
								let relcoor = aa.currpose[partname].relcoor;
								if(percent) {
									_point = Points.multiply(_point, aa.hypot(partname, move_axis !== -1 && words.includes("currlength")));
								};
								if(rel) {
									_point = Points.add(_point, relcoor);
								};
								_point = (
									percent === 1
									?
									Points.add(Points.trunc(Points.subtract(_point, relcoor)), relcoor)
									:
									Points.divide(Points.trunc(Points.multiply(_point, 2)), 2)
								);
								return _point;
							};
							//
							let args = {};
							if(move_axis !== -1) {
								let axis1 = posmod(move_axis + 1, 3);
								let axis2 = posmod(move_axis + 2, 3);
								let axis3 = move_axis;
								for(i3 = 0; i3 < target.length; i3++) {
									let _i3 = target[i3];
									let part = aa.currpose[_i3];
									let _point = finishpoint(_i3);
									if(part.parent === "standpoint") {
									// move doesn't make sense for stems.
									// there's no reason to keep a part's
									// distance from standpoint consistent.
										aa.posescript_dry([_i3], "deform", _point);
									}
									else {
										let temp = aa.movecoor(
											_point[axis1],
											_point[axis2],
											aa.hypot(_i3, words.includes("currlength")),
											part.rel_oddness[axis3]
										);
										if(move_neg) {
											temp[2] *= -1;
										};
										_point[axis1] = temp[0];
										_point[axis2] = temp[1];
										_point[axis3] = temp[2];
										aa.posescript_dry([_i3], "deform", Points.apply(_point));
									}
								}
							}
							else {
								const disjointed = words.includes("disjointed");
								for(i3 = 0; i3 < target.length; i3++) {
									let _i3 = target[i3];
									let _point = Points.subtract(finishpoint(_i3), aa.currpose[_i3].relcoor);
									if(!disjointed || !target.includes(aa.currpose[_i3].parent)) {
										aa.posescript_dry([_i3], "deform", Points.apply(_point, {rel: true}));
									}
									_point = Points.invert(_point);
									if(disjointed) {
									// apply an opposite change to all children.
										AAX.getchildren(aa.currpose, _i3).forEach(function(element) {
											if(!target.includes(element)) {
												aa.posescript_dry([element], "deform", Points.apply(_point, {rel: true}));
											};
										});
									};
								}
								// why the conditionals are so wonky for
								// disjointed:
								// - let's say you're moving the torso
								//   silhouette group...
								// - all parts in that group should be moved.
								// - all of those parts' children should be
								//   moved the opposite way if they're not in
								//   the group, right? to cancel it out.
								// - except, the children should have that
								//   cancel-out even if they're in the group, so
								//   changes don't compound along a branch
								// - if you stop here, the logic is simple, and
								//   functional
								// - but it's a little inefficient. for parts in
								//   the group whose parents are also in the
								//   group, they get moved, and that movement is
								//   cancelled out. two operations, but the
								//   result is no change at all. that's
								//   wasteful.
								// - granted, that waste would be too small to
								//   care about if it wasn't for the setter
								//   system. when coordinates change, caches get
								//   cleared. shape images have to be
								//   regenerated, sometimes.
							};
						}
						else if(
							words.length >= 2
							&&
							"0123".includes(words[0]) && words[0].length === 1
							&&
							words[1].startsWith("[") && words[1].endsWith("]")
						) {
						// perspective
							let view = Number(words[0]);
							let point = convertpoint(words[1]);
							if(point.length !== 2) {
								end();
								return "a perspective action should have 2 coordinates, not " + point.length + ".";
							};
							words = words.slice(2);
							aa.posescript_dry(target, "perspective", {view, x: point[0], y: point[1], rel: !words.includes("abs")});
						}
						else if(words.length >= 2 && (words[0] === "stretch" || words[0] === "widen")) {
						// stretch, widen
							let num = readnumber(words[1]);
							if(num !== null) {
								for(i3 = 0; i3 < target.length; i3++) {
									aa.currpose[target[i3]][words[0]] = num;
								}
							}
						}
						else if(words[0] === "reset") {
							aa.posescript_dry(
								target, "reset",
								{
									omit_self: words.includes("desc") && !words.includes("branch"),
									desc: words.includes("desc") || words.includes("branch"),
									coor: words.includes("coor"),
									orient: words.includes("orient")
								}
							);
						}
						else if(words.length >= 2 && words[0] === "mirror" && "xyz".includes(words[1]) && words[1].length === 1) {
							aa.posescript_dry(target, "mirror", {axis: "xyz".indexOf(words[1])});
						}
						else if(action === "hide" || action === "show") {
							for(i3 = 0; i3 < target.length; i3++) {
								aa.currpose[target[i3]].hide = action === "hide";
							}
						};
					}
					else if(target === "rotate") {
						if(AAX.valid.rotate_type.includes(action)) {
							aa.control.rotate.type = action;
						}
						else if(action === "curl") {
							aa.control.curl = true;
						}
						else if(action === "no curl") {
							aa.control.curl = false;
						}
						else if(words.length >= 2 && words[0] === "invert") {
							let axis = convertaxis(words[1]);
							if(typeof axis === "number") {
								aa.posescript_dry(target, "invert", {axis});
							}
							else {
								return "invalid rotate invert action: " + action;
							}
						}
						else if(words.length >= 3 && words[0] === "switch") {
							let axis1 = convertaxis(words[1]);
							let axis2 = convertaxis(words[2]);
							if(typeof axis1 === "number" && typeof axis2 === "number") {
								aa.posescript_dry(target, "switch", {axis1, axis2});
							}
							else {
								return "invalid rotate switch action: " + action;
							}
						}
						else if(
							words.length >= 3
							&&
							words[1] === "="
							&&
							AAX.valid.rotate_axis_setters.includes(words[2])
						) {
							let axis = convertaxis(words[0]);
							if(aa.control.rotate.type !== "custom") {
								end();
								return "you tried to change the custom axes despite currently using " + aa.control.rotate.type + " axes. this is likely a mistake. custom axes can only be used when custom axes are selected. (\"rotate: custom\")";
							}
							else if(typeof axis === "string") {
								end();
								return "invalid axis: " + axis;
							};
							let type = words[2];
							let args = {axis};
							action = removewords(action, words, 3);
							if(type === "parent" || type === "child" || type === "local") {
								action = action.replaceAll("::", ":");
								if(aa.body.hasOwnProperty(action)) {
									args.partname = action;
								}
								else {
									end();
									return type + "-type custom axis setting requires specifying a part name.";
								};
							}
							else if(type === "written") {
								if(action.startsWith("[") && action.endsWith("]")) {
									args.input = action.slice(1, -1).trim();
								}
								else {
									end();
									return type + "-type custom axis setting requires inputting a three-coordinate point.";
								};
							};
							aa.posescript_dry(target, type, args);
						}
						else if(
							words.length >= 3
							&&
							words[0].includes("/")
							&&
							words[1] === "="
						) {
							if(aa.control.rotate.type !== "local") {
								return "you tried to name the local axes despite currently using " + aa.control.rotate.type + " axes. this is likely a mistake. local axis names can only be used when local axes are selected. (\"rotate: local\")";
							};
							let name = words[0].split("/");
							let _name = name[1];
							name = name[0];
							let old = structuredClone(localnaming);
							for(i3 = 2; i3 < words.length; i3++) {
								if(words[i3].startsWith("except(") && words[i3].endsWith(")")) {
									let list = parttarget(words[i3].slice("except(".length, -")".length));
									if(typeof list === "string") {
										end();
										return list;
									}
									else {
										list.forEach(function(element, index, array) {
											let part = element;
											localnaming[part].forEach(function(element, index, array) {
												if(element === name || element === _name) {
													array[index] = old[part][index];
												};
											});
										});
									};
								}
								else {
									let temp = words[i3].indexOf("(");
									let valid = (words[i3].startsWith("-") || words[i3].startsWith("+")) && temp !== -1 && words[i3].endsWith(")");
									if(valid) {
										let neg = words[i3].startsWith("-");
										let axis = convertaxis(words[i3].slice(1, temp));
										valid = typeof axis !== "string";
										if(valid) {
											let num = 2*axis + (neg ? 0 : 1);
											let _num = 2*axis + (neg ? 1 : 0);
											let list = parttarget(words[i3].slice(temp + 1, -1));
											if(typeof list === "string") {
												end();
												return list;
											}
											else {
												list.forEach(function(element, index, array) {
													localnaming[element][num] = name;
													localnaming[element][_num] = _name;
												});
											};
										};
									};
									if(!valid) {
										end();
										return "unsure what this word of a local axis naming means: " + words[i3] + ". it must be a plus or minus, followed by a true axis name, (xy, yz, xz, x, y, or z) followed by a set of parentheses showing which parts it's applied to.";
									};
								};
							}
						}
						else {
							end();
							return "unsure what this " + target + " action means: " + action;
						};
					}
					else if(target === "frame") {
						let move = words[0] === "move" && (words[1] === "up" || words[1] === "down");
						if(
							words[0] === "prev" || words[0] === "next"
							||
							words[0] === "blank" || words[0] === "duplicate"
							||
							words[0] === "delete"
							||
							move
						) {
							let num = Number(words[1 + move] ?? "");
							num = (Number.isInteger(num) && num > 0) ? num : 1;
							for(i3 = 0; i3 < num; i3++) {
								aa.posescript_dry(target, words.slice(0, 1 + move).join(" "));
							}
						}
						else {
							aa.posescript_dry(target, "jump", {input: action});
							// if it isn't a number, nothing will happen.
						};
					}
					else if(target === "tween") {
						let ref = aa.control.inbetween;
						function easechange(type) {
						// changes easeA and easeB. returns true if type was
						// valid, false if it wasn't.
							if(type === "in") {
								ref.easeA = false;
								ref.easeB = false;
							}
							else if(type === "out") {
								ref.easeA = true;
								ref.easeB = true;
							}
							else if(type === "in-out") {
								ref.easeA = false;
								ref.easeB = true;
							}
							else if(type === "out-in") {
								ref.easeA = true;
								ref.easeB = false;
							}
							else {
								return false;
							};
							return true;
						};
						if(words.length >= 2 && words[0] === "curve") {
							aa.posescript_dry(target, "curve", {input: words[1]});
						}
						else if(words.length >= 2 && words[0] === "ease") {
							easechange(words[1]);
						}
						else if(words[0] === "create" || words[0] === "apply") {
							let num = ref.number;
							let easeA = ref.easeA;
							let easeB = ref.easeB;
							let values = null;
							for(i3 = 1; i3 < words.length; i3++) {
							// apply temporary changes, or look for custom values
								if(words[i3].startsWith("[") && words[i3].endsWith("]")) {
									values = words[i3].slice(1, -1).trim();
									if(values) {
										values = values.split(",");
										values.forEach(function(element, index, array) {
											array[index] = readnumber(element) ?? 0;
										});
									};
								}
								else {
									let bool = aa.posescript_dry(target, "number", {input: words[i3]});
									if(!bool) {
										bool = easechange(words[i3]);
									};
								}
							}
							aa.posescript_dry(target, words[0], values ? {values} : null);
							// create/apply
							ref.number = num;
							ref.easeA = easeA;
							ref.easeB = easeB;
							// reverse temporary changes
						}
						else {
							aa.posescript_dry(target, "number", {input: action});
							// maybe it's a number. if not, no big deal.
						};
					}
					else if(target === "scene") {
						let stems = AAX.getchildren(aa.currpose, "standpoint");
						if(words[0].startsWith("[") && words[0].endsWith("]")) {
						// shift
							let point = convertpoint(words[0]);
							if(point.length !== 3) {
								end();
								return "a scene shift action should have 3 coordinates, not " + point.length + ".";
							};
							aa.posescript_dry(stems, "deform", Points.apply(point, {rel: true}));
						}
						else if(words[0] === "rotate" && words.length >= 3) {
							/*
							let axis = convertaxis(words[1]);
							//
							let fulcrum = null;
							if(words.length >= 4 && words[3].startsWith("[") && words[3].endsWith("]")) {
								let point = words[3].slice(1, -1).split(",");
								fulcrum = [];
								if(point.length >= 3) {
									for(i1 = 0; i1 < 3; i1++) {
										let num = Number(point[i1]);
										fulcrum[i1] = (isNaN(num) || num === Infinity || num === -Infinity) ? 0 : num;
									}
								}
								fulcrum = Math.hypot(...fulcrum) ? fulcrum : null;
							}
							if(fulcrum) {
								aa.posescript_dry(stems, "deform", Points.apply(Points.invert(fulcrum)));
								aa.posescript_dry(stems, "rotate", {axis, angle});
								aa.posescript_dry(stems, "deform", Points.apply(fulcrum));
							}
							else {
								aa.posescript_dry(stems, "rotate", {axis, angle});
							};
							//*/
						}
						else if(words.length >= 2 && words[0] === "mirror" && "xyz".includes(words[1]) && words[1].length === 1) {
							let axis = "xyz".indexOf(words[1]);
							let num = 0;
							if(words.length >= 3) {
								let name = removewords(action, words, 2).replaceAll("::", ":");
								if(aa.currpose.hasOwnProperty(name)) {
									num = aa.currpose[ name ].abscoor[axis];
								}
								else {
									num = Number(words[2]);
									num = Number.isInteger(Math.round(num)) ? num : 0;
								};
							};
							for(i1 = 0; i1 < stems.length; i1++) {
								let part = aa.currpose[ stems[i1] ];
								let coor = part["xyz"[axis]];
								coor -= num;
								coor *= -1;
								coor += num;
								part["xyz"[axis]] = coor;
							}
							aa.posescript_dry(stems, "mirror", {axis});
						};
					}
					else if(target === "time") {
						if(words[0] === "clear") {
							let num = aa.frames.length;
							for(i3 = 0; i3 < num; i3++) {
								aa.posescript_dry("frame", "delete");
							}
						}
						else if(words[0].startsWith("hide") || words[0].startsWith("show")) {
							let value = words[0].startsWith("hide");
							let list = words[0].slice((value ? "hide" : "show").length);
							list = parttarget(
								(list.startsWith("(") && list.endsWith(")"))
								?
								list.slice("(".length, -")".length)
								:
								"all"
							);
							aa.frames.forEach(function(element) {
								list.forEach(function(_element) {
									element[_element].hide = value;
								});
							});
						}
						else if(words[0] === "correct" && words[1] === "ap") {
							let unlooping = words.includes("unlooping");
							aa.frames.forEach(function(pose, index, frames) {
								if(unlooping && (index === 0 || index === frames.length - 1)) {
									return;
								};
								for(let part in pose) {
									if(pose.hasOwnProperty(part)) {
										let prev = frames[posmod(index - 1, frames.length)][part];
										let next = frames[posmod(index + 1, frames.length)][part];
										for(let view = 0; view < 4; view++) {
											let valid = true;
											let propertyname = "perspective_coor_" + view;
											for(let i1 = 0; i1 < 3 && valid; i1++) {
												let ref = i1 === 0 ? prev : i1 === 1 ? next : pose[part];
												let auto = ref.getwithoutredirects(propertyname);
												auto = (auto === "default" ? ref.getwithoutredirects(propertyname, false, true) : auto) === "auto";
												valid = valid && auto;
											}
											// only proceed if all three use
											// autoperspective.
											if(valid) {
												let prevcoor = prev[propertyname];
												let nextcoor = next[propertyname];
												let currcoor = pose[part][propertyname];
												let newcoor = null;
												let pre = {
													prev: aa.coortocanvas(prev.abscoor, view, true),
													next: aa.coortocanvas(next.abscoor, view, true),
													curr: aa.coortocanvas(pose[part].abscoor, view, true),
												};
												for(let axis = 0; axis < 2; axis++) {
													if(
														prevcoor[axis] === nextcoor[axis]
														&&
														Math.abs(prevcoor[axis] - currcoor[axis]) === 1
														&&
														pre.curr[axis] === pre.prev[axis]
														&&
														pre.curr[axis] === pre.next[axis]
													) {
														newcoor ??= structuredClone(currcoor);
														newcoor[axis] = prevcoor[axis];
													};
												}
												if(newcoor) {
													pose[part][propertyname] = newcoor;
												};
											}
										}
									};
								}
							});
						};
					}
					else {
						console.log("this shouldn't happen");
					};
				}
			}
			end();
			return no_refresh ? "no refresh" : "";
		}
	};
	//aa.initialize();
	//
	document.write(`<div id="bm_div"></div>`);
	let bm = {
	// tool for making bodytexts.
	// - this was written after the facial proportions tool, i just wanted it
	//   right after armature artist.
	// - if something isn't explained, chances are it's because there's an
	//   armature artist equivalent. read the comments there.
		bodydata: {},
		// stores data used to make bodytext.
		form_bodytext: function(bodydata) {
		// forms a bodytext from bodydata.
			let i1 = 0;
			bodydata ??= bm.bodydata;
			let text = [];
			let order = AAX.getchildren(bodydata);
			function addbranch(name, level) {
				level = Number.isInteger(level) && level > 0 ? level : 0;
				text.push(" ".repeat(level) + name + ": " + bodydata[name].x + ", " + bodydata[name].y + ", " + bodydata[name].z);
				for(let i1 in bodydata) {
					if(bodydata.hasOwnProperty(i1) && bodydata[i1].parent === name) {
						addbranch(i1, level + 1);
					}
				}
			}
			for(i1 = 0; i1 < order.length; i1++) {
				addbranch(order[i1]);
			}
			text = text.join("\n");
			text += "\n###";
			//
			order = AAX.getdesc(bodydata);
			// it's better to use getchildren/getdesc than to iterate through.
			// the order of iteration might not match the family tree if parts
			// were deleted or renamed.
			for(i1 = 0; i1 < order.length; i1++) {
				let _i1 = order[i1];
				if(bodydata[_i1].image_text.trim()) {
					text += "\n[ " + _i1 + " ]\n" + bodydata[_i1].image_text;
				}
			}
			text += "\n###";
			//
			for(i1 = 0; i1 < order.length; i1++) {
				let _i1 = order[i1];
				let symmetry = (
					bodydata[_i1].symmetry
					?
					"symmetry(" + (
						(bm.control.prefix1 === AAX.prefix1 && bm.control.prefix2 === AAX.prefix2)
						?
						""
						:
						bm.control.prefix1 + ", " + bm.control.prefix2
					) + ")"
					:
					""
				);
				let temp = bodydata[_i1].extra_text;
				if(symmetry) {
					temp = symmetry + (symmetry && temp ? "\n" : "") + temp;
				};
				if(temp) {
					text += "\n" + _i1 + ":\n\t" + temp.replaceAll("\n", "\n\t");
				};
			}
			//
			return text;
		},
		bodytext_change: function(text) {
		// used in the "apply changes" button and when loading a file. figures
		// out and applies everything needed to finalize the change, or alerts
		// the user if it ran into a problem.
			let i1 = 0;
			let i2 = 0;
			text ??= bm.bodytext;
			// whatever's in the bodytext textarea
			let obj = AAX.body_read.collect(text);
			if(typeof obj === "string") {
				alert(obj);
				return;
			};
			let data = {};
			let array = "parent x y z image_text extra_text".split(" ");
			let symmetry_found = false;
			// whether any parts are symmetrical. (gotta keep track of this so
			// it only saves the first prefix choice.)
			let prefix1 = AAX.prefix1;
			let prefix2 = AAX.prefix2;
			let prefix_schism = false;
			for(i1 in obj) {
				if(obj.hasOwnProperty(i1)) {
					data[i1] = bm.newpart();
					for(i2 = 0; i2 < array.length; i2++) {
						data[i1][ array[i2] ] = obj[i1][ array[i2] ];
					}
					let commands = AAX.body_read.extra_commands(data[i1].extra_text);
					for(i2 = 0; i2 < commands.length && !data[i1].symmetry; i2++) {
						let ref = commands[i2];
						if(ref.name === "symmetry") {
							let prefix = AAX.body_read.symmetry_prefixes(ref.content);
							prefix_schism = prefix_schism || (symmetry_found && (prefix[0] !== prefix1 || prefix[1] !== prefix2));
							if(!symmetry_found) {
								prefix1 = prefix[0];
								prefix2 = prefix[1];
							};
							symmetry_found = true;
							data[i1].symmetry = true;
						}
					}
					if(data[i1].symmetry) {
						data[i1].extra_text = bm.remove_symmetry(data[i1].extra_text, commands);
					}
				}
			}
			if(symmetry_found) {
			// ancestors with symmetry on override descendants with symmetry
			// on.
				let order = AAX.getdesc(data);
				for(i1 = 0; i1 < order.length; i1++) {
					let _i1 = order[i1];
					if(data[_i1].symmetry && AAX.getanc(data, _i1).some((element) => data[element].symmetry)) {
						data[_i1].symmetry = false;
					}
				}
			};
			//
			text = bm.form_bodytext(data);
			let body = AAX.Body.new(text);
			if(typeof body === "string") {
			// report Body.new errors
				alert(body);
				return;
			};
			//
			bm.bodydata = structuredClone(data);
			bm.control.prefix1 = prefix1;
			bm.control.prefix2 = prefix2;
			bm.control.partname = AAX.getchildren(body)[0];
			// select the first stem
			bm.refresh(null, text, body);
			// pass on the bodytext and body to refresh
		},
		remove_symmetry: function(text, commands) {
		// input an extra_text, and it'll slice out any symmetry() commands.
			commands ??= AAX.body_read.extra_commands;
			let offset = 0;
			// gotta keep track of how much you sliced out, so the
			// slicing indexes stay accurate.
			for(let i1 = 0; i1 < commands.length; i1++) {
				let ref = commands[i1];
				if(ref.name === "symmetry") {
					text = text.slice(0, offset + ref.start) + text.slice(offset + ref.end);
					offset += ref.end - ref.start;
				}
			}
			return text.replaceAll("\n\n", "\n");
		},
		extra_text_symmetry: function(string) {
		// returns an array of the starts and ends of symmetry() commands in an
		// extra_text.
		// - the indexes specifically mark the start and end of the parenthese
		//   contents.
			let comment_char = "//";
			let start = "symmetry(";
			let end = ")";
			let ranges = [];
			for(let i1 = 0; i1 < string.length; i1++) {
				let left = string.slice(0, i1);
				let right = string.slice(i1);
				if(right.startsWith(comment_char)) {
				// skip to the end of the comment.
					let temp = right.indexOf("\n");
					i1 += temp === -1 ? string.length : temp - 1;
					// it's a comment if it's in or after a comment_char but
					// before a \n. (the \n doesn't count as part of it, i
					// mean.)
				}
				else if(!(ranges.length%2) && right.startsWith("(") && left.endsWith("symmetry")) {
				// command start
					ranges.push(i1 + 1);
				}
				else if(ranges.length%2 && right.startsWith(")")) {
				// command end
					ranges.push(i1);
				};
			}
			return ranges;
		},
		get bodytext() {
			return document.getElementById("bm_bodytext").value;
		},
		set bodytext(value) {
			document.getElementById("bm_bodytext").value = value;
			document.getElementById("bm_bodytext").rows = value.split("\n").length;
		},
		body: null,
		pose: null,
		// Body, and pose.
		// - NOTE: the pose is only created so it can be drawn. it will never be
		//   posed.
		newpart: () => structuredClone({
		// returns a blank bodydata part.
			parent: "standpoint",
			x: 0,
			y: 0,
			z: 0,
			symmetry: false,
			image_text: AAX.Shape.templates.sphere,
			// text used in the second field. (shapes and images.)
			extra_text: "",
			// text used in the third field.
			// - NOTE: do not allow symmetry() commands. this tool needs to
			//   reliably know whether a part is symmetried or not, and with
			//   what prefixes.
		}),
		valid: {
			tools: "child sibling move select horizontal vertical radius".split(" "),
			refresh: ["bodytext", "states", "draw", "ui"],
			draw_type: ["parts", "silhouette", "neither"],
			// - parts only, with overlapping outlines
			// - silhouettes only, with different groups differentiated
			// - neither
			scale_type: ["position", "dimension", "both"],
		},
		drawsettings: new AAX.DrawSettings(),
		color: new AAX.Color(),
		ctx: null,
		ui_ctx: null,
		states: null,
		// States object for undo/redo
		initialize: function() {
			let i1 = 0;
			let i2 = 0;
			bm.bodydata.core = bm.newpart();
			bm.control.partname = "core";
			bm.drawsettings.total_hide = false;
			// total hide makes less sense for this, especially if it makes
			// parts unselectable.
			//bm.drawsettings.grid = [];
			bm.control.draw_type = bm.valid.draw_type[0];
			bm.states = new States(
				bm, 32,
				function(tool) {
					let state = {bodydata: structuredClone(tool.bodydata)};
					let array = "partname prefix1 prefix2".split(" ");
					for(let i1 = 0; i1 < array.length; i1++) {
						state[array[i1]] = tool.control[array[i1]];
					}
					return state;
				},
				function(tool, state) {
					for(let i1 in state) {
						if(state.hasOwnProperty(i1)) {
							if(i1 === "bodydata") {
								tool[i1] = structuredClone(state[i1]);
							}
							else {
								tool.control[i1] = state[i1];
							}
						}
					}
					tool.refresh("states");
				}
			);
			let string = `<details class="text">`;
			string += `\n\t<summary>manual</summary><ul>`;
			let manual = {
				"edit tools": [
					`child: create a child to the current part.`,
					`sibling: create a sibling to the current part.`,
					//`rapid: creates a child, but autonames it. useful for creating bodies quickly.`
					`move: move where a part is, relative to its parent.`,
					`select: select the part closest to where you click. useful for mobile devices.`
				],
				"scale tools": [
					`radius: scales the shape so that the furthest point of the shape is just as far away from the center as the mouse is.`,
					`horizontal, vertical: changes where the bounds of the shape are by scaling the points along the given axis.`,
					[
						`click past the front edge with horizontal, and you'll be able to move where the front edge is.`,
						`click past the back edge, and you move the back edge.`,
						`clicking between the edges moves the shape.`
					],
					`clicking a part selects it, and clicking anywhere else adjusts sizing.`
				],
				"etc": [
					`for child, sibling, and the scale tools, clicking a part will select it instead of doing anything else.`,
					`child and sibling will copy the images and third coordinate of the parent part.`,
					`the symmetry button toggles whether this branch of parts has a symmetrical duplicate.`,
					`expand lets you expand the part in whatever directions you toggled on the pad below the button.`,
					[
						`it's useful for fat and muscle. body parts get bigger with more fat/muscle, but they usually expand asymmetrically in the y/z axes.`,
					],
					`a lot of key shortcuts from armature artist work here, like tfgh letting you select a part's parent, siblings, or child.`,
					`the "apply changes" button near the bodytext area lets you apply manual changes to the bodytext.`
				],
			};
			for(i1 in manual) {
				if(manual.hasOwnProperty(i1)) {
					string += [
						``,
						`<details>`,
						`\t<summary>` + i1 + `</summary>`,
						`\t` + arraytoul(manual[i1], 1).replaceAll(`\n`, `\n\t`),
						`</details>`
					].join(`\n`).replaceAll(`\n`, `\n\t`);
				}
			}
			string += `\n</ul></details>`;
			string += `\n<canvas id="bm_canvas"></canvas>`;
			string += `\n<div id="bm_coor" style="text-shadow: silver .5px .5px; font-size: 8px"></div>`;
			string += `\n<br><canvas id="bm_ui_canvas"></canvas>`;
			string += `<br><button id="bm_applychanges">apply changes</button>`;
			string += `<br><textarea id="bm_bodytext" cols=48></textarea>`;
			for(i1 = 0; i1 < 3; i1++) {
				let id = "bm_" + (i1 === 0 ? "image_text" : i1 === 1 ? "extra_text" : "fatscript");
				string += `\n<dialog id="` + id + `" style=\"width: 40em;\" autofocus>`;
				if(i1 === 0) {
					string += `\nenter new text to define the shape and images.`;
					string += `\n<br>templates:`;
					string += `\n<ul>`;
					for(i2 in AAX.Shape.templates) {
						if(AAX.Shape.templates.hasOwnProperty(i2)) {
							string += `\n<button id=` + id + `_template_` + i2 + `>` + i2 + `</button>`;
						}
					}
					string += `\n</ul>`;
				}
				else if(i1 === 1) {
					string += `\nenter new text to define the extra parameters. (check the bodytext section of the armature artist manual for a full list of commands you can write here, and what they do.)`;
					string += `\n<ul>`;
					string += `\n\t<li>`;
					string += `\n\tdon't put "symmetry()" commands here. use the symmetry button instead.`;
					string += `\n\t</li>`;
					string += `\n</ul>`;
				}
				else if(i1 === 2) {
					string += `\nlets you do more complex expansions, on tons of parts at once. it's named "fatscript" because it's mostly useful for distributing fat throughout a body.`;
					string += `\n<details class=\"text\"><summary>syntax</summary>`;
					string += arraytoul([
						"the structure of one line of script is [part name (leave out symmetry prefixes)] + \": \" + [number or fraction] + \" \" + [direction letters]. for example, \"r_hip: 1/2 rdf\" will expand the right, bottom, and front side of r_hip by 1/2.",
						"this applies to the part and all its descendants, unless a descendant has a line of its own.",
						"if a number is written with * at the beginning, it will be multiplied by whatever expansion factor it already had. (so, \"*1/2\" means \"half of whatever the ancestor(s) already set it as\".)",
						"the direction letters are l for left, r for right, u for up, d for down, b for back, f for front.",
						"if there's multiple letters in the same direction, the effect will be multiplied. for example, \"1 lrddbf\" means it'll expand by 1 in every direction except up, and it'll expand by 2 down.",
						"use // to write comments.",
						"spaces at the beginning of lines are ignored, so you can use that to show what's a descendant of what, if you want."
					]);
					string += `</details>`;
				};
				string += `\n<br><textarea id="` + id + `_input" cols=48></textarea>`;
				if(i1 === 2) {
					string += `\n<br><label>factor: <input type="number" id="` + id + `_factor" style="width: 3em" step=1 value=1></label>`;
					string += `\n<br><label>floor: <input type="checkbox" id="` + id + `_floor" checked></label>`;
				};
				string += `\n<br><button id="` + id + `_enter">enter</button>`;
				if(i1 === 2) {
					string += `\n<button id="` + id + `_undo">undo</button>`;
					string += `\n<button id="` + id + `_redo">redo</button>`;
					// fat distribution requires some trial and error. (desktop
					// users can use the keyboard to undo/redo, but mobile users
					// can't.)
				};
				string += `\n<button id="` + id + `_close">close</button>`;
				string += `\n</dialog>`;
			}
			//string += ``;
			document.getElementById("bm_div").innerHTML = string;
			bm.writecoordinates(null);
			for(i1 = 0; i1 < 2; i1++) {
				let canvas = document.getElementById("bm_" + (i1 ? "ui_" : "") + "canvas");
				canvas.style["image-rendering"] = "crisp-edges";
				bm[i1 ? "ui_ctx" : "ctx"] = canvas.getContext("2d");
				if(i1) {
					canvas.onpointerdown = bm.ui.mousedown;
				}
				else {
					canvas.onpointerdown = bm.mousedown;
					canvas.onpointermove = bm.mousemove;
					canvas.onpointerup = bm.mouseup;
					canvas.onpointerleave = function(e) {
						bm.pasteimages(true);
						bm.pasteimages(false);
						bm.writecoordinates(null);
					};
					// like mouse events, except they work for phones and
					// drawing tablets.
					canvas.style["touch-action"] = "pinch-zoom";
					// this keeps it from sliding around when you're using a
					// phone.
					AAX.dragndrop(canvas, bm.readfile);
					// drag n drop file loading
					/*
					canvas.ondragover = function(e) {
						e.preventDefault();
					};
					canvas.ondrop = function(e) {
						let files = e.dataTransfer.items;
						if(files.length >= 1 && files[0].kind === "file") {
							bm.readfile(files[0].getAsFile());
						};
						e.preventDefault();
					};
					// lets you load things by dropping files onto the
					// canvas.
					*/
				}
			}
			for(i1 in AAX.Shape.templates) {
				if(AAX.Shape.templates.hasOwnProperty(i1)) {
					let text = "\n" + AAX.Shape.templates[i1];
					document.getElementById("bm_image_text_template_" + i1).onclick = function() {
						let input = document.getElementById("bm_image_text_input");
						let start = input.selectionStart;
						let end = input.selectionEnd;
						let trimend = input.value.trimEnd().length;
						let _text = (trimend ? "\n|\n" : "") + text;
						input.value = input.slice(0, trimend) + _text + input.slice(trimend);
						input.selectionStart = start + (start >= trimend ? _text.length : 0);
						input.selectionEnd = end + (end >= trimend ? _text.length : 0);
					};
				}
			}
			for(i1 = 0; i1 < 3; i1++) {
				let _i1 = (i1 === 0 ? "image_text" : i1 === 1 ? "extra_text" : "fatscript");
				let id = "bm_" + _i1;
				document.getElementById(id + "_input").onkeydown = textarea_autosize;
				if(i1 === 2) {
					document.getElementById(id + "_close").onclick = function(e) {
						document.getElementById(id).close();
					};
					document.getElementById(id + "_enter").onclick = function(e) {
						let script = document.getElementById(id + "_input").value;
						let factor = readnumber(document.getElementById(id + "_factor").value);
						if(script.trim() && factor) {
							let error = bm.fatscript(script, factor, document.getElementById(id + "_floor").checked);
							if(error) {
								alert(error);
							}
							else {
								bm.refresh();
								//document.getElementById(id).close();
							};
						};
					};
					document.getElementById(id + "_undo").onclick = function(e) { bm.states.undo() };
					document.getElementById(id + "_redo").onclick = function(e) { bm.states.redo() };
				}
				else {
					document.getElementById(id + "_close").onclick = function(e) {
						document.getElementById(id + "_input").value = "";
						document.getElementById(id).close();
					};
					document.getElementById(id + "_enter").onclick = function(e) {
						let old_text = bm.control.bodydata_part[_i1];
						let new_text = document.getElementById(id + "_input").value.trim();
						if(_i1 === "extra_text") {
							let commands = AAX.body_read.extra_commands(new_text);
							let temp = new_text.length;
							new_text = bm.remove_symmetry(new_text, commands);
							// slice out symmetry() commands
							if(new_text.length < temp) {
								// alert the user
								alert("do not use symmetry() commands. use the symmetry button instead.");
							};
						}
						bm.control.bodydata_part[_i1] = new_text;
						let bodytext = bm.form_bodytext();
						let body = AAX.Body.new(bodytext);
						if(typeof body === "string") {
							alert("invalid " + _i1 + ". (" + body + ")");
							bm.control.bodydata_part[_i1] = old_text;
						}
						else {
							bm.refresh(null, bodytext, body);
						}
						document.getElementById(id + "_input").value = "";
						document.getElementById(id).close();
					};
				};
			}
			/*
			document.getElementById("bm_fatscript_input").value = [
				"torso: 1 lr",
				" shoulder: 1 lrddbf",
				"  elbow: *1/2 ldb",
				"   hand: *1/2 ldb",
				" neckbase: 0",
				"hip: 1 ldf",
				" knee: *1/2 ldf",
				"  ankle: *1/2 luf",
				"   toe: *1/2 lluubf"
			].join("\n");
			//*/
			document.getElementById("bm_applychanges").onclick = function() { bm.bodytext_change(); };
			bm.ui.create();
			bm.refresh("states");
		},
		refresh: function(skip, bodytext, body) {
		// - skip: string or string array of actions to skip. (ex: "states" will
		//   keep it from saving a state. bm.valid.refresh has the full list.)
		// - bodytext, body: used to pass on bodytext/body, to avoid redundant
		//   runnings of bm.get_bodytext and AAX.Body.new.
		//   - when editing shape_text or something like that, before it decides
		//     to refresh and save the user's changes, it has to run those
		//     functions to make sure invalid input didn't cause an error
		//     somewhere. it'd be a waste to throw the generated bodytext/body
		//     out and run that stuff again.
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			skip = typeof skip === "string" ? [skip] : Array.isArray(skip) ? skip : [];
			if(!skip.includes("bodytext")) {
			// rewrite the bodytext, redefine the body and pose
				bodytext ??= bm.form_bodytext();
				body ??= AAX.Body.new(bodytext);
				if(typeof body === "string") {
					console.log("this shouldn't happen");
					console.log(body);
				}
				else if(body instanceof AAX.Body) {
					bm.bodytext = bodytext;
					bm.body = body;
					bm.pose = AAX.newpose(bm, bm.body);
					for(i1 in bm.pose) {
						if(bm.pose.hasOwnProperty(i1) && !bm.control.partname) {
						// NOTE: ALWAYS ALWAYS ITERATE THROUGH THE POSE, NOT
						// BODYDATA!
						// - otherwise, you'll miss parts created as symmetrical
						//   duplicates.
						// - not that that's particularly relevant here, but
						//   shut up!
							bm.control.partname = i1;
						}
					}
				}
				else {
					console.log("this shouldn't happen");
				}
			};
			if(!skip.includes("states")) {
				bm.states.save();
			};
			if(!skip.includes("draw")) {
				bm.draw_background();
				bm.draw();
				const ctx = bm.ctx;
				const cell = bm.drawsettings.cell;
				for(i1 = 0; i1 < 2; i1++) {
					bm["image_" + (i1 ? "right" : "front")] = ctx.getImageData(cell.w*i1, 0, cell.w, cell.h);
				}
				// save images, which are used to reverse graphical changes in
				// the clickable interface
			};
			if(!skip.includes("ui")) {
				bm.ui.draw();
			};
		},
		symmetry: function(name) {
		// input a partname from the body/pose, and it'll return 0, 1, or 2
		// depending on what kind of symmetry the named part has.
		// - 1 and 2 mean it's part of a branch with symmetry duplication
		// - 0 means it isn't
		// - 2 means it's specifically the branch that gets x-mirrored, and
		//   takes bm.control.prefix2
		// - 1 means it's the branch that isn't, and takes prefix1
			if(name in bm.bodydata) {
				return 0;
			}
			else if(name.startsWith(bm.control.prefix1) && name.slice(bm.control.prefix1.length) in bm.bodydata) {
				return 1;
			}
			else if(name.startsWith(bm.control.prefix2) && name.slice(bm.control.prefix2.length) in bm.bodydata) {
				return 2;
			}
			else {
				if(name in bm.body) {
					console.log("this shouldn't happen");
					// the only kind of part that should be in body/pose but not
					// bodydata is symmetrical counterparts.
				}
				else {
					console.log("invalid part name.");
				}
			};
		},
		has_symmetry: (name) => bm.bodydata[name].symmetry || AAX.getanc(bm.bodydata, name).some((element) => bm.bodydata[element].symmetry),
		// input a bodydata part name. returns whether it's symmetrical, ie one
		// of its ancestors has true .symmetry
		bodydata_name: function(name) {
		// takes a body/pose partname and gives the corresponding bm.bodydata
		// name.
			let symmetry = bm.symmetry(name);
			name = (
				symmetry === 1 ? name.slice(bm.control.prefix1.length) :
				symmetry === 2 ? name.slice(bm.control.prefix2.length) :
				name
			);
			if(!(name in bm.bodydata)) {
				console.log("this shouldn't happen");
			};
			return name;
		},
		body_name: (name) => (bm.has_symmetry(name) ? bm.control.prefix1 : "") + name,
		replaceshape: function(bodydata_part, shape) {
		// converts the given shape into text, and replaces the first field of
		// the given part's image_text with it.
			let temp = bodydata_part.image_text.split("||");
			temp[0] = AAX.Shape.string(shape);
			if(temp[0] && temp.length > 1) {
				temp[0] += "\n";
			};
			bodydata_part.image_text = temp.join("||");
		},
		disable_delete: () => (
			bm.control.delete_branch
			?
			(
				bm.control.bodydata_part.parent === "standpoint"
				&&
				AAX.getchildren(bm.bodydata, "standpoint").length <= 1
			)
			:
			AAX.getdesc(bm.bodydata).length <= 1
		),
		// evaluates whether the delete button should be disabled.
		// - if branch is on, than it should be disabled if it's the only stem.
		// - otherwise, it should be disabled if it's the only part.
		control: {
			view: 0,
			// on account of armature artist conventions and that i am just not
			// willing to fully implement a "right" boolean or whatever would be
			// more efficient... 0 means the front, 1 means the right.
			partname: "",
			// name of the selected part. it must always be the name of a part
			// in the body/pose.
			get symmetry() {
				return bm.symmetry(bm.control.partname);
			},
			get bodydata_name() {
				return bm.bodydata_name(bm.control.partname);
			},
			get bodydata_part() {
				return bm.bodydata[bm.control.bodydata_name];
			},
			get body_part() {
				return bm.body[bm.control.partname];
			},
			get pose_part() {
				return bm.pose[bm.control.partname];
			},
			get node() {
				return AAX.getnode(bm.nodes, bm.control.view, bm.control.partname);
			},
			tool: "child",
			clicktype: null,
			partclicked: false,
			strokecache: null,
			//
			prefix1: AAX.prefix1,
			prefix2: AAX.prefix2,
			// used in symmetry
			// - NOTE: one of the few things besides bodydata to be saved in a state.
			delete_branch: true,
			expand_number: 1,
			expand: {
				l: false,
				r: false,
				u: false,
				d: false,
				b: false,
				f: false,
			},
			expand_branch: true,
			adjust_half: true,
			last_adjust: "",
			// a direction. it can be empty.
			scale_numer: 2,
			scale_denom: 1,
			scale_type: "both",
			scale_x: true,
			scale_y: true,
			scale_z: true,
			scale_branch: true,
			//
			draw_type: null,
			get skeleton() {
				return bm.drawsettings.skeleton && bm.drawsettings.nodes;
			},
		},
		get noderadius() {
			return bm.control.tool === "select" ? Infinity : AAX.noderadius;
		},
		nodecheck: function(click, view) {
			let node = null;
			let hypot = bm.noderadius + .5;
			for(let i1 = bm.nodes[view].length - 1; i1 >= 0; i1--) {
			// search backwards, so it finds the closer nodes first.
				let _node = bm.nodes[view][i1];
				let _hypot = Math.hypot(
					_node.x - click[0],
					_node.y - click[1]
				);
				if(_hypot < hypot && (!bm.pose[_node.name].hide || !bm.drawsettings.total_hide)) {
				// if the part is hidden and total hide is on, don't allow the
				// node to be selected or clicked.
					node = _node;
					hypot = _hypot;
				};
			}
			return node;
		},
		coortocanvas: (point, view, nonulls, viewoffset) => AAX.coortocanvas(bm.drawsettings.cell, bm.drawsettings.standpoint, point, view, nonulls, viewoffset),
		coorfromcanvas: (x, y, view) => AAX.coorfromcanvas(bm.drawsettings.cell, bm.drawsettings.standpoint, x, y, view),
		mousedown: function(e) {
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let click = clickxy(e, "bm");
			const cell = bm.drawsettings.cell;
			const view = Math.floor(click[0]/cell.w);
			const tool = bm.control.tool;
			bm.control.view = view;
			let node = bm.nodecheck(click, view);
			bm.control.partclicked = node !== null;
			if(bm.control.partclicked) {
				bm.control.partname = node.name;
				let skip = structuredClone(bm.valid.refresh);
				skip.splice(skip.indexOf("ui"), 1);
				bm.refresh(skip);
			}
			else {
				node = bm.control.node;
			};
			bm.control.strokecache = {};
			for(i1 in bm.pose) {
				if(bm.pose.hasOwnProperty(i1)) {
					let _part = bm.pose[i1];
					bm.control.strokecache[i1] = {
						front: _part.image_front,
						right: _part.image_right,
					}
					let ref = bm.control.strokecache[i1];
					for(i2 in ref) {
						if(ref.hasOwnProperty(i2)) {
							ref[i2] = AAX.sq_raster.fill(ref[i2], _part.dim(i2, ref[i2].length)[0]);
						}
					}
				}
			}
			// fill strokecache (lets it reuse images so it doesn't run rasterize
			// every mousemove)
			bm.control.clicktype = "main";
			if(bm.control.partclicked && tool !== "move") {
				// select the part, don't do anything else.
			}
			else if(tool === "child" || tool === "sibling" || tool === "chain") {
				let parent = tool === "sibling" ? bm.control.body_part.parent : bm.control.partname;
				let parentcoor = parent === "standpoint" ? [0, 0, 0] : bm.pose[parent].abscoor;
				// abscoor of the new part's parent
				let _parentcoor = parent === "standpoint" ? parentcoor : Points.add(parentcoor, bm.pose[parent].relcoor);
				// the third relative coordinate should imitate the parent.
				// that'll probably be closer to what the user wants than 0.
				let relcoor = bm.coorfromcanvas(...click, view);
				relcoor = [
					relcoor.x ?? _parentcoor[0],
					relcoor.y ?? _parentcoor[1],
					relcoor.z ?? _parentcoor[2]
				];
				relcoor = Points.trunc(Points.subtract(relcoor, parentcoor));
				// subtract the parent's abscoor, and truncate.
				let name = "";
				if(tool === "chain") {
				// autonaming
					let _name = parent.split("_");
					let num = Number(_name[_name.length - 1]);
					_name = _name.slice(0, -1);
					if(parent === "standpoint" || !Number.isInteger(num) || num < 0) {
						_name = parent;
						num = 0;
					}
					_name += _name ? "_" : "";
					while((_name + num) in bm.bodydata) {
						num++;
					};
					name = _name + num;
				}
				else {
					name = (prompt("enter a name for the new part.") ?? "").trim();
					let error = AAX.body_read.validname(name);
					if(error) {
						alert(error);
						name = "";
					};
				};
				if(name) {
					if(name in bm.body && !(name in bm.bodydata)) {
						name = bm.bodydata_name(name);
					};
					let symmetry = parent === "standpoint" ? 0 : bm.symmetry(parent);
					if(symmetry === 2) {
						relcoor[0] *= -1;
					}
					parent = parent === "standpoint" ? parent : bm.bodydata_name(parent);
					let skip_refresh = false;
					//
					if(name in bm.bodydata) {
						// instead of making a new part, make the named part a
						// child/sibling of the selected part.
						let anc = parent === "standpoint" ? [] : AAX.getanc(bm.bodydata, parent);
						if(anc.includes(name) || name === parent) {
							// the named part is an ancestor of the part the user is
							// attempting to parent it to. this would cause a
							// parenting loop.
							skip_refresh = true;
							alert("part already exists. (normally it would shift parenting around to add it as a " + tool + ", but in this case it would cause a parenting loop.)");
						}
						else {
							bm.bodydata[name].parent = parent;
						};
					}
					else {
						bm.bodydata[name] = bm.newpart();
						bm.bodydata[name].parent = parent;
						if(parent !== "standpoint") {
							bm.bodydata[name].image_text = bm.bodydata[parent].image_text;
						};
						for(i1 = 0; i1 < 3; i1++) {
							bm.bodydata[name]["xyz"[i1]] = relcoor[i1];
						}
						bm.control.partname = (symmetry ? bm.control["prefix" + symmetry] : "") + name;
						// select it
					}
					// - name is in bodydata: change its parenting
					// - name is not in bodydata, but is in body: use the
					//   bodydata_name, and change its parenting like a bodydata
					//   name
					// - name is in neither: make a new part, and copy the
					//   relcoor
					//
					if(!skip_refresh) {
						bm.refresh();
					};
				}
			}
			else if(tool === "radius" || tool === "horizontal" || tool === "vertical") {
			// figure out the strokedata.
				bm.control.strokedata = {};
				let ref = bm.control.strokedata;
				let points = bm.control.body_part.shape.points;
				if(tool === "radius") {
					ref.radius = AAX.Shape.radius(points);
				}
				else {
					ref.bounds = AAX.Shape.bounds(points);
					ref.axis = tool === "vertical" ? 1 : view%2 ? 2 : 0;
				};
				if(tool === "horizontal" || tool === "vertical") {
					ref.coor = bm.coorfromcanvas(...click, view)["xyz"[ref.axis]];
					// the amount you move the box or bound by is measured by
					// how many pixels away you moved from where the click
					// started.
					if(ref.bounds) {
						if(bm.control.symmetry === 2) {
						// mirror the bounding box
							let temp = ref.bounds.l;
							ref.bounds.l = -ref.bounds.r;
							ref.bounds.r = -temp;
						};
						let center = bm.control.pose_part.abscoor[ref.axis];
						let temp = ref.coor - center;
						ref.sign = (
							temp <= ref.bounds["lub"[ref.axis]] ? -1 :
							temp >= ref.bounds["rdf"[ref.axis]] ? 1 :
							0
						);
						// if you click on or past an edge, your click drags that
						// edge around. if you click between the edges, you move the
						// whole box.
						ref.zero = !(ref.bounds["rdf"[ref.axis]] - ref.bounds["lub"[ref.axis]]);
					}
					else {
						ref.sign = 0;
						ref.zero = true;
					}
				}
			}
		},
		mousemove: function(e, finish) {
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let click = clickxy(e);
			const ctx = bm.ctx;
			const cell = bm.drawsettings.cell;
			const view = bm.control.clicktype === "main" ? bm.control.view : Math.floor(click[0]/cell.w);
			const coor = bm.coorfromcanvas(click[0], click[1], view);
			let part_select = bm.control.tool !== "move" ? bm.nodecheck(click, view) : null;
			part_select = part_select && part_select.name !== bm.control.partname ? part_select.name : null;
			// it doesn't happen for the part that's already selected. not just
			// because that's wasteful; it would also mean you can't use the
			// radius tool to shrink something smaller than noderadius.
			if(view === 0 || view === 1) {
			// draw coordinates
				let text = [
					"",
					"xz"[view%2] + ": " + coor["xz"[view%2]],
					"y: " + coor.y
				];
				if(bm.control.clicktype !== "main" || part_select) {
					let node = bm.nodecheck(click, view);
					bm.pasteimages(false);
					bm.pasteimages(true);
					if(node !== null) {
						text[0] = node.name;
						// display the name
						node = AAX.noderect(node.x, node.y);
						ctx.strokeStyle = bm.color.interface[0];
						ctx.fillStyle = bm.color.interface[1];
						ctx.strokeRect(node.x - .5, node.y - .5, node.w + 1, node.h + 1);
						ctx.fillRect(node.x, node.y, node.w, node.h);
						bm.pasteimages(!view);
					}
				};
				bm.writecoordinates(text);
			};
			if(bm.control.clicktype !== "main") {
				return;
			};
			//
			if(part_select) {
			// tilt/rotate should allow node selection on mouseup, and visualize
			// it. that gives much more visual feedback, and therefore
			// precision.
				if(finish) {
					bm.control.partname = part_select;
					//
					bm.control.strokecache = null;
					bm.control.clicktype = null;
					bm.control.strokedata = null;
					bm.writecoordinates(null);
					bm.refresh(["bodytext", "states", "draw"]);
				};
				return;
			};
			//
			bm.pasteimages(!!bm.control.view);
			bm.writecoordinates(null);
			ctx.strokeStyle = bm.color.interface[0];
			ctx.fillStyle = bm.color.interface[1];
			const tool = bm.control.tool;
			const strokedata = bm.control.strokedata;
			if(
				(tool === "move" !== bm.control.partclicked)
				// you have to click a part and drag it.
				// - move without clicking a part: invalid, you have to click
				//   and drag a node.
				// - clicking a part in any other mode: don't do anything after
				//   mousedown, just select it.
				||
				tool === "child" || tool === "sibling" || tool === "chain"
				// everything happens on mousedown for these.
				||
				(tool === "radius" && !strokedata.radius)
				// if the radius was zero or null, no matter how much the shape
				// is multiplied, it won't change.
				||
				((tool === "horizontal" || tool === "vertical") && (
					(strokedata.zero && strokedata.sign)
					// can't drag the edges around if the dimension is zero, since
					// it works by multiplying.
					||
					!strokedata.bounds
					// scaling a shape with no valid points makes no sense.
				))
			) {
				bm.control.strokecache = null;
				bm.control.clicktype = null;
				bm.control.strokedata = null;
				bm.writecoordinates(null);
				return;
			}
			const node = bm.control.node;
			const bodydata_part = bm.control.bodydata_part;
			const body_part = bm.control.body_part;
			const pose_part = bm.control.pose_part;
			let parent_node = node.parent;
			if(node.parent === "standpoint") {
				parent_node = bm.coortocanvas([0, 0, 0], view, true, true);
				parent_node = {
					x: parent_node[0],
					y: parent_node[1],
					name: parent,
				};
			};
			// a node-like object for standpoint, or the .parent reference.
			//
			let data = {};
			// things that the position of the mouse is adjusting... it's like
			// strokedata, except it can be deleted now.
			// - if that's confusing, just don't worry about it. this is just to
			//   escape block-scoping.
			if(tool === "radius") {
				data.radius = Math.round(Math.hypot(click[0] - node.x, click[1] - node.y));
				bm.writecoordinates(data.radius);
			}
			else if(tool === "move") {
				let oldcoor = pose_part.abscoor;
				let newcoor = bm.coorfromcanvas(...click, view);
				newcoor = [
					newcoor.x ?? oldcoor[0],
					newcoor.y ?? oldcoor[1],
					newcoor.z ?? oldcoor[2]
				];
				for(i1 = 0; i1 < 3; i1++) {
					newcoor[i1] = oldcoor[i1] + Math.trunc(newcoor[i1] - oldcoor[i1]);
				}
				// truncate the coordinates so that the floats are the same as they
				// were before.
				let parent = body_part.parent;
				data.coor = parent === "standpoint" ? structuredClone(newcoor) : Points.subtract(newcoor, bm.pose[parent].abscoor);
				// data.coor is the new relcoor to apply to the selected part.
			}
			else if(tool === "horizontal" || tool === "vertical") {
				data.bounds = structuredClone(strokedata.bounds)
				let bounds = strokedata.bounds;
				let _bounds = data.bounds;
				let neg = "lub"[strokedata.axis];
				let pos = "rdf"[strokedata.axis];
				data.change = Math.trunc(bm.coorfromcanvas(...click, view)["xyz"[strokedata.axis]] - strokedata.coor);
				let sign = strokedata.sign;
				let temp = data.change;
				if(sign === -1) {
					temp *= -1;
				};
				temp = (temp > 0 ? "+" : "") + temp;
				bm.writecoordinates("lxruydbzf"[3*strokedata.axis + 1 + sign] + " " + temp);
				data.multiplier = 1;
				if(sign === 0) {
					_bounds[neg] += data.change;
					_bounds[pos] += data.change;
				}
				else if(sign === -1) {
					_bounds[neg] += data.change;
					data.multiplier = _bounds[neg]/bounds[neg];
					_bounds[pos] *= data.multiplier;
					// bounds*multiplier = _bounds
					// multiplier = _bounds/bounds
				}
				else if(sign === 1) {
					_bounds[pos] += data.change;
					data.multiplier = _bounds[pos]/bounds[pos];
					_bounds[neg] *= data.multiplier;
				};
			}
			//
			if(tool === "radius" || (tool === "move" && body_part.parent !== "standpoint")) {
			// draw circles.
			// - radius: show the current radius of the part's shape, and the
			//   radius your click would set it as
			// - move: show the current hypotenuse, and where the parent is
				let center = tool === "radius" ? node : parent_node;
				center = [center.x, center.y];
				let radius = tool === "radius" ? strokedata.radius : Math.floor(Math.hypot(bodydata_part.x, bodydata_part.y, bodydata_part.z));
				circledraw(ctx, ...center, radius);
				if(tool === "radius") {
					circledraw(ctx, ...center, data.radius);
				};
				temp = ctx.fillStyle;
				ctx.fillStyle = ctx.strokeStyle;
				circledraw(ctx, ...center, AAX.noderadius, true);
				ctx.fillStyle = temp;
			}
			else if(tool === "horizontal" || tool === "vertical") {
				let center = bm.control.pose_part.abscoor;
				let temp = view%2 ? ["ruf", "rub", "rdb", "rdf"] : ["luf", "ruf", "rdf", "ldf"];
				let rect = Rect.new();
				let _rect = Rect.new();
				for(i1 = 0; i1 < 2; i1++) {
					let bounds = i1 ? data.bounds : strokedata.bounds;
					for(i2 = 0; i2 < 4; i2++) {
						let point = Points.add(
							center,
							[
								bounds[ temp[i2][0] ],
								bounds[ temp[i2][1] ],
								bounds[ temp[i2][2] ]
							]
						);
						point = bm.coortocanvas(point, view, true, true);
						//console.log(point);
						if(i1) {
							if(i2) {
								_rect = Rect.reach(_rect, ...point);
							}
							else {
								_rect.x = point[0];
								_rect.y = point[1];
							}
						}
						else {
							if(i2) {
								rect = Rect.reach(rect, ...point);
							}
							else {
								rect.x = point[0];
								rect.y = point[1];
							}
						}
					}
					//console.log(i1 ? _rect : rect);
				}
				for(i1 = 0; i1 < 4; i1++) {
				// 0: draw a black outline for the original box
				// 1: draw a black outline for the modified box
				// 2: draw the original box, in gray
				// 3: draw the modified box, in white
					ctx.strokeStyle = bm.color.interface[i1 === 2 ? 2 : i1 === 3 ? 1 : 0];
					for(i2 = 0; i2 < 2; i2++) {
					// - first iteration: round the coordinates so the rect gets
					//   smaller (and subtract 1, if it's outline)
					// - second iteration: round the coordinates so the rect
					//   gets bigger (and add 1, if it's outline)
						let temp = structuredClone(i1%2 ? _rect : rect);
						temp = i2 ? Rect.round_out(temp) : Rect.round_in(temp);
						if(i1 < 2) {
							let sign = i2 ? 1 : -1;
							temp = Rect.expanded(temp, "l", sign);
							temp = Rect.expanded(temp, "r", sign);
							temp = Rect.expanded(temp, "u", sign);
							temp = Rect.expanded(temp, "d", sign);
						}
						Rect.fauxstroke(temp, ctx);
					}
				}
			};
			bm.pasteimages(!view);
			//
			if(tool === "move") {
				let rect = {
					x: Math[([1, 2].includes(view) ? "ceil" : "floor")](parent_node.x) + .5,
					y: Math[([1, 2].includes(view) ? "ceil" : "floor")](parent_node.y) + .5,
					// floor/ceil it so it's what the coortocanvas would be
					// without floats, and add .5 so it's in the center of
					// the pixels.
					w: ([1, 2].includes(view) ? -1 : 1)*Math.trunc(data.coor[view%2 ? 2 : 0]),
					h: Math.trunc(data.coor[1]),
				};
				ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
				bm.writecoordinates(data.coor);
			}
			if(finish) {
				let skip_refresh = false;
				if(tool === "move") {
					bodydata_part.x = data.coor[0];
					bodydata_part.y = data.coor[1];
					bodydata_part.z = data.coor[2];
					if(bm.control.symmetry === 2) {
					// bodydata_part is actually the symmetrical counterpart,
					// so.
						bodydata_part.x *= -1;
					};
				}
				else if((tool === "horizontal" || tool === "vertical") && !strokedata.sign) {
				// move the shape
					if(data.change) {
						let points = structuredClone(body_part.shape.points);
						for(i1 = 0; i1 < points.length; i1++) {
							for(i2 = 0; i2 < points[i1].length; i2++) {
								let point = points[i1][i2];
								point[strokedata.axis] += data.change;
								if(bm.control.symmetry === 2) {
								// shape belongs to the counterpart, but will be
								// applied to the original
									point[0] *= -1;
								};
							}
						}
						bm.replaceshape(bodydata_part, {points});
					}
				}
				else if(tool === "radius" || tool === "horizontal" || tool === "vertical") {
					let multiply = [1, 1, 1];
					let mirror = [false, false, false];
					if(tool === "radius") {
						let num = data.radius/strokedata.radius;
						multiply = [num, num, num];
					}
					else if(tool === "horizontal" || tool === "vertical") {
						multiply[strokedata.axis] = data.multiplier;
						if(data.multiplier < 0) {
							mirror[strokedata.axis] = true;
						}
					}
					let all_same = multiply[0] === multiply[1] && multiply[1] === multiply[2];
					// endless, finite (copy that.)
					skip_refresh = all_same && multiply[0] === 1;
					if(!skip_refresh) {
					// editing the shapes like this wipes comments. at least
					// avoid it if it won't do anything.
						let points = structuredClone(body_part.shape.points);
						for(i1 = 0; i1 < points.length; i1++) {
							for(i2 = 0; i2 < points[i1].length; i2++) {
								let point = points[i1][i2];
								if(point.length >= 4 && point.length < 6 && !all_same) {
								// there's different multipliers for each axis,
								// so turn spheres into spheroids. (make sure
								// there's three numbers, filling in missing
								// numbers with [3].)
									point[4] ??= point[3];
									point[5] ??= point[3];
								}
								for(i3 = 0; i3 < Math.min(point.length, 6); i3++) {
									point[i3] *= i3 < 3 ? multiply[i3] : Math.abs(multiply[i3 - 3]);
								}
								if(point.length >= 7 && mirror.includes(true)) {
									point[6] = Quat.mirror.multi(point[6], ...mirror);
								};
							}
						}
						bm.replaceshape(bodydata_part, {points});
						//let points = structuredClone(bm.body[(bm.has_symmetry(_i0) ? bm.control.prefix1 : "") + _i0].shape.points);
					}
				}
				bm.control.strokecache = null;
				bm.control.clicktype = null;
				bm.control.strokedata = null;
				bm.writecoordinates(null);
				bm.refresh();
			};
		},
		mouseup: function(e) {
			if(bm.control.clicktype !== "main") {
				return;
			};
			bm.mousemove(e, true);
		},
		ui: {
			buttons: {},
			// rectangle objects
			heading: [],
			// list of button names that are headings
			depress: [],
			// list of button names that are animated
			checkbox: [],
			// buttons that are checkboxes. you get the idea.
			finddirection: function(x, y) {
			// used for the expand and adjust directional buttons. input two 0
			// to 1 numbers for where the click is on the button, and it'll
			// return the appropriate direction letter.
				if(x > 2/3) {
					return y < .5 ? "b" : "f";
				};
				x /= 2/3;
				x -= .5;
				y -= .5;
				return (
					Math.abs(x) >= Math.abs(y)
					?
					(x < 0 ? "l" : "r")
					:
					(y < 0 ? "u" : "d")
				);
			},
			create: function() {
				let i1 = 0;
				let temp1 = [];
				for(i1 in AAX.Shape.templates) {
					if(AAX.Shape.templates.hasOwnProperty(i1)) {
						temp1.push(i1);
					};
				}
				let temp2 = structuredClone(AAX.ui.color_area);
				temp2.direction = "r";
				bm.ui.buttons = Rect.ui([
					{
						prefix: "",
						actions: [
							["row", "undo redo".split(" "), "r", 4, 2]
						],
					},
					{
						prefix: "",
						actions: [
							["row", "save load".split(" "), "r", 4, 2]
						],
					},
					{
						prefix: "scale",
						direction: "r",
						gap: 5,
						actions: [
							["column", "number", "d", 4.5, 1],
							["expand", "x y z".split(" "), "d", 1, true],
							["column", " type".split(" "), "l", 6, 1],
							["expand", "branch", "d", 1]
						],
					},
					{
						prefix: "adjust",
						direction: "d",
						actions: [
							["column", "directions", "d", 6, 4],
							["expand", "half", "d", 1]
						],
						heading: 1,
					},
					{
						prefix: "expand",
						direction: "r",
						actions: [
							["column", "", "d", 4, 1],
							["expand", "number", "r", 2],
							["expand", "directions", "d", 4],
							["expand", "branch", "d", 1],
							["expand", "fatscript", "d", 1]
						],
					},
					/*
					{
						prefix: "rename",
						direction: "d",
						previous: -2,
						actions: [
							["column", "part branch ancestry".split(" "), "d", 6, 1]
						],
						heading: 1,
					},
					//*/
					{
						prefix: "template",
						direction: "d",
						adjust: -1,
						actions: [
							["column", temp1, "d", 7, 1]
						],
						heading: 2,
					},
					{
						prefix: "tool",
						previous: 0,
						direction: "d",
						actions: [
							["column", "create child sibling move select".split(" "), "r", 7, 1],
							["column", "scale radius horizontal vertical".split(" "), "r", 7, 1]
						],
					},
					{
						prefix: "delete",
						direction: "r",
						adjust: 1,
						actions: [
							["column", "", "d", 5, 2],
							["expand", "branch", "d", 1]
						],
					},
					{
						prefix: "part",
						previous: -2,
						direction: "d",
						actions: [
							["column", "image_text", "d", 11, 2],
							["expand", "symmetry", "d", 1],
							["expand", "extra_text", "d", 2],
							["column", "hypot", "l", 10, 5],
							["expand", "name", "u", 1]
						],
					},
					{
						prefix: "drawsettings",
						direction: "d",
						actions: [
							["column", "background draw_type skeleton".split(" "), "d", 9, 1],
							["expand", "grid", "d", 1],
							["expand", "standpoint", "d", 2],
							["expand", "cell", "d", 1],
							["expand", "fineness", "d", 1],
						],
						heading: 1,
					},
					temp2,
					{
						prefix: "px",
						previous: -2,
						actions: [
							["column", "paste replace".split(" "), "d", 6, 2],
						],
						heading: 2,
					}
					// - simplified:
				    //   - prefix
				    //   - previous, direction, gap, adjust
				    //   - first
				    //     - suffix
				    //     - w, h
				    //     - horizontal
				    //   - actions
				    //     - ["row"/"column", suffixes, direction, w, h]
				    //     - ["expand", suffix, direction, amount, horizontal]
				    //     - ["subtract", suffix, direction, amount]
				    //     - ["align", suffix, direction]
				    //   - heading
				]);
				bm.ui.buttons.part_prefix1 = Rect.fromslice(bm.ui.buttons.part_symmetry, "r", 5);
				bm.ui.buttons.part_prefix2 = Rect.fromslice(bm.ui.buttons.part_prefix1, "r", 2.5);
				bm.ui.buttons.part_relcoor = Rect.fromslice(bm.ui.buttons.part_hypot, "d", 4);
				bm.ui.buttons.part_abscoor = Rect.fromslice(bm.ui.buttons.part_relcoor, "l", bm.ui.buttons.part_relcoor.w/2);
				let w = 0;
				let h = 0;
				for(i1 in bm.ui.buttons) {
					if(bm.ui.buttons.hasOwnProperty(i1)) {
						let ref = bm.ui.buttons[i1];
						ref.x *= AAX.ui.block;
						ref.y *= AAX.ui.block;
						ref.w *= AAX.ui.block;
						ref.h *= AAX.ui.block;
						w = Math.max(w, ref.x, ref.x + ref.w);
						h = Math.max(h, ref.y, ref.y + ref.h);
						let prefix = PreSuf.get(i1);
						let suffix = prefix[1];
						prefix = prefix[0];
						if(
							suffix === "heading"
							||
							(prefix === "tool" && (suffix === "create" || suffix === "scale"))
						) {
							bm.ui.heading.push(i1);
						}
						else if(
							(suffix === "branch" && prefix !== "rename")
							||
							(prefix === "adjust" && suffix === "half")
						) {
							bm.ui.checkbox.push(i1);
						}
						else if(
							!suffix
							||
							(prefix === "part" && (suffix === "image_text" || suffix === "extra_text"))
							||
							prefix === "template"
							||
							(prefix === "adjust" && suffix === "directions")
							||
							prefix === "px"
						) {
							bm.ui.depress.push(i1);
						};
					}
				}
				w++;
				h++;
				let canvas = bm.ui_ctx.canvas;
				canvas.width = w;
				canvas.height = h;
			},
			draw: function(depress) {
				let i1 = 0;
				let i2 = 0;
				let i3 = 0;
				let ctx = bm.ui_ctx;
				ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
				ctx.font = AAX.ui.font;
				ctx.textBaseline = "middle";
				let part = bm.control.bodydata_part;
				for(let button in bm.ui.buttons) {
					if(bm.ui.buttons.hasOwnProperty(button)) {
						let rect = structuredClone(bm.ui.buttons[button]);
						let center = Rect.center(rect);
						center = [
							Math.floor(center[0]),
							Math.floor(center[1])
						];
						let prefix = PreSuf.get(button);
						let suffix = prefix[1];
						prefix = prefix[0];
						let heading = bm.ui.heading.includes(button);
						let checkbox = bm.ui.checkbox.includes(button);
						let directions = suffix === "directions" && (prefix === "expand" || prefix === "adjust");
						let selected = (
							(prefix === "tool" && !heading && suffix === bm.control.tool)
							||
							(checkbox && bm.control[button])
							||
							(button === "part_symmetry" && bm.control.bodydata_part.symmetry)
							||
							(prefix === "scale" && (suffix === "x" || suffix === "y" || suffix === "z") && bm.control[button])
						);
						selected = Number(selected);
						if(depress && button === depress) {
							selected = posmod(selected + 1, 3);
						};
						if(
							(button === "delete" && bm.disable_delete())
							||
							(button === "part_symmetry" && !selected && bm.has_symmetry(bm.control.bodydata_name))
						) {
							selected = 2;
						};
						if(prefix === "drawsettings") {
							if(suffix === "draw_type") {
								selected = bm.valid[suffix].indexOf(bm.control[suffix]);
							}
							else if(suffix === "skeleton") {
								selected = Number(bm.control.skeleton);
							};
						}
						else if(button === "scale_type") {
							selected = bm.valid[button].indexOf(bm.control[button]);
						};
						let color = bm.color.buttons;
						ctx.strokeStyle = color[posmod(-selected, color.length)];
						ctx.fillStyle = color[posmod(1 - selected, color.length)];
						if(!heading && !checkbox && !directions) {
							ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
							Rect.fauxstroke(rect, ctx);
						};
						if(prefix === "drawsettings" && suffix !== "heading" && suffix !== "draw_type" && suffix !== "skeleton") {
							AAX.ui.draw.drawsettings(ctx, rect, bm.drawsettings, suffix, suffix === "standpoint" ? "double" : "row");
							// row: grid, cell, fineness
							// double: standpoint
						}
						else if(prefix === "color" && suffix !== "heading") {
							AAX.ui.draw.color(ctx, rect, bm.color, suffix);
						}
						else {
							let text = (
								!suffix ? prefix :
								suffix === "heading" ? (
									prefix === "tool" ? prefix + "s" :
									prefix === "template" ? ["shape", prefix + "s"] :
									prefix === "drawsettings" ? "draw settings" :
									prefix === "px" ? ["pixel art", "transfer"] :
									prefix
								) :
								prefix === "part" ? (
									suffix === "name" ? "part: " + bm.control.partname :
									suffix === "image_text" ? "edit image text" :
									(suffix === "prefix1" || suffix === "prefix2") ? bm.control[suffix] :
									suffix === "extra_text" ? "edit extra text" :
									suffix === "hypot" ? (Math.hypot(part.x, part.y, part.z) + "").slice(0, 7) :
									(suffix === "relcoor" || suffix === "abscoor") ? bm.control.pose_part[suffix] :
									suffix
								) :
								directions ? [] :
								(prefix === "expand" && suffix === "number") ? bm.control.expand_number :
								prefix === "scale" ? (
									suffix === "number" ? "x" :
									suffix === "type" ? bm.control[button] :
									suffix
								) :
								(prefix === "drawsettings" && suffix === "draw_type") ? bm.control[suffix] :
								suffix
							);
							let left = [];
							let centered = [];
							let right = [];
							// string arrays. each one is a different alignment,
							// each item is a different row.
							if(prefix === "part" && (suffix === "relcoor" || suffix === "abscoor")) {
								for(i1 = 0; i1 < 3; i1++) {
									text[i1] = (text[i1] > 0 ? "+" : "") + text[i1] + (text[i1]%1 ? "" : "  ");
								}
								// make it a string, add plus signs, and make sure
								// the decimal points align.
								text.splice(0, 0, "");
								left = [suffix.slice(0, 3) + ":", "", "", ""];
							}
							else if(prefix === "part" && suffix === "hypot") {
								left.push("length:");
							}
							else if(prefix === "scale" && suffix === "number") {
								right.push(
									bm.control.scale_denom === 1
									?
									(bm.control.scale_numer + "").slice(0, 5)
									:
									(bm.control.scale_numer + "/" + bm.control.scale_denom)
								);
							};
							//
							if(
								(prefix === "part" && (suffix === "hypot" || suffix === "relcoor" || suffix === "abscoor"))
								||
								(prefix !== "scale" && suffix === "number")
							) {
								if(Array.isArray(text)) {
									right = structuredClone(text);
								}
								else {
									right.push(text);
								};
							}
							else if(
								heading
								||
								(!suffix && prefix !== "expand")
								||
								(prefix === "part" && (suffix === "image_text" || suffix === "extra_text" || suffix === "symmetry"))
								||
								prefix === "px"
								||
								suffix === "x" || suffix === "y" || suffix === "z"
							) {
								if(Array.isArray(text)) {
									centered = structuredClone(text);
								}
								else {
									centered.push(text);
								};
							}
							else {
								if(Array.isArray(text)) {
									left = structuredClone(text);
								}
								else {
									left.push(text);
								};
							};
							//
							if(checkbox) {
								/*
								let box = Rect.expand_all(Rect.new(rect.x, rect.y, AAX.ui.block, AAX.ui.block), -1);
								ctx.fillStyle = bm.color.buttons[1];
								ctx.strokeStyle = bm.color.buttons[0];
								ctx.fillRect(box.x + 1, box.y + 1, box.w, box.h);
								Rect.fauxstroke(box, ctx);
								box = Rect.expand_all(box, -2);
								if(selected) {
									// draw a pink x, or filled box.
									//ctx.strokeStyle = bm.color.buttons[2];
									ctx.strokeStyle = bm.color.buttons[0];
									if(selected === 1) {
										linespecial(ctx, box.x, box.y, box.x + box.w, box.y + box.h);
										linespecial(ctx, box.x + box.w, box.y, box.x, box.y + box.h);
									}
									else if(selected === 2) {
										ctx.fillRect(box.x, box.y, box.w + 1, box.h + 1);
									};
								};
								//*/
								AAX.ui.checkbox(ctx, bm.color.buttons, rect.x, rect.y, selected === 2 ? "special check" : !!selected);
								ctx.strokeStyle = bm.color.buttons[0];
								rect.x += AAX.ui.block;
								rect.w -= AAX.ui.block;
							}
							else if(directions) {
								let selected = prefix === "expand" ? bm.control[prefix] : {
									l: false,
									r: false,
									u: false,
									d: false,
									b: false,
									f: false,
								};
								if(prefix === "adjust" && button === depress && bm.control.last_adjust) {
									selected[bm.control.last_adjust] = true;
								};
								let order = "lrudbf".split("");
								order.sort((a, b) => selected[a] - selected[b]);
								for(i1 = 0; i1 < order.length; i1++) {
									let _i1 = order[i1];
									ctx.fillStyle = bm.color.buttons[selected[_i1] ? 0 : 1];
									ctx.strokeStyle = bm.color.buttons[selected[_i1] ? 2 : 0];
									if(_i1 === "b" || _i1 === "f") {
										let box = Rect.new(rect.x + rect.w*2/3, rect.y, rect.w/3, rect.h/2);
										if(_i1 === "f") {
											box.y += box.h;
										};
										ctx.fillRect(box.x, box.y, box.w, box.h);
										Rect.fauxstroke(box, ctx);
									}
									else {
										let tri = [[1/2, 1/2]];
										tri.push([
										Number(_i1 === "r" || _i1 === "d"),
										Number(_i1 === "d" || _i1 === "l")
										]);
										tri.push([
										Number(_i1 === "u" || _i1 === "r"),
										Number(_i1 === "r" || _i1 === "d")
										]);
										for(i2 = 0; i2 < 3; i2++) {
											tri[i2] = [
											rect.x + tri[i2][0]*rect.w*2/3,
											rect.y + tri[i2][1]*rect.h
											];
										}
										_2dPoly.draw(ctx, tri, "both");
									}
								}
							};
							AAX.ui.button_text(ctx, rect, left, centered, right);
						}
					}
				}
			},
			mousedown: function(e) {
				let click = clickxy(e, "bm");
				bm.control.clicktype = "ui";
				for(let i1 in bm.ui.buttons) {
					if(bm.ui.buttons.hasOwnProperty(i1) && Rect.inside(bm.ui.buttons[i1], ...click)) {
						bm.ui.action(i1, click);
						bm.control.clicktype = null;
					}
				}
				bm.control.clicktype = null;
			},
			action: function(button, click) {
				let i0 = 0;
				let i1 = 0;
				let i2 = 0;
				let i3 = 0;
				let i4 = 0;
				let part = bm.control.bodydata_part;
				let prefix = PreSuf.get(button);
				let suffix = prefix[1];
				prefix = prefix[0];
				let refresh = {};
				for(i1 = 0; i1 < bm.valid.refresh.length; i1++) {
					let _i1 = bm.valid.refresh[i1];
					if(_i1 !== "bodytext") {
						refresh[_i1] = _i1 !== "states";
					}
				}
				// an object of booleans, for which parts of refresh should be
				// done or skipped.
				let no_refresh = false;
				function prompt_number(text, increment, no_negative, allow_inf) {
				// opens a prompt for changing a number. allows fractions.
				// returns null if their input was invalid.
				// - increment: 1 means the input will be truncated to the
				//   nearest integer, .5 means to the nearest .5, etc. 0 or any
				//   non-number will skip this.
				// - invalid inputs:
				//   - cancel
				//   - empty string (or a string that's just whitespace)
				//   - NaN when Number() is used
				//   - Infinity, -Infinity
					let input = prompt(text);
					if(input === null || !input.trim()) {
						return null;
					};
					input = input.split("/").slice(0, 2);
					for(let i1 = 0; i1 < 2; i1++) {
						input[i1] = Number(input[i1] ?? 1);
					}
					input = input[0]/input[1];
					if(typeof increment === "number" && increment) {
						input = Math.trunc(input/increment)*increment;
					};
					return (
						(
							isNaN(input)
							||
							((input === Infinity || input === -Infinity) && !allow_inf)
							||
							(input < 0 && no_negative)
						)
						?
						null
						:
						input
					);
				};
				//
				if(bm.ui.heading.includes(button)) {
					no_refresh = true;
				}
				else if(suffix === "directions" && click) {
					let rect = bm.ui.buttons[button];
					let direction = bm.ui.finddirection(
						(click[0] - rect.x)/rect.w,
						(click[1] - rect.y)/rect.h
					);
					if(prefix === "expand") {
						bm.control.expand[direction] = !bm.control.expand[direction];
					}
					else if(prefix === "adjust") {
						let temp = "lrudbf".indexOf(direction);
						if(bm.control.symmetry === 2 && (temp === 0 || temp === 1)) {
							temp = posmod(temp + 1, 2);
						}
						part["xyz"[Math.floor(temp/2)]] += (temp%2 ? 1 : -1)*(bm.control.adjust_half ? .5 : 1);
						refresh.states = true;
						bm.control.last_adjust = direction;
					}
				}
				else if(suffix === "number") {
					let text = (
						prefix === "scale" ? "enter the scale factor. it can be a fraction." :
						prefix === "expand" ? "enter how much to expand each side by." :
						"enter a number."
					);
					let num = null;
					if(prefix === "scale") {
						text = prompt(text);
						if(text) {
							let temp = text.indexOf("/");
							num = temp === -1 ? [Number(text), 1] : [Number(text.slice(0, temp)), Number(text.slice(temp + 1))];
							if(num[1] < 0) {
								num[0] *= -1;
								num[1] *= -1;
							};
							if(
								isNaN(num[0]) || isNaN(num[1])
								||
								num[0] === Infinity || num[0] === -Infinity
								||
								num[1] === Infinity || num[1] === 0
							) {
								num = null;
							};
						}
					}
					else {
						num = prompt_number(text, prefix === "expand" ? .5 : 0);
					}
					if(num === null) {
						no_refresh = true;
					}
					else {
						if(prefix === "scale") {
							bm.control.scale_numer = num[0];
							bm.control.scale_denom = num[1];
						}
						else {
							bm.control[button] = num;
						}
					};
				}
				else if(bm.ui.checkbox.includes(button) || (prefix === "scale" && (suffix === "x" || suffix === "y" || suffix === "z"))) {
					bm.control[button] = !bm.control[button];
				}
				else if(prefix === "scale" && suffix === "type") {
					let array = bm.valid[button];
					bm.control[button] = array[posmod(array.indexOf(bm.control[button]) + 1, array.length)];
				}
				else if(button === "scale") {
					let numer = bm.control.scale_numer;
					let denom = bm.control.scale_denom;
					let axes = [];
					for(i1 = 0; i1 < 3; i1++) {
						axes.push(bm.control["scale_" + "xyz"[i1]]);
					}
					let position = bm.control.scale_type === "position" || bm.control.scale_type === "both";
					let dimension = bm.control.scale_type === "dimension" || bm.control.scale_type === "both";
					let same_floats = true;
					if((numer !== 1 || denom !== 1) && denom && (position || dimension) && axes.includes(true)) {
						let keep_float = function(num, odd) {
							if(!num) {
								return num;
							};
							let float = odd ? .5 : 0;
							let sign = Math.sign(num);
							num = Math.abs(num);
							num = Math.round(num - float) + float;
							// make sure it has the same float as
							// the original
							return Math.max(num, float)*sign;
							// make sure the rounding didn't invert
							// the sign, reverse the Math.abs
						};
						let order = bm.control.scale_branch ? AAX.getdesc(bm.bodydata, bm.control.bodydata_name) : [];
						order.splice(0, 0, bm.control.bodydata_name);
						let start = part.parent === "standpoint" ? [0, 0, 0] : AAX.abscoor(bm.bodydata, part.parent);
						// position of the selected part's parent
						let all_abs = AAX.all_abs(bm.bodydata);
						// save this before you modify coordinates. that way,
						// ancestors' changes won't have cumulative effects on
						// their descendants.
						for(i0 = 0; i0 < order.length; i0++) {
							let _i0 = order[i0];
							let _part = bm.bodydata[_i0];
							if(position) {
								let coor = Points.subtract(all_abs[_i0], start);
								coor = Points.divide(Points.multiply(coor, numer), denom);
								coor = Points.add(coor, start);
								// multiply or divide its distance from the
								// branch start
								let abs_parent = _part.parent === "standpoint" ? [0, 0, 0] : AAX.abscoor(bm.bodydata, _part.parent);
								//
								for(i1 = 0; i1 < 3; i1++) {
									if(axes[i1]) {
										let num = coor[i1];
										if(same_floats) {
										// keep the same oddness it had before
											num = keep_float(num, !!(all_abs[_i0][i1]%1));
										}
										num = Math.trunc(num*2)/2;
										// make extra sure it's a .0 or .5
										_part["xyz"[i1]] = num - abs_parent[i1];
									};
								}
							}
							if(dimension) {
								let points = structuredClone(bm.body[(bm.has_symmetry(_i0) ? bm.control.prefix1 : "") + _i0].shape.points);
								for(i1 = 0; i1 < points.length; i1++) {
									for(i2 = 0; i2 < points[i1].length; i2++) {
										let point = points[i1][i2];
										if(point.length >= 4 && axes.includes(false)) {
											point[4] ??= point[3];
											point[5] ??= point[3];
										};
										for(i3 = 0; i3 < point.length && i3 < 6; i3++) {
											if(axes[i3%3]) {
												let num = point[i3]*numer/denom;
												if(same_floats) {
													num = i3 < 3 ? keep_float(num, !!(point[i3]%1)) : Math.round(num);
												};
												point[i3] = num;
											}
										}
										if(point.length >= 7 && dimension && (numer/denom) < 0 && axes.includes(false)) {
											point[6] = Quat.mirror.multi(point[6], ...axes);
										}
									}
								}
								bm.replaceshape(_part, {points});
							}
						}
						refresh.states = true;
					}
					else {
						no_refresh = true;
					}
				}
				else if(button === "expand") {
					let parts = bm.control.expand_branch ? AAX.getdesc(bm.bodydata, bm.control.bodydata_name) : [];
					parts.splice(0, 0, bm.control.bodydata_name);
					refresh.states = true;
					no_refresh = true;
					let num = bm.control.expand_number;
					const letters = "lrudbf";
					for(i0 = 0; num && i0 < parts.length; i0++) {
						let _part = bm.bodydata[parts[i0]];
						let points = structuredClone(bm.body[bm.body_name(parts[i0])].shape.points);
						let bounds = AAX.Shape.bounds(points);
						if(bounds) {
						// expansion is both movement and scaling of the shape
						// points.
							for(i1 = 0; i1 < letters.length; i1++) {
								let _i1 = i1;
								if((_i1 === 0 || _i1 === 1) && bm.control.symmetry === 2) {
								// the use of bm.control.symmetry sounds wrong,
								// but keep in mind all bodydata parts are
								// unmirrored; it isn't being inverted because
								// the part currently being edited is mirrored,
								// it's inverted because the user has an
								// inverted part selected; therefore, what would
								// make that part expand right is actually left
								// expansion on the shape the mirrored shape is
								// derived from.
								// - i hate this kind of xor-y logic. the values
								//   are stupid simple, but there's so many
								//   variations of the same thing that it's hard
								//   to keep track of where and how they're
								//   applied.
									_i1 = Number(!_i1);
								};
								_i1 = letters[_i1];
								if(bm.control.expand[_i1]) {
									no_refresh = false;
									bounds[_i1] += (i1%2 ? 1 : -1)*num;
								}
							}
							// get the old box with AAX.Shape.bounds, modify it
							// to get the new box
							if(!no_refresh) {
								bm.replaceshape(_part, {points: AAX.Shape.expand(points, bounds)});
							};
						};
					}
				}
				else if(prefix === "expand" && suffix === "fatscript") {
					document.getElementById("bm_fatscript").showModal();
					no_refresh = true;
				}
				else if(button === "delete") {
					if(bm.disable_delete()) {
						no_refresh = true;
					}
					else {
						let symmetry = bm.control.symmetry;
						let name = bm.control.bodydata_name;
						let _name = bm.bodydata[name].parent;
						// part that it'll switch to
						if(bm.control.delete_branch) {
							let array = AAX.getdesc(bm.bodydata, name);
							delete bm.bodydata[name];
							for(i1 = 0; i1 < array.length; i1++) {
								delete bm.bodydata[ array[i1] ];
							}
						}
						else {
							let array = AAX.getchildren(bm.bodydata, name);
							for(i1 = 0; i1 < array.length; i1++) {
								let _part = bm.bodydata[ array[i1] ];
								for(i2 = 0; i2 < 3; i2++) {
									_part["xyz"[i2]] += part["xyz"[i2]];
								}
								_part.parent = _name;
								if(part.symmetry) {
									_part.symmetry = true;
								}
							}
							delete bm.bodydata[name];
						};
						if(_name === "standpoint") {
							_name = AAX.getchildren(bm.bodydata, "standpoint")[0];
						};
						bm.control.partname = (bm.has_symmetry(_name) ? bm.control["prefix" + symmetry] : "") + _name;
						// - you have to use has_symmetry, since it might be
						//   symmetrical through an ancestor
						// - if it is symmetrical, match what the deleted part
						//   was
						// - if the deleted part wasn't symmetrical, that
						//   shouldn't be possible. so i'm okay with it causing
						//   undefined error.
						refresh.states = true;
					};
				}
				else if(prefix === "tool") {
					bm.control.tool = suffix;
				}
				else if(prefix === "part") {
					if(suffix === "name") {
						let symmetry = bm.control.symmetry;
						let name = prompt("enter a new name." + (symmetry ? " (leave out symmetry prefixes.)" : ""));
						//let name = prompt("enter a new name to rename the part," + (symmetry ? " (leave out symmetry prefixes.)" : "") + " or enter an existing part to select it.");
						name = (name ?? "").trim();
						if(!name) {
							no_refresh = true;
						}
						else if(name in bm.bodydata) {
							alert("part already exists.");
							no_refresh = true;
						}
						else {
							let _name = bm.control.bodydata_name;
							bm.bodydata[name] = structuredClone(bm.bodydata[_name]);
							delete bm.bodydata[_name];
							for(i1 in bm.bodydata) {
								if(bm.bodydata.hasOwnProperty(i1)) {
									let _part = bm.bodydata[i1];
									if(_part.parent === _name) {
										_part.parent = name;
									};
								}
							}
							bm.control.partname = (symmetry ? bm.control["prefix" + symmetry] : "") + name;
							refresh.states = true;
						};
					}
					else if(suffix === "image_text" || suffix === "extra_text") {
						let temp = part[suffix];
						let dialog = document.getElementById("bm_" + suffix);
						let textarea = document.getElementById("bm_" + suffix + "_input");
						textarea.rows = temp.split("\n").length + 4;
						textarea.value = temp;
						dialog.showModal();
						no_refresh = true;
						// clicking the button just opens the dialog. it doesn't
						// do anything worth refreshing, only the buttons inside
						// it do.
					}
					else if(suffix === "symmetry" || suffix === "prefix1" || suffix === "prefix2") {
						let name = bm.control.bodydata_name;
						let symmetry = bm.control.symmetry;
						if(suffix === "symmetry") {
							if(!bm.control.bodydata_part.symmetry && bm.has_symmetry(bm.control.bodydata_name)) {
							// descendant of a part with true symmetry (ie it
							// must stay false.)
								no_refresh = true;
							}
							else {
								bm.bodydata[name].symmetry = !bm.bodydata[name].symmetry;
								if(bm.bodydata[name].symmetry) {
									// when flipping symmetry on, flip it off for all
									// descendants
									let desc = AAX.getdesc(bm.bodydata, name);
									for(i1 = 0; i1 < desc.length; i1++) {
										bm.bodydata[ desc[i1] ].symmetry = false;
									}
									//
								}
								bm.control.partname = (bm.bodydata[name].symmetry ? bm.control.prefix1 : "") + name;
								// in either case, update partname
								refresh.states = true;
							}
						}
						else if(suffix === "prefix1" || suffix === "prefix2") {
							let text = prompt("enter a new prefix for " + (suffix === "prefix2" ? "mirrored" : "unmirrored") + " symmetrical parts.") ?? "";
							text = text.replaceAll(",", "").replaceAll("(", "").replaceAll(")", "").trim();
							// forbid parentheses and commas, for syntax reasons
							if(text && text !== bm.control["prefix" + (suffix === "prefix2" ? "1" : "2")]) {
								bm.control[suffix] = text;
								bm.control.partname = (symmetry ? bm.control["prefix" + symmetry] : "") + name;
								// update partname
								refresh.states = true;
								// prefixes are part of states.
							}
							else {
								no_refresh = true;
							}
						}
					}
				}
				else if(prefix === "template") {
					let temp = part.image_text.split("\n||\n");
					temp[0] = AAX.Shape.templates[suffix];
					part.image_text = temp.join("\n||\n");
					refresh.states = true;
				}
				else if(prefix === "drawsettings") {
					let ref = bm.drawsettings;
					if(suffix === "background") {
						let num = AAX.valid[suffix].indexOf(bm.drawsettings[suffix]);
						num = (num + 1)%3;
						if(num === 2) {
							num = (num + 1)%3;
						}
						bm.drawsettings[suffix] = AAX.valid[suffix][num];
					}
					else if(suffix === "draw_type") {
						let num = bm.valid[suffix].indexOf(bm.control[suffix]);
						num = (num + 1)%3;
						bm.control[suffix] = bm.valid[suffix][num];
						ref.silhouette = AAX.valid.silhouette[num === 1 ? 2 : 0];
						ref.parts = AAX.valid.parts[num === 0 ? 2 : 0];
					}
					else if(suffix === "skeleton") {
					// skeletons and nodes share one toggle.
						let bool = ref.skeleton && ref.nodes;
						ref.skeleton = !bool;
						ref.nodes = !bool;
					}
					else {
						no_refresh = AAX.ui.action.drawsettings(ref, suffix);
						if(!no_refresh && suffix === "fineness") {
							// clear the cache
							// - fineness affects the shape, the rest affect
							//   perspective.
							for(i1 in bm.pose) {
								if(bm.pose.hasOwnProperty(i1)) {
									// for every body part.
									AAX.clearcache(bm.pose, i1, "orientedshape");
									// this isn't an AAX., so we
									// can't use the method.
								}
							}
						};
					}
				}
				else if(prefix === "color") {
					no_refresh = AAX.ui.action.color(bm.color, suffix, click, bm.ui.buttons[button]);
				}
				else if(prefix === "px") {
					changefocus("px");
					px.transfer(bm.ctx, suffix === "replace");
					//px.transfer(bm.ctx, suffix === "replace", true, bm.drawsettings.cell.w, bm.drawsettings.cell.w);
					no_refresh = true;
				}
				else if(!suffix) {
					if(prefix === "undo") {
						bm.states.undo();
						no_refresh = true;
						// refresh already happens in undo/redo.
					}
					else if(prefix === "redo") {
						bm.states.redo();
						no_refresh = true;
					}
					else if(prefix === "save") {
						bm.save();
						no_refresh = true;
						// save doesn't do anything that requires a refresh
					}
					else if(prefix === "load") {
						bm.load();
						no_refresh = true;
						// load already refreshes
					};
				};
				// expand
				//  expand
				//  number
				//  directions
				//  no heading
				// adjust
				//  directions
				// shape templates
				//  sphere
				//  pelvis
				//  torso
				//  head
				//  cranium
				//  jaw
				// scale
				//  scale
				//  number
				//  divide
				//  no heading
				//
				if(bm.ui.depress.includes(button)) {
					refresh.ui = false;
					// it'll get redrawn for the depressing, so the other refresh
					// would just be redundant.
					bm.ui.draw(button);
					// draw the button depressed
					setTimeout(bm.ui.draw, 1000*AAX.ui.depress);
					// draw it undepressed after a little bit.
				}
				refresh.bodytext = refresh.states;
				let temp = [];
				for(i1 = 0; i1 < bm.valid.refresh.length; i1++) {
					let _i1 = bm.valid.refresh[i1];
					if(!refresh[_i1]) {
						temp.push(_i1);
					};
				}
				// now it's an array of what to skip.
				if(!no_refresh) {
					bm.refresh(temp);
				}
			},
		},
		nodes: [[], []],
		image_front: null,
		image_right: null,
		pasteimages: function(right) {
		// pastes image_front or image_right over the canvas, to reverse
		// graphical changes or correct overflow.
			bm.ctx.putImageData(bm["image_" + (right ? "right" : "front")], (right ? bm.drawsettings.cell.w : 0), 0);
		},
		writecoordinates: function(text) {
			AAX.writecoordinates(document.getElementById("bm_coor"), text);
		},
		nodeline: function(ctx, x1, y1, x2, y2, view, viewoffset) {
			let temp = bm.coortocanvas([0, 0, 0], view, true, viewoffset);
			temp[0] += .5;
			temp[1] += .5;
			// center of the standpoint pixel
			linespecial(ctx, x1, y1, x2, y2, temp);
		},
		draw_background: function() {
			AAX.draw_background(bm.ctx, bm.drawsettings, bm.color, false, "multi2");
		},
		draw: function() {
			AAX.draw(
				bm.ctx, bm.drawsettings, bm.color, false, "multi2",
				bm.pose, bm.nodes, bm.control.strokecache
			);
		},
		save: function() {
			AAX.save("bm " + filedate() + ".txt", bm.bodytext);
		},
		load: function() {
			AAX.load(bm.readfile);
		},
		readfile: function(file) {
		// run by load and the drag-and-drop event listener.
			if(!file) {
				console.log("this shouldn't happen");
				return;
			};
			let temp = file.name.lastIndexOf(".");
			let reader = new FileReader();
			reader.onload = function() {
				bm.bodytext_change(reader.result);
			};
			reader.readAsText(file);
		},
		fatscript: function(script, factor, floor) {
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			script = script.split("\n");
			for(i1 = 0; i1 < script.length; i1++) {
				let line = script[i1].trim();
				let temp = line.indexOf("//");
				line = temp === -1 ? line : line.slice(0, temp);
				if(line) {
					script[i1] = line;
				}
				else {
					script.splice(i1, 1);
					i1--;
				};
			}
			let data = {};
			for(i1 in bm.bodydata) {
				if(bm.bodydata.hasOwnProperty(i1)) {
					data[i1] = {
						factor: 0,
						l: 1, r: 1,
						u: 1, d: 1,
						b: 1, f: 1,
					};
				}
			};
			const dir = "lrudbf";
			for(i1 = 0; i1 < script.length; i1++) {
				let line = script[i1];
				let temp = line.indexOf(":");
				if(temp === -1) {
					return "unsure what this line means: " + script[i1];
				};
				let name = line.slice(0, temp);
				if(!bm.bodydata.hasOwnProperty(name)) {
					return "invalid part name: " + name;
				};
				line = line.slice(temp + 1).trim();
				let multiply = line.startsWith("*");
				line = multiply ? line.slice(1) : line;
				line = trimunspecial(line).split(" ");
				if(line.length >= 1) {
					let _factor = readnumber(line[0]);
					if(_factor === null) {
						return "invalid number/fraction: " + line[0];
					};
					data[name].factor = (multiply ? data[name].factor : 1)*_factor;
					if(line.length >= 2) {
						let bool = false;
						for(i2 = 0; i2 < dir.length; i2++) {
							data[name][dir[i2]] = 0;
						}
						for(i2 = 0; i2 < line[1].length; i2++) {
							let _i2 = line[1][i2];
							if(dir.includes(_i2)) {
								data[name][_i2]++;
							};
						}
					}
					let desc = AAX.getdesc(bm.bodydata, name);
					for(i2 = 0; i2 < desc.length; i2++) {
						let _i2 = desc[i2];
						let __factor = data[_i2].factor;
						data[_i2] = structuredClone(data[name]);
						if(multiply) {
							data[_i2].factor = __factor*_factor;
						};
					}
				}
			}
			for(i1 in bm.bodydata) {
				if(bm.bodydata.hasOwnProperty(i1) && data[i1].factor) {
					let points = structuredClone(bm.body[bm.body_name(i1)].shape.points);
					let bounds = AAX.Shape.bounds(points);
					if(bounds) {
						let bool = false;
						for(i2 = 0; i2 < dir.length; i2++) {
							let num = factor*data[i1].factor*data[i1][dir[i2]];
							num = floor ? Math.floor(roundspecial(num)) : num;
							bool = bool || num;
							bounds[dir[i2]] += (i2%2 ? 1 : -1)*num;
						}
						// get the old box with AAX.Shape.bounds, modify it
						// to get the new box
						if(bool) {
							bm.replaceshape(bm.bodydata[i1], {points: AAX.Shape.expand(points, bounds)});
						};
					};
				}
			};
			return "";
		},
	};
	//bm.initialize();
	//
	document.write(`\n<div id="px_div"></div>`);
	let px = null;
	//let px = new PixelArt(document.getElementById("px_div"));
	//
	document.write(`\n<div id="se_div"></div>`);
	let se = {
		initialize: function() {
			let i1 = 0;
			let i2 = 0;
			let html = [
				"<textarea name=\"shape\" cols=48></textarea>",
				"<br><label><input type=\"number\" name=\"spacing\" style=\"width: 3em\" step=1 value=1> cross section spacing</label>",
				"<br><label><input type=\"number\" name=\"fineness\" style=\"width: 3em\" step=1 value=4> spheroid fineness</label>",
				"<br><button name=\"update\">update</button>",
				"<br><br><canvas></canvas>",
				"<br><label><input type=\"range\" name=\"scan range\"><br><input type=\"number\" name=\"scan\"> scan</label>",
				// any changes to the tickbox apply to the slider, and vice versa.
				"<br><label><input type=\"checkbox\" name=\"flip\"> flip</label>"
			].join("\n");
			this.html = {};
			this.html.container = document.getElementById("se_div");
			let container = this.html.container;
			container.innerHTML = html;
			let desc = htmldescendants(container);
			for(i1 = 0; i1 < desc.length; i1++) {
				let ref = desc[i1];
				let name = (
					ref.name
					??
					(
						"name" in ref.attributes ? ref.attributes.name.value :
						ref.tagName.toLowerCase() === "button" ? ref.innerHTML :
						""
					)
				);
				if(name) {
					this.html[name] = ref;
				};
			}
			//this.html.shape.value = AAX.Shape.templates.sphere;
			this.html.shape.value = AAX.Shape.templates.head + " / | / 0, 0, 0, 10 / 8, -14, 8".replaceAll(" / ", "\n");
			this.html.canvas = container.querySelector("canvas");
			this.html.canvas.style["image-rendering"] = "crisp-edges";
			this.ctx = this.html.canvas.getContext("2d");
			let _this = this;
			this.html.shape.onkeydown = textarea_autosize;
			textarea_autosize(this.html.shape);
			this.html.update.onclick = function(e) { _this.update(_this) };
			this.html.scan.onchange = function(e) {
				_this.html["scan range"].value = _this.html.scan.value;
				_this.redraw(_this);
			};
			this.html["scan range"].onchange = function(e) {
				_this.html.scan.value = _this.html["scan range"].value;
				_this.redraw(_this);
			};
			this.html.scan.min = 0;
			this.html.scan.step = 1;
			this.html["scan range"].min = 0;
			this.html["scan range"].step = 1;
			this.html.flip.onchange = function(e) { _this.redraw(_this) };
			this.update();
		},
		update: function(_this) {
			_this ??= this;
			let i0 = 0;
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let shape = AAX.Shape.new(_this.html.shape.value);
			let spacing = readnumber(_this.html.spacing.value);
			let fineness = readnumber(_this.html.fineness.value);
			if(spacing === null || spacing <= 0) {
				return;
			};
			let points = shape.points;
			let bounds = AAX.Shape.bounds(points);
			if(!bounds) {
				alert("invalid shape. there are no points, or one of the dimensions is zero.");
				return;
			};
			let dim = 0;
			for(i1 = 0; i1 < 6; i1++) {
				dim = Math.max(dim, Math.abs(bounds["lrudbf"[i1]]));
			}
			let slice_count = 2*Math.floor(dim/spacing) + 1;
			dim++;
			dim *= 2;
			// dim is used for the dimensions of all views. the views will
			// always show a cube-shaped area centered on [0, 0, 0], so it has
			// to be whatever number will contain the whole shape.
			let _points = [];
			for(i1 = 0; i1 < points.length; i1++) {
				_points.push(addspheroids(points[i1], fineness));
				/*
				for(i2 = 0; i2 < _points[i1].length; i2++) {
					_points[i1][i2][0] += .5;
					_points[i1][i2][1] += .5;
					_points[i1][i2][2] += .5;
				}
				//*/
			}
			_this.control.slices = {xy: [], xz: [], yz: []};
			// square rasters for every slice of every axis, showing which
			// pixels are part of the cross section.
			_this.control.sectors = {xy: [], xz: [], yz: []};
			// similar, but not quite the same.
			// - a sector is the shape created by convexing together two slices.
			// - this is what is actually shown, since that looks smoother, and
			//   is closer to what the shape looks like.
			// - the only reason slices are kept around is so that it can color
			//   stuff differently if it's inside the shape because of scanning
			//   is being used.
			//   - you see, it's inside if it's the layer one scan away from
			//     being hidden, but...
			//   - sectors are 3d shapes, not the 2d cross section. so coloring
			//     the whole sector would be overboard.
			//   - it doesn't make that much of a difference, but i don't wanna
			//     half-ass it.
			// - there is always one more sector than there are slices, since
			//   slices are divisions between sectors.
			//   - sector[0], slice[0], sector[1], slice[1], etc. sector[index]
			//     between slice[index - 1] and slice[index].
			let rect = Rect.new(-dim/2, -dim/2, dim, dim);
			for(i0 = 0; i0 < 3; i0++) {
			// for each axis, make a set of cross sections
				let axis = "xyz".replace("xyz"[2 - i0], "");
				let quat = Quat.new();
				if(axis === "xz") {
					quat = Quat.rotate(quat, "yz", Math.PI/2);
				}
				else if(axis === "yz") {
					quat = Quat.rotate(quat, "xz", -Math.PI/2);
				};
				//
				let data = [];
				let center = Points.multiply(Quat.basis(quat)[2], -((slice_count - 1)/2)*spacing);
				for(i1 = 0; i1 < _points.length; i1++) {
					data.push(shapeslices(_points[i1], quat, center, slice_count, spacing, true));
					// (points, quat, center, slice_count, slice_spacing, convert) {
				}
				// a shapeslices for each axis, which will be used to make slices
				// and sectors.
				for(i1 = 0; i1 <= 2*slice_count; i1++) {
				// make each slice and sector.
					let _i1 = Math.floor(i1/2);
					let image = [];
					for(i2 = 0; i2 < dim**2; i2++) {
						image.push(false);
					}
					for(i2 = 0; i2 < _points.length; i2++) {
					// for each point group, add it to the image
						let shape = null;
						if(i1%2) {
						// for a slice, just take the slice shapeslices made.
							shape = data[i2].slices[_i1];
						}
						else {
						// for a sector, combine the slices that are the
						// boundaries of the sector, or if it's at the end,
						// include the points outside all slices.
							let start = _i1 ? data[i2].slices[_i1 - 1] : data[i2].neg;
							let end = _i1 < slice_count ? data[i2].slices[_i1] : data[i2].pos;
							shape = _2dPoly.convexed(structuredClone(start).concat(structuredClone(end)));
						};
						if(shape && shape.length) {
							let _shape = structuredClone(shape);
							let _rect = Rect.frompoints(shape);
							_rect = Rect.round_out(_rect);
							shape = _2dPoly.getdata(shape, true);
							// convert that from a shape to pixels
							if(!Rect.encloses(shape.rect, _rect)) {
								let temp = Rect.overlap(shape.rect, _rect);
								temp = temp ? temp.w*temp.h : 0;
								temp = temp/(_rect.w*_rect.h);
								if(temp < .9) {
									console.log("-");
									console.log([axis, (i1%2 ? "slice" : "sector"), _i1].join(" "));
									console.log(_rect);
									console.log(shape.rect);
									console.log("coverage: " + temp);
									console.log(_shape);
								}
							}
							for(i3 = 0; i3 < shape.within.length; i3++) {
							// add those pixels to within.
								if(shape.within[i3]) {
									let index = Rect.convertindex(shape.rect, rect, i3);
									if(index === -1) {
										console.log("this shouldn't happen");
									}
									else {
										image[index] = true;
									}
								}
							}
						}
					}
					_this.control[i1%2 ? "slices" : "sectors"][axis].push(image);
				}
			}
			_this.html.scan.max = slice_count - 1;
			_this.html.scan.value = 0;
			_this.html["scan range"].max = slice_count - 1;
			_this.html["scan range"].value = 0;
			_this.control.dim = dim;
			_this.html.flip.checked = false;
			_this.redraw();
		},
		redraw: function(_this) {
		// refreshes the image, to apply the changes of a shape update, or a
		// change to scan or flip.
			_this ??= this;
			let i0 = 0;
			let i1 = 0;
			let i2 = 0;
			let ctx = _this.ctx;
			let dim = _this.control.dim;
			let margin = Math.floor(dim/4);
			let _dim = dim + 2*margin;
			let flip = _this.html.flip.checked;
			let scan = Math.max(0, readnumber(_this.html.scan.value) ?? 0);
			ctx.canvas.width = 2*_dim;
			ctx.canvas.height = 2*_dim;
			ctx.clearRect(0, 0, 2*_dim, 2*_dim);
			ctx.fillStyle = "#181";
			ctx.fillRect(0, 0, 2*_dim, 2*_dim);
			let rect = Rect.new(-dim/2, -dim/2, dim, dim);
			for(i0 = 0; i0 < 3; i0++) {
				let axis = "xyz".replace("xyz"[2 - i0], "");
				let sectors = _this.control.sectors[axis];
				let x = (axis === "yz" ? 3 : 1)*_dim/2;
				let y = (axis === "xz" ? 1 : 3)*_dim/2;
				for(i1 = 0; i1 < sectors.length - scan; i1++) {
					let _i1 = flip ? (sectors.length - 1 - i1) : i1;
					let sector = sectors[_i1];
					let inside = scan && i1 === sectors.length - 1 - scan;
					// if at least one sector has been hidden by scan, and this
					// is the closest unhidden sector, some pixels should be
					// marked as being inside.
					let color = i1/(sectors.length - 1);
					inside = (
						inside
						?
						{
							color: "rgb(255, " + (127 + Math.round(128*color)) + ", 127)",
							slice: _this.control.slices[axis][_i1],
						}
						:
						null
					);
					color = "rgb(255, " + Math.round(255*color) + ", 0)";
					ctx.fillStyle = color;
					for(i2 = 0; i2 < sector.length; i2++) {
						if(sector[i2]) {
							let coor = Rect.getcoor(rect, i2);
							if(flip) {
							// flip doesn't just mean reversing the order, it's
							// mean to emulate looking at the back, left, and
							// bottom. so, flip it so it's actually analogous.
								coor[axis === "xz" ? 1 : 0] *= -1;
							};
							if(inside) {
							// if the inside stuff applies AND this pixel is
							// also in the slice, use the inside color.
								ctx.fillStyle = inside.slice[i2] ? inside.color : color;
							};
							ctx.fillRect(x + coor[0], y + coor[1], 1, 1);
						};
					}
				}
			}
		},
		control: {
			dim: 0,
			slices: null,
			sectors: null,
		},
	};
	//se.initialize();
	//
	document.write(`\n<div id="bg_div"></div>`);
	let bg = {
		initialize: function() {
			let i1 = 0;
			let html = [
				"<canvas name=\"canvas\"></canvas>",
				"<br><button name=\"render\">render</button>"
			].join("\n");
			this.container = document.getElementById("bg_div");
			this.container.innerHTML = html;
			this.html = {};
			let list = htmldescendants(this.container);
			for(i1 = 0; i1 < list.length; i1++) {
				let name = list[i1].name || list[i1].attributes?.name?.value || "";
				if(name) {
					name = name.replaceAll(" ", "_");
					this.html[name] = list[i1];
				}
			}
			if(false) {
				this.gl = this.html.canvas.getContext("webgl2");
				if(!this.gl) {
					console.log("this shouldn't happen");
				};
				let gl = this.gl;
				gl.clearColor(0, 0, 0, 1);
				gl.clear(gl.COLOR_BUFFER_BIT);
			}
			else {
				this.ctx = this.html.canvas.getContext("2d");
				let _this = this;
				this.html.render.onclick = function() {
					let paper = new Paper();
					paper.w = _this.w;
					paper.h = _this.h;
					paper.viewer.vp_x = _this.vp_x;
					paper.viewer.vp_y = _this.vp_y;
					// - viewer
					// - w, h
					// - bg
					// - fineness
					// - light
					//   - x, y, z
					//   - light_value, dark_value
					// - sheets
					const head_front = [
						[0, -11],
						[8, -10],
						[12, -2],
						[12, 5],
						[8, 12],
						[3, 16],
						[0, 17],
						[-3, 16],
						[-8, 12],
						[-12, 5],
						[-12, -2],
						[-8, -10]
					];
					const head_right = [
						[0, -11],
						[8, -7],
						[12, -1],
						[5, 14],
						[-8, 17],
						[-12, 11],
						[-12, -1],
						[-8, -7]
					];
					for(let i1 = 0; i1 < 6; i1++) {
						// create a cube. left, right, up, down, back, front.
						let w = paper.w;
						let h = (i1 === 2 || i1 === 3) ? paper.w : paper.h;
						paper.sheets[i1] = new Paper.Sheet(w, h);
						// - color
						// - x, y, z
						// - center
						//   - x, y
						// - quat
						// - shapes
						// - neighbors
						let ref = paper.sheets[i1];
						ref.color = "red orange yellow green blue purple".split(" ")[i1];
						ref.x = ((i1 === 1 || i1 === 5) ? 1 : -1)*w/2;
						ref.y = (i1 === 3 ? 1 : -1)*h/2;
						ref.z = ((i1 === 0 || i1 === 2 || i1 === 5) ? 1 : -1)*w/2;
						// the position should be the upper left corner of the
						// rectangle, so...
						// - l: l u f
						// - r: r u b
						// - u: l u f
						// - d: l d b
						// - b: l u b
						// - f: r u f
						ref.quat = (
						i1 === 2 ? Quat.new("yz", -Math.PI/2) :
						i1 === 3 ? Quat.new("yz", Math.PI/2) :
						i1 === 4 ? Quat.new() :
						Quat.new("xz", (i1 === 0 ? 3 : i1 === 1 ? 1 : i1 === 5 ? 2 : 0)*Math.PI/2)
						);
						let shape = structuredClone(head_right);
						for(let i2 = 0; i2 < shape.length; i2++) {
							shape[i2][0] += w/2;
							shape[i2][1] += h/2;
							shape[i1][0] *= 2;
							shape[i1][1] *= 2;
						}
						//ref.shapes.push(new Paper.Shape("subtract", [shape]));
					}
					//paper.viewer.disable = true;
					paper.render(_this.ctx);
				};
				this.html.render.onclick();
				this.html.canvas.onclick = function(e) {
					_this.vp_x = Math.round(e.clientX - e.target.getBoundingClientRect().left) - _this.w/2;
					_this.vp_y = Math.round(e.clientY - e.target.getBoundingClientRect().top) - _this.h/2;
					_this.html.render.onclick();
				}
			}
		},
		w: 128,
		h: 128,
		vp_x: 0,
		vp_y: 0,
	};
	//bg.initialize();
	//
	let temp = document.getElementsByName("userfocus");
	for(let i1 in temp) {
		if(temp.hasOwnProperty(i1)) {
			let focus = temp[i1].value;
			document.getElementById(focus + "_div").hidden = true;
			temp[i1].onchange = function(e) {
				if(e.target.checked) {
					changefocus(e.target.value);
				}
			}
		}
	}
	let userfocus_init = [];
	// lists strings that userfocus has been set to, so that it can initialize
	// the tools only the first time you use them.
	function changefocus(focusname) {
		userfocus = focusname;
		if(!userfocus_init.includes(userfocus)) {
		// initializing happens here, mostly because it's a little wasteful for
		// shape examiner to generate all those cross sections if the user
		// doesn't even open it.
			userfocus_init.push(userfocus);
			if(userfocus === "aa") {
				aa.initialize();
			}
			else if(userfocus === "bm") {
				bm.initialize();
			}
			else if(userfocus === "px") {
				px = new PixelArt(document.getElementById("px_div"));
				//px.html.anim_vertical.checked = true;
				// it shouldn't be checked by default most of the time, but it
				// should for this page, to match how aa exports animations.
			}
			else if(userfocus === "se") {
				se.initialize();
			}
			else if(userfocus === "bg") {
				bg.initialize();
			};
		};
		document.getElementsByName("userfocus").forEach(function(element) {
			element.checked = element.value === userfocus;
			document.getElementById(element.value + "_div").hidden = !element.checked;
		});
		document.getElementById("desc").innerHTML = (
			userfocus === "aa" ? "a character animation system that's featured out the ass. works better with a mouse. read the manual." :
			userfocus === "bm" ? "a tool for creating bodytexts you can use in armature artist. make sure to read the manual of that to get how bodytext works. or what a bodytext is." :
			userfocus === "px" ? "a pixel art tool. lets you edit images from armature artist or body maker into proper sprites." :
			userfocus === "se" ? "lets you examine the 3d shapes you can use in armature artist and body maker. the 3d system doesn't show inner outlines or lighting, so this lets you look at cross sections to get an idea of its form." :
			userfocus === "bg" ? "uses a scripting system to generate backgrounds out of 2d shapes oriented in 3d space." :
			""
		);
	};
	changefocus("aa");
	//
	addEventListener("load", function() {
	// this is so stupid. but i'm cryin tears of joy that it works.
	// - the font in the ui graphics is blurry until the first page refresh or
	//   ui refresh, since the page/canvas loads faster than the font. this
	//   triggers a ui refresh after the page fully loads.
		if(userfocus === "aa") {
			aa.ui.draw();
			aa.pa.ui.draw();
			//let skip = structuredClone(AAX.valid.refresh);
			//skip.splice(skip.indexOf("ui"), 1);
			//aa.refresh(skip);
		}
		else if(userfocus === "bm") {
			bm.ui.draw();
			//let skip = structuredClone(bm.valid.refresh);
			//skip.splice(skip.indexOf("ui"), 1);
			//bm.refresh(skip);
		};
	}, false);
	</script>
	</body>
</html>
