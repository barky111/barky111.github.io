<!DOCTYPE html>
<html lang="en">
	<script src="script/barky_main.js"></script>
	<script src="script/site.js"></script>
	<script src="script/barky_strings.js"></script>
	<script src="script/barky_graphics.js"></script>
	<script>
		document.write(head);
		//document.write(header);
		document.write(nav + "\n<br>");
		document.querySelector("title").innerHTML = "armature artist";
	</script>
	<head>
		<style>
			body {
				background: #fffae3;
				color: black;
			}
		</style>
	</head>
	<body>
	<script>
	document.onkeydown = function(e) {
		if(["textarea", "input"].includes(document.activeElement.tagName.toLowerCase())) {
			return;
		};
		let key = keyinterpreter(e.key);
		if(userfocus === "aa") {
			let keymap = (aa.control.editmode ? aa.pa.ui.keymap : aa.ui.keymap);
			if(keymap.hasOwnProperty(key)) {
				let action = keymap[key];
				if(typeof action !== "string") {
					if(action.length > 2) {
						action = (
							e.ctrlKey
							?
							action.slice(2)
							:
							action.slice(0, 2)
						);
					};
					if(action.length === 1) {
						action = action[0];
					}
					else if(action.length === 2) {
						action = action[Number(e.shiftKey)];
					}
					else {
						console.log("this shouldn't happen");
					};
				};
				if(action) {
					e.preventDefault();
					if(aa.control.editmode) {
						aa.pa.ui.action(action, e.shiftKey, e.ctrlKey);
					}
					else {
						aa.ui.action(action, e.shiftKey, e.ctrlKey);
					}
				};
			};
		}
		else if(userfocus === "bm") {
			let prevent = true;
			if(e.ctrlKey && e.shiftKey) {
				if(key === "z") {
					e.preventDefault();
					bm.states.redo();
				}
				else {
					prevent = false;
				};
			}
			else if(e.ctrlKey) {
				if(key === "z") {
					bm.states.undo();
				}
				else if(key === "s") {
					bm.save();
				}
				else if(key === "o") {
					bm.load();
				}
				else {
					prevent = false;
				};
			}
			else if(e.shiftKey) {
				prevent = false;
			}
			else if(key.length === 1 && "wasd".includes(key)) {
				let array = bm.valid.tools;
				let index = array.indexOf(bm.control.tool);
				index += (
					key === "w" ? -1 :
					key === "a" ? -3 :
					key === "s" ? 1 :
					key === "d" ? 3 :
					0
				);
				bm.control.tool = array[posmod(index, array.length)]
				let skip = structuredClone(bm.valid.refresh);
				skip.splice(skip.indexOf("ui"), 1);
				bm.refresh(skip);
			}
			else if(key.length === 1 && "tfgh".includes(key)) {
			// family selection
				let name = bm.control.partname;
				let parent = bm.control.body_part.parent;
				let siblings = AAX.getchildren(bm.body, parent);
				let select = (
					key === "t" ? (parent === "standpoint" ? "" : parent) :
					key === "f" ? (siblings.length <= 1 ? "" : siblings[posmod(siblings.indexOf(name) - 1, siblings.length)]) :
					key === "g" ? (AAX.getchildren(bm.body, name)[0] ?? "") :
					key === "h" ? (siblings.length <= 1 ? "" : siblings[posmod(siblings.indexOf(name) + 1, siblings.length)]) :
					""
				);
				if(select) {
					bm.control.partname = select;
					let skip = structuredClone(bm.valid.refresh);
					skip.splice(skip.indexOf("ui"), 1);
					skip.splice(skip.indexOf("states"), 1);
					bm.refresh(skip);
				};
			}
			else {
				prevent = false;
			};
			//
			if(prevent) {
				e.preventDefault();
			};
		}
		else if(userfocus === "px") {
			px.keydown(e);
		};
	};
	//
	document.write(`<label><input type="radio" name="userfocus" value="aa">armature artist</label>`);
	document.write(`\n<br><label><input type="radio" name="userfocus" value="bm">body maker</label>`);
	document.write(`\n<br><label><input type="radio" name="userfocus" value="px">pixel art</label>`);
	document.write(`\n<br hidden><label hidden><input type="radio" name="userfocus" value="se">shape examiner</label>`);
	document.write(`\n<br hidden><label hidden><input type="radio" name="userfocus" value="bg">paper background maker</label>`);
	document.write("<details class=\"text\">\n\t<summary>changelog</summary>\n\t" + arraytoul([
		/*
		"???: v1.4",
		[
			"initial release of the shape examiner",
			"the default bodytext now has 3d shapes for the hands, not 2d images.",
		],
		//*/
		"25mar25: v1.4",
		[
			"initial release of the pixel art tool, which armature artist and body maker can send images to. it also has an animation tester.",
			"on the armature artist page, tools do not initialize until they're opened, which makes the page load faster",
			"it's much easier to select parts, especially on mobile.",
			[
				"the clickable radius is a little bigger, to account for the inaccuracy of touch clicks,",
				"but more importantly, there's enough visual feedback to be as precise as with a mouse. tools that can select parts can now select them by ending a click on them, not just starting a click on them, and when you're close enough for this to happen, it'll highlight the node to show you."
			],
			"rotate/tilt pose tools",
			[
				"they no longer save a new state if the magnitude is zero.",
				"xz now always uses the same radius, which is pretty much as big as it can be while still having access to the full range of rotation.",
				"cosmetic changes to the displayed angle. now it ranges from -180 to 180 degrees, not 0 to 360 degrees"
			],
			"added changelog.",
			"edited the manual to warn about cases where tweening sucks.",
			"renamed invert buttons to \"mirror\". they also depress properly now. (before, they'd be colored to show the signs of the part's relative coordinates. that made sense for what it did before, but not what it does now.)",
			"after creating inbetweens, it now switches to the end key frame, not the first tween frame. (better for making tweens between every frame, and other actions like that.)",
			"rewrote the class i use for animation, adding new features.",
			[
				"previous frame and next frame buttons",
				"being able to switch the axes of the animation (which axis is time, and which is direction)",
				"number input for editing how many rows/columns are in the spritesheet (takes effect instantly, without you having to update the animation again)"
			],
			"one view animation updates are much faster than before",
			"added curl to the rotate settings.",
			"BODYTEXT FORMAT CHANGE: silhouettes work much differently now.",
			[
				"the commands used to be like:",
				[
					"silhouette(): sets the group/subgroup",
					"generation(), capsule(): the two kinds of connection. (must be one or the other.)",
					[
						"generation: tangents the part's image to some of its ancestors and/or descendants",
						"capsule: just adds a capsule shape from the part to its parent, and avoids the convexing"
					]
				],
				"now:",
				[
					"group(): sets the group/subgroup",
					"it's possible to use multiple types of connection at once.",
					[
						"generation()",
						"core(): new type of connection, makes a sphere, for convexing",
						"bone(): new name for capsule"
					],
					"concave(): avoids convexing for the part's main image, and bone() connections if applicable"
				],
				"the object structure has changed, too.",
				[
					"then:",
					[
						".silhouette: array of the group and subgroup",
						".connection: {type, value} object"
					],
					"now:",
					[
						".silhouette: object of all silhouette-related data",
						[
							"group",
							"subgroup",
							"anc",
							"desc",
							"core",
							"bone",
							"concave"
						]
					]
				]
			],
			"\"STANDARD\" BODYTEXT CHANGES:",
			[
				"got rid of the split between wrist and hand, because that was stupid. (the point was to show orientation, like a vague idea of where the fingers are. but orientation is visualized, and the shape is subject to orientation too.)",
				"changed the silhouettes, to match the changes to the silhouette system. the hands are the only parts whose silhouettes are actually changed.",
				"minor changes to the elbow and wrist coordinates.",
				"changes the hand's images to look less vague and more like the pose a hand takes in a typical standing pose."
			],
			"body maker: you can enter fractions in the scale button now. (ex: instead of doing *5 then /4, you can do *5/4. makes it easier to use. it's visualized as a fraction too, to avoid long decimals that are hard to read.)",
			"you can automatically insert the current date in the project name, by typing an asterisk.",
			"bug fixes",
			[
				"buttons like undo/redo didn't depress properly.",
				"filenames sucked.",
				[
					"this is a browser tool, so it can't overwrite your files, just save new files.",
					"when you load a new file, it takes note of the name, to use it if you save it again later",
					"since it matches the name of the file you loaded, your file system probably names it something like \"animation(1).txt\"",
					"which is only okay the first time, because the second time you load and save it, it becomes \"animation(1)(1).txt\", and the third time it becomes \"animation(1)(1)(1).txt\", you get the idea, it's fucking awful",
					"after the changes i made, it should be \"animation(2).txt\", \"animation(3).txt\", etc. changing the number, not adding new numbers",
					"if that's not how your file system handles duplicate names, or it otherwise sucks for you, let me know! i can probably fix it once i understand the rename scheme."
				],
				"loading a project with less animations than the index of the selected animation would cause an error.",
				"duplicating an animation while it had redo states would cause an error.",
				"the tab key didn't work in bodytext."
			]
		],
		"07feb25: v1.3",
		[
			"body maker changes",
			[
				"making the child/sibling tools copy the parent's image text",
				"family selection keys, just like armature artist",
				"adding more options to the scale button",
				[
					"only scaling certain axes",
					"only scaling position, or only scaling dimensions",
					"making it scale a branch rather than all parts",
					"letting it scale only one part"
				]
			],
			"quaternion flipping (allows parts and shapes to be mirrored properly. before, the mirroring of symmetry parts and the invert buttons would not affect the orientation of shape spheroids.)",
			"ui adjustments",
			"rotate settings",
			[
				"rounding",
				"rotating on local axes",
				"rotating on custom axes",
				"tools for setting and modifying custom axes"
			],
			"adding oddness switching to rotation",
			[
				"originally, parts always kept the same oddness before and after rotation.",
				"but that isn't necessarily what the user expects. like if you rotated [-2, 6.5] by 90, it should be [-6.5, -2]. meaning, the oddness should switch.",
				"the rule is, if the magnitude is closer to 90 or 270 than 0 or 360, and the axis is closer to one axis than the others, the oddness of the other two axes are switched.",
				"an axis angle can be understood as a 3d point that's 1 away from zero, right.",
				"the switch axis is whichever of those three coordinates has the highest absolute value.",
				"if there's a tie, there's no switching at all."
			],
			"migrating armature artist and body maker to a separate page",
			"capsule silhouettes are no longer convexed. (ie if the head has horns, the silhouette will look fine if it's capsule. whereas generations would make it look like there's skin stretched over the horns.)",
			"invert buttons work differently",
			[
				"before, they would invert the coordinates of a part and all its descendants. now, they invert the shape of the part and its descendants, and the coordinates of descendants but not the part.",
				"basically, it works more like the rotate pose tool."
			]
		],
		"22dec24: v1.2",
		[
			"initial release of body maker",
			"reset part and reset branch buttons",
			"pose to shape button",
			"rework of how symmetrical parts work in bodytext",
			"new stem-based color system:",
			[
				"the part fill color and silhouette fill color have been combined into one",
				"you can specify multiple colors, which it'll use to differentiate parts that belong to different bodies. (that is, they don't share any common ancestor)"
			],
			"when changing cell dimensions, the standpoint now moves to match it.",
			"scaled up the template bodytexts by 1.5x, tweaked them a bit.",
			"parts with no shape or image, when being incorporated into a silhouette, will act as if they have one point, at the center.",
			"capsule connections look better",
			"more efficient spheroid system. fineness now measures the number of sides of a quarter-circle, not a full circle.",
			"fixes",
			[
				"problems with changing interface/buttons colors",
				"problem with multi-stem bodies",
				"problem where, the first time the page loads and before any ui refreshes, the ui is drawn in Default Who Gives A Shit Font",
				"issue in bodytext where unsquarish image dimensions would cause errors"
			]
		],
		"22nov24: v1.1.1",
		[
			"writing the manual",
			"html changes",
			"fixing issues with bodytext changes"
		],
		"28oct24: v1.1",
		[
			"reordering pose tools",
			"fixing issue where inbetweening would make shapes like the head shrink",
			"better ui layout",
			"invert is applied to the whole branch",
			"changed draw settings ratio to range"
		],
		"10oct24: v1.0.1",
		[
			"minor fixes",
			"adding a description",
			"making it so entering an empty string for a color change resets the color to default"
		],
		"07oct24: v1.0"
	]).replaceAll("\n", "\n\t") + "\n</details>");
	//document.write("\n<br>");
	document.write("<ul id=\"desc\" style=\"width: 40em\"></ul>");
	//
	document.write(`\n<div id="aa_div"></div>`);
	//document.write(`<div id="aa_preface"></div>\n<div id="aapa"></div><div id="aa"></div>`);
	let aa = {
	// "armature artist", a simpler version of what i wanted from the posing
	// interface.
	// - a lot of the code for this is in the AAX object in my graphics script.
	//   basically, anything i was gonna use in other armature-related tools
	//   went there. you'll have to read that too to get a lot of this.
		pa: {
			part: {
			// all the data that will be sent to the rest of aa
				front: [],
				// data for the front view of the part. it's like ImageData, an
				// array of what value each pixel has, left to right, top to
				// bottom. 0 is unfilled, 1 is filled, 2 is filled in color2.
				// - color1 pixels are only drawn on the armature if they're on
				//   the outside, color2 are drawn regardless.
				// - color2 can be used for guides and stuff.
				right: [],
				// counterpart for the side
				size: 8,
				oddness: [false, false, false],
				get box() {
					return aa.box(this.size, this.oddness);
				},
				dim: function(right) {
					const box = this.box;
					return [box[right ? "d" : "w"], box.h];
				},
				// this will create an object like: {x: -4, y: -4, z: 4, w: 9,
				// h: 9, d: 9}
				// - the pixels of the part are mapped to relative coordinates
				//   of the part's placement on the canvas.
				// - the coordinates represent the corner of the box that's the
				//   lowest in each axis. (ie the leftmost, topmost, backmost.)
				rect: function(right) {
					const dim = this.dim(right);
					return {
						x: (dim[0] - 1)*(-1/2),
						y: (dim[1] - 1)*(-1/2),
						w: dim[0],
						h: dim[1],
					};
				},
				color1: AAX.Color.template.parts[1],
				color2: AAX.Color.template.parts[0],
				fill: AAX.Color.template.part_fill[0],
				//"#ef007f", // violet red
				//"#bfef1f", // lime
				//"#007fef", // azure
				//"#7f00ef" // purple
			},
			ctx: {
				front: null,
				right: null,
				ui: null,
			},
			// canvas contexts
			grid_color: "silver",
			// color used for grid lines and empty pixels. this isn't really
			// important, it's only changeable so you can fix it if it blends in
			// with the part color.
			empty_color: "gray",
			grid_w: 1,
			block_w: 7,
			editright: false,
			// boolean for whether actions done in the ui like the doubleclick
			// ellipse should be done on the front view or the right view. this
			// is set as false when you click the front view, true when you
			// click the right view.
			// - it's also used as a faster way of checking which canvas was
			//   clicked to trigger the function.
			tool: "pen1",
			// string for what to use when the canvas is clicked.
			strokedata: null,
			// stores data used within the action of a mousedown and mouseup.
			clicktype: null,
			// string for the canvas you're currently clicking
			editactions: [
				"changedimensions",
				"ellipse",
				"rotate",
				"rotate90",
				"clear",
				"xmirror",
				"ymirror",
				"move_l",
				"move_r",
				"move_u",
				"move_d",
				"fullellipse",
				"swap"
			],
			redraw: function() {
				let i0 = 0;
				let i1 = 0;
				for(i0 = 0; i0 < 2; i0++) {
					let ctx = this.ctx[i0 ? "right" : "front"];
					let image = this.part[i0 ? "right" : "front"];
					let w = this.part.rect(i0).w;
					// screen width, not box.w.
					if(true) {
						image = AAX.sq_raster.fill(image, w);
					};
					ctx.canvas.width = (this.grid_w + this.block_w)*w;
					ctx.canvas.height = (this.grid_w + this.block_w)*this.part.rect(i0).h;
					ctx.fillStyle = this.grid_color;
					ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
					//
					let coor = [
						-this.part.rect(i0).x,
						-this.part.rect(i0).y
					];
					coor = [
						(coor[0] * (this.grid_w + this.block_w)) + this.grid_w + Math.floor(this.block_w/2 - this.grid_w/2),
						(coor[1] * (this.grid_w + this.block_w)) + this.grid_w + Math.floor(this.block_w/2 - this.grid_w/2),
					];
					ctx.fillStyle = this.empty_color;
					ctx.fillRect(0, coor[1], ctx.canvas.width, this.grid_w);
					ctx.fillRect(coor[0], 0, this.grid_w, ctx.canvas.height);
					// draw lines at the zeroes.
					for(i1 = 0; i1 < image.length; i1++) {
						let coor = [
							i1 % w,
							Math.floor(i1/w)
						];
						// column and row
						coor = [
							(coor[0] * (this.grid_w + this.block_w)) + this.grid_w,
							(coor[1] * (this.grid_w + this.block_w)) + this.grid_w,
						];
						// x and y, in pixels
						if(image[i1] === 0) {
							ctx.fillStyle = this.empty_color;
						}
						else if([1, 2].includes(image[i1])) {
							ctx.fillStyle = this.part["color" + image[i1]];
						}
						else if(image[i1] === "fill") {
							ctx.fillStyle = aa.pa.part.fill;
						}
						else {
							console.log("invalid aa.pa.part pixel data.");
							return;
						};
						ctx.fillRect(...coor, this.block_w, this.block_w);
					}
				}
			},
			clickrowcol: function(x, y, giveindex) {
			// converts canvas coordinates to block coordinates on the thing.
			// - returns null if it's off the canvas.
			// - giveindex: returns the number index instead
				const right = this.clicktype === "right";
				let ctx = this.ctx[right ? "right" : "front"];
				if(x < 0 || x >= ctx.canvas.width || y < 0 || y >= ctx.canvas.height) {
					return null;
				};
				const block = (this.grid_w + this.block_w);
				let coor = [
					Math.floor(x/block),
					Math.floor(y/block)
				];
				return (
					giveindex
					?
					coor[1]*this.part.rect(right).w + coor[0]
					:
					coor
				);
			},
			ui: {
			// PART ARTIST
			// functions/variables related to the buttons
				scale: 1,
				buttons: {},
				// object of buttons.
				// - each button is just a rectangle object. x, y, w, h
				create: function() {
					let i1 = 0;
					let i2 = 0;
					let block = AAX.ui.block;
					let ref = this.buttons;
					let area = {x: 0, y: 0, w: 6*block, h: 4*block};
					ref.switch = structuredClone(area);
					ref.switch_no_export = structuredClone(area);
					ref.switch_no_export.x += area.w;
					area.y += area.h + block;
					area.w = 8*block;
					area.h = 2*block;
					let array = ["clear", "fullellipse", "xmirror", "ymirror", "rotate90", "swap"];
					for(i1 = 0; i1 < array.length; i1++) {
						if(i1 === 2) {
							area.h = 1*block;
						};
						ref[ array[i1] ] = structuredClone(area);
						area.y += area.h;
					}
					area.x += area.w;
					area.w = 4*block;
					area.h = 4*block;
					area.y -= area.h;
					ref.move = structuredClone(area);
					area.y -= 4*block;
					area.x += 1*block;
					area.w = 3*block;
					area.h = 1.5*block;
					array = ["grid_color", "empty_color"];
					for(i1 = 0; i1 < array.length; i1++) {
						ref[ array[i1] ] = structuredClone(area);
						area.y += area.h;
					}
					area = {
						x: area.x + area.w + block,
						y: 0,
						w: 7*block,
						h: 1*block,
					};
					array = ["heading", "pen1", "pen2", "ellipse", "rotate"];
					for(i1 = 0; i1 < array.length; i1++) {
						ref[ "tool_" +  array[i1] ] = structuredClone(area);
						area.y += area.h;
					}
					area.y += area.h;
					area.h = 3*block;
					ref.changedimensions = structuredClone(area);
					// - switch, switch without export (same place it is in the main ui)
					// - tools (ie, buttons that change what clicks do)
					//   - pen1, pen2 (3)
					//   - ellipse (5)
					//   - rotate (4)
					// - edits (buttons that apply changes by themselves)
					//   - clear (4)
					//   - full ellipse (8)
					//   - move (special case)
					//   - x mirror (6)
					//   - y mirror (6)
					//   - rotate 90
					//   - swap (3)
					// - settings changes
					//   - grid_color, empty_color (special cases)
					//   - change dimensions (7 x 2)
				},
				keymap: {
					q: ["switch", "switch_no_export"],
					w: "move_u",
					a: "move_l",
					s: "move_d",
					d: "move_r",
					"1": "tool_pen1",
					"2": "tool_pen2",
				},
				draw: function() {
				// for now this is going to be stunningly half-assed.
				// - this also acts as a "reset graphics" function, and it changes
				//   the ui canvas dimensions too.
					let i1 = 0;
					let i2 = 0;
					let color = aa.color.buttons;
					let ctx = aa.pa.ctx.ui;
					let ranges = [0, 0];
					for (i1 in this.buttons) {
						if (this.buttons.hasOwnProperty(i1)) {
							let ref = this.buttons[i1];
							ranges[0] = Math.max(ranges[0], ref.x, ref.x + ref.w);
							ranges[1] = Math.max(ranges[1], ref.y, ref.y + ref.h);
						};
					}
					ranges[0]++;
					ranges[1]++;
					ctx.canvas.width = ranges[0];
					ctx.canvas.height = ranges[1];
					ctx.clearRect(0, 0, ...ranges);
					ctx.font = AAX.ui.font;
					ctx.textAlign = "center";
					ctx.textBaseline = "middle";
					const margin = AAX.ui.margin;
					const spacednames = [
						"full ellipse",
						"x mirror",
						"y mirror",
						"rotate 90",
						"change dimensions"
					];
					for (i1 in this.buttons) {
						if (this.buttons.hasOwnProperty(i1)) {
							let ref = this.buttons[i1];
							let text = (i1.startsWith("tool_") ? i1.slice("tool_".length) : i1).replaceAll("_", " ");
							if(i1 === "tool_heading") {
								text = "tools";
							}
							else if(i1 === "switch_no_export") {
								text = "switch without export";
							}
							else {
								for(i2 = 0; i2 < spacednames.length; i2++) {
									if(spacednames[i2].replaceAll(" ", "") === text) {
										text = spacednames[i2];
										i2 += spacednames.length;
									};
								}
							};
							let align = (i1.startsWith("tool_") && i1 !== "tool_heading") ? "left" : "center";
							let selected = Number(i1.startsWith("tool_") && aa.pa.tool === i1.slice("tool_".length));
							ctx.strokeStyle = color[ posmod(- selected, color.length) ];
							ctx.fillStyle = color[ posmod(1 - selected, color.length) ];
							if(i1 !== "tool_heading") {
								ctx.fillRect(ref.x, ref.y, ref.w, ref.h);
								Rect.fauxstroke(ref, ctx);
							};
							if(["color1", "color2", "grid_color", "empty_color"].includes(i1)) {
								ctx.fillStyle = ["grid_color", "empty_color"].includes(i1) ? aa.pa[i1] : aa.pa.part[i1];
								ctx.fillRect(ref.x, ref.y, ref.w, ref.h);
								Rect.fauxstroke(ref, ctx);
							}
							else if(i1 === "move") {
								linespecial(ctx, ref.x, ref.y, ref.x + ref.w, ref.y + ref.h);
								linespecial(ctx, ref.x + ref.w, ref.y, ref.x, ref.y + ref.h);
								// x
								linespecial(ctx,
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*1/8),
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*2/8)
								);
								linespecial(ctx,
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*6/8),
								Math.floor(ref.x + ref.w/2),
								Math.floor(ref.y + ref.h*7/8)
								);
								linespecial(ctx,
								Math.floor(ref.x + ref.w*1/8),
								Math.floor(ref.y + ref.h/2),
								Math.floor(ref.x + ref.w*2/8),
								Math.floor(ref.y + ref.h/2)
								);
								linespecial(ctx,
								Math.floor(ref.x + ref.w*6/8),
								Math.floor(ref.y + ref.h/2),
								Math.floor(ref.x + ref.w*7/8),
								Math.floor(ref.y + ref.h/2)
								);
							}
							else {
								if((2*margin[0] + 5*text.length - 1) > ref.w) {
									text = text.split(" ");
								};
								if(!Array.isArray(text)) {
									text = [text];
								};
								ctx.textAlign = align;
								ctx.fillStyle = ctx.strokeStyle;
								for(i2 = 0; i2 < text.length; i2++) {
									ctx.fillText(
										text[i2],
										Math.floor(ref.x + (align === "center")*(ref.w/2) + margin[0]) - (text[i2].length%2 && align === "center")/2,
										Math.floor(ref.y + ref.h/2 + margin[1] + 8*(-(text.length - 1)/2 + i2))
									);
								};
							};
						};
					}
				},
				action: function(action, shift, ctrl) {
					let i1 = 0;
					if(action.endsWith("heading")) {
					}
					else if(shift && action === "ellipse") {
						aa.pa.edit("fullellipse");
					}
					else if(action === "switch") {
						const part = aa.control.part;
						const view = aa.control.view;
						const ref = aa.pa.part;
						const prompttext = "the current part image doesn't have the same oddness as the part you're trying to apply it to. the center rows/columns might be collapsed or expanded.";
						let no_export = false;
						if(aa.control.perspectived) {
						// - save the aa.pa oddness
						// - if it's different:
						//   - prompt confirmation
						//   - changeoddness
						// - then crop it with imagefunc.crop
							const right = !!(view%2);
							let image = structuredClone(ref[right ? "right" : "front"]);
							const pa_oddness = [ref.oddness[right ? 2 : 0], ref.oddness[1]];
							const new_oddness = part.image_oddness(view);
							no_export = (
								pa_oddness[0] !== new_oddness[0]
								||
								pa_oddness[1] !== new_oddness[1]
							);
							if(no_export && confirm(prompttext)) {
							// if the oddness is different, confirm that oddness
							// edits are ok
								no_export = false;
								image = AAX.sq_raster.changeoddness(image, pa_oddness, new_oddness);
								// oddness differences change the image
							};
							if(!no_export) {
								part._perspective[view] = AAX.sq_raster.autocrop(image, new_oddness);
								// autocrop it so all the pixels just barely fit
								// inside
							};
						}
						else {
							let image = [
								structuredClone(ref.front),
								structuredClone(ref.right)
							];
							const new_oddness = [
								part.image_oddness("front"),
								part.image_oddness("right")
							];
							no_export = (
								ref.oddness[0] !== new_oddness[0][0]
								||
								ref.oddness[1] !== new_oddness[0][1]
								||
								ref.oddness[1] !== new_oddness[1][1]
								||
								ref.oddness[2] !== new_oddness[1][0]
							);
							// ref.oddness is 3d, new_oddness [0] and [1] are
							// 2d.
							if(no_export && confirm(prompttext)) {
							// correct for oddness
								no_export = false;
								image = [
									AAX.sq_raster.changeoddness(image[0], [ref.oddness[0], ref.oddness[1]], new_oddness[0]),
									AAX.sq_raster.changeoddness(image[1], [ref.oddness[2], ref.oddness[1]], new_oddness[1])
								];
								// oddness differences change the image
							};
							if(!no_export) {
								part._image.front = AAX.sq_raster.autocrop(image[0], new_oddness[0]);
								part._image.right = AAX.sq_raster.autocrop(image[1], new_oddness[1]);
								// autocrop
							};
						};
						// i'm not using the size setters because it has to edit
						// the image for oddness anyway.
						aa.refresh(no_export ? "states" : null);
						aa.editmodetoggle();
					}
					else if(action === "switch_no_export") {
						aa.editmodetoggle();
					}
					else if(action.startsWith("tool_")) {
						aa.pa.tool = action.slice("tool_".length);
						// so that it knows what to do with the next canvas click
						aa.pa.ui.draw();
						// so that graphics changes take effect
					}
					else if(action.startsWith("move_") && ["l", "r", "u", "d", "ul", "ur", "dl", "dr"].includes(action.slice("move_".length))) {
						aa.pa.edit(action);
					}
					else if(aa.pa.editactions.includes(action) && !["ellipse", "move"].includes(action)) {
						aa.pa.edit(action);
					}
					else if(["color1", "color2", "grid_color", "empty_color"].includes(action)) {
						aa.pa.changecolor(action);
					};
				},
				mousedown: function(e, doubleclick) {
					let i1 = 0;
					let click = clickxy(e, "aa");
					let _this = aa.pa.ui;
					let action = null;
					for (i1 in _this.buttons) {
						if (_this.buttons.hasOwnProperty(i1) && Rect.inside(_this.buttons[i1], click[0], click[1])) {
							if(i1 === "move") {
								let angle = get2dangle(
									click[0] - (_this.buttons[i1].x + _this.buttons[i1].w/2),
									click[1] - (_this.buttons[i1].y + _this.buttons[i1].h/2),
									true
								) ?? 0;
								angle = posmod(angle + 2*Math.PI/8, 2*Math.PI);
								angle = "rdlu"[Math.floor(angle/(2*Math.PI/4))];
								action = i1 + "_" + angle;
							}
							else {
								action = i1;
							}
						};
					}
					if(action !== null) {
						_this.action(action, doubleclick);
					};
				},
			},
			mousedown: function(e) {
				let click = clickxy(e, "aa");
				let _this = aa.pa;
				if(e.target.id === "aapa_front") {
					_this.editright = false;
					_this.clicktype = "front";
				}
				else if(e.target.id === "aapa_right") {
					_this.editright = true;
					_this.clicktype = "right";
				}
				else {
					console.log("this shouldn't happen");
					console.log(e.target.id);
				};
				if(["pen1", "pen2"].includes(_this.tool)) {
					_this.penaction(...click);
					_this.pen(...click);
				}
				else if(_this.tool === "ellipse") {
					_this.strokedata = {
						start: _this.clickrowcol(...click),
						image: structuredClone(_this.part[_this.clicktype]),
					};
				}
				else if(_this.tool === "rotate") {
					let canvas = _this.ctx[_this.clicktype].canvas;
					_this.strokedata = {
						start: get2dangle(
							click[0] - canvas.width/2,
							click[1] - canvas.height/2,
							true
						) ?? 0,
						image: structuredClone(_this.part[_this.clicktype]),
					};
					// save the starting angle
				}
			},
			mousemove: function(e, finish) {
				if(e.target.id !== "aapa_" + aa.pa.clicktype) {
					return;
				};
				let click = clickxy(e);
				let _this = aa.pa;
				if(["pen1", "pen2"].includes(_this.tool)) {
					if(!finish) {
						_this.pen(...click);
					};
				}
				else if(_this.tool === "ellipse" && _this.strokedata.start !== null) {
				// reset it to how it was before the click, and create an
				// ellipse
					let temp = _this.clickrowcol(...click);
					if(temp !== null) {
						_this.edit("ellipse", _this.strokedata.start.concat(temp));
						// redraws too
					};
					if(!finish) {
						_this.part[_this.clicktype] = structuredClone(_this.strokedata.image);
					};
				}
				else if(_this.tool === "rotate") {
				// same thing, but rotate
					let canvas = _this.ctx[_this.clicktype].canvas;
					let angle = get2dangle(
						click[0] - canvas.width/2,
						click[1] - canvas.height/2,
						true
					) ?? 0;
					angle = posmod(angle - _this.strokedata.start, 2*Math.PI);
					_this.edit("rotate", [angle]);
					if(!finish) {
						_this.part[_this.clicktype] = structuredClone(_this.strokedata.image);
					};
				};
				if(finish) {
					_this.strokedata = null;
					_this.clicktype = null;
				};
			},
			mouseup: function(e) {
				if(e.target.id !== "aapa_" + aa.pa.clicktype) {
					return;
				};
				aa.pa.mousemove(e, true);
			},
			// functions below this line are what happens when you click the
			// buttons.
			penaction: function(x, y) {
			// sets this.strokedata as the action this stroke will take. (that
			// is, whether to fill or erase. this depends on the value of the
			// pixel you clicked.)
				let value = this.part[this.clicktype][ this.clickrowcol(x, y, true) ];
				// value of the pixel being clicked on
				if(this.tool === "pen1") {
					this.strokedata = (value === 0 ? 1 : 0);
				}
				else if(this.tool === "pen2") {
					this.strokedata = (value === 2 ? "2 to 1" : 2);
				}
				else {
					console.log("this shouldn't happen");
				};
			},
			pen: function(x, y) {
				let action = this.strokedata;
				let index = this.clickrowcol(x, y, true);
				if(index === null) {
					return;
				};
				let image = this.part[this.clicktype];
				if([0, 1, 2].includes(action)) {
					image[index] = action;
				}
				else if(action === "2 to 1") {
					if(image[index] === 2) {
						image[index] = 1;
					};
				}
				else {
					console.log("this shouldn't happen");
				};
				this.redraw();
			},
			changecolor: function(type) {
			// prompts the user and changes color accordingly.
				let text = {
					color1: "main color.",
					color2: "secondary color.",
					grid_color: "color for the grid.",
					empty_color: "color for unfilled blocks.",
				};
				if(!text.hasOwnProperty(type)) {
					console.log("this shouldn't happen");
					return;
				};
				text = "type the " + text[type];
				const color = prompt(text);
				if(!color) {
					return;
				};
				if(["color1", "color2"].includes(type)) {
					this.part[type] = color;
				}
				else {
					this[type] = color;
				}
				this.ui.draw();
				this.redraw();
			},
			edit: function(action, args) {
			// all-purpose function for most editing tools.
			// - action: the string of the function in Raster you plan
			//   to use
			//   - there's also fullellipse and switch. those aren't imagefunc
			//     functions, but there's code for those.
			//   - go to aa.pa.editactions for the full list of actions.
			// - args: an array of arguments to pass on. (not counting image and
			//   w. it can figure those out on its own.)
			//   - ellipse: x1, y1, x2, y2
			//   - move is figured out from the direction suffix.
				args ??= [];
				const box = structuredClone(this.part.box);
				let rect = this.part.rect(this.editright);
				let image = this.part[this.editright ? "right" : "front"];
				const w = rect.w;
				if(action.startsWith("move_")) {
					action = action.split("_");
					args = {
						l: [-1, 0],
						r: [1, 0],
						u: [0, -1],
						d: [0, 1],
						ul: [-1, -1],
						ur: [1, -1],
						dl: [-1, 1],
						dr: [1, 1],
					}[action[1]];
					action = action[0];
				};
				//
				if(action === "changedimensions") {
				// changedimensions only thinks in 2d. this prompts the user to
				// create a changes object, then applies edits to both front and
				// right.
					let text = prompt([
						`type dimension changes here to expand the canvas.`,
						`dimensions and coordinates are created with an overall size number, and "oddness" booleans for each axis.`,
						`the box the part is within will always center on [0, 0, 0] and all its dimensions will be mostly equal.`,
						`but depending on the axis' oddness, dimensions might be size + 1.`,
						`type "size:" and a number to change size, and an axis letter with a colon and boolean to change oddness. use commas to separate multiple commands.`,
					].join(String.fromCharCode(10).repeat(2)));
					if(!text) {
						return;
					};
					text = text.split(",");
					for(i1 = 0; i1 < text.length; i1++) {
						let value = text[i1].split(":");
						let name = value[0].trim();
						value = (
							name === "size"
							?
							Number(value[1])
							:
							value[1].trim()
						);
						if(name === "size" && Number.isInteger(value) && value >= 0) {
							this.part.size = value;
						}
						else if("xyz".includes(name) && name.length === 1 && ["true", "false"].includes(value)) {
							this.part.oddness["xyz".indexOf(name)] = value === "true";
						};
					}
					const new_box = structuredClone(this.part.box);
					this.part.front = Raster.redimension(this.part.front, box.w, new_box.w, new_box.h);
					this.part.right = Raster.redimension(this.part.right, box.d, new_box.d, new_box.h);
				}
				else if(["ellipse", "rotate", "clear", "xmirror", "ymirror", "move"].includes(action)) {
					this.part[this.editright ? "right" : "front"] = Raster[action](image, w, ...args);
				}
				else if(action === "fullellipse") {
					this.edit("ellipse", [0, 0, rect.w - 1, rect.h - 1]);
					return;
					// avoids .redraw since this new running of .edit will do
					// that
				}
				else if(action === "swap") {
					let temp = Raster.redimension(this.part.front, box.w, box.d, box.h);
					this.part.front = Raster.redimension(this.part.right, box.d, box.w, box.h);
					this.part.right = structuredClone(temp);
					// dimensions might be different, because of oddness and all
					// that.
				}
				else if(action === "rotate90") {
					this.part[this.editright ? "right" : "front"] = Raster.rotate(image, w, Math.PI/2);
				};
				this.redraw();
			},
		},
		drawsettings: new AAX.DrawSettings,
		// stuff is here if it's data that only affects how things are
		// visualized, not stuff that affects processing like which tool is
		// selected.
		// - NOTE color doesn't count. that's separate.
		color: new AAX.Color,
		// object storing the colors of various things.
		ctx: {
			main: null,
			ui: null,
		},
		div: {
			editmodetrue: null,
			editmodefalse: null,
			coor: null,
		},
		version_history: "v1.0 v1.0.1 v1.1 v1.1.1 v1.2 v1.3".split(" "),
		get version() {
			return aa.version_history[aa.version_history.length - 1];
		},
		partinfo_is_default: function(part, view, suffix) {
			let _default = false;
			if(suffix in AAX.part_properties && ["body_exclusive", "pose_exclusive"].includes(AAX.part_properties[suffix].type)) {
				_default = true;
			}
			else if(suffix === "shape") {
				//_default = part["_" + suffix] === "default";
				_default = part.getwithoutredirects(suffix) === "default";
			}
			else if(["name", "colors"].includes(suffix)) {
				_default = true;
			}
			else if(suffix === "hide") {
				_default = part.bodyref[suffix] === part[suffix];
			}
			else if(suffix === "coor") {
				_default = compareobject(AAX.relcoor(part.bodyref), part.relcoor);
			}
			else if(suffix === "image") {
				_default = (
					part._image.front === "default"
					&&
					part._image.right === "default"
				);
			}
			else if(suffix === "perspective_coor") {
				_default = part._perspective.coor[view] === "default";
			}
			else if(suffix === "perspective_image") {
				_default = part._perspective[view] === "default";
			}
			else if(suffix === "shape_settings") {
				let quat = part.body[part.name].mirror ? Quat.mirror.x() : Quat.new();
				_default = part.stretch === 1 && part.widen === 1 && compareobject(part.orient, quat);
			}
			else {
				console.log("there are partinfo properties the logic doesn't account for. (" + suffix + ")");
			};
			return _default;
		},
		hidelist: function(partname, suffix) {
		// makes an array of parts based on the partname and the type of hide.
		// for example, making an array of the body the part is part of, or the
		// branch made from it.
			let i1 = 0;
			let loop = new Loop("aa.hidelist");
			let array = [];
			let minus = null;
			if(suffix.includes("_minus_")) {
				suffix = suffix.split("_minus_");
				minus = suffix[1];
				suffix = suffix[0];
			};
			if(suffix === "part") {
				array = [partname];
			}
			else if(suffix === "group") {
				let num = aa.currpose[partname].silhouette.group;
				let bodylist = aa.hidelist(partname, "body");
				// group basically means "same set of limbs", so it should
				// omit parts that aren't in the same body.
				for(i1 = 0; i1 < bodylist.length; i1++) {
					let _i1 = bodylist[i1];
					if(aa.currpose[_i1].silhouette.group === num) {
						array.push(_i1);
					}
				}
			}
			else if(suffix === "branch" || suffix === "body") {
				let start = suffix === "body" ? AAX.getstem(aa.currpose, partname) : partname;
				array = AAX.getdesc(aa.currpose, start);
				array.splice(0, 0, start);
			}
			else if(suffix === "all") {
				for(i1 in aa.currpose) {
					loop.tick(1);
					if(aa.currpose.hasOwnProperty(i1)) {
						array[array.length] = i1;
					}
				}
				loop.end();
			}
			else {
				console.log("this shouldn't happen");
			};
			if(minus) {
				minus = aa.hidelist(partname, minus);
				for(i1 = 0; i1 < minus.length; i1++) {
					loop.tick(1);
					let temp = array.indexOf(minus[i1]);
					if(temp !== -1) {
						array.splice(temp, 1);
					}
				}
				loop.end();
			}
			return array;
		},
		ishidden: function(partname, suffix) {
		// used with the hide/show buttons, to tell whether the button should be
		// highlighted, and whether clicking it should show or hide the parts
		// involved.
			let i1 = 0;
			let loop = new Loop("aa.");
			let array = aa.hidelist(partname, suffix);
			for(i1 = 0; i1 < array.length; i1++) {
				loop.tick(1);
				if(!aa.currpose[ array[i1] ].hide) {
					return false;
				};
			}
			loop.end();
			return true;
		},
		inbetweenvalues: function(num, curve, easeA, easeB) {
		// used by the inbetween visual and creation.
		// - one of those things that's only a function because it bothers me to
		//   write the same code twice.
			let array = [];
			let ease = (
				easeA
				?
				(easeB ? "out" : "out/in")
				:
				(easeB ? "in/out" : "in")
			);
			let _array = null;
			if(curve < 0) {
			// makes it look sorta wonky and random.
				_array = [];
				curve = Math.abs(curve);
				for(let i1 = 0; i1 < num; i1++) {
					_array[_array.length] = (Math.random() + (i1 + 1)/(num + 1))/2;
				}
				_array.sort((a, b) => a - b);
			}
			for(let i1 = 0; i1 < num; i1++) {
				array[i1] = easing(_array ? _array[i1] : (i1 + 1)/(num + 1), ease, curve);
			}
			return array;
		},
		ui: {
		// ARMATURE ARTIST
		// functions/data specific to ui, like what creates/draws buttons. and
		// some other stuff, like arrays of valid values for string properties
			buttons: {},
			create: function() {
				let i1 = 0;
				let i2 = 0;
				let loop = new Loop("aa.ui.create");
				let temp = structuredClone(AAX.ui.color_area);
				temp.direction = "r";
	            temp.adjust = 2;
				let areas = [
					{
						prefix: "states",
						first: {
							suffix: "undo redo".split(" "),
							w: 4, h: 2,
							horizontal: true,
						},
						actions: [
							["expand", "limit", "d", 2]
						],
					},
					{
						prefix: "frame",
						first: {
							suffix: "display",
							w: 3, h: 3,
						},
						actions: [
							["expand", "previous", "l", 2],
							["expand", "next", "r", 2],
							["subtract", "previous", "u", 1],
							["subtract", "next", "u", 1],
							["column", "blank duplicate delete move_up move_down".split(" "), "d", 7, 1]
						],
					},
					{
						prefix: "inbetween",
						first: {
							suffix: "curve",
							w: 6, h: 1,
						},
						actions: [
							["expand", "easeA easeB".split(" "), "d", 1, true],
							["expand", "visual", "d", 1],
							["expand", "add number subtract".split(" "), "r", 2],
							["expand", "create", "d", 3],
							["expand", "apply", "d", 3],
						],
					},
					{
						prefix: "hide",
						first: {
							suffix: [],
							w: 8, h: 1,
						},
					},
					{
						prefix: "misc",
						first: {
							suffix: "autoperspective",
							w: 10, h: 4,
						},
						actions: [
							["expand", "clearimage editshape".split(" "), "d", 2, true],
							["expand", "stretch_widen refreshshape".split(" "), "d", 2, true],
							["expand", "reset_part reset_branch".split(" "), "d", 2, true],
							["expand", "posetoshape", "d", 1]
						],
					},
					{
						prefix: "view",
						first: {
							suffix: "0 1 2 3".split(" "),
							w: 1.5, h: 1,
							horizontal: true,
						},
					},
					{
						prefix: "oddify",
						direction: "d",
						first: {
							suffix: "x y z".split(" "),
							w: 2, h: 1,
							horizontal: true,
						},
					},
					{
						prefix: "mirror",
						gap: 0,
						first: {
							suffix: "x y z".split(" "),
							w: 2, h: 1,
							horizontal: true,
						},
					},
					{
						prefix: "switch",
						first: {
							suffix: " no_export".split(" "),
							w: 6, h: 3,
						},
						heading: 2,
					},
					{
						prefix: "px",
						actions: [
							["column", "paste replace".split(" "), "d", 6, 2],
							["column", AAX.valid.px_export, "d", 6, 1],
							["column", "one_view vertical".split(" "), "d", 6, 1]
						],
						heading: 2,
					},
					{
						prefix: "posetool",
						previous: 0,
						direction: "d",
						first: {
							suffix: AAX.valid.posetools,
							w: 8, h: 1,
						},
					},
					{
						prefix: "rotate",
						actions: [
							["column", "round type curl".split(" "), "d", 6.5, 1],
							["expand", "display", "r", 4],
						],
					},
					{
						prefix: "rotate",
						gap: 0,
						actions: [
							["column", "invert", "d", 4.5, 1],
							["expand", "invert_x invert_y invert_z".split(" "), "d", 1, true],
							["expand", "switch", "d", 1],
							["expand", "switch_x_y switch_y_z switch_z_x".split(" "), "d", 2, true]
						],
						heading: false,
					},
					{
						prefix: "rotate",
						gap: 0,
						direction: "r",
						actions: [
							["column", AAX.valid.rotate_axis_setters, "d", 6, 1],
							["expand", "select_x select_y select_z".split(" "), "u", 1, true]
						],
						heading: false,
					},
					{
						prefix: "drawsettings",
						previous: -3,
						direction: "r",
						adjust: -2,
						first: {
							suffix: "grid standpoint range".split(" "),
							w: 12, h: 1,
						},
						actions: [
							["expand", "cell vp camera".split(" "), "d", 3, true],
							["expand", "fineness", "d", 1]
						],
					},
					temp,
					{
						prefix: "partinfo",
						//previous: -2,
						//direction: "d",
						previous: -4,
						direction: "d",
						gap: 3,
						first: {
							suffix: "name",
							w: 20,
							h: 1,
						},
						actions: [],
					},
					{
						prefix: "",
						previous: 0,
						direction: "u",
						gap: 1,
						first: {
							suffix: "save load".split(" "),
							w: 4, h: 2,
							horizontal: true,
						},
					},
					{
						prefix: "",
						direction: "u",
						gap: 0,
						first: {
							suffix: "title",
							w: Math.ceil(((AAX.ui.charwidth + 1)*("armature artist " + aa.version).length - 1 + 3)/AAX.ui.block), h: 1,
						},
						actions: [
							["expand", "projectname", "r", 1],
							["align", "projectname", "r"],
						],
					},
					{
						prefix: "anim",
						previous: -2,
						direction: "r",
						gap: 0,
						first: {
							suffix: "menu",
							w: 16, h: 1,
							horizontal: true,
						},
						actions: [
							["row", "blank duplicate delete".split(" "), "d", 6, 1],
							["align", "menu", "r"],
						],
					}
				];
				for(i1 = 0; i1 < areas.length; i1++) {
					let prefix = areas[i1].prefix;
					if(prefix && prefix !== "anim" && prefix !== "color") {
						areas[i1].heading ??= 1;
					}
				}
				// add heading
				temp = "zxcvbnm";
				for(i1 = 0; i1 < AAX.valid.posetools.length; i1++) {
					this.keymap[ temp[i1] ] ??= [];
					this.keymap[ temp[i1] ][0] = "posetool_" + AAX.valid.posetools[i1];
				};
				// pose tools keymap
				let array = [
					"part",
					"branch",
					"group",
					"body_minus_part",
					"body_minus_branch",
					"body_minus_group",
					"all",
					"body",
					"all_minus_body"
				];
				temp = areas.find((element) => element.prefix === "hide");
				temp.first.suffix = structuredClone(array);
				for(i1 = 0; i1 < array.length; i1++) {
					this.keymap[(i1 + 1).toString()] ??= [null];
					this.keymap[(i1 + 1).toString()][1] = "hide_" + array[i1];
					// add 1 so it doesn't start at 0
				}
				// hide keymap
				array = [];
				for(i1 in AAX.DrawSettings.template) {
					if(AAX.DrawSettings.template.hasOwnProperty(i1) && (typeof AAX.DrawSettings.template[i1] === "boolean" || AAX.valid.hasOwnProperty(i1))) {
						array[array.length] = i1;
					};
				}
				temp = areas.find((element) => element.prefix === "drawsettings");
				temp.actions[temp.actions.length] = ["column", array, "l", 7.5, 1];
				for(i1 = 0; i1 < array.length; i1++) {
					this.keymap[(i1 + 1).toString()] ??= [];
					this.keymap[(i1 + 1).toString()][0] = "drawsettings_" + array[i1];
				}
				// finish drawsettings
				array = [
					"colors",
					"coor",
					"perspective_coor",
					"shape",
					"image",
					"perspective_image",
					"shape_settings",
					"hide",
					"silhouette"
				];
				temp = areas.find((element) => element.prefix === "partinfo");
				for(i1 = 0; i1 < array.length; i1++) {
					let h = (
						array[i1] === "coor" ? 6 :
						array[i1] === "shape_settings" ? 2 :
						array[i1] === "silhouette" ? 3 :
						1
					);
					temp.actions.push(["expand", array[i1], "d", h]);
					// - relative coordinates title and numbers on
					//   two lines, absolute coordinates on two
					//   lines, and the current and original
					//   hypotenuse on two lines.
					// - connections need a line for the type, and a
					//   line for the value
					// - stretch and widen both get their own lines
				}
				// finish partinfo
				aa.ui.buttons = Rect.ui(areas);
				//
				let ref = aa.ui.buttons;
				for(i1 in ref) {
					if(ref.hasOwnProperty(i1)) {
						ref[i1].x *= AAX.ui.block;
						ref[i1].y *= AAX.ui.block;
						ref[i1].w *= AAX.ui.block;
						ref[i1].h *= AAX.ui.block;
					};
				}
			},
			keymap: {
			// property names are keys, the values are which button is supposed
			// to trigger.
			// - keys should be named the same as they are in KeyboardEvent.key,
			//   except single letters should be lowercase.
			// - if they're arrays:
			//   - 1: action when shift is held
			//   - 2: action when ctrl is held
			//   - 3: action when both are held
				w: ["posetool_previous", null],
				a: ["frame_previous", "view_previous"],
				s: ["posetool_next", null, "save"],
				d: ["frame_next", "view_next"],
				//
				q: ["switch", "switch_no_export"],
				e: "posetool_invert",
				//
				t: "select_parent",
				f: "select_prevsibling",
				g: "select_child",
				h: "select_nextsibling",
				//
				j: "frame_blank",
				i: "frame_duplicate",
				k: "frame_delete",
				o: "frame_move_up",
				l: "frame_move_down",
				//
				z: [null, null, "states_undo", "states_redo"],
				o: [null, null, "load"],
			},
			// keys added automatically:
			// - the number keys are drawsettings toggles, and hide toggles when
			//   shift is held
			// - zxcvbnm is pose tools
			get buttons_w() {
				let loop = new Loop("aa.ui.buttons_w");
				let w = 0;
				let buttons = aa.ui.buttons;
				for(let i1 in buttons) {
					loop.tick(1);
					if(buttons.hasOwnProperty(i1)) {
						w = Math.max(w, buttons[i1].x + buttons[i1].w);
					}
				};
				loop.end();
				return w;
			},
			get buttons_h() {
				let loop = new Loop("aa.ui.buttons_h");
				let h = 0;
				let buttons = aa.ui.buttons;
				for(let i1 in buttons) {
					loop.tick(1);
					if(buttons.hasOwnProperty(i1)) {
						h = Math.max(h, buttons[i1].y + buttons[i1].h);
					}
				};
				loop.end();
				return h;
			},
			animtabwidth: 8,
			// measured in blocks
			draw: function(depress) {
			// draws the buttons. this needs to be run every time...
			// - the current part changes
			// - the oddness of the current part changes
			// - the selected posetool changes
			// =
			// - depress: argument for which button is currently being animated
			//   as having been pressed.
				let i1 = 0;
				let i2 = 0;
				let i3 = 0;
				let loop = new Loop("aa.ui.draw");
				loop.tick(1);
				loop.tick(2);
				loop.end();
				let w = aa.ui.buttons_w;
				let h = aa.ui.buttons_h;
				w++;
				h++;
				// add 1 so there's room for the bottom/right edges of buttons
				let buttons = aa.ui.buttons;
				let ctx = aa.ctx.ui;
				ctx.canvas.width = w;
				ctx.canvas.height = h;
				let color = aa.color.buttons;
				//ctx.fillStyle = color[1];
				//ctx.fillRect(0, 0, w, h);
				ctx.clearRect(0, 0, w, h);
				const part = aa.control.part;
				const view = aa.control.view;
				const oddness = part.oddness;
				const image_oddness = AAX.image_oddness(aa.currpose, part.name, view);
				let relcoor = part.relcoor;
				const margin = AAX.ui.margin;
				const lineheight = AAX.ui.lineheight;
				const charwidth = AAX.ui.charwidth;
				let text_x = (button, align, text) => Math.floor(button.x + (
					align === "center" ? button.w/2 :
					align === "right" ? button.w - margin[0] :
					margin[0]
				)) + (align === "center" && !((text.length*(AAX.ui.charwidth + 1) - 1)%2) ? .5 : 0);
				ctx.font = AAX.ui.font;
				ctx.textAlign = "left";
				ctx.textBaseline = "middle";
				for(i1 in buttons) {
					loop.tick(1);
					if(buttons.hasOwnProperty(i1)) {
						let prefix = PreSuf.get(i1);
						let suffix = prefix[1];
						prefix = prefix[0];
						//let prefix = i1.includes("_") ? i1.slice(0, i1.indexOf("_")) : i1;
						//let suffix = i1.slice(prefix.length + 1);
						let text = (
							suffix === "heading" ? (
								prefix === "posetool" ? "pose tools" :
								prefix === "hide" ? "hide/show" :
								prefix === "switch" ? "part artist".split(" ") :
								prefix === "px" ? ["pixel art", "transfer"] :
								prefix === "frame" ? "frames" :
								prefix === "partinfo" ? "part information" :
								prefix === "drawsettings" ? "draw settings" :
								prefix === "rotate" ? "rotate settings" :
								prefix
							) :
							prefix === "misc" ? (
								suffix === "autoperspective" ? "automate perspective coordinates".split(" ") :
								suffix === "clearimage" ? "clear image".split(" ") :
								suffix === "editshape" ? "edit shape".split(" ") :
								suffix === "stretch_widen" ? "stretch /widen".split(" ") :
								suffix === "refreshshape" ? "refresh shape".split(" ") :
								suffix === "reset_part" || suffix === "reset_branch" ? suffix.split("_") :
								suffix === "posetoshape" ? ["pose to shape"] :
								null
							) :
							(prefix === "hide" && suffix.includes("_minus_")) ? suffix.replaceAll("_minus_", "-") :
							i1 === "switch" ? " switch ".split(" ") :
							i1 === "switch_no_export" ? "switch without export".split(" ") :
							/*
							prefix === "drawsettings" ? (
								suffix === "background" ? aa.drawsettings[suffix] :
								suffix === "cell" ? "cell w: h:".split(" ") :
								(suffix === "grid" || suffix === "standpoint" || suffix === "range" || suffix === "fineness") ? suffix + ":" :
								suffix === "vp" ? "vp x: y:".split(" ") :
								suffix === "camera" ? "camera xz: yz:".split(" ") :
								null
							) :
							//*/
							i1 === "title" ? ("armature artist " + aa.version) :
							i1 === "projectname" ? aa.control.projectname :
							i1 === "states_limit" ? "limit: truncator:".split(" ") :
							prefix === "rotate" ? (
								suffix === "round" ? suffix + ":" :
								suffix === "type" ? aa.control[prefix][suffix] :
								suffix === "display" ? "" :
								suffix.startsWith("switch_") ? suffix.slice("switch_".length).split("_") :
								(suffix.startsWith("invert_") || suffix.startsWith("select_")) ? suffix.slice(suffix.indexOf("_") + 1) :
								null
							) :
							null
						);
						text ??= (!suffix ? prefix : suffix).replaceAll("_", " ");
						let right_text = (
							/*
							prefix === "drawsettings" ? (
								suffix === "cell" ? ["", aa.drawsettings.cell.w, aa.drawsettings.cell.h] :
								suffix === "grid" ? aa.drawsettings.grid.join(",") :
								suffix === "standpoint" ? [
									(aa.drawsettings.standpoint.x - aa.drawsettings.cell.w/2),
									(aa.drawsettings.standpoint.y - aa.drawsettings.cell.h/2)
								].join(", ") :
								suffix === "vp" ? [
									"",
									(aa.drawsettings.vp.x - aa.drawsettings.standpoint.x),
									(aa.drawsettings.vp.y - aa.drawsettings.standpoint.y)
								] :
								suffix === "range" ? aa.drawsettings.range :
								suffix === "camera" ? [
									"",
									Math.round(Angle.convert(aa.drawsettings.camera.xz)),
									Math.round(Angle.convert(aa.drawsettings.camera.yz))
								] :
								suffix === "fineness" ? aa.drawsettings[suffix] :
								null
							) :
							//*/
							i1 === "states_limit" ? [aa.states_limit, aa.states_truncator] :
							i1 === "rotate_round" ? aa.control.rotate.round :
							null
						);
						right_text ??= "";
						if(prefix === "inbetween") {
							let ref = aa.control.inbetween;
							text = (
								suffix === "heading" ? "inbetweens" :
								suffix === "add" ? "+" :
								suffix === "subtract" ? "-" :
								suffix === "number" ? ref.number :
								suffix === "curve" ? (ref.curve < 0 ? "?" : "^") + roundspecial(Math.abs(ref.curve), -5) :
								suffix === "easeA" || suffix === "easeB" ? (
									suffix === "easeB" && ref.easeA === ref.easeB ? "" :
									ref[suffix] ? "out" : "in"
								) :
								suffix === "create" ? "create inbetweens".split(" ") :
								suffix === "apply" ? "apply tweening".split(" ") :
								""
							);
							if(!text && suffix !== "visual" && suffix !== "easeB") {
								console.log("this shouldn't happen");
							}
						}
						if(Array.isArray(text)) {
							for(i2 = 0; i2 < text.length; i2++) {
								text[i2] += "";
							}
						}
						else {
							text += "";
						};
						// make sure it isn't a number, so it can use .length
						let checkbox = (
							prefix === "px" ? (suffix === "one_view" || suffix === "vertical") :
							prefix === "rotate" ? suffix === "curl" :
							false
						);
						let radio = (
							prefix === "px" ? AAX.valid.px_export.includes(suffix) :
							false
						);
						let heading = (
							suffix === "heading"
							||
							(prefix === "rotate" && (suffix === "invert" || suffix === "switch"))
							||
							checkbox || radio
						);
						let selected = Number(
							(prefix === "posetool" && suffix === aa.control.posetool)
							||
							(prefix === "oddify" && (
									aa.control.perspectived
									?
									["x", "y"].includes(suffix) && image_oddness["xy".indexOf(suffix)]
									:
									["x", "y", "z"].includes(suffix) && oddness["xyz".indexOf(suffix)]
								)
							)
							||
							(prefix === "view" && aa.control.view === Number(suffix))
							||
							(
								prefix === "drawsettings"
								&&
								aa.drawsettings.hasOwnProperty(suffix)
								&&
								typeof aa.drawsettings[suffix] === "boolean"
								&&
								aa.drawsettings[suffix]
							)
							||
							(prefix === "hide" && suffix !== "heading" && aa.ishidden(aa.control.partname, suffix))
							||
							(
								prefix === "inbetween"
								&&
								(suffix === "easeA" || suffix === "easeB")
								&&
								aa.control.inbetween[suffix]
							)
							||
							(prefix === "rotate" && (
								suffix === "curl" ? aa.control.rotate.curl :
								suffix.startsWith("select_") && suffix.slice("select_".length) === "xyz"[aa.control.rotate.select]
							))
							||
							(prefix === "px" && (
								checkbox ? aa.animator.html[suffix].checked :
								radio ? suffix === aa.control.px_export :
								false
							))
							//||
							//i1 === "projectname"
						);
						if(prefix === "drawsettings" && AAX.valid.hasOwnProperty(suffix)) {
							selected = AAX.valid[suffix].indexOf(aa.drawsettings[suffix]);
						}
						else if(heading) {
						}
						else if(
							(prefix === "posetool" && selected && aa.control.posetool_inversion)
							||
							(aa.control.perspectived && prefix === "oddify" && suffix === "z")
							// 2 in this instance means "not applicable"
							||
							(prefix === "hide" && aa.hidelist(aa.control.partname, suffix).length === 0)
							//||
							//(prefix === "inbetween" && suffix === "easeB" && aa.control.inbetween.easeA === aa.control.inbetween.easeB)
							||
							i1 === "title"
							||
							(
								prefix === "rotate" && aa.control.rotate.type !== "custom"
								&&
								!heading
								&&
								suffix !== "type"
								&&
								suffix !== "round"
								&&
								suffix !== "curl"
								&&
								suffix !== "display"
							)
							||
							(
								prefix === "rotate"
								&&
								AAX.valid.rotate_axis_setters.includes(suffix)
								&&
								AAX.ui.rotate_axis_setter_disabled(aa.currpose, part.name, aa.control.rotate.basis, aa.control.rotate.select, suffix)
							)
						) {
							selected = 2;
						}
						else if(i1 === "rotate_type") {
							selected = AAX.valid[i1].indexOf(aa.control[prefix][suffix]);
						}
						if(depress && i1 === depress) {
							selected = posmod(selected + 1, 3);
						};
						let rect = structuredClone(buttons[i1]);
						let center = [Math.floor(rect.x + rect.w/2) + .5, Math.floor(rect.y + rect.h/2)];
						ctx.strokeStyle = color[ posmod(- selected, color.length) ];
						ctx.fillStyle = color[ posmod(1 - selected, color.length) ];
						if(prefix !== "color" && !heading && i1 !== "anim_menu") {
							ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
							Rect.fauxstroke(rect, ctx);
						};
						//console.log([prefix, suffix]);
						let align = (
							(Array.isArray(text) && prefix !== "drawsettings" && prefix !== "states")
							||
							(heading && prefix !== "partinfo")
							||
							(prefix === "states" && (suffix === "undo" || suffix === "redo"))
							||
							["view", "save", "load"].includes(prefix)
							||
							(prefix === "inbetween" && (suffix === "add" || suffix === "subtract" || suffix === "number"))
							||
							(prefix === "rotate" && (suffix.startsWith("select") || suffix.startsWith("invert") || suffix.startsWith("switch") || suffix === "type"))
							||
							prefix === "px"
						);
						align = align ? "center" : "left";
						if(prefix === "partinfo" && !heading) {
							ctx.fillStyle = ctx.strokeStyle;
							const nondefault = "!";
							// character to use for these
							// - everything gets an space before it if it's
							//   "default", or an exclamation point if it isn't.
							let _default = aa.partinfo_is_default(part, view, suffix);
							const digits = 5;
							function convertnumber(num, addsign) {
								let text = "" + num;
								if(addsign && Math.sign(num) === 1) {
									text = "+" + text;
								};
								text += ".0".repeat(!text.includes("."));
								let index = text.indexOf(".");
								if(index > digits) {
									text = text.slice(index - digits);
								}
								else if(index < digits) {
									text = " ".repeat(digits - index) + text;
								};
								return text;
							};
							// numbers always have .0 or .5, and if the left
							// digits plus sign are longer than 5, they get
							// cut off. spaces are added if it's shorter, so
							// it's always the same length.
							if(suffix === "coor") {
								text = [
									(_default ? " " : nondefault) + "relative coordinates",
									null,
									" absolute coordinates",
									null,
									" hypotenuse:",
									" default:"
								];
								let relcoor = part.relcoor;
								let abscoor = part.abscoor;
								for(i2 = 0; i2 < 3; i2++) {
									loop.tick(2);
									relcoor[i2] = convertnumber(relcoor[i2], true);
									abscoor[i2] = convertnumber(abscoor[i2], false);
								}
								loop.end();
								text[1] = relcoor.join(" ");
								text[3] = abscoor.join(" ");
								for(i2 = 0; i2 < text.length; i2++) {
									loop.tick(2);
									ctx.textAlign = ([1, 3].includes(i2) ? "center" : "left");
									const x = (ctx.textAlign === "center" ? center[0] : rect.x + margin[0]);
									const y = Math.floor(rect.y + rect.h*(i2 + .5)/text.length + margin[1]);
									ctx.fillText(text[i2], x, y);
									if([4, 5].includes(i2)) {
										ctx.textAlign = "right";
										let string = "" + (i2 === 4 ? Math.hypot(...part.relcoor) : AAX.hypot(part.body, part.pose, part.name));
										if(!string.includes(".")) {
											string += " ".repeat(1 + 2);
										}
										else {
											let num = string.length - (string.indexOf(".") + 1);
											// number of decimal places
											num = 2 - num;
											// -1 is one too many, +1 is one too
											// few
											if(num > 0) {
												string += " ".repeat(num);
											}
											else if(num < 0) {
												string = string.slice(0, num);
											};
										}
										ctx.fillText(
											string,
											rect.x + rect.w - margin[0],
											y
										);
									};
								};
								loop.end();
								ctx.textAlign = "left";
							}
							else if(suffix === "silhouette") {
								let sil = part[suffix];
								for(i2 = 0; i2 < 3; i2++) {
									let _text = (
										i2 === 0 ? ["silhouette: group " + sil.group + sil.subgroup] :
										i2 === 1 ? ["ancestors: " + sil.anc, "descendants: " + sil.desc] :
										i2 === 2 ? [(sil.core ? ("core: " + sil.core) : ""), (sil.bone ? ("bone: " + sil.bone) : ""), (sil.concave ? "concave" : "")] :
										[]
									);
									let y = Math.floor(rect.y + rect.h*(i2 + .5)/3 + margin[1]);
									for(i3 = 0; i3 < _text.length; i3++) {
										let x = margin[0] + charwidth + 1;
										x += Math.floor((rect.w - x)*i3/_text.length);
										let line = _text[i3];
										if(!i2 && !i3) {
											line = (_default ? " " : nondefault) + line;
											x -= charwidth + 1;
										};
										ctx.fillText(line, x, y);
									}
								}
							}
							else if(suffix === "shape_settings") {
							// two lines, and a circle on the right showing the
							// orient.
								text = [
									(_default ? " " : nondefault) + "stretch:",
									" widen:"
								];
								let r = Math.floor((Math.min(rect.w, rect.h) - margin[0])/2);
								let x = rect.x + rect.w - (r + margin[0]);
								let y = Math.floor(rect.y + rect.h/2);
					            if(part.orient.flip) {
					            // draw a tiny x under the axes if it's
					            // flipped.
					                ctx.strokeStyle = aa.color.buttons[2];
					                linespecial(ctx, x - 2, y - 2, x + 2, y + 2);
					                linespecial(ctx, x + 2, y - 2, x - 2, y + 2);
					            };
								AAX.ui.basis(ctx, x, y, r, Quat.basis(part.orient));
								// draw orient sphere
								ctx.textAlign = "right";
								for(i2 = 0; i2 < 2; i2++) {
									loop.tick(2);
									ctx.fillText(
										convertnumber(part[i2 ? "widen" : "stretch"]),
										rect.x + rect.w - 2*(r + margin[0]),
										// make room for the orient sphere
										Math.floor(rect.y + rect.h*(i2 + .5)/2 + margin[1])
									);
								}
								loop.end();
								ctx.textAlign = "left";
								for(i2 = 0; i2 < text.length; i2++) {
									loop.tick(2);
									ctx.fillText(
										text[i2],
										rect.x + margin[0],
										Math.floor(rect.y + rect.h*(i2 + .5)/text.length + margin[1])
									);
								};
								loop.end();
							}
							else {
							// properties that aren't too complex for a simple
							// text + ":" + value structure...
								let value = null;
								if(suffix === "name") {
									text = part[suffix];
									value = "";
								}
								else if(suffix === "colors") {
									value = [part.bodyref.color1, part.bodyref.color2].join(", ");
								}
								else if(suffix === "image") {
									let temp = [
										(_default ? part.bodyref.image.front : part._image.front) !== null,
										(_default ? part.bodyref.image.right : part._image.right) !== null,
									]
									value = (
										temp[0]
										?
										// front exists
										(temp[1] ? "both" : "front")
										:
										// right exists
										(temp[1] ? "right" : "none")
									);
								}
								else if(suffix === "perspective_coor") {
									value = part["perspective_coor_" + view].join(", ");
									if((_default ? part.bodyref.perspective.coor[view] : part._perspective.coor[view]) === "auto") {
										value = "(auto) " + value;
									};
								}
								else if(suffix === "perspective_image") {
									text += " " + view;
									value = (
										(_default ? part.bodyref.perspective[view] : part._perspective[view]) === null
										?
										"absent"
										:
										""
									);
								}
								else if(suffix === "hide") {
									value = part[suffix] ? "on" : "off";
								}
								else if(suffix === "shape") {
									value = "";
								}
								else {
									console.log("there are partinfo properties the logic doesn't account for. (" + suffix + ")");
								};
								if(!["name", "shape", "perspective_image"].includes(suffix) || (suffix === "perspective_image" && value)) {
									text += ":";
								};
								// coor, connection: special code
								// name
								// - omit suffix + ":"
								// - center the value
								// colors
								// - needs to use integer colors, which requires bodyref
								// - needs to be be joined with a space
								// image
								// - no value
								// - no colon
								// perspective coor
								// - need to add the view number
								// - need to check if it's auto
								// perspective image
								// - no value unless it's null
								// - no colon unless it's null
								ctx.fillText((_default ? " " : nondefault) + text, rect.x + margin[0], center[1] + margin[1]);
								ctx.textAlign = "right";
								ctx.fillText(value, rect.x + rect.w - margin[0], center[1] + margin[1]);
								ctx.textAlign = "left";
							};
						}
						else if(prefix === "frame" && ["previous", "next"].includes(suffix)) {
							const w = (suffix === "previous" ? -1 : 1)*rect.w/2;
							const h = rect.h*1/2;
							const points = [
								[
									center[0] - w/2,
									center[1] - h/2,
								],
								[
									center[0] + w/2,
									center[1],
								],
								[
									center[0] - w/2,
									center[1] + h/2,
								]
							];
							_2dPoly.linespecial(ctx, points, center);
						}
						else if(prefix === "frame" && suffix === "display") {
							linespecial(ctx,
								center[0] - rect.w*3/8,
								center[1],
								center[0] + rect.w*3/8,
								center[1],
							center);
							ctx.fillStyle = ctx.strokeStyle;
							const coor = [
								center[0] - 1,
								Math.floor(rect.y + rect.h/4 + margin[1])
							];
							ctx.fillText(aa.currframe + 1, ...coor);
							coor[1] = Math.floor(coor[1] + rect.h/2);
							ctx.fillText(aa.frames.length, ...coor);
						}
						else if(prefix === "drawsettings" && !heading) {
							AAX.ui.draw.drawsettings(ctx, rect, aa.drawsettings, suffix);
						}
						else if(prefix === "color" && !heading) {
							AAX.ui.draw.color(ctx, rect, aa.color, suffix);
						}
						else if(!heading && ["oddify", "mirror", "image"].includes(prefix)) {
							ctx.fillStyle = ctx.strokeStyle;
							ctx.textAlign = "center";
							ctx.fillText(suffix, center[0], center[1] + margin[1]);
							ctx.textAlign = "left";
						}
						else if(prefix === "inbetween" && suffix === "visual") {
							let start = rect.x + rect.h/2;
							let end = rect.x + rect.w - rect.h/2;
							ctx.strokeStyle = color[2];
							linespecial(ctx, start, center[1], end, center[1], center);
							for(i2 = 0; i2 <= 1; i2 += 1/4) {
								let x = start + i2*(end - start);
								let tick = i2 === 0 || i2 === 1 ? 3 : i2 === .5 ? 2 : 1;
								linespecial(ctx, x, center[1] - tick, x, center[1] + tick, center);
							}
							ctx.fillStyle = color[0];
							let ref = aa.control.inbetween;
							ref.values = aa.inbetweenvalues(ref.number, ref.curve, ref.easeA, ref.easeB);
							circledraw(ctx, start + .5, center[1] + .5, 2.5, true);
							for(i2 = -1; i2 <= ref.values.length; i2++) {
								circledraw(ctx, start + ref.values[i2]*(end - start) + .5, center[1] + .5, 2.5, true);
							}
							circledraw(ctx, end + .5, center[1] + .5, 2.5, true);
						}
						else if(i1 === "title") {
							ctx.fillStyle = color[0];
							for(i2 = -1; i2 <= 1; i2++) {
								for(i3 = -1; i3 <= 1; i3++) {
									ctx.fillText(text, rect.x + margin[0] + i2, center[1] + margin[1] + i3);
								}
							}
							ctx.fillStyle = color[1];
							ctx.fillText(text, rect.x + margin[0], center[1] + margin[1]);
						}
						else if(prefix === "anim" && suffix === "menu") {
							ctx.fillStyle = color[2];
							ctx.fillRect(rect.x, rect.y + Math.floor(rect.h/2), rect.w, 1);
							let tabwidth = Math.min(aa.ui.animtabwidth*AAX.ui.block, rect.w/aa.anims.length);
							let divides = [];
							for(i2 = 0; i2 <= aa.anims.length; i2++) {
								divides[i2] = Math.floor(i2*tabwidth);
							}
							for(i2 = 0; i2 <= aa.anims.length; i2++) {
								if(i2 !== aa.anim_index) {
									let index = i2 === aa.anims.length ? aa.anim_index : i2;
									// make sure the selected tab is drawn last
									let _rect = [rect.x + divides[index], rect.y, divides[index + 1] - divides[index], rect.h];
									let style = i2 === aa.anims.length ? 2 : 0;
									style = [
										color[posmod(style + 0, 3)],
										color[posmod(style + 2, 3)]
									];
									ctx.fillStyle = style[0];
									ctx.strokeStyle = style[1];
									ctx.fillRect(..._rect);
									Rect.fauxstroke(Rect.new(..._rect), ctx);
									let name = aa.getanimname(index);
									let width = margin[0] + (charwidth + 1)*name.length;
									// how wide the tab has to be to fit the
									// name
									let ellipses = false;
									// whether to draw an ellipses after it
									if(width > tabwidth) {
										if(margin[0] + 6 > tabwidth) {
										// even an ellipse wouldn't fit, just
										// make it blank.
											name = "";
										}
										else {
										// cut it off with an ellipses
											name = name.slice(0, Math.floor((tabwidth - (margin[0] + 6))/(charwidth + 1)));
											width = margin[0] + (charwidth + 1)*name.length;
											ellipses = true;
										}
									}
									ctx.fillStyle = style[1];
									ctx.fillText(name, rect.x + divides[index] + margin[0], center[1] + margin[1]);
									if(ellipses) {
										for(i3 = 0; i3 < 3; i3++) {
											ctx.fillRect(rect.x + divides[index] + width + 2*i3, center[1] + 0*margin[1], 1, 1);
											// adding margin would put it right
											// at the level of a normal period
											// but i like it better in the
											// middle. i think dragon quest 3
											// drew them like that, and it makes
											// it look less like text.
										}
									}
								}
							}
						}
						else if(prefix === "rotate" && suffix === "display") {
							let basis = aa.control.rotate.type;
							basis = (
								basis === "local" ? Quat.basis(part.orient) :
								basis === "custom" ? aa.control.rotate.basis :
								Basis.new()
							);
							AAX.ui.basis(
								ctx,
								Math.floor(rect.x + rect.w/2), Math.floor(rect.y + rect.h/2),
								Math.min(rect.w, rect.h)/2 - 2,
								basis
							);
						}
						else {
							if(checkbox || radio) {
								AAX.ui.checkbox(ctx, color, rect.x, rect.y, checkbox ? !!selected : selected ? "radio on" : "radio off");
								ctx.strokeStyle = color[0];
								rect.x += AAX.ui.block;
								rect.w -= AAX.ui.block;
								align = "left";
							}
							ctx.fillStyle = ctx.strokeStyle;
							ctx.textAlign = align;
							if(Array.isArray(text)) {
								const start_y = Math.floor(center[1] - lineheight*(text.length - 1)/2 + margin[1]);
								for(i2 = 0; i2 < text.length; i2++) {
									const start_x = text_x(rect, align, text[i2]);
									const right_edge = text_x(rect, "right", right_text[i2]);
									loop.tick(2);
									const coor = [
										start_x,
										start_y + i2*lineheight
									];
									ctx.fillText(
										text[i2],
										...coor
									);
									if(right_text || right_text === 0) {
										ctx.textAlign = "right";
										ctx.fillText(
											right_text[i2],
											right_edge,
											coor[1]
										);
										ctx.textAlign = align;
									};
								};
								loop.end();
							}
							else {
								ctx.fillText(text, text_x(rect, align, text), center[1] + margin[1]);
								if(right_text || right_text === 0) {
									ctx.textAlign = "right";
									ctx.fillText(
										right_text,
										text_x(rect, "right", right_text),
										center[1] + margin[1]
									);
								};
							};
							ctx.textAlign = "left";
						};
					}
				};
				loop.end();
			},
			action: function(button, shift, ctrl, click) {
			// do whatever action the indicated button name does. can run both
			// from clicks or keys.
			// - shift: indicates that the shift key was held, or the click was
			//   a doubleclick.
			// - ctrl: indicates that ctrl was held. not sure if i'll use this
			//   though.
			// - click: coordinates of the click. (relative to the canvas, not
			//   the button.)
				let i1 = 0;
				let i2 = 0;
				let i3 = 0;
				let prefix = PreSuf.get(button);
				let suffix = prefix[1];
				prefix = prefix[0];
				//let prefix = button.includes("_") ? button.slice(0, button.indexOf("_")) : button;
				//let suffix = button.slice(prefix.length + 1);
				let refresh = {};
				let loop = new Loop("aa.ui.action");
				for(i1 = 0; i1 < AAX.valid.refresh.length; i1++) {
					loop.tick(1);
					refresh[AAX.valid.refresh[i1]] = true;
				}
				loop.end();
				refresh.states = false;
				// an object of booleans for which refresh actions to perform.
				// by default, it's everything but states.
				// - switch, switch without export: skip draw and ui (unless the switch is
				//   happening in the part artist.)
				// - frame actions: don't skip states
				//   - previous/next
				//   - duplicate
				//   - delete
				//   - move up
				//   - move down
				//   =
				//   - move up/down could skip draw
				//   - previous/next could skip states
				// - view buttons, family selection keys, partinfo_name: skip draw
				// - pose tool switches (including up/down): skip draw (unless if the new
				//   tool or old tool is perspective.)
				// - oddify, mirror, other partinfo, automate perspective coordinates:
				//   don't skip states
				let no_refresh = (
					(prefix === "states" && (suffix === "undo" || suffix === "redo"))
					||
					["switch", "save", "load"].includes(prefix)
					||
					suffix === "heading"
					||
					["misc_editshape", "inbetween_visual", "title"].includes(button)
				);
				// switch means changing to the part artist, so a refresh
				// wouldn't be seen. (and the switch button over there runs
				// refresh, so you're fine.) undo/redo/save/load either don't
				// need a refresh or run it in their respective functions. and
				// headings and displays don't do anything.
				// - misc_editshape just opens a <dialog>, and the buttons in
				//   there are what cause edits.
				const part = aa.control.part;
				const view = aa.control.view;
				if(!aa.ui.buttons.hasOwnProperty(button)) {
				// it's not like these have to be separate, i just wanna group
				// all key-only actions in the same place.
					if(["previous", "next"].includes(suffix)) {
						let index = null;
						let remainder = null;
						if(prefix === "posetool") {
							index = AAX.valid.posetools.indexOf(aa.control.posetool);
							remainder = AAX.valid.posetools.length;
						}
						else if(prefix === "view") {
							index = aa.control.view;
							remainder = 4;
						};
						if(index === null || remainder === null) {
							console.log("this shouldn't happen, or there's button-only actions i forgot to write.");
						};
						if(suffix === "next") {
							index++;
						}
						else if(suffix === "previous") {
							index--;
						};
						index = posmod(index, remainder);
						if(prefix === "posetool") {
							refresh.draw = (aa.control.posetool === "perspective") !== (AAX.valid.posetools[index] === "perspective");
							aa.control.posetool = AAX.valid.posetools[index];
						}
						else if(prefix === "view") {
							aa.control.view = index;
							refresh.draw = false;
						}
						else {
							no_refresh = true;
						};
					}
					else if(prefix === "select") {
					// lets you select the parent of the current part, the first
					// child, or cycle through siblings.
						if(suffix === "parent") {
							if(part.parent !== "standpoint") {
								aa.control.partname = part.parent;
							};
						}
						else if(suffix === "child") {
							let array = AAX.getchildren(aa.currpose, part.name);
							if(array.length >= 1) {
								aa.control.partname = array[0];
							};
						}
						else {
							let array = AAX.getchildren(aa.currpose, part.parent);
							let index = array.indexOf(part.name);
							if(suffix === "prevsibling") {
								index--;
							}
							else if(suffix === "nextsibling") {
								index++;
							}
							else {
								console.log("this shouldn't happen");
								return;
							};
							aa.control.partname = array[posmod(index, array.length)];
						};
						refresh.draw = false;
					}
					else if(button === "posetool_invert") {
						aa.control.posetool_inversion = !aa.control.posetool_inversion;
						refresh.draw = false;
					}
					else {
						no_refresh = true;
						console.log("this shouldn't happen, or there's button-only actions i forgot to write.");
					};
				}
				else if(suffix === "heading") {
				}
				else if(prefix === "posetool") {
					refresh.draw = (aa.control.posetool === "perspective") !== (suffix === "perspective");
					if(aa.control.posetool === suffix) {
						aa.control.posetool_inversion = !aa.control.posetool_inversion;
					}
					else {
						aa.control.posetool = suffix;
					};
				}
				else if(button === "switch") {
					const ref = aa.pa.part;
					ref.color1 = part.color1;
					ref.color2 = part.color2;
					ref.fill = AAX.getfill(aa.color, aa.currpose, part.name);
					if(aa.control.perspectived) {
					// export only the image of the view you have selected.
						const right = !!(view%2);
						const _old_w = ref.dim(!right)[0];
						// width of the image not being replaced. (need to
						// remember it for changedimensions later.)
						let new_image = structuredClone(part["perspective_" + view]);
						let oddness = part.image_oddness(view);
						ref.size = Math.max(
							AAX.sq_raster.cropsize(ref[!right ? "right" : "front"], [ref.oddness[!right ? 2 : 0], ref.oddness[1]], true),
							// image not being replaced
							AAX.sq_raster.cropsize(new_image, oddness, true)
							// new image
						);
						// expand the size if it's too small for both images to
						// fit and rotate freely
						ref.oddness[right ? 2 : 0] = oddness[0];
						ref.oddness[1] = oddness[1];
						// apply changes to .oddness
						// - NOTE since oddness can be different per view,
						//   exporting multiple perspective views at once could
						//   cause dimensional inconsistencies.
						ref[right ? "right" : "front"] = Raster.redimension(
							new_image,
							//part.dim(view)[0],
							part.dim(view, new_image.length)[0],
							...ref.dim(right)
						);
						ref[!right ? "right" : "front"] = Raster.redimension(
							ref[!right ? "right" : "front"],
							_old_w,
							...ref.dim(!right)
						);
						// make sure both images conform to the new dimensions.
					}
					else {
					// export both unperspectiveds
						ref.front = part.image_front;
						ref.right = part.image_right;
						const old_w = [
							part.dim("front", ref.front.length)[0],
							part.dim("right", ref.right.length)[0]
						];
						ref.oddness = structuredClone(part.oddness);
						ref.size = Math.max(
							AAX.sq_raster.cropsize(ref.front, [ref.oddness[0], ref.oddness[1]], true),
							AAX.sq_raster.cropsize(ref.right, [ref.oddness[2], ref.oddness[1]], true)
						);
						ref.front = Raster.redimension(
							ref.front,
							old_w[0],
							...ref.dim(false)
						);
						ref.right = Raster.redimension(
							ref.right,
							old_w[1],
							...ref.dim(true)
						);
					};
					aa.pa.redraw();
					aa.editmodetoggle();
				}
				else if(button === "switch_no_export") {
					aa.editmodetoggle();
				}
				else if(prefix === "oddify") {
					let part = aa.control.part;
					let axis = suffix;
					if(aa.control.perspectived) {
						if(axis !== "z") {
							const view = aa.control.view;
							let temp = structuredClone(part["perspective_coor_" + view]);
							const index = "xy".indexOf(axis);
							temp[index] = Math.floor(temp[index]) + !(temp[index]%1)*.5;
							// change the oddness of that axis
							part["perspective_coor_" + view] = structuredClone(temp);
							// you have to set both at once, or the setter won't
							// run.
							refresh.states = true;
						};
					}
					else {
						let oddify = part.oddify(axis);
						// new relative coordinates.
						// - looks at the current relative coordinates, changes the
						//   oddness of the specified axis, and returns whatever
						//   relative coordinates are within 1 in each axis to how it
						//   was before, while still fitting in the hypotenuse.
						part.x = oddify[0];
						part.y = oddify[1];
						part.z = oddify[2];
						refresh.states = true;
					}
				}
				else if(prefix === "mirror") {
					let desc = aa.control.part.descendants;
					refresh.states = true;
					for(i1 = -1; i1 < desc.length; i1++) {
						let partname = i1 === -1 ? aa.control.partname : desc[i1];
						if(i1 !== -1) {
							aa.currpose[partname][suffix] *= -1;
						}
						aa.currpose[partname].orient = Quat.mirror[suffix]( aa.currpose[partname].orient );
					}
				}
				else if(prefix === "frame") {
					refresh.states = true;
					if(suffix === "previous" || suffix === "next") {
						aa.currframe = posmod(aa.currframe + (suffix === "previous" ? -1 : suffix === "next" ? 1 : 0), aa.frames.length);
						refresh.states = false;
					}
					else if(suffix === "display") {
						let num = Number(prompt(`which frame do you want to switch to?`)) - 1;
						if(Number.isInteger(num) && num >= 0 && num < aa.frames.length) {
							aa.currframe = num;
						}
						refresh.states = false;
					}
					else if(["blank", "duplicate"].includes(suffix)) {
						aa.frames.splice(aa.currframe + 1, 0, (suffix === "duplicate" ? aa.frameclone(aa.currframe) : aa.newpose()));
						aa.currframe++;
						// splice it into the position after this one, and
						// switch to it.
					}
					else if(suffix === "delete") {
						if(aa.frames.length === 1) {
						// clear the pose instead
							aa.frames.splice(aa.currframe, 1, aa.newpose());
						}
						else {
							aa.frames.splice(aa.currframe, 1);
							aa.currframe--;
						};
					}
					else if(["move_up", "move_down"].includes(suffix)) {
						let newframe = aa.currframe + (suffix === "move_up" ? 1 : suffix === "move_down" ? -1 : 0);
						if(newframe >= 0 && newframe < aa.frames.length) {
							let temp = aa.frames[aa.currframe];
							aa.frames.splice(aa.currframe, 1);
							aa.frames.splice(newframe, 0, temp);
							aa.currframe = newframe;
							refresh.draw = false;
						}
						else {
							no_refresh = true;
						};
					};
					aa.clampframe();
					// make sure it isn't out of bounds.
				}
				else if(prefix === "view") {
					aa.control.view = Number(suffix);
					refresh.draw = false;
				}
				else if(prefix === "misc") {
					if(suffix === "autoperspective") {
						let choice = prompt(`automate perspective for the part, frame, or all frames? (add "(one view)" to only do this for one view.)`);
						if(choice) {
							const one_view = choice.includes("(one view)");
							if(one_view) {
								choice = choice.replace("(one view)", "");
							};
							choice = choice.trim();
							function automate(frame, part, view) {
								if(one_view) {
									aa.frames[frame][part]._perspective.coor[aa.control.view] = "auto";
								}
								else {
									let loop = new Loop("aa.ui.action automate");
									for(let i1 = 0; i1 < 4; i1++) {
										loop.tick(1);
										aa.frames[frame][part]._perspective.coor[i1] = "auto";
									}
									loop.end();
								};
							};
							refresh.states = true;
							if(choice === "part") {
								automate(aa.currframe, aa.control.partname);
							}
							else if(["frame", "all frames"].includes(choice)) {
								for(i1 = 0; i1 < aa.frames.length; i1++) {
									loop.tick(1);
									if(choice === "all frames" || i1 === aa.currframe) {
										for(i2 in aa.currpose) {
											loop.tick(2);
											if(aa.currpose.hasOwnProperty(i2)) {
												automate(i1, i2);
											};
										}
										loop.end();
									};
								}
								loop.end();
							}
							else {
								alert(`invalid choice. it must be "part", "frame", or "all frames".`);
								refresh.states = false;
							};
						}
					}
					else if(suffix === "clearimage") {
						refresh.states = true;
						if(aa.control.perspectived) {
							part._perspective[view] = null;
						}
						else {
							part._image.front = null;
							part._image.right = null;
						};
					}
					else if(suffix === "editshape") {
						let temp = AAX.Shape.string(part.shape);
						document.getElementById("aa_editshape_input").rows = temp.split("\n").length;
						document.getElementById("aa_editshape_input").value = temp;
						document.getElementById("aa_editshape_dialog").showModal();
					}
					else if(suffix === "stretch_widen") {
						refresh.states = true;
						let input = prompt([
							`enter two numbers for stretch/widen, separated by a comma.`,
							`stretch stretches the 3d shape along the line to the part's parent, widen expands it in the other directions.`,
							`enter a single number to set both at once.`,
							`enter a single number with a comma after to only change the stretch, and a number with a comma before to only change widen.`
						].join("\n\n"));
						let valid = input !== null;
						if(valid) {
							input = input.trim();
							if(input.includes(",")) {
								input = input.split(",");
								input = [
									readnumber(input[0]),
									readnumber(input[1])
								];
								if(input[0] === null && input[1] === null) {
									valid = false;
								}
								else {
									if(input[0] !== null) {
										part.stretch = input[0];
									};
									if(input[1] !== null) {
										part.widen = input[1];
									};
								};
							}
							else {
								input = readnumber(input);
								if(input === null) {
									valid = false;
								}
								else {
									part.stretch = input;
									part.widen = input;
								};
							};
						};
						if(!valid) {
							refresh.states = false;
						};
					}
					else if(suffix === "refreshshape") {
						part.clearcache("orientedshape");
						refresh.ui = false;
					}
					else if(suffix === "reset_part" || suffix === "reset_branch") {
						let list = aa.hidelist(aa.control.partname, suffix === "reset_branch" ? "branch" : "part");
						for(i1 = 0; i1 < list.length; i1++) {
							let _i1 = list[i1];
							aa.currpose[_i1] = new AAX.Part(aa, aa.body, aa.currpose, _i1);
						}
						refresh.states = true;
					}
					else if(suffix === "posetoshape") {
						no_refresh = true;
						// all this does is open a <dialog> showing you shape
						// text.
						let scale = prompt("enter a scale factor for the shape. (it can be a fraction.)");
						if(typeof scale === "string") {
							scale = readnumber(scale) ?? 1;
							let shape = AAX.posetoshape(aa.currpose);
							if(scale !== 1) {
								for(i1 = 0; i1 < shape.points.length; i1++) {
									let group = shape.points[i1];
									for(i2 = 0; i2 < group.length; i2++) {
										for(i3 = 0; i3 < Math.min(group[i2].length, 6); i3++) {
											group[i2][i3] *= scale;
										}
									}
								}
							}
							document.getElementById("aa_posetoshape_text").value = AAX.Shape.string(shape);
							document.getElementById("aa_posetoshape_dialog").showModal();
						}
					};
				}
				else if(prefix === "partinfo" && suffix === "name") {
					let hidden = [];
					for(i1 in aa.currpose) {
						loop.tick(1);
						if(aa.currpose.hasOwnProperty(i1) && aa.currpose[i1].hide) {
							hidden[hidden.length] = i1;
						}
					}
					loop.end();
					let select = prompt("enter a part name to select." + (hidden.length ? " (hidden parts: " + hidden.join(", ") + ")" : ""));
					if(aa.currpose.hasOwnProperty(select)) {
						aa.control.partname = select;
						refresh.draw = false;
					}
					else if(select) {
						alert("invalid part name.");
					};
				}
				else if(prefix === "partinfo") {
					const part = aa.control.part;
					const view = aa.control.view;
					let temp = suffix.replaceAll("_", " ");
					if(temp.endsWith("coor")) {
						temp += "dinates";
					};
					if(!aa.partinfo_is_default(part, view, suffix) && confirm("reset " + temp + " to default?")) {
					// reset to default
						if(["hide", "shape"].includes(suffix)) {
							part[suffix] = "default";
						}
						else if(suffix === "coor") {
							part.x = "default";
							part.y = "default";
							part.z = "default";
						}
						else if(suffix === "image") {
							part[suffix + "_front"] = "default";
							part[suffix + "_right"] = "default";
						}
						else if(suffix === "perspective_coor") {
							part["perspective_coor_" + view] = "default";
						}
						else if(suffix === "perspective_image") {
							part["perspective_" + view] = "default";
						}
						else if(suffix === "shape_settings") {
							part.orient = Quat.new();
							part.stretch = 1;
							part.widen = 1;
						}
						else if(!["name", "colors", "silhouette"].includes(suffix)) {
							console.log("this button is unaccounted for in the ui.action partinfo logic.")
						};
						refresh.states = true;
					};
				}
				else if(prefix === "drawsettings") {
					no_refresh = AAX.ui.action.drawsettings(aa.drawsettings, suffix);
					if(!no_refresh && ["fineness", "vp", "range", "camera"].includes(suffix)) {
					// clear the cache
					// - fineness affects the shape, the rest affect
					//   perspective.
						let type = (
							suffix === "fineness"
							?
							"orientedshape"
							// clear .oriented and .rasterize
							:
							"rasterize perspective"
							// clear .rasterize, but only the perspective
							// views.
						);
						for(let i0 = 0; i0 <= aa.states.length; i0++) {
						// for every state,
							let ref = i0 === aa.states.length ? aa.frames : aa.states[i0].poseobjs;
							for(i1 = 0; i1 < ref.length; i1++) {
							// for every frame,
								for(i2 in ref[i1]) {
									if(ref[i1].hasOwnProperty(i2)) {
									// for every body part.
										AAX.clearcache(ref[i1], i2, type);
										// this isn't an AAX.Part, so we
										// can't use the method.
									}
								}
							}
						}
					};
				}
				else if(prefix === "color") {
					no_refresh = AAX.ui.action.color(aa.color, suffix, click, aa.ui.buttons[button]);
				}
				else if(prefix === "states") {
					if(suffix === "undo" || suffix === "redo") {
						// aa.undo();
						// aa.redo();
						aa[suffix]();
					}
					else if(suffix === "limit") {
						no_refresh = true;
						refresh.ui = true;
						let value = prompt([
							`enter new numbers for the states limit and the states truncator, separated by a comma.`,
							`the state limit is how many undo/redo states it can store before it starts deleting the oldest states. you can undo that many times before you hit a wall.`,
							`the state truncator is applied when you switch away from an animation. it trims the states so that this number is the maximum undos and maximum redos kept. (ex: if the truncator is 12, it'll keep a maximum of 12 past states and a maximum of 12 future states, so up to 25 states.)`,
							`if you're having performance issues, lowering these numbers might help. for every animation, there's states, and for every state, there's frames. if you had 3 animations, 8 frames each, and with a limit of 25 and a truncator of 12, that could be 600 poses it has to store.`
						].join(`\n\n`));
						if(value) {
							value = value.split(",");
							for(i1 = 0; i1 < 2; i1++) {
								if(i1 < value.length && value[i1].trim()) {
									let num = Number(value[i1]);
									if(Number.isInteger(num) && num >= Number(!i1)) {
									// needs to be 1 or more if it's the limit,
									// 0 or more if it's the truncator. (can't
									// let the number of states be less than 1.)
										aa["states_" + (i1 ? "truncator" : "limit")] = num;
										no_refresh = false;
									}
								}
							}
						}
					}
					else {
						console.log("this shouldn't happen");
					}
				}
				else if(prefix === "save" || prefix === "load") {
					// aa.save();
					// aa.load();
					aa[prefix]();
				}
				else if(prefix === "hide") {
					const value = !aa.ishidden(aa.control.partname, suffix);
					const array = aa.hidelist(aa.control.partname, suffix);
					for(i1 = 0; i1 < array.length; i1++) {
						loop.tick(1);
						aa.currpose[ array[i1] ].hide = value;
					};
					loop.end();
					refresh.states = true;
				}
				else if(prefix === "inbetween") {
					refresh.draw = false;
					// only create affects the pose, and nothing else affects
					// the visuals like drawsettings.
					let ref = aa.control.inbetween;
					if(suffix === "add") {
						ref.number++;
					}
					else if(suffix === "subtract") {
						if(ref.number >= 2) {
							ref.number--;
						}
						else {
							no_refresh = true;
						}
					}
					else if(suffix === "number") {
						let num = prompt(`enter how many inbetweens to make.`);
						if(num === null) {
							no_refresh = true;
						}
						else {
							num = Number(num);
							if(Number.isInteger(num) && num >= 1) {
								ref.number = num;
							}
							else {
								alert(`invalid number. must be an integer greater than zero.`);
								no_refresh = true;
							};
						}
					}
					else if(suffix === "curve") {
						let num = prompt(`enter the curve factor. (2 is like square easing, 3 is like cubic, etc. look up stuff about easing. the default value is the square root of 3, which makes it very close to a sine curve.)`);
						if(num === null) {
							no_refresh = true;
						}
						else {
							num = Number(num);
							if(Number.isInteger(Math.round(num))) {
								ref.curve = num;
							}
							else {
								alert(`invalid number.`);
								no_refresh = true;
							};
						}
					}
					else if(suffix === "easeA" || suffix === "easeB") {
						ref[suffix] = !ref[suffix];
						if(suffix === "easeA") {
						// this makes a weird sort of sense.
							ref.easeB = !ref.easeB;
						}
					}
					else if(suffix === "create" || suffix === "apply") {
						refresh.draw = true;
						refresh.states = true;
						const apply = suffix === "apply";
						let values = aa.control.inbetween.values;
						if(apply && aa.frames.length < values.length + 2) {
							alert(`not counting the start and end frame, there's ` + (aa.frames.length - 2) + ` frames, but you're trying to apply tweening to ` + values.length + ` frames.`);
							no_refresh = true;
						}
						else {
							AAX.inbetweening(aa, aa.body, aa.frames, aa.currframe, values, apply);
							//aa.currframe++;
							// switch to the first inbetween.
							aa.currframe = posmod(aa.currframe + values.length + 1, aa.frames.length);
							// switch to the end pose.
						}
					}
					else {
						no_refresh = true;
					}
				}
				else if(button === "projectname") {
					let name = prompt(`enter a name for the project.\n\nif you type an asterisk anywhere, it'll be replaced by the current date.`);
					if(name) {
						aa.control.projectname = name.replaceAll("*", filedate());
					}
					else {
						no_refresh = true;
					};
				}
				else if(prefix === "anim") {
					if(suffix === "menu") {
						let ref = aa.ui.buttons[button];
						let tabwidth = Math.min(aa.ui.animtabwidth*AAX.ui.block, ref.w/aa.anims.length);
						let index = Math.floor((click[0] - ref.x)/tabwidth);
						if(index === aa.anim_index) {
						// rename the animation
							let name = prompt(`enter a name for the animation.`);
							if(name === null) {
								no_refresh = true;
							}
							else {
								aa.curranim.name = name;
							};
						}
						else if(index >= 0 && index < aa.anims.length) {
							aa.anim_index = index;
						}
						else {
							no_refresh = true;
						};
					}
					else if(suffix === "blank") {
						aa.anims.splice(aa.anim_index + 1, 0, aa.newanim());
						aa.anim_index++;
					}
					else if(suffix === "duplicate") {
						aa.anims.splice(aa.anim_index + 1, 0, structuredClone(aa.curranim));
						let prevanim = aa.curranim;
						aa.anim_index++;
						aa.curranim.name = prevanim.name ? prevanim.name + " - copy" : "";
						// it's fine if names are shared.
						aa.curranim.states = [structuredClone(prevanim.states[prevanim.state_index])];
						aa.curranim.state_index = 0;
						// keep only the current state
					}
					else if(suffix === "delete") {
						if(aa.anims.length > 1 && confirm(`deleting animations cannot be undone/redone. are you sure?`)) {
							let old = aa.anim_index;
							let islast = old === aa.anims.length - 1;
							aa.anim_index = islast ? aa.anims.length - 2 : aa.anim_index + 1;
							// trigger the setter
							aa.anims.splice(old, 1);
							// delete the old animation
							if(old <= aa.anim_index) {
							// decrement the index, but be sneaky about it.
								aa._anim_index--;
							}
						}
						else {
							no_refresh = true;
						}
					}
				}
				else if(prefix === "rotate") {
					if(suffix === "invert" || suffix === "switch" || suffix === "display") {
					// headings/visuals
						no_refresh = true;
					}
					else if(suffix === "round") {
						let num = prompt("enter a new rounding factor for the rotate and tilt pose tools.\n\nif it's 72, angle magnitudes will be rounded to the nearest 360/72 degrees.\n\n0 will make it so there's no rounding at all.") ?? "";
						no_refresh = true;
						if(num) {
							num = Number(num);
							if(Number.isInteger(num) && num >= 0) {
								aa.control[prefix][suffix] = num;
								no_refresh = false;
							};
						};
					}
					else if(suffix === "type") {
						let array = AAX.valid[button];
						aa.control[prefix][suffix] = array[(array.indexOf(aa.control[prefix][suffix]) + 1)%array.length];
					}
					else if(suffix === "curl") {
						aa.control[prefix][suffix] = !aa.control[prefix][suffix];
					}
					else if(aa.control[prefix].type === "custom") {
						let basis = aa.control.rotate.basis;
						if(suffix.startsWith("select_")) {
							aa.control[prefix].select = "xyz".indexOf(suffix.slice("select_".length));
						}
						else if(suffix.startsWith("invert_")) {
							let axis = "xyz".indexOf(suffix.slice("invert_".length));
							basis[axis] = Points.invert(basis[axis]);
						}
						else if(suffix.startsWith("switch_")) {
							let temp = suffix.slice("switch_".length).split("_");
							let axis1 = "xyz".indexOf(temp[0]);
							let axis2 = "xyz".indexOf(temp[1]);
							temp = structuredClone(basis[axis1]);
							basis[axis1] = structuredClone(basis[axis2]);
							basis[axis2] = structuredClone(temp);
						}
						else if(
							AAX.valid.rotate_axis_setters.includes(suffix)
							&&
							!AAX.ui.rotate_axis_setter_disabled(aa.currpose, part.name, basis, aa.control.rotate.select, suffix)
						) {
							let point = [0, 0, 0];
							let axis = aa.control.rotate.select;
							if(suffix === "parent") {
								point = Points.normalized(Points.invert(part.relcoor));
							}
							else if(suffix === "child") {
								let child = AAX.getchildren(aa.currpose, part.name)[0];
								point = Points.normalized(aa.currpose[child].relcoor);
							}
							else if(suffix === "cross") {
								point = Points.normalized(Points.cross(
									basis[posmod(axis + 1, 3)],
									basis[posmod(axis + 2, 3)]
								));
							}
							else if(suffix === "true") {
								point[axis] = 1;
							}
							else if(suffix === "local") {
								point[axis] = (part.bodyref.mirror && axis === 0) ? -1 : 1;
								// the -1 thing mimics how the local mode of the
								// rotate tool works.
								point = Quat.apply(part.orient, point);
							}
							else if(suffix === "written") {
								point = prompt("enter a new axis. three coordinates, separated by commas or spaces. it'll use the angle that has, relative to (0, 0, 0).\n\ncurrent:\n\t" + basis[axis].join(",\n\t")) ?? "";
								point = trimunspecial(point.replaceAll(",", " ")).split(" ");
								if(point.length >= 3) {
									for(i1 = 0; i1 < 3; i1++) {
										point[i1] = Number(point[i1]);
										if(isNaN(point[i1]) || point[i1] === Infinity || point[i1] === -Infinity) {
											point[i1] = 0;
										};
									}
									point = Points.normalized(point.slice(0, 3));
								}
								else {
									point = null;
								};
							}
							//
							if(point && Math.hypot(...point)) {
								basis[axis] = structuredClone(point);
							}
							else {
								if(suffix !== "written") {
									console.log("this shouldn't happen");
								};
								no_refresh = true;
							};
							//
							if(!no_refresh) {
								aa.control.rotate.select = posmod(aa.control.rotate.select + 1, 3);
							};
						};
					}
					else {
						no_refresh = true;
					}
				}
				else if(prefix === "px") {
					if(AAX.valid.px_export.includes(suffix)) {
						aa.control.px_export = suffix;
					}
					else if(suffix === "one_view" || suffix === "vertical") {
					// duplicates of the animator checkboxes.
						aa.animator.html[suffix].click();
					}
					else {
						changefocus("px");
						// switch first, to make sure it's initialized
						let type = aa.control.px_export;
						let replace = suffix === "replace";
						let ds = aa.drawsettings;
						let cell = ds.cell;
						let sheet = aa.animator.sheet_ctx;
						let images = [];
						// each item is an ImageData, representing an animation.
						let canvas = document.createElement("canvas");
						let ctx = canvas.getContext("2d");
						if(type === "frame") {
						// export the canvas
							let one = aa.animator.html.one_view.checked;
							if(one || aa.animator.html.vertical.checked) {
								images.push(aa.ctx.main.getImageData((one ? aa.control.view : 0)*cell.w, 0, (one ? 1 : 4)*cell.w, cell.h));
							}
							else {
							// line up the views vertically
								canvas.width = cell.w;
								canvas.height = 4*cell.h;
								for(i2 = 0; i2 < 4; i2++) {
									ctx.putImageData(
										aa.ctx.main.getImageData(i2*cell.w, 0, cell.w, cell.h),
										0, i2*cell.h
									);
								}
								images.push(ctx.getImageData(0, 0, cell.w, 4*cell.h));
							}
						}
						else if(type === "anim") {
						// update the animation sheet, and export that
							aa.updateanimation(true);
							images.push(sheet.getImageData(0, 0, sheet.canvas.width, sheet.canvas.height));
						}
						else if(type === "all_x" || type === "all_y") {
						// export every animation, with borders and names.
						// - the borders and names are drawn in whatever px'
						//   current forecolor is.
						// - the borders and names stay outside the frames
						// - the margins and the gaps between animations match
						//   whatever px.grid currently is. that way, there's
						//   clear separation between them, and if the user uses
						//   grid snap with the paste tool, the top left corners
						//   of the canvases will be placed right on the grid.
						//   - unless if the cell dimensions aren't divisible by
						//     the grid dimensions, but that's weird anyway.
						// - there's little gaps in the border that show the
						//   boundaries between views or frames.
							for(i1 = 0; i1 < aa.anims.length; i1++) {
								images.push(null);
							}
							let truncator = aa.states_truncator;
							aa.states_truncator = Infinity;
							// this should avoid truncating the current
							// animation's states.
							let anim_index = aa.anim_index;
							let posetool = aa.control._posetool;
				            for(i1 = 0; i1 < aa.anims.length; i1++) {
								let _i1 = posmod(anim_index + 1 + i1, aa.anims.length);
								// end with the animation it was at before. that
								// way there's no wasteful updateanimation
								// runnings.
								aa.anim_index = _i1;
								aa.control._posetool = posetool;
								// the anim_index setter loads the animation's
								// current state, which includes what pose tool
								// was selected. that sounds completely
								// unrelated, except, perspective.
								aa.updateanimation(true);
								images[_i1] = sheet.getImageData(0, 0, sheet.canvas.width, sheet.canvas.height);
							}
							aa.states_truncator = truncator;
						};
						// gather up the images
						const grid = 8;
						let dim = [0, 0];
						let axis1 = Number(type === "all_y");
						let axis2 = posmod(axis1 + 1, 2);
						for(i1 = 0; i1 < images.length; i1++) {
							let _dim = [images[i1].width, images[i1].height];
							_dim = [
								Math.ceil(_dim[0]/grid)*grid,
								Math.ceil(_dim[1]/grid)*grid
							];
							dim[axis1] += _dim[axis1];
							dim[axis2] = Math.max(dim[axis2], _dim[axis2]);
						};
						dim[axis1] += (1 + images.length)*grid;
						dim[axis2] += 2*grid;
						canvas.width = dim[0];
						canvas.height = dim[1];
						ctx.clearRect(0, 0, ...dim);
						if(replace) {
							ctx.fillStyle = px.backcolor;
							ctx.fillRect(0, 0, ...dim);
						}
						ctx.fillStyle = px.forecolor;
						ctx.textBaseline = "alphabetic";
						ctx.font = "6px 'thick 4x4'";
						let pos = [grid, grid];
						let standpoint = aa.control.perspectived ? ds.perspectived_standpoint : ds.standpoint;
						for(i1 = 0; i1 < images.length; i1++) {
							let _dim = [images[i1].width, images[i1].height];
							let rect = Rect.new(...pos, ..._dim);
							_dim = [
								Math.ceil(_dim[0]/grid)*grid,
								Math.ceil(_dim[1]/grid)*grid
							];
							ctx.putImageData(images[i1], ...pos);
							for(i2 = rect.x; i2 + cell.w <= rect.x + rect.w; i2 += cell.w) {
								ctx.fillRect(i2 + 1, rect.y - 1, cell.w - 2, 1);
								ctx.fillRect(i2 + 1, rect.y + rect.h, cell.w - 2, 1);
								// draw top and bottom borders
								ctx.fillRect(i2 + standpoint.x, rect.y - 1 - 1, 1, 1);
								ctx.fillRect(i2 + standpoint.x, rect.y + rect.h + 1, 1, 1);
								// mark standpoint x
							}
							for(i2 = rect.y; i2 + cell.h <= rect.y + rect.h; i2 += cell.h) {
								ctx.fillRect(rect.x - 1, i2 + 1, 1, cell.h - 2);
								ctx.fillRect(rect.x + rect.w, i2 + 1, 1, cell.h - 2);
								// draw left and right borders
								ctx.fillRect(rect.x - 1 - 1, i2 + standpoint.y, 1, 1);
								ctx.fillRect(rect.x + rect.w + 1, i2 + standpoint.y, 1, 1);
								// mark standpoint y
							}
							if(type.startsWith("all") && aa.anims[i1].name) {
							// write the name
								ctx.fillText(aa.anims[i1].name, rect.x, rect.y - 2);
							}
							pos[axis1] += _dim[axis1] + grid;
						};
						// form it into a spritesheet
						px.transfer(ctx, replace);
						if(replace) {
							px.select = Rect.new(grid, grid, cell.w, cell.h);
						};
						px.html.anim_fps.value = aa.animator.fps;
						px.html.anim_duration.value = aa.animator.frames.length;
						px.html.anim_loop.checked = aa.animator.loop;
						px.html.anim_wrap.value = aa.animator.sheet.wrap.value;
						px.html.anim_vertical.checked = aa.animator.html.vertical.checked;
						no_refresh = true;
						// send it, edit px' select and animation settings to
						// match it
					}
				};
				let depress = (
					suffix === "heading" ? false :
					prefix === "states" ? (suffix === "undo" || suffix === "redo") :
					prefix === "px" ? !AAX.valid.px_export.includes(suffix) :
					no_refresh ? false :
					prefix === "switch" ? true :
					prefix === "frame" ? suffix !== "display" :
					prefix === "inbetween" ? (suffix === "add" || suffix === "subtract" || suffix === "create" || suffix === "apply") :
					(button === "save" || button === "load") ? true :
					prefix === "misc" ? (suffix !== "autoperspective" && suffix !== "stretch_widen" && suffix !== "posetoshape") :
					prefix === "anim" ? (suffix === "blank" || suffix === "duplicate" || suffix === "delete") :
					prefix === "rotate" ? (
						(AAX.valid.rotate_axis_setters.includes(suffix) && suffix !== "written")
						||
						suffix.startsWith("invert_")
						||
						suffix.startsWith("switch_")
					) :
					prefix === "mirror" ? true :
					false
				);
				// boolean for whether to animate it being depressed.
				// - there aren't actually a lot of buttons worth depressing.
				//   most buttons are toggles, prompts, stuff like that.
				if(depress) {
				// it'll get redrawn for the depressing, so the other refresh
				// would just be redundant.
					refresh.ui = false;
				}
				let temp = [];
				for(i1 in refresh) {
					loop.tick(1);
					if(refresh.hasOwnProperty(i1) && !refresh[i1]) {
						temp[temp.length] = i1;
					}
				}
				loop.end();
				// now it's an array of what to skip.
				if(!no_refresh) {
					aa.refresh(temp);
				}
				if(depress) {
					aa.ui.draw(button);
					// draw the button depressed
					setTimeout(function() {aa.ui.draw()}, 1000*AAX.ui.depress);
					// draw it undepressed after a little bit.
				}
			},
			mousedown: function(e, doubleclick) {
			// searches the buttons for where your click was, and runs .action.
				let i1 = 0;
				let click = clickxy(e, "aa");
				aa.control.clicktype = "ui";
				let buttons = aa.ui.buttons;
				for(i1 in buttons) {
					if(buttons.hasOwnProperty(i1)) {
						let ref = buttons[i1];
						if(
							click[0] >= ref.x
							&&
							click[0] < ref.x + ref.w
							&&
							click[1] >= ref.y
							&&
							click[1] < ref.y + ref.h
						) {
							aa.ui.action(i1, doubleclick, false, click);
							aa.control.clicktype = null;
							return;
						};
					};
				}
				aa.control.clicktype = null;
			},
		},
		control: {
		// stores various data that changes based on what you're trying to do,
		// like which node you have selected and which posing tool you're using.
			view: 0,
			partname: "",
			// this CANNOT be left empty, everything in the interactivity and
			// part-editing buttons uses it. .initialize will set it.
			get part() {
				return aa.currpose[this.partname];
			},
			get node() {
				return aa.getnode(this.view, this.partname);
			},
			// don't use this too much, obviously. run it at the start of the
			// function, don't use it multiple times in one expression
			get perspectived() {
				return aa.control.posetool === "perspective";
			},
			// boolean for whether .draw should draw it perspectived or
			// unperspectived.
			// - a getter is easier to edit. i don't know when i might change
			//   the conditions of perspectived imaging.
			_posetool: "rotate",
			posetool_inversion: false,
			// a boolean for an alternate mode for each pose tool. selecting the
			// pose tool you already have selected toggles this, and switching
			// pose tools turns it off.
			// - it used to be a double-click, but those don't work on mobile.
			//   or maybe they do and it's just a pain in the ass.
			get posetool() {
				return this._posetool;
			},
			set posetool(value) {
				if(this._posetool === value) {
					this.posetool_inversion = false;
					return;
				};
				if(!AAX.valid.posetools.includes(value)) {
					console.log("this shouldn't happen");
					value = AAX.valid.posetools[0];
				};
				this._posetool = value;
				this.posetool_inversion = false;
			},
			moveaway: false,
			// boolean for if the third axis should be whatever sign moves
			// things away from the screen rather than towards it.
			partclicked: false,
			// boolean for whether the user's mousedown actually clicked a part
			// or not
			// - i can't just check if the node is null, because the last
			//   clicked node is stored between clicks so the buttons know what
			//   to edit.
			strokedata: null,
			// stores mid-stroke data, like the starting angle for rotate.
			clicktype: null,
			// used to tell if mouse events should trigger. (it's like a boolean
			// for whether they're in the middle of a click. except i have to
			// specify whether it's the main area or the ui, or ui clicks could
			// register for main and vice versa.)
			all_frames_posetext: false,
			// boolean for whether pose text input and output shows all frames.
			activeonly_cache: true,
			// boolean that makes it clear the part caches in an animation when
			// switching away from it.
			editmode: false,
			// boolean for whether the part artist should be visible instead of
			// the multiview.
			strokecache: null,
			// stores images for each part/view. this is filled at mousedown and
			// cleared at mouseup.
			// - this wouldn't actually be necessary if not for shapes.
			//   Part.rasterize is too slow to run every mousemove.
			// =
			// - [parts]
			//   - front, right (or 0-3 numbers if it's in perspective mode):
			//     images
			inbetween: {
				number: 3,
				curve: Math.sqrt(3),
				// a good approximation of a sine curve.
				easeA: false,
				easeB: false,
				// false means in, true means out.
				values: [.5],
				// this stores the values generated during aa.ui.draw for the
				// visualization.
				// - ...it sounds weird, but it's useful for the negative curve
				//   thing, where the easing has randomness to it
				// - the default value should never be used, but just in case, i
				//   want one value in there. (aa.currframe ticks up one when
				//   create inbetween is used. if there's no values, there's no
				//   inbetweens, so currframe could end up out of bounds.)
			},
			projectname: "untitled",
			rotate: {
				round: 72,
				type: "true",
				curl: false,
				select: 0,
				basis: Basis.new(),
			},
			px_export: AAX.valid.px_export[0],
		},
		get oddify_deform() {
			return aa.control.posetool === "deform";
		},
		// used in AAX.oddify.
		nodes: [[], [], [], []],
		// screen positions and names of all the parts, divided up by view.
		// they're ordered by z, with the further parts being first.
		// - structure:
		//   - x, y, z: screen coordinates. x includes view offset, and x and y
		//     include perspective offset if the multiview was drawn in
		//     perspective.
		//   - name: part name string
		//   - parent: reference to the parent's node, or if it's standpoint,
		//     just a "standpoint" string.
		// - iterate in order when drawing parts using this, iterate backward
		//   when checking which node the user clicked.
		images: null,
		// an object of ImageDatas, which the interface uses to correct overflow
		// or reverse the changes it made.
		pasteimages: function(invert, view) {
		// - invert === false: paste the image for the specified view.
		//   (reverses changes.)
		// - invert === true: paste all images except the one for the specified
		//   view. (corrects overflow.)
			view ??= aa.control.view;
			const ctx = aa.ctx.main;
			const cell = aa.drawsettings.cell;
			let i1 = 0;
			let loop = new Loop("aa.pasteimages");
			for(i1 = 0; i1 < 4; i1++) {
				loop.tick(1);
				if(invertboolean(i1 === view, invert)) {
					ctx.putImageData(aa.images[i1], cell.w*i1, 0);
				};
			}
			loop.end();
		},
		nodecheck: function(click, view) {
			let i1 = 0;
			let loop = new Loop("aa.nodecheck");
			for(i1 = aa.nodes[view].length - 1; i1 >= 0; i1--) {
			// search backwards, so it finds the closer nodes first.
				loop.tick(1);
				let node = aa.nodes[view][i1];
				let hypot = Math.hypot(
					node.x - click[0],
					node.y - click[1]
				);
				if(hypot < AAX.noderadius + .5 && (!aa.currpose[node.name].hide || !aa.drawsettings.total_hide)) {
				// if the part is hidden and total hide is on, don't allow the
				// node to be selected or clicked.
					return node;
				};
			}
			loop.end();
			return null;
		},
		getnode: (view, name) => AAX.getnode(aa.nodes, view, name),
		xz_radius: () => Math.floor((aa.drawsettings.cell.w - 2*AAX.noderadius)/4),
		// returns the radius used to calculate angle in inverted rotate mode.
		// (ie xz rotation)
		xz_angle: function(click, view) {
		// used in the xz rotate mode.
			const r = aa.xz_radius();
			let acos = (cos) => (
				false
				?
				Math.acos(cos)
				:
				(1 - cos)*Math.PI/2
			);
			// make it true, and it'll do the acos stuff. make it false, and
			// it'll be a linear relationship between x position and angle. the
			// former is harder to control in practice.
			if(r) {
				const center = aa.control.node.x;
				let cos = (click[0] - center)/r;
				// Math.cos of the angle.
				if(view === 1 || view === 2) {
					//cos *= -1;
				};
				// 4-3-2-1-0-1-2-3-4
				// d r u l d r u l d
				cos = posmod(cos + 1, 4) - 1;
				// 1-0-1-2-3
				// l d r u l
				if(cos >= 1) {
					cos = (cos - 1)*(-1) + 1;
					cos = 2*Math.PI - acos(cos);
				}
				else {
					cos = acos(cos);
				};
				return cos;
			}
			else {
				return 0;
				// always return the same angle, so that the relative angle is
				// always 0 too.
			}
		},
		mousedown: function(e) {
			let i1 = 0;
			let i2 = 0;
			let click = clickxy(e, "aa");
			const cell = aa.drawsettings.cell;
			const view = Math.floor(click[0]/cell.w);
			aa.control.view = view;
			let node = aa.nodecheck(click, view);
			aa.control.partclicked = node !== null;
			if(aa.control.partclicked) {
				aa.control.partname = node.name;
			}
			else {
				node = aa.control.node;
			};
			if((aa.control.posetool === "tilt" || aa.control.posetool === "rotate") && !aa.control.partclicked) {
			// if it's rotate mode and they didn't click a part, save the angle.
			// (when you click a part, it acts like select mode. otherwise, it
			// rotates based on the start and end angle.)
				let angle = null;
				if(aa.control.posetool_inversion) {
					let r = aa.xz_radius();
					let center = node.x;
					const ctx = aa.ctx.main;
					ctx.strokeStyle = aa.color.interface[0];
					linespecial(
						ctx,
						center - r,
						0,
						center - r,
						ctx.canvas.height,
						[node.x, node.y]
					);
					linespecial(
						ctx,
						center + r,
						0,
						center + r,
						ctx.canvas.height,
						[node.x, node.y]
					);
					angle = aa.xz_angle(click, view);
				}
				else {
					angle = get2dangle(([2, 3].includes(view) ? -1 : 1)*(click[0] - node.x), click[1] - node.y, true) ?? 0;
				}
				aa.control.strokedata = angle;
			};
			aa.control.strokecache = {};
			for(i1 in aa.currpose) {
				if(aa.currpose.hasOwnProperty(i1)) {
					let _part = aa.currpose[i1];
					aa.control.strokecache[i1] = (
						aa.control.perspectived
						?
						{
							0: _part.perspective_0,
							1: _part.perspective_1,
							2: _part.perspective_2,
							3: _part.perspective_3,
						}
						:
						{
							front: _part.image_front,
							right: _part.image_right,
						}
					);
					let ref = aa.control.strokecache[i1];
					for(i2 in ref) {
						if(ref.hasOwnProperty(i2)) {
							ref[i2] = AAX.sq_raster.fill(ref[i2], _part.dim(i2, ref[i2].length)[0]);
							//ref[i2] = AAX.sq_raster.fill(ref[i2], _part.dim(i2, ref[i2].length)[0]);
						}
					}
				}
			}
			// fill strokecache (lets it reuse images so it doesn't run rasterize
			// every mousemove)
			aa.control.clicktype = "main";
		},
		mousemove: function(e, finish) {
		// - finish: boolean used in mouseup. means it should enact the changes
		//   it's calculating. that happens here because it already has to do a
		//   lot of the math to visualize things.
			let i1 = 0;
			let i2 = 0;
			let click = clickxy(e);
			let no_refresh = false;
			const ctx = aa.ctx.main;
			const cell = aa.drawsettings.cell;
			const view = (aa.control.clicktype === "main" ? aa.control.view : Math.floor(click[0]/cell.w));
			if(![0, 1, 2, 3].includes(view)) {
				return;
			};
			const coor = aa.coorfromcanvas(click[0], click[1], view);
			let part_select = (
				(
					aa.control.posetool === "tilt"
					||
					aa.control.posetool === "rotate"
					||
					(aa.control.posetool === "perspective" && aa.control.posetool_inversion)
				)
				?
				aa.nodecheck(click, view)
				:
				null
			);
			part_select = part_select && part_select.name !== aa.control.partname ? part_select.name : null;
			if([0, 1, 2, 3].includes(view)) {
			// draw coordinates
			// - unless it's perspectived, ie coorfromcanvas doesn't really make
			//   sense
			// - or code for move, deform, or perspective will be run, which
			//   draws relative coordinates instead
			// - the conditional is here for really dumb reasons. if you hover
			//   over the right edges, the view can be calculated as 4.
				let text = [
					"",
					"xz"[view%2] + ": " + coor["xz"[view%2]],
					"y: " + coor.y
				];
				if(aa.control.perspectived) {
					text[1] = "";
					text[2] = "";
				};
				// coorfromcanvas doesn't work for perspective mode, and that
				// wouldn't make sense anyway.
				if(aa.control.clicktype !== "main" || part_select) {
					let node = aa.nodecheck(click, view);
					aa.pasteimages(false);
					aa.pasteimages(true);
					if(node !== null) {
						//aa.control.view = view;
						//aa.ui.draw();
						text[0] = node.name;
						// display the name
						node = AAX.noderect(node.x, node.y);
						ctx.strokeStyle = aa.color.interface[0];
						ctx.fillStyle = aa.color.interface[1];
						ctx.strokeRect(node.x - .5, node.y - .5, node.w + 1, node.h + 1);
						ctx.fillRect(node.x, node.y, node.w, node.h);
						aa.pasteimages(true, view);
					}
					// you can make this slightly less wasteful at the cost of
					// making it select nodes, by deleting the
					// aa.pasteimages(true) command and un-commenting the lines
					// that set aa.control.view and run aa.ui.draw.
					// - actually, running aa.ui.draw needlessly is more
					//   wasteful. whatever.
				};
				aa.writecoordinates(text);
			};
			if(aa.control.clicktype !== "main") {
				return;
			};
			//
			if(part_select) {
			// tilt/rotate should allow node selection on mouseup, and visualize
			// it. that gives much more visual feedback, and therefore
			// precision.
				if(finish) {
					aa.control.partname = part_select;
					//
					aa.control.strokecache = null;
					aa.control.clicktype = null;
					aa.control.strokedata = null;
					aa.refresh(["draw", "states"]);
					aa.writecoordinates(null);
				};
				return;
			};
			//
			aa.pasteimages(false);
			aa.writecoordinates(null);
			ctx.strokeStyle = aa.color.interface[0];
			ctx.fillStyle = aa.color.interface[1];
			const mode = (
				aa.control.posetool === "move" && aa.control.part.parent === "standpoint"
				?
				"deform"
				:
				aa.control.posetool
			);
			const inversion = aa.control.posetool_inversion;
			const node = aa.control.node;
			const part = aa.control.part;
			let parent_node = node.parent;
			if(node.parent === "standpoint") {
				parent_node = aa.coortocanvas([0, 0, 0], view, true, true);
				parent_node = {
					x: parent_node[0],
					y: parent_node[1],
					name: parent,
				};
			};
			// a node-like object for standpoint, or the .parent reference.
			const parent_part = (node.parent === "standpoint" ? null : aa.currpose[ parent_node.name ]);
			if(aa.control.partclicked) {
			// don't do anything if this is false
				const parent_abs = (
					node.parent === "standpoint"
					?
					[0, 0, 0]
					:
					parent_part.abscoor
				);
				const oddness = part.oddness;
				let relcoor = part.relcoor;
				const floats = [
					posmod(relcoor[0], 1),
					posmod(relcoor[1], 1),
					posmod(relcoor[2], 1)
				];
				if(view%2) {
					relcoor[2] = coor.z + oddness[2]/2 - parent_abs[2];
				}
				else {
					relcoor[0] = coor.x + oddness[0]/2 - parent_abs[0];
				}
				relcoor[1] = coor.y + oddness[1]/2 - parent_abs[1];
				// add oddness so it retains the same floats, subtract parent.
				relcoor = [
					Math.round(relcoor[0]*2)/2,
					Math.round(relcoor[1]*2)/2,
					Math.round(relcoor[2]*2)/2
				];
				// make sure nothing's infinitesimally close to a .0/.5
				const float_check = [
					posmod(relcoor[0], 1) === floats[0],
					posmod(relcoor[1], 1) === floats[1],
					posmod(relcoor[2], 1) === floats[2]
				];
				if(float_check.includes(false)) {
					console.log([
						"new oddness doesn't match old oddness.",
						floats,
						[
							posmod(relcoor[0], 1),
							posmod(relcoor[1], 1),
							posmod(relcoor[2], 1)
						]
					].join(String.fromCharCode(10)));
					if(finish) {
						aa.control.clicktype = null;
						aa.control.strokedata = null;
						aa.pasteimages(false);
						aa.writecoordinates(null);
					};
					return;
				};
				const hypot = aa.hypot(part.name, mode === "move" && inversion);
				// use the altered hypotenuse in inverted move mode.
				if(["move", "deform"].includes(mode)) {
				// draw circles, to show its range and where the fulcrum is
					circledraw(ctx, parent_node.x, parent_node.y, Math.floor(hypot));
					let temp = ctx.fillStyle;
					ctx.fillStyle = ctx.strokeStyle;
					circledraw(ctx, parent_node.x, parent_node.y, AAX.noderadius, true);
					ctx.fillStyle = temp;
				};
				if(mode === "deform") {
					let rect = {
						x: Math[([1, 2].includes(view) ? "ceil" : "floor")](parent_node.x) + .5,
						y: Math[([1, 2].includes(view) ? "ceil" : "floor")](parent_node.y) + .5,
						// floor/ceil it so it's what the coortocanvas would be
						// without floats, and add .5 so it's in the center of
						// the pixels.
						w: ([1, 2].includes(view) ? -1 : 1)*Math.trunc(relcoor[view%2 ? 2 : 0]),
						h: Math.trunc(relcoor[1]),
					};
					ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
					aa.writecoordinates(relcoor);
				}
				else if(mode === "move") {
					aa.nodeline(
						ctx,
						parent_node.x, parent_node.y,
						click[0] + ([1, 2].includes(view) ? -1 : 1)*floats[0], click[1] + floats[1],
						view,
						true
					);
					let sign3 = (
						invertboolean([2, 3].includes(view), aa.control.moveaway)
						?
						-1
						:
						1
					);
					relcoor = aa.movecoor(part, hypot, relcoor[view%2 ? 2 : 0], relcoor[1], sign3, "xz"[view%2] + "y");
					aa.writecoordinates(relcoor);
				}
				else if(mode === "perspective" && !inversion) {
					const unperspective_coor = aa.coortocanvas(part.abscoor, view, true, true);
					// unperspectived canvas coordinates.
					const rotated_coor = aa.coortocanvas(
						AAX.camerarotations(part.abscoor, null, aa.drawsettings.camera.xz, aa.drawsettings.camera.yz, "same floats"),
						view, true, true
					);
					// perspective lines are drawn from the rotated coordinates,
					// so that it resembles a line to the vanishing point.
					// - view is null because coortocanvas doesn't expect the
					//   view number rotation.
					const old_coor = part["perspective_coor_" + view];
					relcoor = [
						click[0] - unperspective_coor[0] + posmod(unperspective_coor[0] + old_coor[0], 1),
						click[1] - unperspective_coor[1] + posmod(unperspective_coor[1] + old_coor[1], 1)
					];
					ctx.strokeStyle = aa.color.perspective;
					aa.nodeline(ctx, ...rotated_coor, ...click, view, true);
					aa.writecoordinates([
						part.name,
						"screen x: " + (relcoor[0] > 0 ? "+" : relcoor[0] === 0 ? " " : "") + relcoor[0],
						"screen y: " + (relcoor[1] > 0 ? "+" : relcoor[1] === 0 ? " " : "") + relcoor[1]
					]);
				};
				// no logic for select mode because it doesn't do anything.
				// (rotate mode acts like select mode if a part was clicked.)
				if(finish) {
					if(["move", "deform"].includes(mode)) {
						if(mode === "deform" && inversion) {
							let change = [
								Math.trunc(relcoor[0] - part.x),
								Math.trunc(relcoor[1] - part.y),
								Math.trunc(relcoor[2] - part.z)
							];
							// these should all be integers to begin with, but.
							let children = AAX.getchildren(aa.currpose, part.name);
							for(i1 = 0; i1 < children.length; i1++) {
								let ref = aa.currpose[ children[i1] ];
								ref.x -= change[0];
								ref.y -= change[1];
								ref.z -= change[2];
							};
							// apply an inverse change to all children, so that they
							// stay in place.
						}
						part.x = relcoor[0];
						part.y = relcoor[1];
						part.z = relcoor[2];
						// descendants will follow, since it's relative.
					}
					else if(mode === "perspective" && !inversion) {
						part["perspective_coor_" + view] = structuredClone(relcoor);
					}
				};
			}
			else if(mode === "tilt" || mode === "rotate") {
				let angle = null;
				let axis = view%2 ? 0 : 2;
				// yz = x axis
				// xy = z axis
				if(inversion) {
					axis = 1;
					// inverted = y axis
					angle = aa.xz_angle(click, view);
				}
				else {
					angle = get2dangle(([2, 3].includes(view) ? -1 : 1)*(click[0] - node.x), click[1] - node.y, true) ?? 0;
				};
				angle = posmod(angle - aa.control.strokedata, 2*Math.PI);
				// now it's a relative angle instead of absolute
				const round = aa.control.rotate.round;
				if(round) {
					angle /= 2*Math.PI;
					angle = Math.round(angle*round)/round;
					angle *= 2*Math.PI;
				}
				let _angle = roundspecial(Angle.convert(angle));
				_angle -= _angle > 180 ? 360 : 0;
				_angle = {
					sign: _angle < 0 ? "-" : _angle > 0 ? "+" : "&#160;",
					num: Math.abs(_angle),
				};
				_angle = _angle.sign + "&#160;".repeat(3 - (_angle.num + "").length) + _angle.num;
				aa.writecoordinates(_angle + " " + ["yz", "xz", "xy"][axis]);
				if(inversion) {
				// i equate xy rotation to the z axis and yz to the x axis, but
				// xz is different. since the coordinate order is reversed, the
				// magnitude has to be inverted to reach the same results.
				// - that was confusing, wasn't it.
				// - 30 degrees xz rotation equals *negative* 30 degrees
				//   rotation around the y axis.
				// - but i don't wanna make it so the "true" axis for y is [0,
				//   -1, 0]. that's confusing and inconsistent.
					angle *= -1;
				};
				if(aa.control.rotate.type === "local") {
					axis = Quat.basis(part.bodyref.mirror ? Quat.mirror.x(part.orient) : part.orient)[axis];
					// the flipping is sorta inconsistent, but more intuitive.
					// this way, a totally unaltered part's locals will always
					// align with the true axes, like the user expects.
				}
				else if(aa.control.rotate.type === "custom") {
					axis = structuredClone(aa.control.rotate.basis[axis]);
				}
				else {
					let temp = axis;
					axis = [0, 0, 0];
					axis[temp] = 1;
				};
				axis = Angle.get(...axis);
				let partname = aa.control.partname;
				let rotatecoor = mode === "tilt" ? null : aa.rotatecoor(partname, axis, angle);
				let quat = Quat.rotate(part.orient, axis, (part.orient.flip ? -1 : 1)*angle);
				// if flip is on, rotations have the opposite effect of what
				// they're supposed to. (on the quaternion, anyway.)
				let basis = Quat.basis(quat);
				// basis to display
				let check = Basis.check(basis);
				if(Basis.check(basis)) {
					console.log(check);
					console.log(basis);
				};
				no_refresh = !angle;
				if(finish) {
				// apply the new relative coordinates in rotatecoor
					if(!no_refresh) {
						//console.log("before:" + String.fromCharCode(10) + Quat.string(part.orient));
						part.orient = structuredClone(quat);
						//console.log(Quat.string(part.orient));
						if(mode !== "tilt") {
							for(i1 in rotatecoor) {
								if(rotatecoor.hasOwnProperty(i1)) {
									let _part = aa.currpose[i1];
									_part.x = rotatecoor[i1][0];
									_part.y = rotatecoor[i1][1];
									_part.z = rotatecoor[i1][2];
									_part.orient = structuredClone(Quat.rotate(_part.orient, axis, (_part.orient.flip ? -1 : 1)*angle));
								}
							}
						}
					}
				}
				else {
				// use rotatecoor with aa.draw (only the parts not being rotated
				// are drawn, then the rotated parts are drawn as nodes/skeleton
				// in the colors of the interface.)
					aa.draw_background();
					aa.draw(null, rotatecoor, {[partname]: basis});
				}
			};
			if((mode !== "tilt" && mode !== "rotate") || aa.control.partclicked) {
			// get rid of overflow
				aa.pasteimages(true);
			};
			if(finish) {
				aa.control.strokecache = null;
				aa.control.clicktype = null;
				aa.control.strokedata = null;
				if(!no_refresh) {
					aa.refresh( (
						mode === "select"
						||
						((mode === "tilt" || mode === "rotate") && aa.control.partclicked)
						||
						(mode === "perspective" && inversion)
					) ? "states" : null );
				}
				// don't edit datatext or states if all you did was select
				// something.
				aa.writecoordinates(null);
			};
		},
		mouseup: function(e) {
			if(aa.control.clicktype !== "main") {
				return;
			};
			aa.mousemove(e, true);
		},
		writecoordinates: function(text) {
			AAX.writecoordinates(aa.div.coor, text);
		},
		nodeline: function(ctx, x1, y1, x2, y2, view, viewoffset) {
			let temp = aa.coortocanvas([0, 0, 0], view, true, viewoffset);
			temp[0] += .5;
			temp[1] += .5;
			// center of the standpoint pixel
			linespecial(ctx, x1, y1, x2, y2, temp);
		},
		body: null,
		bodytext: null,
		anims: [],
		// anims and states:
		// - each item of anims represents a different animation.
		//   - for example, a walking animation, jumping animation
		//   - they're all based on the same body, but they're distinct in the
		//     undo/redo system.
		// - structure of an anim:
		//   - name: the name displayed for it. it can be a number or string. if
		//     it's invalid, it'll use the index of the animation within
		//     aa.anims.
		//   - states: an array of states for it to undo/redo between.
		//   - state_index: which index of states is the one to use right now.
		//     (undo/redo move this up and down.)
		// - structure of a state:
		//   - states are what the undo/redo system saves/loads. they store the
		//     state of a single animation. all of its frames, and some data
		//     about aa.control stuff at the time. (like what frame you were on,
		//     or what pose tool you were using)
		//   - newer states come earlier in a states array.
		//   - state arrays never get longer than aa.states_limit.
		//   =
		//   - poseobjs: an array of AAX.poseobjs for each frame.
		//     - a poseobj is an armature of partobjs, and partobjs are trimmed
		//       versions of AAX.s. partobjs have no getters/setters or
		//       methods, and properties that are "default" are omitted entirely.
		//     - generally, not even functions like AAX.dim work on them. some of
		//       them might, like AAX.abscoor, but in general they written with
		//       the assumption of being used on aa.body or AAX.s/aa.frames.
		//   - currframe: what frame you were on when this state was saved
		//   - view, partname, posetool_inversion, _posetool: aa.control values
		//     at the time this state was saved
		// - various properties like aa.currframe, aa.states, aa.state_index are
		//   getters/setters for the properties of the animation.
		// - however, AA.FRAMES IS NOT. aa.frames is a copy of the current state
		//   the current animation, where every part is a genuine AAX.
		//   instead of just using AAX.poseobj.
		//   - every time states are saved during aa.refresh, it makes sure the
		//     current state's poseobjs match the changes made.
		_anim_index: 0,
		get anim_index() {
			return aa._anim_index;
		},
		set anim_index(value) {
			let ref = aa.curranim;
			if(value !== aa._anim_index) {
				//ref.states = ref.states.slice(ref.state_index, ref.state_index + aa.states_truncator);
				//ref.state_index = 0;
				ref.states = ref.states.slice(ref.state_index - aa.states_truncator, ref.state_index + 1 + aa.states_truncator);
				ref.state_index = Math.min(ref.state_index, aa.states_truncator);
				// apply states_truncator
				// - if state_index is higher than the truncator, it should become
				//   the truncator, since it can only store that many redos. if it's
				//   lower, don't change it at all, since only undos would be
				//   deleted.
				if(aa.control.activeonly_cache) {
					// clear the cache for inactive animations.
					for(let i1 = 0; i1 < ref.states.length; i1++) {
						// for every state,
						let _ref = ref.states[i1].poseobjs;
						for(let i2 = 0; i2 < _ref.length; i2++) {
							// frame,
							for(let i3 in _ref[i2]) {
								if(_ref[i2].hasOwnProperty(i3)) {
									// part.
									let __ref = _ref[i2][i3];
									__ref.cache = structuredClone(AAX.cache_init);
								}
							}
						}
					}
				}
			};
			aa._anim_index = value;
			aa.loadstate(aa.state_index, true);
			// apply those changes to aa.frames.
			// - skip refresh. this is only set in .initialize and buttons for
			//   changing it, so refresh will run anyway.
		},
		newstate: function() {
			return {
				poseobjs: [],
				currframe: 0,
				view: aa.control.view,
				partname: aa.control.partname,
				posetool_inversion: aa.control.posetool_inversion,
				_posetool: aa.control._posetool,
			};
		},
		newanim: function() {
			let anim = {
				name: "",
				states: [aa.newstate()],
				state_index: 0,
			};
			anim.states[0].poseobjs = [AAX.poseobj(aa.newpose())];
			return anim;
		},
		get curranim() {
			return aa.anims[aa.anim_index];
		},
		getanimname: (index) => aa.anims[index].name ? aa.anims[index].name : "anim " + index,
		// use this whenever an animation name is displayed.
		frames: [],
		// an array of posed armatures. the structure is as follows:
		get states() {
			return aa.curranim.states;
		},
		set states(value) {
			if(Array.isArray(value)) {
				aa.curranim.states = value;
			}
			else {
				console.log("this shouldn't happen");
			}
		},
		get state_index() {
			return aa.curranim.state_index;
		},
		set state_index(value) {
			if(Number.isInteger(value) && value >= 0 && value < aa.states.length) {
				aa.curranim.state_index = value;
			}
			else {
				console.log("this shouldn't happen");
			}
		},
		get currstate() {
			return aa.states[aa.state_index];
		},
		get currframe() {
			return aa.currstate.currframe;
		},
		/*
		set currframe(value) {
			if(!Number.isInteger(value)) {
				console.log("this shouldn't happen (" + value + ")");
			}
			//else if(value >= 0 && value < aa.frames.length) {
			//	aa.currstate.currframe = value;
			//}
			else {
				aa.currstate.currframe = Math.max(0, Math.min(value, aa.currstate.poseobjs.length - 1));
			}
		},
		//*/
		set currframe(value) {
			if(Number.isInteger(value) && value >= 0 && value < aa.frames.length) {
				aa.currstate.currframe = value;
			}
			else {
				//console.log("this shouldn't happen (" + value + ")");
				// this runs when it shouldn't. specifically, if undo/redoing
				// takes you to a state where there's less frames than makes
				// sense for what currframe is. it's fine because loadstate runs
				// clampframe, so i don't want this error showing up.
			}
		},
		get poseobjs() {
			return aa.currstate.poseobjs;
		},
		get currpose() {
			return aa.frames[aa.currframe];
		},
		get currposeobj() {
			return aa.poseobjs[aa.currframe];
		},
		states_limit: 32,
		// poses aren't very big, but i really don't want it to swell
		// infinitely. having to start over because it crashed or whatever would
		// suck.
		states_truncator: 4,
		// when it switches away from an animation, it truncates it so only this
		// many undos/redos are kept.
		clampframe: function() {
			aa.currframe = Math.min(aa.frames.length - 1, Math.max(aa.currframe, 0));
		},
		savestate: function() {
			let loop = new Loop("aa.savestate");
			let currframe = aa.currframe;
			if(aa.state_index > 0) {
			// clear redo
				aa.states.splice(0, aa.state_index);
				aa.state_index = 0;
			};
			aa.states.splice(0, 0, aa.newstate());
			aa.currframe = currframe;
			let ref = aa.poseobjs;
			for(let i1 = 0; i1 < aa.frames.length; i1++) {
				loop.tick(1);
				ref[i1] = AAX.poseobj(aa.frames[i1]);
			}
			loop.end();
			if(aa.states.length > aa.states_limit) {
			// keep it within states_limit
				aa.states.splice(aa.states_limit, aa.states.length - aa.states_limit);
			};
		},
		loadstate: function(index, skiprefresh) {
		// using in undo/redo, and the anim_index setter. applies the changes
		// stored in a state.
			let i1 = 0;
			let loop = new Loop("aa.loadstate");
			let ref = aa.states[index];
			for(i1 in ref) {
				loop.tick(1);
				if(ref.hasOwnProperty(i1) && i1 !== "poseobjs" && i1 !== "currframe") {
					if(i1 === "_posetool" && (ref[i1] === "perspective") !== (aa.control[i1] === "perspective")) {
					// only do posetool changes if it changes whether it's
					// perspectived or not (since some things are only visible
					// in one mode or another.)
						aa.control[i1] = ref[i1];
						// move this outside the conditional to apply changes to
						// view and partname.
						// - it sounds more intuitive, but it isn't. so it's in
						//   here.
						aa.control.posetool_inversion = ref.posetool_inversion;
						if(ref[i1] === "perspective") {
							aa.control.view = ref.view;
						};
					};
				};
			}
			loop.end();
			aa.frames = [];
			// clearing this prevents problems with length differences
			for(i1 = 0; i1 < ref.poseobjs.length; i1++) {
				loop.tick(1);
				aa.frames[i1] = aa.posefromobj(ref.poseobjs[i1]);
			}
			loop.end();
			aa.currframe = ref.currframe;
			// this comes after the changes to aa.frames, since the currframe
			// setter doesn't accept values outside the current aa.frames
			// length.
			aa.clampframe();
			if(!skiprefresh) {
				aa.refresh("states");
			}
			aa.filldatatext();
		},
		undo: function() {
			if(aa.state_index < aa.states.length - 1) {
				aa.state_index++;
				aa.loadstate(aa.state_index);
			};
		},
		redo: function() {
			if(aa.state_index > 0) {
				aa.state_index--;
				aa.loadstate(aa.state_index);
			};
		},
		anim: null,
		updateanimation: function(no_shortcut) {
		// updates the animation.
		// - this is to be used sparingly, with a button. to avoid drawsettings
		//   inconsistency, it needs to draw every frame again to save it.
		// - no_shortcut
		//   - to save time, it skips the drawing for whatever the current frame
		//     is. it just copies aa.ctx, instead.
		//   - this is usually fine, because between switching animations and
		//     clicking the updateanimation button, there's guaranteed to be a
		//     refresh.
		//   - but in the case of the pixel art multianimation export, that
		//     isn't true.
			let ref = aa.animator;
			let view = ref.html.one_view.checked ? aa.control.view : -1;
			let viewtype = view === -1 ? "multi4" : view;
			let ctx = aa.ctx.main;
			let vertical = ref.html.vertical.checked;
			let cell = aa.drawsettings.cell;
			ref.w = (view === -1 && vertical ? 4 : 1)*cell.w;
			ref.h = (view === -1 && !vertical ? 4 : 1)*cell.h;
			// if it's a multiview and the time direction is vertical, the four
			// views should be lined up horizontally. if it's a multiview and
			// time is horizontal, they should be lined up vertically.
			ref.frames = [];
			let currframe = aa.currframe;
			// this is going to change, so save what it is right now
			for(let i1 = 0; i1 < aa.frames.length; i1++) {
				let _i1 = posmod(currframe + i1, aa.frames.length);
				aa.currframe = _i1;
				if(!(i1 && view !== -1 && !no_shortcut)) {
				// if it's the first drawing and it isn't a one-view update, you
				// can skip one drawing by taking whatever's already on the
				// canvas. (unless no_shortcut is on to prevent it.)
					aa.draw_background(viewtype);
					// (viewtype, side_tint_invert)
					// - _i1%2 would make the side tint have like a checker
					//   pattern, to differentiate cells in both axes, not just
					//   one..
					// - but, well. it's kind of stupid to make the whole
					//   background change color every other frame.
					aa.draw(viewtype);
					// (viewtype, rotatecoor, basis)
				};
				if(view === -1 && !vertical) {
				// if it's a horizontal multiview, the views should be lined up
				// vertically.
					let canvas = document.createElement("canvas");
					let _ctx = canvas.getContext("2d");
					canvas.width = cell.w;
					canvas.height = 4*cell.h;
					for(i2 = 0; i2 < 4; i2++) {
						_ctx.putImageData(ctx.getImageData(i2*cell.w, 0, cell.w, cell.h), 0, i2*cell.h);
					}
					ref.frames[_i1] = _ctx.getImageData(0, 0, cell.w, 4*cell.h);
				}
				else {
					ref.frames[_i1] = ctx.getImageData(0, 0, ref.w, ref.h);
				}
			}
			aa.currframe = currframe;
			if(view === -1) {
				ctx.putImageData(ref.frames[currframe], 0, 0);
			}
			else {
				aa.draw_background();
				aa.draw();
			}
			// put the canvas back how it was
			ref.frame = 0;
			ref.sheet.vertical.checked = ref.html.vertical.checked;
			ref.updatesheet();
		},
		initialize: function() {//yyyaai
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let i4 = 0;
			let loop = new Loop("aa.initialize");
			//
			//aa.drawsettings.silhouette = "overlap";
			//aa.drawsettings.parts = "off";
			if(typeof aa.bodytext !== "string") {
				aa.bodytext = AAX.Body.templates.standard;
				aa.body = AAX.Body.new(aa.bodytext);
			};
			if(typeof aa.body !== "object" || aa.body === null) {
				console.log("this shouldn't happen" + (typeof aa.body === "string" ? " (error is \"" + aa.body + "\")" : ""));
				return;
			};
			//console.log(aa.body);
			// make sure a body exists
			//
			let string = `<details class="text">`;
			string += `\n\t<summary>manual</summary><ul>`;
			let manual = {
				"pose tools": [
					`the deform pose tool lets you move parts anywhere, even if it changes how far the part is from their parent. (useful for body parts connected by a spine instead of a bone.)`,
					`the move pose tool lets you move parts, but keeps it as far away from the parent as it is in the default pose. (the third axis will be whatever positivity/negativity brings it closer to the camera for that view. if you're on the front view, it will move forward, if it's the back view it will move backward.)`,
					`if you click a part in the rotate pose tool, it will select that part. if you click anywhere else, you can rotate the selected part and its descendants.`,
					[
						`tilt is similar, but doesn't affect descendants.`,
						`you can select parts by starting OR ending your click on them.`
					],
					`the perspective pose tool lets you create an offset for each view, letting you position things around a vanishing point.`,
					`certain graphical changes only apply in perspective mode, namely the perspective offsets, and camera angle. perspective mode is for visualizing what the pose/animation will look like at the end, while the other modes are meant to be easier to understand and edit, like an engineering multiview.`,
					`selecting the pose tool you already have selected "inverts" it, making it work differently.`,
					[
						`inverted move will use the current hypotenuse of the part, rather than the hypotenuse it has in the default pose. (useful if you used deform to lengthen limbs or something.)`,
						`inverted deform will move the part without moving its descendants.`,
						`inverted tilt/rotate does xz rotation.`,
						`inverted perspective selects parts without editing them. (useful while editing different perspective images)`
					]
				],
				"editing/switching bodies": [
					`open the "bodytext" thing.`,
					`by editing the content in that text area and clicking "apply changes", you can edit or replace the body. a lot of part properties can only be changed in here.`,
					`there's also a dropdown with some example bodytexts to use or start from, like a hand.`,
					`you can write these manually, but the "body maker" tool makes it much easier.`,
					`structure of a bodytext`,
					[
						`the first area defines parts, their names, parent structure, and coordinates.`,
						`the second area is images.`,
						[
							`type a bracketed part name to make lines after that part of that part's shapes/images.`,
							`use "||" lines to transition from a part's shape to its unperspectived images, or from that to its perspectived images.`,
							`read the "shape system" and "image system" sections for more about how shapes/images work and how to write them.`
						],
						`the third area is other properties. enter a part name and colon, then...`,
						[
							`symmetry(): creates horizontally mirrored duplicates of the part and all its descendants.`,
							[
								`the original branch will get a "l_" prefix, and the duplicate branch will have "r_" prefixes. (you can also choose your own prefixes by putting them in the parentheses, separated by a comma.)`,
								`coordinates, shapes, and images are x-mirrored.`
							],
							`color1(), color2(): enter numbers in the parentheses to set first and second colors for the part and all its descendants.`,
							[
								`these numbers represent items of the list of part colors. (you can edit that list by clicking that rainbowy button.)`,
								`you can enter multiple numbers, separated by commas. this will make colors alternate between generations. (ex: "color1(1, 2)" will make the part's color1 the first color in the part colors list, and make all its children use the second color in that list. then the grandchildren use the first color, great-grandchildren use the second, etc.)`,
								`if you use "color1*()" or "color2*()" instead, descendants won't be affected.`
							],
							`group(), generation(), core(), bone(), concave(): these affect the silhouette/connection system.`,
							[
								`when the silhouettes toggle in draw settings is on, it draws an approximation of the armature's silhouette, using these properties.`,
								`generally, silhouette images are combinations of the part's image and other parts' images, turned into a convex shape.`,
								`group(): enter a number, and maybe follow it with letters. this defines the "silhouette group", which helps differentiate different limbs.`,
								[
									`if parts have the same number <i>and</i> letters, they're drawn together, with no outlines between their silhouette shapes.`,
									`if parts have the same number but different letters, they're drawn like separate shapes, but in the same color.`,
									`the number is used to select one of the silhouette colors. there's a color button that lets you edit those. the dark blue/green/red one.`,
									`if a mirrored part has no letters in their silhouette group, when it gets a symmetrical counterpart, the left one will get "l" and the right one will get "r".`,
									[
										`this doesn't happen if the silhouette group was 0. (the assumption is that if it's 0, you didn't want these limbs differentiated from the rest of the body anyway.)`
									],
									`just like color1 and color2, group has a "group*()" counterpart that doesn't affect descendants.`
								],
								`generation(): enter two numbers in the parentheses to add the images of the part's ancestors and/or descendants. for example, "generation(1, 2)" makes it combine the part's image, its parent's image, all of its childrens' images, and all of its grandchildrens' images.`,
								[
									`<b>by default, it adds the parent's image. if you don't want that, you have to override it with an empty generation() command.</b>`
								],
								`core(): enter a number. using that as the diameter, it will add a circle centered on the part. this is used for the hands.`,
								`bone(): enter a number. using that as the diameter, it will add a capsule shape, that begins at the part's parent and ends at the part. used for the neck.`,
								`concave(): if you enter this, the silhouette image will be turned into a convex shape <i>before</i> the part's main image is added. use this for concave shapes, like if the head has horns, or you just don't want it convexed to its parent.`,
								[
									`this affects bone(), too, if you have one.`,
								]
							],
							`hide(): the part is hidden by default.`,
							`perspective(): lets you predefine perspective offset? this isn't very useful, but it's there.`,
							[
								`enter view 0's x, view 0's y, view 1's x, etc.`,
								`you can also enter "auto". that counts for two coordinates, since it applies to a whole view`,
								`by default, all views have automatic perspective.`
							]
						]
					],
					`writing // anywhere in a bodytext makes a comment, ie the rest of that line is ignored.`,
					`poses can survive bodytext changes, for the most part. if a part with the same name exists in both the old and new body, it'll adopt changes in coordinates and the like, while accounting for the angle/hypotenuse difference the part has in the default pose.`
				],
				"shape system": [
					`parts usually use 3d shapes to generate 2d images.`,
					`these shapes are defined in bodytext, but you can also redefine them with the "edit shape" button.`,
					`shapes are lists of points, broken up into groups. each line is a point, and a "|" line starts a new group.`,
					`every group is drawn as a convex shape. you can make simple convex shapes like pyramids/cubes/etc by just placing all the points. the order of the points doesn't matter.`,
					`concave shapes are impossible with just that, so that's what point groups are for. you can form concave shapes by breaking it up into multiple convex parts.`,
					`points can be made into spheres/spheroids by writing more than three numbers. if there's four, the fourth is used as the diameter of a sphere. if there's six, the last three numbers are used for width, height, and depth.`,
					`you can rotate spheroids, too. anything past the sixth number is used for that, either through xy/yz/xz rotations (axis, colon, 0 to 1 number, ex: "xy: 1/4, xz: .37") or a quaternion. (ex: "w: .707, x: 0, y: 0, z: .707")`,
					[
						`you can also write "x mirror", "y mirror", or "z mirror" to mirror the quaternion.`
					],
					`you can type a point that's nothing but axis letters to copy the previous point with those axes inverted in the coordinates and orientation. useful for designing symmetrical shapes.`,
					`if you type axis letters and a point index, you can make copies of other points. (the first point is 0. negative indexes will start from the most recent points, so -1 means "the point before this one".)`,
					`the "orient" part property rotates the shape. the rotate and tilt pose tools can edit this. the part information window visualizes it by showing the directions of the x/y/z axes of the shape.`,
					`"stretch" and "widen" scale the shape. stretch scales it along the line from the part to its parent, and widen scales it in other directions.`,
					`orient flipping`,
					[
						`this is a technical detail that, 90% of the time, is not important. skip this if you don't care.`,
						`for symmetry parts and tools like the mirror buttons, parts get mirrored across some axis, right? including even the orientation of the shape.`,
						`that's impossible with traditional quaternions. you can invert two axes by rotating it 180 degrees, but inverting one or all axes is impossible.`,
						`my orient quaternions get around that by having a "flip" property. that makes it so, whenever the quaternion is used to orient a point or set of axes, every coordinate of those points will be inverted.`,
						`combined with 180 rotations, this makes it possible to mirror quaternions.`,
						`when the part information orientation visual has a little X at the center, that means the quaternion is currently flipped.`,
						`you cannot specify whether flip is on in the point quaternions. since those quaternions are only applied to spheroids, and spheroids are symmetrical in all three axes, inverting the directions of all of those axes does nothing. i guess if you really wanted to, you could write "x mirror, y mirror, z mirror".`,
						[
							`things only change if a spheroid axis points in a different direction that isn't exactly the opposite direction of what it was. one or two x/y/z mirrors can cause that, but three mirrors won't.`
						]
					],
					`extra notes`,
					[
						`// comments are especially useful in shapes, to remember how the shape is structured.`
					]
				],
				"image system": [
					`shapes are generally more useful than 2d images. things are designed around them more than they're designed around 2d images.`,
					`but 2d images are useful for things like hands, that are important but can't be drawn with shapes. that's what "part artist" is for, creating 2d images manually.`,
					`a part can have a shape, unperspectived images, and perspectived images. if it has multiple, unperspectived is used over shapes, and perspectived is used over unperspectived.`,
					`there can be two unperspectived images per part. a front view, and right view. (it's mirrored for the other two views.)`,
					`there can be four perspectived images. one per view. this is only shown when the selected pose tool is perspective.`,
					`structure of images, in bodytext:`,
					[
						`make a rectangle of characters. any dimensions are fine.`,
						`- for empty pixels, % for the first color, * for the second color.`,
						`use a | line to switch to the next image.`,
					],
					`the "switch" button in armature artist copies the current part's 2d image to part artist and switches over to part artist so you can edit it.`,
					`the "switch" button in part artist applies your changes to the part in armature artist and switches back to it.`,
					`extra notes`,
					[
						`the "switch without export" buttons switch between the two without doing any image import/export.`,
						`when the pose tool is "perspective", switching to/from part artist will import/export the perspective image of the current part, in the current selected view. (the selected view is whatever view you last clicked to edit. there's view buttons to indicate/change the view.)`,
						`when the pose tool is anything else, switching to/from part artist will import/export both the front and right unperspectived images.`,
						`the "clear image" button follows the same rules.`,
						`if said 2d image doesn't exist, part artist imports/exports whatever the 3d shape draws.`,
						`if you ever get mixed up which images exist and don't exist, check the part information window.`,
						`the difference between the first and second color is that for the first color, any interior pixels will use the "part fill" color, with only the edges being the part's color. this isn't true for the second color.`,
						[
							`the first color is meant to define the shape, the second marks reference points or whatever.`
						]
					]
				],
				"hide/show": [
					`"part" hide/show: hides/shows the selected part.`,
					`"branch" hide/show: hides/shows the selected part and its descendants.`,
					`"group" hide/show: hides/shows all parts in the same silhouette group.`,
					`"body" hide/show: hides/shows all parts in the same body. (if you have parts that are unconnected objects or even separate characters, those won't be affected.)`,
					`"body-branch" hide/show: short for "body minus branch". hides all parts part of the same body but not the same branch.`,
					`hide/shows with similar names work the same way. hiding/showing everything that fits into the first type but not the second.`,
					`hidden parts aren't selectable, unless the "total hide" setting is off. it's useful for animating complex bodies or multiple characters at once, without irrelevant characters/parts getting in the way.`
				],
				"other part properties": [
					`relative coordinates are the part's coordinates relative to the part's parent.`,
					`perspective coor is the offset the perspective pose tool creates. it's only shown in perspective mode. if it's set to "auto", it'll be calculated automatically, based on the draw settings vanishing point and range.`,
				],
				"draw settings": [
					`grid: increments for the grid lines. "2, 2, 4" would mean lines are drawn every 2 pixels in the first grid color, then every 2*2 pixels in the second grid color, then every 2*2*4 pixels in the third grid color. putting a 0 anywhere makes it draw lines at the standpoint and only the standpoint.`,
					`standpoint: parts that are at (0, 0, 0) will appear at this position in the cell, relative to the cell's center.`,
					`range: used in automatic perspective. when a point has perspective applied, no matter where it is, it's placed within this radius from the vanishing point. lower numbers mean more curvature, higher numbers mean less.`,
					`cell: cell dimensions.`,
					`vp: "vanishing point". used in the automatic perspective. the coordinates are relative to the standpoint.`,
					`camera: an xz and yz angle. when it's in perspective mode, everything is rotated by these.`,
					`fineness: used in shape spheroids. spheroids are drawn as if a circle has (4 * this) sides. higher numbers are a bit more taxing, but if you're making shapes big enough to see flat sides in your spheroids, increasing this will fix that.`,
					`toggles`,
					[
						`grid: between the background being a grid, color but no grid, or totally transparent. useful when generating images from your animation.`,
						`silhouette: connects parts' images to form a somewhat realistic-looking silhouette. switches between them being shown, shown with different silhouette groups being distinguished, or no silhouettes at all.`,
						[
							`differentiating different limbs is the whole point of silhouette groups, but they only clutter up the image unless you actually need to see those interior outlines at the moment.`
						],
						`parts: toggles whether parts' images are drawn. (the pink setting makes it so all images' outlines are visible, even if they would normally be covered up by another image's fill.)`,
						`vertices: when it generates 2d images from the part's shape, it draws the points that make up the shape in the part's second color. this is a toggle for that.`,
						`skeleton: lines between parts and their parents`,
						`perspective: draws lines between where parts are in and out of perspective mode.`,
						`nodes: highlights the center of each part`,
						`total hide: when this is off, some things are still drawn even for hidden parts. just enough to know where they are and edit them. (the nodes are visible, and so is their skeleton if they have unhidden descendants.)`
					],
					`colors`,
					[
						`the left set of colors affects the grid.`,
						`the middle set of colors affects the elements of an armature. (in about the same order as the draw settings toggles for those elements, and the order they're layered.)`,
						`the right set of colors is interface stuff. stuff used in pose tool graphics, and the ui.`,
						`but if you forget which is which, the button prompts will tell you what they are.`,
						`you can enter multiple part/silhouette fill colors to differentiate parts that belong to different bodies. (that is, parts that don't share a common ancestor.) this is useful for animating multiple characters.`,
						[
							`it loops around. if you have two colors and five bodies, the first, third, and fifth body will use the first color, and the second and fourth bodies will use the second color.`
						]
					],
					`extra notes`,
					[
						`if you use a bodytext with a part named "head", the vanishing point's y will automatically be set as the y that part has in the default pose. like placing the camera at eye level.`,
						`hitting "cancel" on a color prompt will keep it as it is, but hitting "ok" without typing anything will reset the color to default.`,
						`the standpoint grid lines move while in perspective mode, but that only represents where a [0, 0, 0] point would be perspectived to. it's not like it changes which pixels are what coordinates or anything.`
					]
				],
				"keymap": [
					`w, a, s, d: lets you switch pose tools and frames.`,
					`shift+a, shift+d: change which view you have selected. (relevant to buttons that edit perspective images or perspective coordinates, and the "update animation" button.)`,
					`e: inverts or uninverts the pose tool.`,
					`q, shift+q: switches to/from the image editor, with or without exporting.`,
					`t, f, g, h: selects parts by moving through the family structure. t selects the parent of the current part, g selects the first child of the part, and f and h cycle through siblings.`,
					`j, i, k, o, l: frame actions (blank, duplicate, delete, etc)`,
					`ctrl+z, ctrl+shift+z: undo, redo`,
					`ctrl+s, ctrl+o: save, load`
				],
				"inbetweens": [
					`what tweening is`,
					[
						`if you have a start pose and an end pose, and you simplify the differences between them into a "difference" object of rotations and length multipliers...`,
						`start pose + difference = end pose.`,
						`start pose + difference*1/4 = a pose that's sort of like the start pose, but 1/4 of the way to being like the end pose.`,
						`so if you insert a 1/4, 1/2, and 3/4 pose between the start and end pose, you can animate a smooth transition between the start and end pose, without even doing anything.`
					],
					`when you click "create inbetweens", it creates inbetweens between the current frame and the next frame.`,
					`"apply inbetweens" does something similar, but assumes these frames already exist. so the end frame is assumed to be start frame + [number of inbetweens] + 1, and the frames between that are made to transition between the two.`,
					`the rest of these buttons just control easing stuff. most motion is eased.`,
					[
						`the number you can tick up/down is how many inbetweens to make.`,
						`the ^ number is the curve, used for exponenting. the higher the number it is, the more severe the easing is. 1 will make all the frames equally spaced. 2 would place the inbetweens at (1/4)^2, (1/2)^2, (3/4)^2, etc.`,
						`the two buttons beneath that control if it's ease in, ease out, ease in/out, or ease out/in.`,
						`the area under that visualizes what the inbetweens will be like. the closer a circle is to the left end, the more it'll be like the start pose, and the closer it is to the right, the more it'll be like the end pose.`
					],
					`<i>when using apply inbetweening, it won't tween parts that are hidden in the starting frame.</i> this lets you control what inbetweening is applied to, like only tweening certain characters or limbs.`,
					`<b>there are two cases where tweening looks weird.</b> if your tweening looks weird, it's probably one of these cases.`,
					[
						`one is when the angles a part points in in the start and end pose are perfect opposites.`,
						[
							`it figures out how to get from here to there by finding the shortest rotation that would do that, but... if the angles are perfectly opposite, there's an infinite number of angles it could be.`,
							`instead it just tweens position rather than angle. which doesn't really make sense.`
						],
						`two is when in the start or end pose, the part's orient quaternion is "flipped", but not in both.`,
						[
							`read the "orient flipping" part of the shape system section. generally, orientation only flips or unflips when you use the mirror buttons.`,
							`this just isn't a very tweenable property, and it's impactful enough for the lack of smooth change to look super weird.`,
							`as i said earlier, check the orientation visual in the part information area to tell if it's flipped. it should have an X at the center if it is.`,
							`one common example is walk cycles.`,
							[
								`the standard, beautifully half-assed walk cycle is as follows:`,
								[
									`default pose`,
									`stepping pose`,
									`default pose`,
									`stepping pose, but x mirrored`,
								],
								`if you try to tween that, it'll look creepy. x mirroring all parts in the last frame creates a skew between that frame and the other 3.`,
								`instead, it should be like:`,
								[
									`default pose`,
									`stepping pose`,
									`default pose, but x mirrored`,
									`stepping pose, but x mirrored`,
								],
								`basically, avoid tweening between mirrored and unmirrored frames.`,
								[
									`create and duplicate key frames`,
									[
										`1: default pose`,
										`2: stepping pose`,
										`3: default pose`,
										`4: stepping pose`
									],
									`create tweens between key 1 and 2 (ease out)`,
									`create tweens between key 2 and 3 (ease in)`,
									`x mirror keys 3, 4, and 1`,
									`create tweens between key 3 and 4 (ease out)`,
									`create tweens between key 4 and 1 (ease in)`,
									`x mirror key 1 to put it back how it was`
								]
							]
						]
					]
				],
				"rotate settings": [
					`various settings related to the rotate and tilt pose tools.`,
					`round: affects how angles are rounded. the default, ` + aa.control.rotate.round + `, makes sure angles are always rounded to the nearest ` + (360/aa.control.rotate.round) + ` degrees.`,
					[
						`it sounds unnecessary, but having it off is pretty annoying.`,
						`changing it to 0 will disable it.`
					],
					`curl: when this is on, rotations will be multiplied along a branch of parts.`,
					[
						`like if you rotate a finger 10 degrees, the first segment will rotate 10 degrees, the second will rotate 20 degrees, the third will rotate 30 degrees. it has a sort of curving effect.`,
						`useful for curling fingers, and...`,
						`uhh... doing a bicep flex? just curling fingers, pretty much.`,
						`indispensable for hand posing.`
					],
					`true/local/custom: refers to what kind of axes it rotates around.`,
					[
						`true: the axes you'd expect. xy, xz, yz.`,
						`local: the axes of the part's current orientation.`,
						[
							`you can think of orientation as what direction right is for the part, what direction down is, what direction forward is... rotations move those directions, right?`,
							`local makes it so it rotates around those directions.`,
							`another way to think of it is that it's like the part is completely unoriented, like how it is in the default pose.`,
							`this is useful for things like jaws, or elbows. jaw movement is just a yz rotation. but <i>only</i> a yz rotation. and that's impossible to do if you already did xy rotation or something on the head.`,
							`but if you switch to local, yz rotation still matches the jaw's proper rotation axis.`,
							`unimportant technical detail: for mirrored symmetry parts, (ex: r_shoulder, but not l_shoulder) the x axis is inverted to point in the opposite direction, cancelling out how their orientations start out x-mirrored. technically that's sorta inconsistent, but it's more intuitive.`
						],
						`custom: custom rotation axes, set with the bottom two columns of buttons.`
					],
					`axis setting buttons (bottom right column)`,
					[
						`x, y, z: sets which axis the buttons change.`,
						`parent: the selected axis imitates the angle from the selected part to its parent.`,
						`child: it imitates the angle to the selected part's first child.`,
						`cross: an angle perpendicular to the other two axes. (can't be used if the other two axes are identical or point in perfectly opposite directions.)`,
						`true: the true axis.`,
						`local: the local axis of the selected part.`,
						`written: prompts you to enter an angle yourself.`
					],
					`invert: makes the selected axis point in the opposite direction.`,
					`switch: switches two of the axes.`,
					`invert, switch, and the axis setting buttons only apply to the custom axes.`,
					`using an axis setting button makes it select the next axis. this way, you can quickly set all three axes by just clicking three times.`,
					`parent, child, and cross are especially useful for increasing or decreasing angles between parts. like for an elbow, or a knuckle.`,
					[
						`local axes can do this too, but that's dependent on orientation matching their position. (maybe you don't bother always using rotate/tilt if the part is just a sphere or whatever.)`,
						`select the part, choose custom, select the x axis, then...`,
						`click parent, child, and cross.`,
						`the z axis will be made into something that opens or closes the elbow/knuckle.`
					]
				],
				"animation and exporting": [
					`below the ui buttons is the animation system.`,
					[
						`this lets you convert animations into spritesheets, play them, and save the spritesheet or individual frames.`,
						`click the "update" button to update the animation images.`,
						`the "one view\" checkbox lets you send just the currently selected view, instead of the full multiview.`,
						`if the "vertical" checkbox is checked, the spritesheet is set up so y is the time axis and x is the direction axis. if it's unchecked, it's the opposite.`,
						`generally, multiview spritesheets look better with vertical on, and one-view spritesheets look better with it off. so, checking/unchecking one view will check/uncheck vertical as well. (checking/unchecking vertical will not check/uncheck one view.)`
					],
					`closely related to this is the "pixel art transfer" area of the ui. this lets you send images to the pixel art tool.`,
					[
						`you can send a frame, an animation, or all animations.`,
						[
							`"all x" lines up the animations in a row. "all y" lines them up in a column.`
						],
						`the "one view" and "vertical" checkboxes are linked to the checkboxes in the animation system. checking or unchecking them is the same as checking/unchecking the checkboxes down there.`,
						`the animations are updated before they're sent.`,
						`they can be sent through "paste" or "replace".`,
						[
							`"paste" saves it to the pixel art tool's paste tool, meaning you can place the image anywhere you want.`,
							`"replace" replaces the pixel art image entirely.`,
						],
						`all exports have borders drawn around them, marking the borders between frames, and where standpoint is.`,
						[
							`it uses whatever the "forecolor" and "backcolor" currently are in the pixel art tool.`
						],
						`for "all x" and "all y", the names of the animations are written as well.`
					]
				],
				"etc": [
					`the part information window shows which properties are different from the default pose by marking them with a !. click that line of the window to reset that property to default.`,
					`oddify makes it so the part is centered on a .5 coordinate instead of a .0 coordinate, and vice versa. the images are edited to match, so the center row/column(s) might be deleted or expanded. it can also be used in perspective mode, to affect perspective offset.`,
					`when changing something like the cell dimensions or vanishing point, you can leave a spot empty to leave it how it is. (for example, entering "72," for the cell dimensions would set the width as 72 and leave the height unchanged.)`,
					`you can load files by drag-and-dropping them onto the multiview canvas, or with ctrl+o.`,
					`if multiple nodes are on the same screen position, clicking it will select whichever one is closest to the camera. the text below the multiview shows the name of the part you're about to click.`,
					//`"refresh shape": if images based on 3d shapes aren't updating properly, this might fix it? (by clearing the image cache.) but that really shouldn't happen, so let me know if it does!`,
					`in the part information and rotate settings axis displays, if an axis line looks "incomplete", that means the axis points backward.`,
					`if there are performance issues:`,
					[
						`lower the state limit and truncator. (every state stores every frame's pose, and depending on how many animations you have, it can store a lot of states. the maximum amount it could be storing is limit + (number of animations - 1) * (2*truncator + 1).)`,
						`turn off silhouettes`,
						`create perspectived/unperspectived images so it doesn't have to convert shapes. (i went through a lot of caching hell to avoid this process slowing things down, but it still runs every time orientation or anything like that changes.)`,
						`lower fineness`
					]
					/*
					//`if you switch to the image editor while using the perspective pose tool, you'll only edit how it looks in the current view, while perspectived. you can use this to make a part bigger or smaller depending on how far it is from the camera.`,
					//`if you write a part name at the beginning of a shape point group, or a part name + a colon before a point, that group/point will follow the orientation and scaling of the named part, instead of the part the shape is part of. (this is useful for certain anatomy, like elbows.)`,
					//`if you type a negative number for the inbetween curve factor, the positions will be somewhat random.`,
					`"create inbetweens" creates new frames between the current frame and the next frame that act as a bridge between the two. "apply tweening" modifies existing frames instead. (ex: if you're on frame 2 and you "create" 5 inbetweens, it'll insert 5 inbetweens that start like frame 2 and end like frame 3. if you "apply" instead, existing frames 3-7 will be made into inbetweens for frames 2 and 8.)`,
					`when you use create or apply tweening, it doesn't do anything for parts that are hidden on the starting pose. for "create", those parts will stay like how they are in the starting pose the whole way through. for "apply", they'll stay how they were before. this is what makes "apply" tweening useful: you can keep the poses mostly the same while only tweening one character, one limb, etc.`
					*/
				],
			};
			for(i1 in manual) {
				if(manual.hasOwnProperty(i1)) {
					string += [
						``,
						`<details>`,
						`\t<summary>` + i1 + `</summary>`,
						`\t` + arraytoul(manual[i1], 1).replaceAll(`\n`, `\n\t`),
						`</details>`
					].join(`\n`).replaceAll(`\n`, `\n\t`);
				}
			}
			string += `\n</ul></details>`;
			string += [
				`<details>`,
				`\t<summary>bodytext</summary>`,
				`\t<button id="aa_bodychanges">apply changes</button> <select id="aa_bodychoices"></select>`,
				`\t<br><textarea id="aa_bodytext" cols=48></textarea>`,
				`</details>`
			].join(`\n`);
			string += [
				`<details>`,
				`\t<summary>posetext</summary>`,
				`\t<button id="aa_allframes">show ` + (aa.control.all_frames_posetext ? `one frame` : `all frames`) + `</button>`,
				`\t<br><button id="aa_posechanges">apply changes</button>`,
				`\t<br><textarea id="aa_posetext" cols=48></textarea>`,
				`</details>`
			].join(`\n`);
			string += `\n<div id="aa_editmodetrue">`;
			string += `\n<div id="aa_editmodetrue_active">`;
			let ref = aa.pa.ctx;
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aapa_" + i1;
					if(["front", "ui"].includes(i1)) {
						string += `<br>`;
					}
					else if(i1 === "right") {
						string += ` `;
					};
					string += `<canvas id="` + id + `"></canvas>`;
					if(i1 === "right") {
						string += `</div>`;
						// end active area
					};
				}
			};
			loop.end();
			string += `\n</div>`;
			// end editmodetrue div
			//
			string += `\n<div id="aa_editmodefalse">`;
			string += `\n<div id="aa_editmodefalse_active">`;
			ref = aa.ctx;
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aa_" + i1;
					string += `\n`;
					if(i1 !== "ui") {
						string += `<br>`;
					};
					string += `<canvas id="` + id + `"></canvas>`;
					if(i1 === "main") {
						string += `<div id="aa_div_coor"></div>`;
						string += `</div>`;
						// end of active div
					}
				}
			};
			loop.end();
			string += `</div>`;
			// end of editmodefalse div
			string += `<br>`;
			// data text
			string += "\n" + [
				`<dialog id="aa_editshape_dialog" autofocus>`,
				`enter new text to define the shape.`,
				`<br><textarea id="aa_editshape_input"></textarea>`,
				`<br><button id="aa_editshape_enter">enter</button>`,
				`<button id="aa_editshape_close">close</button>`,
				`</dialog>`
			].join("\n");
			string += "\n" + [
				`<dialog id="aa_posetoshape_dialog" autofocus>`,
				`<textarea id="aa_posetoshape_text"></textarea>`,
				`<br><button id="aa_posetoshape_close">close</button>`,
				`</dialog>`
			].join("\n");
			string += `\n<div id="aa_animator_div"></div>`;
			//
			document.getElementById("aa_div").innerHTML = string;
			//
			aa.div.editmodetrue_active = document.getElementById("aa_editmodetrue_active");
			// the _active divs are used to make sure the height of
			// the active area is always the same, so the ui doesn't
			// jump around when you switch modes.
			aa.div.editmodetrue = document.getElementById("aa_editmodetrue");
			// hide everything in the part artist inside a div.
			aa.div.editmodetrue.hidden = true;
			ref = aa.pa.ctx;
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aapa_" + i1;
					let canvas = document.getElementById(id);
					canvas.style["image-rendering"] = "crisp-edges";
					ref[i1] = canvas.getContext("2d");
					if(i1 === "ui") {
						//canvas.addEventListener("mousedown", aa.pa.ui.mousedown);
						canvas.onpointerdown = aa.pa.ui.mousedown;
					}
					else {
						//canvas.addEventListener("mousedown", aa.pa.mousedown);
						//canvas.addEventListener("mousemove", aa.pa.mousemove);
						//canvas.addEventListener("mouseup", aa.pa.mouseup);
						canvas.onpointerdown = aa.pa.mousedown;
						canvas.onpointermove = aa.pa.mousemove;
						canvas.onpointerup = aa.pa.mouseup;
					}
				}
			};
			loop.end();
			//
			for(i1 = 0; i1 < 2; i1++) {
				loop.tick(1);
				let ref = aa.pa.part[i1 ? "right" : "front"];
				let temp = aa.pa.part.rect(i1);
				temp = temp.w*temp.h;
				for(i2 = 0; i2 < temp; i2++) {
					loop.tick(2);
					ref[i2] = 0;
				};
				loop.end();
			}
			loop.end();
			// the initial defining has the image as an empty array. this
			// multiplies the right dimensions to create an array of zeroes, of
			// the right length
			aa.pa.redraw();
			aa.pa.ui.create();
			aa.pa.ui.draw();
			// aa.pa initialized.
			//
			ref = aa.ctx;
			aa.div.editmodefalse = document.getElementById("aa_editmodefalse");
			// enclose it all in another div, so it can switch which one is
			// hidden.
			aa.div.editmodefalse_active = document.getElementById("aa_editmodefalse_active");
			for (i1 in ref) {
				loop.tick(1);
				if (ref.hasOwnProperty(i1)) {
					let id = "aa_" + i1;
					let canvas = document.getElementById(id);
					canvas.style["image-rendering"] = "crisp-edges";
					ref[i1] = canvas.getContext("2d");
					if(i1 === "ui") {
						//canvas.addEventListener("mousedown", aa.ui.mousedown);
						canvas.onpointerdown = aa.ui.mousedown;
					}
					else {
						//canvas.addEventListener("mousedown", aa.mousedown);
						//canvas.addEventListener("mousemove", aa.mousemove);
						//canvas.addEventListener("mouseup", aa.mouseup);
						canvas.onpointerdown = aa.mousedown;
						canvas.onpointermove = aa.mousemove;
						canvas.onpointerup = aa.mouseup;
						// like mouse events, except they work for phones and
						// drawing tablets.
						canvas.style["touch-action"] = "none";
						// this keeps it from sliding around when you're using a
						// phone.
						AAX.dragndrop(canvas, aa.readfile);
						// lets you load things by dropping files onto the
						// canvas.
					}
				}
			};
			loop.end();
			aa.div.coor = document.getElementById("aa_div_coor");
			aa.div.coor.style["text-shadow"] = "silver .5px .5px";
			aa.div.coor.style["font-size"] = "8px";
			aa.writecoordinates(null);
			let temp = document.getElementById("aa_bodytext");
			temp.value = aa.bodytext;
			textarea_autosize(temp);
			temp.onkeydown = function(e) {
				textarea_tab(e);
				textarea_autosize(e);
			};
			temp.rows = temp.value.split("\n").length;
			temp.style["-moz-tab-size"] = 4;
			temp.style["vertical-align"] = "top";
			temp = document.getElementById("aa_posetext");
			temp.rows = temp.value.split("\n").length;
			temp.style["-moz-tab-size"] = 4;
			temp.style["vertical-align"] = "top";
			string = [];
			for(i1 in AAX.Body.templates) {
				if(AAX.Body.templates.hasOwnProperty(i1)) {
					string[string.length] = `<option value="` + i1 + `">` + i1 + `</option>`;
				}
			}
			string = [
				`<option value="current">current</option>`,
				`<hr>`
			].concat(string).concat([
				`<hr>`,
				`<option value="custom">custom</option>`
			]);
			temp = document.getElementById("aa_bodychoices");
			temp.innerHTML += `\n\t` + string.join(`\n\t`) + `\n`;
			temp.onchange = function() {
				let name = document.getElementById("aa_bodychoices").value;
				let ref = document.getElementById("aa_bodytext");
				if(name === "current") {
					ref.value = aa.bodytext;
					textarea_autosize(ref);
				}
				else if(AAX.Body.templates.hasOwnProperty(name)) {
					ref.value = AAX.Body.templates[name];
					textarea_autosize(ref);
				}
				else if(name !== "custom") {
					console.log("this shouldn't happen");
				}
			};
			document.getElementById("aa_bodytext").onkeyup = function() {
			// using keyup instead of change, since this changes the bodychoices
			// selection, and the bodychoices selection edits the body textarea.
			// that could cause an infinite loop.
				let value = document.getElementById("aa_bodytext").value;
				let options = document.getElementById("aa_bodychoices").options;
				let bool = false;
				let select = "custom";
				if(value === aa.bodytext) {
					select = "current";
				}
				else {
					for(let i1 = 0; i1 < options.length && select === "custom"; i1++) {
						let name = options[i1].innerHTML;
						if(name !== "custom" && name !== "current" && value === AAX.Body.templates[name]) {
							// if the body textarea matches the value of an option,
							// select that option.
							select = name;
						}
					}
				}
				document.getElementById("aa_bodychoices").value = select;
			}
			document.getElementById("aa_bodychanges").addEventListener("pointerdown", function() {
				let text = document.getElementById("aa_bodytext").value;
				let body = AAX.Body.new(text);
				if(typeof body !== "object") {
				// errors from invalid input
					alert(body);
				}
				else if(confirm([
					`if you change the body text, the poses will be edited to fit the new body.`,
					`- ALL UNDO/REDO HISTORY will be cleared.`,
					`- all poses will be converted to a blank pose, carrying over whatever it can from the old version of itself. (properties, what the coordinates' length and angle are relative to how they are in the default pose)`,
					`continue?`
				].join(`\n\n`))) {
					let i1 = 0;
					let i2 = 0;
					let i3 = 0;
					let old_rel = AAX.all_rel(aa.body);
					let old_abs = AAX.all_abs(aa.body);
					// the coordinates every part had in the old body's default
					// pose
					let old_body = aa.body;
					aa.bodytext = text;
					aa.body = body;
					if(aa.body.hasOwnProperty("head")) {
						aa.drawsettings.vp.y = aa.drawsettings.standpoint.y + AAX.abscoor(aa.body, "head")[1];
					};
					// set the camera at eye level
					for(i1 = 0; i1 < aa.anims.length; i1++) {
					// for every frame of every animation, edit the coordinates
					// to be like they're derivative of the new body instead of
					// the old body.
					// - don't use the anim_index setter. it'd be convenient in
					//   some ways, but that makes it use AAX.posefromobj with
					//   the new body instead of the old. that causes errors if
					//   the structure is different.
						let anim = aa.anims[i1];
						anim.states = [ anim.states[ anim.state_index ] ];
						anim.state_index = 0;
						// delete undo/redo history (i don't think it'd cause
						// problems if i converted it like everything else, but
						// it's wasteful to bother with every state when most of
						// them won't be used.)
						// - most importantly, the body change itself doesn't
						//   fit in the undo/redo system at all, so... there's
						//   not much point in previous states if they still
						//   have the biggest possible change applied despite
						//   being before it.
						let poseobjs = anim.states[ anim.state_index ].poseobjs;
						for(i2 = 0; i2 < poseobjs.length; i2++) {
							let pose = AAX.posefromobj(aa, old_body, poseobjs[i2]);
							// they have to be AAX.Parts at the time, or
							// coordinate setters and stuff like abscoor won't
							// run.
							let old_odd = AAX.all_abs(pose);
							for(i3 in old_odd) {
								if(old_odd.hasOwnProperty(i3)) {
									old_odd[i3] = [
										!!(old_odd[i3][0]%1) !== !!(old_abs[i3][0]%1),
										!!(old_odd[i3][1]%1) !== !!(old_abs[i3][1]%1),
										!!(old_odd[i3][2]%1) !== !!(old_abs[i3][2]%1)
									];
								}
							}
							let old_pose_rel = AAX.all_rel(pose);
							//
							let oldpose = AAX.poseobj(pose);
							// non-default stuff in the old pose
							let newpose = AAX.poseobj(aa.newpose());
							// default pose of the new body
							for(i3 in oldpose) {
								if(oldpose.hasOwnProperty(i3) && newpose.hasOwnProperty(i3)) {
								// copy properties, but only for parts shared
								// between old and new
									delete oldpose[i3].cache;
									// cache is obsolete after the body change
									let relcoor = AAX.relcoor(newpose[i3]);
									delete oldpose[i3].x;
									delete oldpose[i3].y;
									delete oldpose[i3].z;
									// these would overwrite the relative
									// coordinates. it needs to start from the
									// new body's default pose. the coordinates
									// part of the pose will be done in
									// AAX.bodychange.
									newpose[i3] = structuredClone(oldpose[i3]);
									newpose[i3].x = relcoor[0];
									newpose[i3].y = relcoor[1];
									newpose[i3].z = relcoor[2];
								}
							}
							poseobjs[i2] = AAX.bodychange(aa, aa.body, newpose, old_rel, old_pose_rel, old_odd);
							// copy the coordinate parts of the pose
							//console.log(objectdifference(logging, AAX.poseobj(pose)));
							if(i1 === aa.anim_index) {
								aa.frames[i2] = aa.posefromobj(poseobjs[i2]);
							};
						}
					}
					//aa.loadstate(aa.state_index, true);
					if(!aa.body.hasOwnProperty(aa.control.partname)) {
					// can't have partname be a part that doesn't exist anymore.
						let done = false;
						for(i1 in aa.body) {
							if(aa.body.hasOwnProperty(i1) && !done && aa.body[i1].parent === "standpoint") {
								aa.control.partname = i1;
								done = true;
							}
						}
						if(!done) {
							console.log("this shouldn't happen");
						}
					}
					aa.refresh("states");
					// it'd be redundant to make a new state.
				};
			});
			document.getElementById("aa_posechanges").addEventListener("pointerdown", function() {
				let text = document.getElementById("aa_posetext").value;
				if(aa.control.all_frames_posetext) {
					text = text.split("\n***\n");
					aa.frames = [];
					for(let i1 = 0; i1 < text.length; i1++) {
						aa.frames[i1] = aa.texttopose(text[i1]);
					};
					aa.clampframe();
				}
				else {
					aa.frames[aa.currframe] = aa.texttopose(text);
					// can't use currpose because that's just a getter.
				};
				aa.refresh();
			});
			document.getElementById("aa_allframes").addEventListener("pointerdown", function(e) {
				aa.control.all_frames_posetext = !aa.control.all_frames_posetext;
				e.target.innerHTML = `show ` + (aa.control.all_frames_posetext ? `one frame` : `all frames`);
				aa.refresh(["draw", "ui", "states"]);
				aa.filldatatext();
			});
			// div creation, non-canvas buttons
			document.getElementById("aa_editshape_enter").onpointerdown = function(e) {
				let shape = AAX.Shape.new(document.getElementById("aa_editshape_input").value, aa.currpose, aa.control.partname);
				if(shape) {
					aa.control.part.shape = structuredClone(shape);
					aa.refresh();
					// don't skip anything
				}
				else {
					alert(`invalid shape input.`);
				};
				document.getElementById("aa_editshape_input").value = "";
				document.getElementById("aa_editshape_dialog").close();
			};
			document.getElementById("aa_editshape_close").onpointerdown = function(e) {
				document.getElementById("aa_editshape_input").value = "";
				document.getElementById("aa_editshape_dialog").close();
			};
			document.getElementById("aa_posetoshape_close").onpointerdown = function(e) {
				document.getElementById("aa_posetoshape_text").value = "";
				document.getElementById("aa_posetoshape_dialog").close();
			};
			let body = aa.body;
			if(typeof body !== "object") {
				alert(body);
				return;
			};
			for(i1 in body) {
				loop.tick(1);
				if(body.hasOwnProperty(i1) && body[i1].parent === "standpoint") {
					aa.control.partname = i1;
				}
			}
			loop.end();
			if((aa.control.partname ?? null) === null) {
				console.log("invalid initial body text.");
				return;
			};
			aa.drawsettings.vp.x = aa.drawsettings.standpoint.x;
			if(aa.body.hasOwnProperty("head")) {
				aa.drawsettings.vp.y = aa.drawsettings.standpoint.y + AAX.abscoor(aa.body, "head")[1];
			}
			else {
				aa.drawsettings.vp.y = Math.floor(aa.drawsettings.vp.y/2);
			}
			// this has to be done here so that head is fully defined
			aa.anims[0] = aa.newanim();
			let canvas = aa.ctx.main.canvas;
			canvas.addEventListener("mousedown", aa.mousedown);
			canvas.addEventListener("mousemove", aa.mousemove);
			canvas.addEventListener("mouseup", aa.mouseup);
			aa.ctx.main.font = "6px 'thick 4x4'";
			aa.ui.create();
			aa.control.projectname = "aa " + filedate() + " " + aa.control.projectname;
			aa.anim_index = 0;
			// it was already 0, but the setter will fill aa.frames.
			temp = {
				html: structuredClone(Animator.template_html),
			};
			temp.index = temp.html.indexOf("#save_frame");
			temp.index = temp.html.findLastIndex((element, index) => element.trim() === "<br>" && index < temp.index);
			temp.index = temp.index === -1 ? temp.html.length : temp.index;
			temp.html.splice(temp.index, 0, [
				"\n<br><button name=\"update\">update</button>",
				"<label><input type=\"checkbox\" name=\"one view\"> one view</label>",
				"<label><input type=\"checkbox\" name=\"vertical\"> vertical</label>",
			].join("\n"));
			aa.animator = new Animator(document.getElementById("aa_animator_div"), temp.html);
			ref = aa.animator;
			ref.html.update.onclick = function(e) {
				aa.updateanimation();
				if(ref.sheet.vertical.checked !== ref.html.vertical.checked) {
					ref.sheet.vertical.click();
				};
			};
			ref.html.one_view.oninput = function(e) {
				ref.html.vertical.click();
			};
			ref.html.vertical.oninput = function(e) {
				let skip = structuredClone(AAX.valid.refresh);
				skip.splice(skip.indexOf("ui"), 1);
				aa.refresh(skip);
			};
			// - changing one view almost always means changing the axis
			// - both of these have counterpart buttons in the px export area of
			//   the ui canvas, so trigger a ui refresh.
			ref.sheet.vertical.parentElement.hidden = true;
			ref.html.vertical.checked = true;
			ref.sheet.vertical.checked = true;
			// why am i making such a weird and stupid split, you ask?
			// - well, the vertical checkbox that comes preloaded with Animator
			//   automatically rearranges the sheet. wow, so nifty. EXCEPT.
			// - if the user updates the animation with one view and vertical
			//   off... that's an animation where multiviews are lined up
			//   horizontally.
			// - so that means a stupidly long and confusingly organized
			//   spritesheet. fuck that! to fix that, the views should be lined
			//   up vertically in that case.
			// - updateanimation does this. but updateanimation does not run for
			//   every time sheet.vertical is clicked. so, if your last update
			//   was a multiview, clicking sheet.vertical after that is
			//   guaranteed to make a stupidly long or tall spritesheet, making
			//   all of that foresight pointless.
			// - so the relationship these two boxes have is that html.vertical
			//   is a less dynamic substitute for sheet.vertical. this way, the
			//   user has to update the animation to change the axes of the
			//   spritesheet.
			ref.loop = true;
			ref.sheet.wrap.value = 0;
			for(i1 = 0; i1 < 2; i1++) {
				let canvas = i1 ? ref.sheet.canvas : ref.canvas;
				canvas.style["image-rendering"] = "crisp-edges";
				canvas.ondragover = function(e) {
					e.preventDefault();
				};
				canvas.ondrop = function(e) {
					e.preventDefault();
				};
				// it's easy to mistake these canvases for the main canvas. for
				// me, it opens the txt in the browser, ie i have to hit back to
				// return to where i was. depending on your browser, that might
				// be the same as refreshing the page and wiping everything you
				// did.
			}
			//
			aa.refresh("states");
			aa.updateanimation();
		},
		editmodetoggle: function() {
			let div = [
				aa.div.editmodefalse,
				aa.div.editmodetrue
			];
			let activediv = [
				aa.div.editmodefalse_active,
				aa.div.editmodetrue_active
			];
			activediv[0].height = undefined;
			activediv[1].height = undefined;
			const h = Math.max(activediv[0].getBoundingClientRect().height, activediv[1].getBoundingClientRect().height);
			aa.control.editmode = !aa.control.editmode;
			div[Number(!aa.control.editmode)].hidden = true;
			div[Number(aa.control.editmode)].hidden = false;
			//activediv[Number(aa.control.editmode)].style.height = h;
			// i went to the trouble of creating separate "active area" divs,
			// and this doesn't even work. oh well.
			// - the problem is that .height is not how you change heights. i
			//   don't know how you do this.
		},
		filldatatext: function() {
			document.getElementById("aa_bodychoices").value = "current";
			let textarea = document.getElementById("aa_bodytext");
			textarea.value = aa.bodytext;
			// you'd think the event listener would do this, but it seems like
			// onchange doesn't fire just from .value being changed.
			textarea.rows = aa.bodytext.split("\n").length;
			// the body textarea should generally be aa.bodytext, but i don't
			// want to reset it to that in the "apply body changes" event
			// listener because that's a really bad time to clear their input...
			// (the two instances where it doesn't use the body text are when
			// the body text has a syntax error, and when the user changes their
			// mind so they don't clear the frames. in neither case should their
			// input be wiped.)
			let text = "";
			if(aa.control.all_frames_posetext) {
				text = [];
				for(let i1 = 0; i1 < aa.poseobjs.length; i1++) {
					text[i1] = aa.poseobjtotext(aa.poseobjs[i1]);
				}
				text = text.join("\n***\n");
				// it isn't super efficient to calculate every one of them
				// but..! tragically..! i can't give a shit about that!
				// - i'd have to create a second array that has to be spliced
				//   with the main array, or create a {pose, text} structure
				//   that's annoying and dumb in its own right. especially since
				//   there's nothing guaranteeing that the text stay accurate.
				// - maybe i'll do it if i ever have a third thing to store per
				//   frame. i'll make sure to have a getter structure, where
				//   _text gets set as null every refresh, and the getter
				//   generates it again if it's null
			}
			else {
				text = aa.poseobjtotext(aa.currposeobj);
			};
			textarea = document.getElementById("aa_posetext");
			textarea.value = text;
			textarea.rows = text.split("\n").length;
		},
		refresh: function(skip) {
		// refreshes everything to account for changes.
		// - multiview
		// - ui graphics
		// - pose text textarea
		// - .images
		// =
		// - i should add arguments for specifying which changes there were. or
		//   which there weren't, probably.
		//   - pose
		//   - ui graphics
		//   - pose text
		// - skip: string or array of strings for specifying steps that should
		//   be skipped. it should be one of the strings in .valid.refresh.
		//   - "draw": .draw, and saving aa.images
		//   - "ui": ui.draw
		//   - "states": updating bodytext/posetext, and adding to the .states
		//     array that undo/redo use. (this one's used the most often. lots
		//     of actions cause .refresh, but not all of those are worth being
		//     undo-able.)
		//     - datatext used to be a separate skip thing, but 90% of the time,
		//       it's skipped when states are. use aa.filldatatext for the
		//       remaining 10%.
			let starttime = new Date().valueOf();
			let i1 = 0;
			let loop = new Loop("aa.refresh");
			if(typeof skip === "string") {
				skip = [skip];
			}
			else if(!Array.isArray(skip)) {
				skip = [];
			}
			if(!skip.includes("draw")) {
				aa.draw_background();
				aa.draw();
				const ctx = aa.ctx.main;
				const cell = aa.drawsettings.cell;
				aa.images = [];
				for(i1 = 0; i1 < 4; i1++) {
					loop.tick(1);
					aa.images[i1] = ctx.getImageData(cell.w*i1, 0, cell.w, cell.h);
				}
				loop.end();
				// save images, which are used to reverse graphical changes in
				// the clickable interface
			};
			if(!skip.includes("ui")) {
				aa.ui.draw();
			};
			if(!skip.includes("states")) {
				aa.savestate();
				aa.filldatatext();
			};
			//console.log("aa.refresh() took " + (new Date().valueOf() - starttime)/1000 + " seconds.");
		},
		box: function(size, oddness) {
		// uses size and oddness to return a box centered on [0, 0, 0], with the
		// right dimension changes from oddness.
		// - even number sizes get +1 if the dimension is odd, odd numbers get
		//   -1 if the dimension is odd.
			let dim = [
				AAX.onedim(size, oddness[0]),
				AAX.onedim(size, oddness[1]),
				AAX.onedim(size, oddness[2])
			];
			return {
				x: -(dim[0] - 1)/2,
				y: -(dim[1] - 1)/2,
				z: -(dim[2] - 1)/2,
				w: dim[0],
				h: dim[1],
				d: dim[2],
			};
		},
		rect: function(size, oddness, right) {
			if(oddness.length === 3) {
				oddness = [oddness[0], oddness[right ? 2 : 1]];
			};
			let rect = aa.box(size, oddness);
			delete rect.z;
			delete rect.d;
			return rect;
		},
		hypot: (partname, deform) => AAX.hypot(aa.body, aa.currpose, partname, deform),
		//AAX.image_oddness(body, name, view);
		//AAX.onedim(size, odd)
		//aa.box(size, oddness)
		//AAX.l_dim(length, oddness, right)
		//AAX.dim(body, part, view, length, size)
		//aa._rect(size, oddness, right)
		//aa.hypot(partname, deform)
		movecoor: function(part, hypot, coor1, coor2, sign3, axes) {
		// what the main move mode uses. returns a full set of coordinates,
		// relative to the parent.
		// - coor1, coor2, axes: new relative coordinates for both axes, and a
		//   two-letter string for what axes those are.
		//   - axes should be a two-letter string of the axes coor1 and coor2
		//     are.
		// - it applies move1 and move2 to the relative coordinates it already
		//   had, then calculates the third axis by what fits within the
		//   hypotenuse, has a Math.sign matching sign3, and has the same
		//   posmod(coordinate, 1)s as before.
		// - NOTE this is not allowed to move in decimal numbers. that's what
		//   oddify is for.
		// - this is used to display numbers on the screen, too.
			let i1 = 0;
			if(typeof axes !== "string" || axes.length < 2 || !"xyz".includes(axes[0]) || !"xyz".includes(axes[1]) || axes[0] === axes[1]) {
				console.log("invalid axes.");
				return;
			}
			else if(![-1, 1].includes(sign3)) {
				console.log("invalid sign3. must be 1 or -1.");
			};
			hypot ??= aa.hypot(part.name);
			// reference the hypotenuse in body (using the pose's hypotenuse
			// would make it subject to rounding decay)
			let axis1 = "xyz".indexOf(axes[0]);
			let axis2 = "xyz".indexOf(axes[1]);
			let axis3 = "xyz".indexOf( "xyz".replace(axes[0], "").replace(axes[1], "") );
			let float = part.rel_oddness;
			float = [
				float[0]/2,
				float[1]/2,
				float[2]/2
			];
			const old_relcoor = part.relcoor;
			const diff = [
				Math.round( (old_relcoor[axis1] - coor1) *2)/2,
				Math.round( (old_relcoor[axis2] - coor2) *2)/2
			];
			if(diff[0] === 0 && diff[1] === 0) {
			// no change
				return old_relcoor;
			}
			else if(
				!Number.isInteger( diff[0] )
				||
				!Number.isInteger( diff[1] )
			) {
				console.log("invalid coor1 or coor2. the difference between them and the original must be an integer.");
				return;
			};
			let point = structuredClone(old_relcoor);
			point[axis1] = coor1;
			point[axis2] = coor2;
			let temp = (hypot + .5)**2 - (point[axis1]**2 + point[axis2]**2);
			point[axis3] = (
				temp <= 0
				?
				0
				// fixfloats will take care of trimming the other two.
				:
				sign3*Math.sqrt(temp)
			);
			point = AAX.fixfloats(point, float, hypot, true, "hypot");
			// list of valid points, sorted by highest hypotenuse first
			if(diff[0] === 0) {
			// pick the first point whose axis1 is still the same as it is in
			// old_relcoor (if you didn't move it in that axis, you wouldn't
			// expect a change in that axis. but the math in fixfloats sort of
			// encourages that.)
				for(i1 = 0; i1 < point.length; i1++) {
					if(point[i1][axis1] === old_relcoor[axis1]) {
						return point[i1];
					}
				}
			}
			else if(diff[1] === 0) {
				for(i1 = 0; i1 < point.length; i1++) {
					if(point[i1][axis2] === old_relcoor[axis2]) {
						return point[i1];
					}
				}
			}
			return point[0];
		},
		rotatecoor: function(fulcrum, axis, magnitude) {
		// returns new relative coordinates for all parts involved in a
		// rotation. (like .movecoor and .oddify, it does not modify the pose,
		// just shows how it should be modified.)
		// - fulcrum: name of the part that acts as a fulcrum, with all
		//   descendants rotating around it
		// - axis, magnitude: 3d angle to revolve them around, and how much to
		//   revolve it by.
			let i1 = 0;
			const curl = aa.control.rotate.curl;
			let basis = Quat.basis(Quat.new(axis, magnitude));
			let temp = Angle.numbers(axis);
			let zeroaxis = -1;
			// which axis should have no change, if any
			let switchaxis = -1;
			// used for float switching.
			for(i1 = 0; i1 < 3; i1++) {
				temp[i1] = roundspecial(temp[i1]);
			}
			for(i1 = 0; i1 < 3; i1++) {
				if(
					zeroaxis === -1
					&&
					temp[i1]
					&&
					!temp[(i1 + 1)%3] && !temp[(i1 + 2)%3]
				) {
					zeroaxis = i1;
				};
				if(
					switchaxis === -1
					&&
					Math.abs(temp[i1]) > Math.abs(temp[(i1 + 1)%3])
					&&
					Math.abs(temp[i1]) > Math.abs(temp[(i1 + 2)%3])
				) {
					switchaxis = i1;
				};
			}
			if(!(Math.floor(4*posmod(magnitude/(2*Math.PI) + 1/8, 1))%2)) {
			// closer to 0 or 180 than 90 or 270
				switchaxis = -1;
			}
			else if(switchaxis !== -1) {
				let perfectaxis = [0, 0, 0];
				perfectaxis[switchaxis] = Math.sign(temp[switchaxis]);
				// +x axis, -x axis, +y axis, etc. whatever perfectly 2d axis
				// the axis is closest to.
				if(Angle.compare(axis, Angle.get(...perfectaxis)) >= 2*Math.PI/8) {
				// Angle.compare is the 2d angle difference between the perfect
				// axis and the axis it's rotating by.
				// - picture a sphere, picture six circles being painted on the
				//   surface, starting from each axis and negative axis angle.
				//   they stop expanding just before they meet.
				// - if the axis isn't in any of those circles, it gives up on
				//   float switching.
					switchaxis = -1;
				};
			};
			//console.log("magnitude: " + Angle.convert(magnitude) + "\nswitchaxis: " + switchaxis);
			// switchaxis and float switching
			// - rotated coordinates keep the same oddness they had before.
			// - but if the coordinates of a part are, say, [7, 3.5], and you
			//   rotate it 90, you expect it to become [-3.5, 7], right.
			// - so, if the axis only affects two coordinates, and the magnitude
			//   is closer to 90 or 270 than 0 or 180... for the "make sure it
			//   has these floats" process, the targeted floats should be
			//   switched, right?
			//   - of course, the math for that "closer to 90/270" process is
			//     freakishly obtuse.
			//     - the result of that posmod should be 0 to .25 if it's
			//       closest to 0 degrees, .25 to .5 if it's closest to 90, etc
			//     - the +1/8 centers it. 0 degrees becomes the middle of the
			//       "closest to 0 degrees" quadrant
			//     - it's always weird when you come across this kind of math.
			//       problems that don't require any kind of advanced
			//       understanding, but require really incomprehensible logic
			//       just because... i dunno... it's a blind spot in our typical
			//       math operations, i guess. i'd make a function, but i can't
			//       even picture myself needing this again.
			// - but hell, that should apply even if it isn't a perfectly 2d
			//   axis. all rotate/tilt axes are equated to x, y, or z, after
			//   all. and most of the time, it's gonna be pretty close.
			// - so, whichever 2d axis it's closest to... for the purposes of
			//   this float switching, it'll pretend it's that perfectly 2d
			//   axis.
			temp = AAX.getdesc(aa.currpose, fulcrum);
			if(!temp.length) {
			// there's no parts to rotate.
				return {};
			};
			let body = {};
			for(i1 = 0; i1 < temp.length; i1++) {
				body[ temp[i1] ] = aa.currpose[ temp[i1] ].relcoor;
			}
			// all that matters is the relative coordinates of the fulcrum's
			// descendants.
			for(let part in body) {
				if(body.hasOwnProperty(part)) {
					body[part] = [
						Math.trunc(body[part][0]*2)/2,
						Math.trunc(body[part][1]*2)/2,
						Math.trunc(body[part][2]*2)/2
					];
					let hypot = aa.hypot(part, true);
					let float = [
						posmod(body[part][0], 1),
						posmod(body[part][1], 1),
						posmod(body[part][2], 1)
					];
					if(switchaxis !== -1) {
						let temp = float[(switchaxis + 1)%3];
						float[(switchaxis + 1)%3] = float[(switchaxis + 2)%3];
						float[(switchaxis + 2)%3] = temp;
					};
					let point = Basis.apply(basis, body[part]);
					if(curl) {
						let _part = aa.currpose[part].parent;
						while(_part && _part !== fulcrum && _part !== "standpoint") {
							point = Basis.apply(basis, point);
							_part = aa.currpose[_part].parent;
						}
					}
					let array = AAX.fixfloats(point, float, hypot, true);
					point = null;
					if(zeroaxis !== -1) {
						for(i1 = 0; point === null && i1 < array.length; i1++) {
							if(array[i1][zeroaxis] === body[part][zeroaxis]) {
								point = structuredClone(array[i1]);
							}
						}
					}
					point ??= array[0];
					// if none of them matched the zeroaxis thing, just pick the
					// the first one.
					body[part] = structuredClone(point);
				}
			};
			return body;
		},
		coortocanvas: (point, view, nonulls, viewoffset) => AAX.coortocanvas(aa.drawsettings.cell, aa.drawsettings.standpoint, point, view, nonulls, viewoffset),
		coorfromcanvas: (x, y, view) => AAX.coorfromcanvas(aa.drawsettings.cell, aa.drawsettings.standpoint, x, y, view),
		newpose: () => AAX.newpose(aa, aa.body),
		frameclone: (frame) => AAX.poseclone(aa, aa.body, aa.frames[frame]),
		posefromobj: (obj) => AAX.posefromobj(aa, aa.body, obj),
		posetext: function(frame, anim_index) {
		// converts a pose to text.
		// - use the poseobj so it only keeps the data worth keeping
		// - convert images to text
		// - objtotext
			anim_index ??= aa.anim_index;
			let anim = aa.anims[anim_index];
			let state = anim.states[anim.state_index];
			frame ??= state.currframe;
			return aa.poseobjtotext(state[frame]);
		},
		poseobjtotext: function(_obj) {
			_obj ??= aa.currposeobj;
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let loop = new Loop("aa.posetext");
			let obj = structuredClone(_obj);
			// clone it, since it'll be edited
			for(i1 in obj) {
				loop.tick(1);
				if(obj.hasOwnProperty(i1)) {
					delete obj[i1].cache;
					// by definition, cache does not save anything worth saving.
					// it'd clutter up the posetext too.
					for(i2 = 0; i2 < 2; i2++) {
					// stringify all images.
					// - remember, AAX.poseobj omits "default"s, empty objects,
					//   and objects with nothing but "default"s, so the logic
					//   has to account for that weird structure.
						loop.tick(2);
						let temp = i2 ? "perspective" : "image";
						if(obj[i1].hasOwnProperty(temp) && typeof obj[i1] === "object" && obj[i1]) {
							const imageobj = obj[i1][temp];
							for(i3 in imageobj) {
								loop.tick(3);
								if(imageobj.hasOwnProperty(i3)) {
									let view = Number(i3);
									view = isNaN(i3) ? i3 : view;
									if(AAX.valid.view.includes(view) && !["default", null].includes(imageobj[view])) {
									// without the help of AAX..dim, it is a
									// bitch to get the right dimensions.
										const w = AAX.l_dim(imageobj[view].length, AAX.partobj_image_oddness(aa.body, i1, obj[i1], view))[0];
										imageobj[view] = "\n" + Raster.totext(imageobj[view], w) + "\n";
										// add line breaks so it doesn't have an
										// awkward indentation skew at the first
										// line. (fromtext uses .trim(), so it's
										// fine.)
									}
								}
							}
							loop.end();
						}
					}
					loop.end();
				}
			};
			loop.end();
			return objtotext(obj);
			// bracketindent JSON.stringify-s when used with an object
		},
		texttopose: function(text) {
			let i1 = 0;
			let loop = new Loop("aa.texttopose");
			let obj = texttoobj(text);
			// this should be the same as a poseobj object, except the images
			// are text.
			for(i1 in obj) {
				loop.tick(1);
				if(obj.hasOwnProperty(i1)) {
					obj[i1].cache = structuredClone(AAX.cache_init);
					// the text omitted the cache, so recreate it.
					for(i2 = 0; i2 < 2; i2++) {
					// unstringify all images.
						loop.tick(2);
						let temp = i2 ? "perspective" : "image";
						if(obj[i1].hasOwnProperty(temp) && typeof obj[i1] === "object" && obj[i1]) {
							const imageobj = obj[i1][temp];
							for(i3 in imageobj) {
								loop.tick(3);
								if(imageobj.hasOwnProperty(i3)) {
									let view = Number(i3);
									view = isNaN(i3) ? i3 : view;
									if(AAX.valid.view.includes(view) && !["default", null].includes(imageobj[view])) {
										const w = pose[i1].dim(view)[0];
										imageobj[view] = Raster.fromtext(imageobj[view]).raster;
									}
								}
							}
							loop.end();
						}
					}
					loop.end();
				}
			};
			loop.end();
			return aa.posefromobj(obj);
		},
		draw_background: function(viewtype, side_tint_invert) {
			AAX.draw_background(aa.ctx.main, aa.drawsettings, aa.color, aa.control.perspectived, viewtype ?? "multi4", side_tint_invert);
		},
		draw: function(viewtype, rotatecoor, basis) {
			viewtype ??= "multi4";
			AAX.draw(
				aa.ctx.main, aa.drawsettings, aa.color, aa.control.perspectived, viewtype,
				aa.currpose, viewtype === "multi4" ? aa.nodes : null, aa.control.strokecache, rotatecoor, basis
			);
		},
		save: function() {
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let obj = {
				version: aa.version,
				// doesn't do anything, but it's useful information.
				anim_index: aa.anim_index,
				bodytext: aa.bodytext,
				drawsettings: structuredClone(aa.drawsettings),
				color: structuredClone(aa.color),
				states_limit: aa.states_limit,
				states_truncator: aa.states_truncator,
				// you can't save settings/preferences on a web tool, so i'd
				// like to get as close as i can.
			};
			// then, integer properties are animations.
			delete obj.drawsettings.viewer;
			// this is a getter.
			for(i1 = 0; i1 < aa.anims.length; i1++) {
				let ref = aa.anims[i1];
				obj[i1] = {name: ref.name};
				ref = ref.states[ref.state_index];
				for(i2 in ref) {
					if(ref.hasOwnProperty(i2)) {
					// copy every aspect of the state
						obj[i1][i2] = structuredClone(ref[i2]);
					}
				}
				// keep only the name and the current state.
				// - make sure the name is the first property
				ref = ref.poseobjs;
				for(i2 = 0; i2 < ref.length; i2++) {
				// for every frame,
					for(i3 in ref[i2]) {
						if(ref[i2].hasOwnProperty(i3)) {
						// every part,
							delete obj[i1].poseobjs[i2][i3].cache;
							// delete cache.
						}
					}
				}
			};
			AAX.save(aa.control.projectname + ".txt", objtotext(obj));
		},
		load: function() {
			AAX.load(aa.readfile);
		},
		readfile: function(file) {
		// run by load and the drag-and-drop event listener.
			if(!file) {
				console.log("this shouldn't happen");
				return;
			};
			aa.control.projectname = filename_handler(file.name);
			let reader = new FileReader();
			reader.onload = function() {
				file = texttoobj(reader.result);
				if(file) {
					let i1 = 0;
					let i2 = 0;
					let i3 = 0;
					let body = AAX.Body.new(file.bodytext);
					if(typeof body === "object") {
					// errors from invalid input
						aa.bodytext = file.bodytext;
						aa.body = body;
					}
					else {
						alert("invalid bodytext: " + body);
					};
					aa.anims = [];
					for(i1 = 0; file.hasOwnProperty(i1); i1++) {
						aa.anims[i1] = aa.newanim();
						let ref = aa.anims[i1];
						ref.name = file[i1].name;
						ref.states = [structuredClone(file[i1])];
						delete ref.states[0].name;
						ref.state_index = 0;
						ref = ref.states[0].poseobjs;
						for(i2 = 0; i2 < ref.length; i2++) {
							for(i3 in ref[i2]) {
								if(ref[i2].hasOwnProperty(i3)) {
									ref[i2][i3].cache = structuredClone(AAX.cache_init);
								}
							}
						}
						// restore cache
					}
					aa._anim_index = file.anim_index;
					aa.loadstate(aa.state_index, true);
					// the anim_index setter can cause errors in rare cases.
					// specifically, if the anim_index was higher than the
					// number of animations the newly loaded project has. it'll
					// try to truncate the states of an animation that doesn't
					// exist.
					for(i1 in aa.drawsettings) {
						if(file.drawsettings.hasOwnProperty(i1)) {
							aa.drawsettings[i1] = structuredClone(file.drawsettings[i1]);
						};
					}
					for(i1 in aa.color) {
						if(file.color.hasOwnProperty(i1)) {
							aa.color[i1] = structuredClone(file.color[i1]);
						};
					}
					// you have to copy these property by property. if you
					// use structuredClone outright, it won't be the AAX
					// DrawSettings/Color class anymore.
					let temp = file.states_limit ?? null;
					if(Number.isInteger(temp) && temp >= 1) {
						aa.states_limit = temp;
					};
					temp = file.states_truncator ?? null;
					if(Number.isInteger(temp) && temp >= 0) {
						aa.states_truncator = temp;
					};
					aa.refresh();
				}
			};
			reader.readAsText(file);
		},
		randompose: function(parts) {
		// poses the given parts by a random rotation quaternion. NOTE this
		// isn't actually used anywhere, at the moment.
		// - parts can also be a number. that makes it choose random parts.
		// - i don't intend to make this a button anytime soon. randomization
		//   fits better with a more playful, toylike tool that armature artist
		//   is not... it'd look out of place.
		//   - maybe misc buttons that are like "select random part" and "create
		//     random rotation"? that's better, but it's still kinda weird.
		// - full random poses are nearly impossible. difficult to balance, and
		//   even more difficult to avoid them just being nonsense.
			let pose = aa.currpose;
			let order = AAX.getdesc(pose);
			parts = typeof parts === "string" ? [parts] : (Array.isArray(parts) || (Number.isInteger(parts) && parts >= 0)) ? parts : 1;
			if(typeof parts === "number") {
				let temp = structuredClone(order);
				let num = parts;
				parts = [];
				for(let i1 = 0; i1 < num && temp.length; i1++) {
					let index = Math.floor(Math.random()*temp.length);
					parts.push(temp[index]);
					temp.splice(index, 1);
				}
			};
			parts.sort((a, b) => order.indexOf(a) - order.indexOf(b));
			for(let i1 = 0; i1 < parts.length; i1++) {
				let part = pose[parts[i1]];
				let axis = Angle.rand();
				let magnitude = Math.random()**2;
				magnitude = posmod((Math.random() < .5 ? -1 : 1)*Math.PI*magnitude, 2*Math.PI);
				part.orient = Quat.rotate(part.orient, axis, magnitude);
				let desc = AAX.getdesc(pose, parts[i1]);
				let quat = Quat.new(axis, magnitude);
				for(let i2 = 0; i2 < desc.length; i2++) {
					let _part = pose[desc[i2]];
					_part.orient = Quat.rotate(_part.orient, axis, magnitude);
					let relcoor = Quat.apply(quat, _part.relcoor);
					for(let i3 = 0; i3 < 3; i3++) {
						_part["xyz"[i3]] += Math.trunc(relcoor[i3] - _part["xyz"[i3]]);
					}
				}
			};
			aa.refresh();
			return parts;
		},
	};
	//aa.initialize();
	//
	document.write(`<div id="bm_div"></div>`);
	let bm = {
	// tool for making bodytexts.
	// - this was written after the facial proportions tool, i just wanted it
	//   right after armature artist.
	// - if something isn't explained, chances are it's because there's an
	//   armature artist equivalent. read the comments there.
		bodydata: {},
		// stores data used to make bodytext.
		form_bodytext: function(bodydata) {
		// forms a bodytext from bodydata.
			let i1 = 0;
			bodydata ??= bm.bodydata;
			let text = [];
			let order = AAX.getchildren(bodydata);
			function addbranch(name, level) {
				level = Number.isInteger(level) && level > 0 ? level : 0;
				text.push(" ".repeat(level) + name + ": " + bodydata[name].x + ", " + bodydata[name].y + ", " + bodydata[name].z);
				for(let i1 in bodydata) {
					if(bodydata.hasOwnProperty(i1) && bodydata[i1].parent === name) {
						addbranch(i1, level + 1);
					}
				}
			}
			for(i1 = 0; i1 < order.length; i1++) {
				addbranch(order[i1]);
			}
			text = text.join("\n");
			text += "\n###";
			//
			order = AAX.getdesc(bodydata);
			// it's better to use getchildren/getdesc than to iterate through.
			// the order of iteration might not match the family tree if parts
			// were deleted or renamed.
			for(i1 = 0; i1 < order.length; i1++) {
				let _i1 = order[i1];
				if(bodydata[_i1].image_text.trim()) {
					text += "\n[ " + _i1 + " ]\n" + bodydata[_i1].image_text;
				}
			}
			text += "\n###";
			//
			for(i1 = 0; i1 < order.length; i1++) {
				let _i1 = order[i1];
				let symmetry = (
					bodydata[_i1].symmetry
					?
					"symmetry(" + (
						(bm.control.prefix1 === AAX.prefix1 && bm.control.prefix2 === AAX.prefix2)
						?
						""
						:
						bm.control.prefix1 + ", " + bm.control.prefix2
					) + ")"
					:
					""
				);
				let temp = bodydata[_i1].extra_text;
				if(symmetry) {
					temp = symmetry + (symmetry && temp ? "\n" : "") + temp;
				};
				if(temp) {
					text += "\n" + _i1 + ":\n\t" + temp.replaceAll("\n", "\n\t");
				};
			}
			//
			return text;
		},
		bodytext_change: function(text) {
		// used in the "apply changes" button and when loading a file. figures
		// out and applies everything needed to finalize the change, or alerts
		// the user if it ran into a problem.
			let i1 = 0;
			let i2 = 0;
			text ??= bm.bodytext;
			// whatever's in the bodytext textarea
			let obj = AAX.body_read.collect(text);
			if(typeof obj === "string") {
				alert(obj);
				return;
			};
			let data = {};
			let array = "parent x y z image_text extra_text".split(" ");
			let symmetry_found = false;
			// whether any parts are symmetrical. (gotta keep track of this so
			// it only saves the first prefix choice.)
			let prefix1 = AAX.prefix1;
			let prefix2 = AAX.prefix2;
			let prefix_schism = false;
			for(i1 in obj) {
				if(obj.hasOwnProperty(i1)) {
					data[i1] = bm.newpart();
					for(i2 = 0; i2 < array.length; i2++) {
						data[i1][ array[i2] ] = obj[i1][ array[i2] ];
					}
					let commands = AAX.body_read.extra_commands(data[i1].extra_text);
					for(i2 = 0; i2 < commands.length && !data[i1].symmetry; i2++) {
						let ref = commands[i2];
						if(ref.name === "symmetry") {
							let prefix = AAX.body_read.symmetry_prefixes(ref.content);
							prefix_schism = prefix_schism || (symmetry_found && (prefix[0] !== prefix1 || prefix[1] !== prefix2));
							if(!symmetry_found) {
								prefix1 = prefix[0];
								prefix2 = prefix[1];
							};
							symmetry_found = true;
							data[i1].symmetry = true;
						}
					}
					if(data[i1].symmetry) {
						data[i1].extra_text = bm.remove_symmetry(data[i1].extra_text, commands);
					}
				}
			}
			if(symmetry_found) {
			// ancestors with symmetry on override descendants with symmetry
			// on.
				let order = AAX.getdesc(data);
				for(i1 = 0; i1 < order.length; i1++) {
					let _i1 = order[i1];
					if(data[_i1].symmetry && AAX.getanc(data, _i1).some((element) => data[element].symmetry)) {
						data[_i1].symmetry = false;
					}
				}
			};
			//
			text = bm.form_bodytext(data);
			let body = AAX.Body.new(text);
			if(typeof body === "string") {
			// report Body.new errors
				alert(body);
				return;
			};
			//
			bm.bodydata = structuredClone(data);
			bm.control.prefix1 = prefix1;
			bm.control.prefix2 = prefix2;
			bm.control.partname = AAX.getchildren(body)[0];
			// select the first stem
			bm.refresh(null, text, body);
			// pass on the bodytext and body to refresh
		},
		remove_symmetry: function(text, commands) {
		// input an extra_text, and it'll slice out any symmetry() commands.
			commands ??= AAX.body_read.extra_commands;
			let offset = 0;
			// gotta keep track of how much you sliced out, so the
			// slicing indexes stay accurate.
			for(let i1 = 0; i1 < commands.length; i1++) {
				let ref = commands[i1];
				if(ref.name === "symmetry") {
					text = text.slice(0, offset + ref.start) + text.slice(offset + ref.end);
					offset += ref.end - ref.start;
				}
			}
			return text.replaceAll("\n\n", "\n");
		},
		extra_text_symmetry: function(string) {
		// returns an array of the starts and ends of symmetry() commands in an
		// extra_text.
		// - the indexes specifically mark the start and end of the parenthese
		//   contents.
			let comment_char = "//";
			let start = "symmetry(";
			let end = ")";
			let ranges = [];
			for(let i1 = 0; i1 < string.length; i1++) {
				let left = string.slice(0, i1);
				let right = string.slice(i1);
				if(right.startsWith(comment_char)) {
				// skip to the end of the comment.
					let temp = right.indexOf("\n");
					i1 += temp === -1 ? string.length : temp - 1;
					// it's a comment if it's in or after a comment_char but
					// before a \n. (the \n doesn't count as part of it, i
					// mean.)
				}
				else if(!(ranges.length%2) && right.startsWith("(") && left.endsWith("symmetry")) {
				// command start
					ranges.push(i1 + 1);
				}
				else if(ranges.length%2 && right.startsWith(")")) {
				// command end
					ranges.push(i1);
				};
			}
			return ranges;
		},
		get bodytext() {
			return document.getElementById("bm_bodytext").value;
		},
		set bodytext(value) {
			document.getElementById("bm_bodytext").value = value;
			document.getElementById("bm_bodytext").rows = value.split("\n").length;
		},
		body: null,
		pose: null,
		// Body, and pose.
		// - NOTE: the pose is only created so it can be drawn. it will never be
		//   posed.
		newpart: () => structuredClone({
		// returns a blank bodydata part.
			parent: "standpoint",
			x: 0,
			y: 0,
			z: 0,
			symmetry: false,
			image_text: AAX.Shape.templates.sphere,
			// text used in the second field. (shapes and images.)
			extra_text: "",
			// text used in the third field.
			// - NOTE: do not allow symmetry() commands. this tool needs to
			//   reliably know whether a part is symmetried or not, and with
			//   what prefixes.
		}),
		valid: {
			tools: "child sibling move horizontal vertical radius".split(" "),
			refresh: ["bodytext", "states", "draw", "ui"],
			draw_type: ["parts", "silhouette", "neither"],
			// - parts only, with overlapping outlines
			// - silhouettes only, with different groups differentiated
			// - neither
			scale_type: ["position", "dimension", "both"],
		},
		drawsettings: new AAX.DrawSettings(),
		color: new AAX.Color(),
		ctx: null,
		ui_ctx: null,
		states: null,
		// States object for undo/redo
		initialize: function() {
			let i1 = 0;
			let i2 = 0;
			bm.bodydata.core = bm.newpart();
			bm.control.partname = "core";
			bm.drawsettings.total_hide = false;
			// total hide makes less sense for this, especially if it makes
			// parts unselectable.
			//bm.drawsettings.grid = [];
			bm.control.draw_type = bm.valid.draw_type[0];
			bm.states = new States(
				bm, 32,
				function(tool) {
					let state = {bodydata: structuredClone(tool.bodydata)};
					let array = "partname prefix1 prefix2".split(" ");
					for(let i1 = 0; i1 < array.length; i1++) {
						state[array[i1]] = tool.control[array[i1]];
					}
					return state;
				},
				function(tool, state) {
					for(let i1 in state) {
						if(state.hasOwnProperty(i1)) {
							if(i1 === "bodydata") {
								tool[i1] = structuredClone(state[i1]);
							}
							else {
								tool.control[i1] = state[i1];
							}
						}
					}
					tool.refresh("states");
				}
			);
			let string = `<details class="text">`;
			string += `\n\t<summary>manual</summary><ul>`;
			let manual = {
				"edit tools": [
					`child: create a child to the current part.`,
					`sibling: create a sibling to the current part.`,
					//`rapid: creates a child, but autonames it. useful for creating bodies quickly.`
					`move: move where a part is, relative to its parent.`,
				],
				"scale tools": [
					`radius: scales the shape so that the furthest point of the shape is just as far away from the center as the mouse is.`,
					`horizontal, vertical: changes where the bounds of the shape are by scaling the points along the given axis.`,
					[
						`click past the front edge with horizontal, and you'll be able to move where the front edge is.`,
						`click past the back edge, and you move the back edge.`,
						`clicking between the edges moves the shape.`
					],
					`clicking a part selects it, and clicking anywhere else adjusts sizing.`
				],
				"etc": [
					`for child, sibling, and the scale tools, clicking a part will select it instead of doing anything else.`,
					`child and sibling will copy the images and third coordinate of the parent part.`,
					`the symmetry button toggles whether this branch of parts has a symmetrical duplicate.`,
					`expand lets you expand the part in whatever directions you toggled on the pad below the button.`,
					[
						`it's useful for fat and muscle. body parts get bigger with more fat/muscle, but they usually expand asymmetrically in the y/z axes.`,
					],
					`a lot of key shortcuts from armature artist work here, like tfgh letting you select a part's parent, siblings, or child.`,
					`the "apply changes" button near the bodytext area lets you apply manual changes to the bodytext.`
				],
			};
			for(i1 in manual) {
				if(manual.hasOwnProperty(i1)) {
					string += [
						``,
						`<details>`,
						`\t<summary>` + i1 + `</summary>`,
						`\t` + arraytoul(manual[i1], 1).replaceAll(`\n`, `\n\t`),
						`</details>`
					].join(`\n`).replaceAll(`\n`, `\n\t`);
				}
			}
			string += `\n</ul></details>`;
			string += `\n<canvas id="bm_canvas"></canvas>`;
			string += `\n<div id="bm_coor" style="text-shadow: silver .5px .5px; font-size: 8px"></div>`;
			string += `\n<br><canvas id="bm_ui_canvas"></canvas>`;
			string += `<br><button id="bm_applychanges">apply changes</button>`;
			string += `<br><textarea id="bm_bodytext" cols=48></textarea>`;
			//string += ``;
			for(i1 = 0; i1 < 2; i1++) {
				let id = "bm_" + (i1 ? "extra" : "image") + "_text";
				string += `\n<dialog id="` + id + `" autofocus>`;
				string += `\nenter new text to define the `;
				if(i1) {
					string += `extra parameters. (check the bodytext section of the armature artist manual for a full list of commands you can write here, and what they do.)`;
					string += `\n<ul>`;
					string += `\n\t<li>`;
					string += `\n\tdon't put "symmetry()" commands here. use the symmetry button instead.`;
					string += `\n\t</li>`;
					string += `\n</ul>`;
				}
				else {
					string += `shape.`;
					string += `\n<br>templates:`;
					string += `\n<ul>`;
					for(i2 in AAX.Shape.templates) {
						if(AAX.Shape.templates.hasOwnProperty(i2)) {
							string += `\n<button id=` + id + `_template_` + i2 + `>` + i2 + `</button>`;
						}
					}
					string += `\n</ul>`;
				};
				string += `\n<br><textarea id="` + id + `_input" cols=48></textarea>`,
				string += `\n<br><button id="` + id + `_enter">enter</button>`,
				string += `\n<button id="` + id + `_close">close</button>`,
				string += `\n</dialog>`;
			}
			document.getElementById("bm_div").innerHTML = string;
			bm.writecoordinates(null);
			for(i1 = 0; i1 < 2; i1++) {
				let canvas = document.getElementById("bm_" + (i1 ? "ui_" : "") + "canvas");
				canvas.style["image-rendering"] = "crisp-edges";
				bm[i1 ? "ui_ctx" : "ctx"] = canvas.getContext("2d");
				if(i1) {
					canvas.onpointerdown = bm.ui.mousedown;
				}
				else {
					canvas.onpointerdown = bm.mousedown;
					canvas.onpointermove = bm.mousemove;
					canvas.onpointerup = bm.mouseup;
					// like mouse events, except they work for phones and
					// drawing tablets.
					canvas.style["touch-action"] = "none";
					// this keeps it from sliding around when you're using a
					// phone.
					AAX.dragndrop(canvas, bm.readfile);
					// drag n drop file loading
					/*
					canvas.ondragover = function(e) {
						e.preventDefault();
					};
					canvas.ondrop = function(e) {
						let files = e.dataTransfer.items;
						if(files.length >= 1 && files[0].kind === "file") {
							bm.readfile(files[0].getAsFile());
						};
						e.preventDefault();
					};
					// lets you load things by dropping files onto the
					// canvas.
					*/
				}
			}
			for(i1 in AAX.Shape.templates) {
				if(AAX.Shape.templates.hasOwnProperty(i1)) {
					let text = "\n" + AAX.Shape.templates[i1];
					document.getElementById("bm_image_text_template_" + i1).onclick = function() {
						let input = document.getElementById("bm_image_text_input");
						let temp = [
							input.selectionStart,
							input.selectionEnd
						];
						if(temp[1] < temp[0]) {
							temp = [temp[1], temp[0]];
						}
						input.value = input.value.slice(0, temp[0]) + text + input.value.slice(temp[1]);
						input.selectionStart = temp[0] + text.length;
						input.selectionEnd = input.selectionStart;
					};
				}
			}
			for(i1 = 0; i1 < 2; i1++) {
				let _i1 = (i1 ? "extra" : "image") + "_text";
				let id = "bm_" + _i1;
				document.getElementById(id + "_close").onclick = function(e) {
					document.getElementById(id + "_input").value = "";
					document.getElementById(id).close();
				};
				document.getElementById(id + "_enter").onclick = function(e) {
					let old_text = bm.control.bodydata_part[_i1];
					let new_text = document.getElementById(id + "_input").value.trim();
					if(_i1 === "extra_text") {
						let commands = AAX.body_read.extra_commands(new_text);
						let temp = new_text.length;
						new_text = bm.remove_symmetry(new_text, commands);
						// slice out symmetry() commands
						if(new_text.length < temp) {
						// alert the user
							alert("do not use symmetry() commands. use the symmetry button instead.");
						};
					}
					bm.control.bodydata_part[_i1] = new_text;
					let bodytext = bm.form_bodytext();
					let body = AAX.Body.new(bodytext);
					if(typeof body === "string") {
						alert("invalid " + _i1 + ". (" + body + ")");
						bm.control.bodydata_part[_i1] = old_text;
					}
					else {
						bm.refresh(null, bodytext, body);
					}
					document.getElementById(id + "_input").value = "";
					document.getElementById(id).close();
				};
			}
			document.getElementById("bm_applychanges").onclick = function() { bm.bodytext_change(); };
			bm.ui.create();
			bm.ui_ctx.font = AAX.ui.font;
			bm.ui_ctx.textBaseline = "middle";
			// these get reset if the canvas dimensions change. fuck if i know
			// why. ask mozilla.
			bm.refresh("states");
		},
		refresh: function(skip, bodytext, body) {
		// - skip: string or string array of actions to skip. (ex: "states" will
		//   keep it from saving a state. bm.valid.refresh has the full list.)
		// - bodytext, body: used to pass on bodytext/body, to avoid redundant
		//   runnings of bm.get_bodytext and AAX.Body.new.
		//   - when editing shape_text or something like that, before it decides
		//     to refresh and save the user's changes, it has to run those
		//     functions to make sure invalid input didn't cause an error
		//     somewhere. it'd be a waste to throw the generated bodytext/body
		//     out and run that stuff again.
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			skip = typeof skip === "string" ? [skip] : Array.isArray(skip) ? skip : [];
			if(!skip.includes("bodytext")) {
			// rewrite the bodytext, redefine the body and pose
				bodytext ??= bm.form_bodytext();
				body ??= AAX.Body.new(bodytext);
				if(typeof body === "string") {
					console.log("this shouldn't happen");
					console.log(body);
				}
				else if(body instanceof AAX.Body) {
					bm.bodytext = bodytext;
					bm.body = body;
					bm.pose = AAX.newpose(bm, bm.body);
					for(i1 in bm.pose) {
						if(bm.pose.hasOwnProperty(i1) && !bm.control.partname) {
						// NOTE: ALWAYS ALWAYS ITERATE THROUGH THE POSE, NOT
						// BODYDATA!
						// - otherwise, you'll miss parts created as symmetrical
						//   duplicates.
						// - not that that's particularly relevant here, but
						//   shut up!
							bm.control.partname = i1;
						}
					}
				}
				else {
					console.log("this shouldn't happen");
				}
			};
			if(!skip.includes("states")) {
				bm.states.save();
			};
			if(!skip.includes("draw")) {
				bm.draw_background();
				bm.draw();
				const ctx = bm.ctx;
				const cell = bm.drawsettings.cell;
				for(i1 = 0; i1 < 2; i1++) {
					bm["image_" + (i1 ? "right" : "front")] = ctx.getImageData(cell.w*i1, 0, cell.w, cell.h);
				}
				// save images, which are used to reverse graphical changes in
				// the clickable interface
			};
			if(!skip.includes("ui")) {
				bm.ui.draw();
			};
		},
		symmetry: function(name) {
		// input a partname from the body/pose, and it'll return 0, 1, or 2
		// depending on what kind of symmetry the named part has.
		// - 1 and 2 mean it's part of a branch with symmetry duplication
		// - 0 means it isn't
		// - 2 means it's specifically the branch that gets x-mirrored, and
		//   takes bm.control.prefix2
		// - 1 means it's the branch that isn't, and takes prefix1
			if(name in bm.bodydata) {
				return 0;
			}
			else if(name.startsWith(bm.control.prefix1) && name.slice(bm.control.prefix1.length) in bm.bodydata) {
				return 1;
			}
			else if(name.startsWith(bm.control.prefix2) && name.slice(bm.control.prefix2.length) in bm.bodydata) {
				return 2;
			}
			else {
				if(name in bm.body) {
					console.log("this shouldn't happen");
					// the only kind of part that should be in body/pose but not
					// bodydata is symmetrical counterparts.
				}
				else {
					console.log("invalid part name.");
				}
			};
		},
		has_symmetry: (name) => bm.bodydata[name].symmetry || AAX.getanc(bm.bodydata, name).some((element) => bm.bodydata[element].symmetry),
		// input a bodydata part name. returns whether it's symmetrical, ie one
		// of its ancestors has true .symmetry
		bodydata_name: function(name) {
		// takes a body/pose partname and gives the corresponding bm.bodydata
		// name.
			let symmetry = bm.symmetry(name);
			name = (
				symmetry === 1 ? name.slice(bm.control.prefix1.length) :
				symmetry === 2 ? name.slice(bm.control.prefix2.length) :
				name
			);
			if(!(name in bm.bodydata)) {
				console.log("this shouldn't happen");
			};
			return name;
		},
		body_name: (name) => (bm.has_symmetry(name) ? bm.control.prefix1 : "") + name,
		replaceshape: function(bodydata_part, shape) {
		// converts the given shape into text, and replaces the first field of
		// the given part's image_text with it.
			let temp = bodydata_part.image_text.split("||");
			temp[0] = AAX.Shape.string(shape);
			if(temp[0] && temp.length > 1) {
				temp[0] += "\n";
			};
			bodydata_part.image_text = temp.join("||");
		},
		disable_delete: () => (
			bm.control.delete_branch
			?
			(
				bm.control.bodydata_part.parent === "standpoint"
				&&
				AAX.getchildren(bm.bodydata, "standpoint").length <= 1
			)
			:
			AAX.getdesc(bm.bodydata).length <= 1
		),
		// evaluates whether the delete button should be disabled.
		// - if branch is on, than it should be disabled if it's the only stem.
		// - otherwise, it should be disabled if it's the only part.
		control: {
			view: 0,
			// on account of armature artist conventions and that i am just not
			// willing to fully implement a "right" boolean or whatever would be
			// more efficient... 0 means the front, 1 means the right.
			partname: "",
			// name of the selected part. it must always be the name of a part
			// in the body/pose.
			get symmetry() {
				return bm.symmetry(bm.control.partname);
			},
			get bodydata_name() {
				return bm.bodydata_name(bm.control.partname);
			},
			get bodydata_part() {
				return bm.bodydata[bm.control.bodydata_name];
			},
			get body_part() {
				return bm.body[bm.control.partname];
			},
			get pose_part() {
				return bm.pose[bm.control.partname];
			},
			get node() {
				return AAX.getnode(bm.nodes, bm.control.view, bm.control.partname);
			},
			tool: "child",
			clicktype: null,
			partclicked: false,
			strokecache: null,
			//
			prefix1: AAX.prefix1,
			prefix2: AAX.prefix2,
			// used in symmetry
			// - NOTE: one of the few things besides bodydata to be saved in a state.
			delete_branch: true,
			expand_number: 1,
			expand: {
				l: false,
				r: false,
				u: false,
				d: false,
				b: false,
				f: false,
			},
			expand_branch: true,
			adjust_half: true,
			last_adjust: "",
			// a direction. it can be empty.
			scale_numer: 2,
			scale_denom: 1,
			scale_type: "both",
			scale_x: true,
			scale_y: true,
			scale_z: true,
			scale_branch: true,
			//
			draw_type: null,
			get skeleton() {
				return bm.drawsettings.skeleton && bm.drawsettings.nodes;
			},
		},
		nodecheck: function(click, view) {
			for(let i1 = bm.nodes[view].length - 1; i1 >= 0; i1--) {
			// search backwards, so it finds the closer nodes first.
				let node = bm.nodes[view][i1];
				if(
					Math.hypot(node.x - click[0], node.y - click[1]) < AAX.noderadius + .5
					&&
					(!bm.pose[node.name].hide || !bm.drawsettings.total_hide)
				) {
				// if the part is hidden and total hide is on, don't allow the
				// node to be selected or clicked.
					return node;
				};
			}
			return null;
		},
		coortocanvas: (point, view, nonulls, viewoffset) => AAX.coortocanvas(bm.drawsettings.cell, bm.drawsettings.standpoint, point, view, nonulls, viewoffset),
		coorfromcanvas: (x, y, view) => AAX.coorfromcanvas(bm.drawsettings.cell, bm.drawsettings.standpoint, x, y, view),
		mousedown: function(e) {
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let click = clickxy(e, "bm");
			const cell = bm.drawsettings.cell;
			const view = Math.floor(click[0]/cell.w);
			const tool = bm.control.tool;
			bm.control.view = view;
			let node = bm.nodecheck(click, view);
			bm.control.partclicked = node !== null;
			if(bm.control.partclicked) {
				bm.control.partname = node.name;
				let skip = structuredClone(bm.valid.refresh);
				skip.splice(skip.indexOf("ui"), 1);
				bm.refresh(skip);
			}
			else {
				node = bm.control.node;
			};
			bm.control.strokecache = {};
			for(i1 in bm.pose) {
				if(bm.pose.hasOwnProperty(i1)) {
					let _part = bm.pose[i1];
					bm.control.strokecache[i1] = {
						front: _part.image_front,
						right: _part.image_right,
					}
					let ref = bm.control.strokecache[i1];
					for(i2 in ref) {
						if(ref.hasOwnProperty(i2)) {
							ref[i2] = AAX.sq_raster.fill(ref[i2], _part.dim(i2, ref[i2].length)[0]);
						}
					}
				}
			}
			// fill strokecache (lets it reuse images so it doesn't run rasterize
			// every mousemove)
			bm.control.clicktype = "main";
			if(bm.control.partclicked && tool !== "move") {
				// select the part, don't do anything else.
			}
			else if(tool === "child" || tool === "sibling" || tool === "chain") {
				let parent = tool === "sibling" ? bm.control.body_part.parent : bm.control.partname;
				let parentcoor = parent === "standpoint" ? [0, 0, 0] : bm.pose[parent].abscoor;
				// abscoor of the new part's parent
				let _parentcoor = parent === "standpoint" ? parentcoor : Points.add(parentcoor, bm.pose[parent].relcoor);
				// the third relative coordinate should imitate the parent.
				// that'll probably be closer to what the user wants than 0.
				let relcoor = bm.coorfromcanvas(...click, view);
				relcoor = [
					relcoor.x ?? _parentcoor[0],
					relcoor.y ?? _parentcoor[1],
					relcoor.z ?? _parentcoor[2]
				];
				relcoor = Points.trunc(Points.subtract(relcoor, parentcoor));
				// subtract the parent's abscoor, and truncate.
				let name = "";
				if(tool === "chain") {
				// autonaming
					let _name = parent.split("_");
					let num = Number(_name[_name.length - 1]);
					_name = _name.slice(0, -1);
					if(parent === "standpoint" || !Number.isInteger(num) || num < 0) {
						_name = parent;
						num = 0;
					}
					_name += _name ? "_" : "";
					while((_name + num) in bm.bodydata) {
						num++;
					};
					name = _name + num;
				}
				else {
					name = (prompt("enter a name for the new part.") ?? "").trim();
					if(name === "standpoint") {
						alert("\"standpoint\" is a reserved word.");
						name = "";
					}
					else if(name in AAX.Body.prototype) {
						alert("\"" + name + "\" is an invalid part name for technical reasons.");
						name = "";
					}
				};
				if(name) {
					if(name in bm.body && !(name in bm.bodydata)) {
						name = bm.bodydata_name(name);
					};
					let symmetry = parent === "standpoint" ? 0 : bm.symmetry(parent);
					if(symmetry === 2) {
						relcoor[0] *= -1;
					}
					parent = parent === "standpoint" ? parent : bm.bodydata_name(parent);
					let skip_refresh = false;
					//
					if(name in bm.bodydata) {
						// instead of making a new part, make the named part a
						// child/sibling of the selected part.
						let anc = parent === "standpoint" ? [] : AAX.getanc(bm.bodydata, parent);
						if(anc.includes(name) || name === parent) {
							// the named part is an ancestor of the part the user is
							// attempting to parent it to. this would cause a
							// parenting loop.
							skip_refresh = true;
							alert("part already exists. (normally it would shift parenting around to add it as a " + tool + ", but in this case it would cause a parenting loop.)");
						}
						else {
							bm.bodydata[name].parent = parent;
						};
					}
					else {
						bm.bodydata[name] = bm.newpart();
						bm.bodydata[name].parent = parent;
						if(parent !== "standpoint") {
							bm.bodydata[name].image_text = bm.bodydata[parent].image_text;
						};
						for(i1 = 0; i1 < 3; i1++) {
							bm.bodydata[name]["xyz"[i1]] = relcoor[i1];
						}
						bm.control.partname = (symmetry ? bm.control["prefix" + symmetry] : "") + name;
						// select it
					}
					// - name is in bodydata: change its parenting
					// - name is not in bodydata, but is in body: use the
					//   bodydata_name, and change its parenting like a bodydata
					//   name
					// - name is in neither: make a new part, and copy the
					//   relcoor
					//
					if(!skip_refresh) {
						bm.refresh();
					};
				}
			}
			else if(tool === "radius" || tool === "horizontal" || tool === "vertical") {
			// figure out the strokedata.
				bm.control.strokedata = {};
				let ref = bm.control.strokedata;
				let points = bm.control.body_part.shape.points;
				if(tool === "radius") {
					ref.radius = AAX.Shape.radius(points);
				}
				else {
					ref.bounds = AAX.Shape.bounds(points);
					ref.axis = tool === "vertical" ? 1 : view%2 ? 2 : 0;
				};
				if(tool === "horizontal" || tool === "vertical") {
					ref.coor = bm.coorfromcanvas(...click, view)["xyz"[ref.axis]];
					// the amount you move the box or bound by is measured by
					// how many pixels away you moved from where the click
					// started.
					if(ref.bounds) {
						if(bm.control.symmetry === 2) {
						// mirror the bounding box
							let temp = ref.bounds.l;
							ref.bounds.l = -ref.bounds.r;
							ref.bounds.r = -temp;
						};
						let center = bm.control.pose_part.abscoor[ref.axis];
						let temp = ref.coor - center;
						ref.sign = (
							temp <= ref.bounds["lub"[ref.axis]] ? -1 :
							temp >= ref.bounds["rdf"[ref.axis]] ? 1 :
							0
						);
						// if you click on or past an edge, your click drags that
						// edge around. if you click between the edges, you move the
						// whole box.
						ref.zero = !(ref.bounds["rdf"[ref.axis]] - ref.bounds["lub"[ref.axis]]);
					}
					else {
						ref.sign = 0;
						ref.zero = true;
					}
				}
			}
		},
		mousemove: function(e, finish) {
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let click = clickxy(e);
			const ctx = bm.ctx;
			const cell = bm.drawsettings.cell;
			const view = bm.control.clicktype === "main" ? bm.control.view : Math.floor(click[0]/cell.w);
			const coor = bm.coorfromcanvas(click[0], click[1], view);
			let part_select = bm.control.tool !== "move" ? bm.nodecheck(click, view) : null;
			part_select = part_select && part_select.name !== bm.control.partname ? part_select.name : null;
			// it doesn't happen for the part that's already selected. not just
			// because that's wasteful; it would also mean you can't use the
			// radius tool to shrink something smaller than noderadius.
			if(view === 0 || view === 1) {
			// draw coordinates
				let text = [
					"",
					"xz"[view%2] + ": " + coor["xz"[view%2]],
					"y: " + coor.y
				];
				if(bm.control.clicktype !== "main" || part_select) {
					let node = bm.nodecheck(click, view);
					bm.pasteimages(false);
					bm.pasteimages(true);
					if(node !== null) {
						text[0] = node.name;
						// display the name
						node = AAX.noderect(node.x, node.y);
						ctx.strokeStyle = bm.color.interface[0];
						ctx.fillStyle = bm.color.interface[1];
						ctx.strokeRect(node.x - .5, node.y - .5, node.w + 1, node.h + 1);
						ctx.fillRect(node.x, node.y, node.w, node.h);
						bm.pasteimages(!view);
					}
				};
				bm.writecoordinates(text);
			};
			if(bm.control.clicktype !== "main") {
				return;
			};
			//
			if(part_select) {
			// tilt/rotate should allow node selection on mouseup, and visualize
			// it. that gives much more visual feedback, and therefore
			// precision.
				if(finish) {
					bm.control.partname = part_select;
					//
					bm.control.strokecache = null;
					bm.control.clicktype = null;
					bm.control.strokedata = null;
					bm.writecoordinates(null);
					bm.refresh(["bodytext", "states", "draw"]);
				};
				return;
			};
			//
			bm.pasteimages(!!bm.control.view);
			bm.writecoordinates(null);
			ctx.strokeStyle = bm.color.interface[0];
			ctx.fillStyle = bm.color.interface[1];
			const tool = bm.control.tool;
			const strokedata = bm.control.strokedata;
			if(
				(tool === "move" !== bm.control.partclicked)
				// you have to click a part and drag it.
				// - move without clicking a part: invalid, you have to click
				//   and drag a node.
				// - clicking a part in any other mode: don't do anything after
				//   mousedown, just select it.
				||
				tool === "child" || tool === "sibling" || tool === "chain"
				// everything happens on mousedown for these.
				||
				(tool === "radius" && !strokedata.radius)
				// if the radius was zero or null, no matter how much the shape
				// is multiplied, it won't change.
				||
				((tool === "horizontal" || tool === "vertical") && (
					(strokedata.zero && strokedata.sign)
					// can't drag the edges around if the dimension is zero, since
					// it works by multiplying.
					||
					!strokedata.bounds
					// scaling a shape with no valid points makes no sense.
				))
			) {
				bm.control.strokecache = null;
				bm.control.clicktype = null;
				bm.control.strokedata = null;
				bm.writecoordinates(null);
				return;
			}
			const node = bm.control.node;
			const bodydata_part = bm.control.bodydata_part;
			const body_part = bm.control.body_part;
			const pose_part = bm.control.pose_part;
			let parent_node = node.parent;
			if(node.parent === "standpoint") {
				parent_node = bm.coortocanvas([0, 0, 0], view, true, true);
				parent_node = {
					x: parent_node[0],
					y: parent_node[1],
					name: parent,
				};
			};
			// a node-like object for standpoint, or the .parent reference.
			//
			let data = {};
			// things that the position of the mouse is adjusting... it's like
			// strokedata, except it can be deleted now.
			// - if that's confusing, just don't worry about it. this is just to
			//   escape block-scoping.
			if(tool === "radius") {
				data.radius = Math.round(Math.hypot(click[0] - node.x, click[1] - node.y));
				bm.writecoordinates(data.radius);
			}
			else if(tool === "move") {
				let oldcoor = pose_part.abscoor;
				let newcoor = bm.coorfromcanvas(...click, view);
				newcoor = [
					newcoor.x ?? oldcoor[0],
					newcoor.y ?? oldcoor[1],
					newcoor.z ?? oldcoor[2]
				];
				for(i1 = 0; i1 < 3; i1++) {
					newcoor[i1] = oldcoor[i1] + Math.trunc(newcoor[i1] - oldcoor[i1]);
				}
				// truncate the coordinates so that the floats are the same as they
				// were before.
				let parent = body_part.parent;
				data.coor = parent === "standpoint" ? structuredClone(newcoor) : Points.subtract(newcoor, bm.pose[parent].abscoor);
				// data.coor is the new relcoor to apply to the selected part.
			}
			else if(tool === "horizontal" || tool === "vertical") {
				data.bounds = structuredClone(strokedata.bounds)
				let bounds = strokedata.bounds;
				let _bounds = data.bounds;
				let neg = "lub"[strokedata.axis];
				let pos = "rdf"[strokedata.axis];
				data.change = Math.trunc(bm.coorfromcanvas(...click, view)["xyz"[strokedata.axis]] - strokedata.coor);
				let sign = strokedata.sign;
				let temp = data.change;
				if(sign === -1) {
					temp *= -1;
				};
				temp = (temp > 0 ? "+" : "") + temp;
				bm.writecoordinates("lxruydbzf"[3*strokedata.axis + 1 + sign] + " " + temp);
				data.multiplier = 1;
				if(sign === 0) {
					_bounds[neg] += data.change;
					_bounds[pos] += data.change;
				}
				else if(sign === -1) {
					_bounds[neg] += data.change;
					data.multiplier = _bounds[neg]/bounds[neg];
					_bounds[pos] *= data.multiplier;
					// bounds*multiplier = _bounds
					// multiplier = _bounds/bounds
				}
				else if(sign === 1) {
					_bounds[pos] += data.change;
					data.multiplier = _bounds[pos]/bounds[pos];
					_bounds[neg] *= data.multiplier;
				};
			}
			//
			if(tool === "radius" || (tool === "move" && body_part.parent !== "standpoint")) {
			// draw circles.
			// - radius: show the current radius of the part's shape, and the
			//   radius your click would set it as
			// - move: show the current hypotenuse, and where the parent is
				let center = tool === "radius" ? node : parent_node;
				center = [center.x, center.y];
				let radius = tool === "radius" ? strokedata.radius : Math.floor(Math.hypot(bodydata_part.x, bodydata_part.y, bodydata_part.z));
				circledraw(ctx, ...center, radius);
				if(tool === "radius") {
					circledraw(ctx, ...center, data.radius);
				};
				temp = ctx.fillStyle;
				ctx.fillStyle = ctx.strokeStyle;
				circledraw(ctx, ...center, AAX.noderadius, true);
				ctx.fillStyle = temp;
			}
			else if(tool === "horizontal" || tool === "vertical") {
				let center = bm.control.pose_part.abscoor;
				let temp = view%2 ? ["ruf", "rub", "rdb", "rdf"] : ["luf", "ruf", "rdf", "ldf"];
				let rect = Rect.new();
				let _rect = Rect.new();
				for(i1 = 0; i1 < 2; i1++) {
					let bounds = i1 ? data.bounds : strokedata.bounds;
					for(i2 = 0; i2 < 4; i2++) {
						let point = Points.add(
							center,
							[
								bounds[ temp[i2][0] ],
								bounds[ temp[i2][1] ],
								bounds[ temp[i2][2] ]
							]
						);
						point = bm.coortocanvas(point, view, true, true);
						//console.log(point);
						if(i1) {
							if(i2) {
								_rect = Rect.reach(_rect, ...point);
							}
							else {
								_rect.x = point[0];
								_rect.y = point[1];
							}
						}
						else {
							if(i2) {
								rect = Rect.reach(rect, ...point);
							}
							else {
								rect.x = point[0];
								rect.y = point[1];
							}
						}
					}
					//console.log(i1 ? _rect : rect);
				}
				for(i1 = 0; i1 < 4; i1++) {
				// 0: draw a black outline for the original box
				// 1: draw a black outline for the modified box
				// 2: draw the original box, in gray
				// 3: draw the modified box, in white
					ctx.strokeStyle = bm.color.interface[i1 === 2 ? 2 : i1 === 3 ? 1 : 0];
					for(i2 = 0; i2 < 2; i2++) {
					// - first iteration: round the coordinates so the rect gets
					//   smaller (and subtract 1, if it's outline)
					// - second iteration: round the coordinates so the rect
					//   gets bigger (and add 1, if it's outline)
						let temp = structuredClone(i1%2 ? _rect : rect);
						temp = i2 ? Rect.round_out(temp) : Rect.round_in(temp);
						if(i1 < 2) {
							let sign = i2 ? 1 : -1;
							temp = Rect.expanded(temp, "l", sign);
							temp = Rect.expanded(temp, "r", sign);
							temp = Rect.expanded(temp, "u", sign);
							temp = Rect.expanded(temp, "d", sign);
						}
						Rect.fauxstroke(temp, ctx);
					}
				}
			};
			bm.pasteimages(!view);
			//
			if(tool === "move") {
				let rect = {
					x: Math[([1, 2].includes(view) ? "ceil" : "floor")](parent_node.x) + .5,
					y: Math[([1, 2].includes(view) ? "ceil" : "floor")](parent_node.y) + .5,
					// floor/ceil it so it's what the coortocanvas would be
					// without floats, and add .5 so it's in the center of
					// the pixels.
					w: ([1, 2].includes(view) ? -1 : 1)*Math.trunc(data.coor[view%2 ? 2 : 0]),
					h: Math.trunc(data.coor[1]),
				};
				ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
				bm.writecoordinates(data.coor);
			}
			if(finish) {
				let skip_refresh = false;
				if(tool === "move") {
					bodydata_part.x = data.coor[0];
					bodydata_part.y = data.coor[1];
					bodydata_part.z = data.coor[2];
					if(bm.control.symmetry === 2) {
					// bodydata_part is actually the symmetrical counterpart,
					// so.
						bodydata_part.x *= -1;
					};
				}
				else if((tool === "horizontal" || tool === "vertical") && !strokedata.sign) {
				// move the shape
					if(data.change) {
						let points = structuredClone(body_part.shape.points);
						for(i1 = 0; i1 < points.length; i1++) {
							for(i2 = 0; i2 < points[i1].length; i2++) {
								let point = points[i1][i2];
								point[strokedata.axis] += data.change;
								if(bm.control.symmetry === 2) {
								// shape belongs to the counterpart, but will be
								// applied to the original
									point[0] *= -1;
								};
							}
						}
						bm.replaceshape(bodydata_part, {points});
					}
				}
				else if(tool === "radius" || tool === "horizontal" || tool === "vertical") {
					let multiply = [1, 1, 1];
					let mirror = [false, false, false];
					if(tool === "radius") {
						let num = data.radius/strokedata.radius;
						multiply = [num, num, num];
					}
					else if(tool === "horizontal" || tool === "vertical") {
						multiply[strokedata.axis] = data.multiplier;
						if(data.multiplier < 0) {
							mirror[strokedata.axis] = true;
						}
					}
					let all_same = multiply[0] === multiply[1] && multiply[1] === multiply[2];
					// endless, finite (copy that.)
					skip_refresh = all_same && multiply[0] === 1;
					if(!skip_refresh) {
					// editing the shapes like this wipes comments. at least
					// avoid it if it won't do anything.
						let points = structuredClone(body_part.shape.points);
						for(i1 = 0; i1 < points.length; i1++) {
							for(i2 = 0; i2 < points[i1].length; i2++) {
								let point = points[i1][i2];
								if(point.length >= 4 && point.length < 6 && !all_same) {
								// there's different multipliers for each axis,
								// so turn spheres into spheroids. (make sure
								// there's three numbers, filling in missing
								// numbers with [3].)
									point[4] ??= point[3];
									point[5] ??= point[3];
								}
								for(i3 = 0; i3 < Math.min(point.length, 6); i3++) {
									point[i3] *= i3 < 3 ? multiply[i3] : Math.abs(multiply[i3 - 3]);
								}
								if(point.length >= 7 && mirror.includes(true)) {
									point[6] = Quat.mirror.multi(point[6], ...mirror);
								};
							}
						}
						bm.replaceshape(bodydata_part, {points});
						//let points = structuredClone(bm.body[(bm.has_symmetry(_i0) ? bm.control.prefix1 : "") + _i0].shape.points);
					}
				}
				bm.control.strokecache = null;
				bm.control.clicktype = null;
				bm.control.strokedata = null;
				bm.writecoordinates(null);
				bm.refresh();
			};
		},
		mouseup: function(e) {
			if(bm.control.clicktype !== "main") {
				return;
			};
			bm.mousemove(e, true);
		},
		ui: {
			buttons: {},
			// rectangle objects
			heading: [],
			// list of button names that are headings
			depress: [],
			// list of button names that are animated
			checkbox: [],
			// buttons that are checkboxes. you get the idea.
			finddirection: function(x, y) {
			// used for the expand and adjust directional buttons. input two 0
			// to 1 numbers for where the click is on the button, and it'll
			// return the appropriate direction letter.
				if(x > 2/3) {
					return y < .5 ? "b" : "f";
				};
				x /= 2/3;
				x -= .5;
				y -= .5;
				return (
					Math.abs(x) >= Math.abs(y)
					?
					(x < 0 ? "l" : "r")
					:
					(y < 0 ? "u" : "d")
				);
			},
			create: function() {
				let i1 = 0;
				let temp1 = [];
				for(i1 in AAX.Shape.templates) {
					if(AAX.Shape.templates.hasOwnProperty(i1)) {
						temp1.push(i1);
					};
				}
				let temp2 = structuredClone(AAX.ui.color_area);
				temp2.direction = "r";
				bm.ui.buttons = Rect.ui([
					{
						prefix: "",
						actions: [
							["row", "undo redo".split(" "), "r", 4, 2]
						],
					},
					{
						prefix: "",
						actions: [
							["row", "save load".split(" "), "r", 4, 2]
						],
					},
					{
						prefix: "scale",
						direction: "r",
						gap: 5,
						actions: [
							["column", "number", "d", 4.5, 1],
							["expand", "x y z".split(" "), "d", 1, true],
							["column", " type".split(" "), "l", 6, 1],
							["expand", "branch", "d", 1]
						],
					},
					{
						prefix: "adjust",
						direction: "d",
						actions: [
							["column", "directions", "d", 6, 4],
							["expand", "half", "d", 1]
						],
						heading: 1,
					},
					{
						prefix: "expand",
						direction: "r",
						actions: [
							["column", "", "d", 4, 1],
							["expand", "number", "r", 2],
							["expand", "directions", "d", 4],
							["expand", "branch", "d", 1]
						],
					},
					/*
					{
						prefix: "rename",
						direction: "d",
						previous: -2,
						actions: [
							["column", "part branch ancestry".split(" "), "d", 6, 1]
						],
						heading: 1,
					},
					//*/
					{
						prefix: "template",
						direction: "r",
						adjust: -2,
						actions: [
							["column", temp1, "d", 7, 1]
						],
						heading: 2,
					},
					{
						prefix: "tool",
						previous: 0,
						direction: "d",
						actions: [
							["column", "create child sibling move".split(" "), "r", 7, 1],
							["column", "scale radius horizontal vertical".split(" "), "r", 7, 1]
						],
					},
					{
						prefix: "delete",
						direction: "r",
						adjust: 1,
						actions: [
							["column", "", "d", 5, 2],
							["expand", "branch", "d", 1]
						],
					},
					{
						prefix: "part",
						previous: -2,
						direction: "d",
						actions: [
							["column", "image_text", "d", 11, 2],
							["expand", "symmetry", "d", 1],
							["expand", "extra_text", "d", 2],
							["column", "hypot", "l", 10, 5],
							["expand", "name", "u", 1]
						],
					},
					{
						prefix: "drawsettings",
						direction: "d",
						actions: [
							["column", "background draw_type skeleton".split(" "), "d", 9, 1],
							["expand", "grid", "d", 1],
							["expand", "standpoint", "d", 2],
							["expand", "cell", "d", 1],
							["expand", "fineness", "d", 1],
						],
						heading: 1,
					},
					temp2,
					{
						prefix: "px",
						previous: -2,
						actions: [
							["column", "paste replace".split(" "), "d", 6, 2],
						],
						heading: 2,
					}
					// - simplified:
				    //   - prefix
				    //   - previous, direction, gap, adjust
				    //   - first
				    //     - suffix
				    //     - w, h
				    //     - horizontal
				    //   - actions
				    //     - ["row"/"column", suffixes, direction, w, h]
				    //     - ["expand", suffix, direction, amount, horizontal]
				    //     - ["subtract", suffix, direction, amount]
				    //     - ["align", suffix, direction]
				    //   - heading
				]);
				bm.ui.buttons.part_prefix1 = Rect.fromslice(bm.ui.buttons.part_symmetry, "r", 5);
				bm.ui.buttons.part_prefix2 = Rect.fromslice(bm.ui.buttons.part_prefix1, "r", 2.5);
				bm.ui.buttons.part_relcoor = Rect.fromslice(bm.ui.buttons.part_hypot, "d", 4);
				bm.ui.buttons.part_abscoor = Rect.fromslice(bm.ui.buttons.part_relcoor, "l", bm.ui.buttons.part_relcoor.w/2);
				let w = 0;
				let h = 0;
				for(i1 in bm.ui.buttons) {
					if(bm.ui.buttons.hasOwnProperty(i1)) {
						let ref = bm.ui.buttons[i1];
						ref.x *= AAX.ui.block;
						ref.y *= AAX.ui.block;
						ref.w *= AAX.ui.block;
						ref.h *= AAX.ui.block;
						w = Math.max(w, ref.x, ref.x + ref.w);
						h = Math.max(h, ref.y, ref.y + ref.h);
						let prefix = PreSuf.get(i1);
						let suffix = prefix[1];
						prefix = prefix[0];
						if(
							suffix === "heading"
							||
							(prefix === "tool" && (suffix === "create" || suffix === "scale"))
						) {
							bm.ui.heading.push(i1);
						}
						else if(
							(suffix === "branch" && prefix !== "rename")
							||
							(prefix === "adjust" && suffix === "half")
						) {
							bm.ui.checkbox.push(i1);
						}
						else if(
							!suffix
							||
							(prefix === "part" && (suffix === "image_text" || suffix === "extra_text"))
							||
							prefix === "template"
							||
							(prefix === "adjust" && suffix === "directions")
							||
							prefix === "px"
						) {
							bm.ui.depress.push(i1);
						};
					}
				}
				w++;
				h++;
				let canvas = bm.ui_ctx.canvas;
				canvas.width = w;
				canvas.height = h;
			},
			draw: function(depress) {
				let i1 = 0;
				let i2 = 0;
				let i3 = 0;
				let ctx = bm.ui_ctx;
				ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
				let part = bm.control.bodydata_part;
				for(let button in bm.ui.buttons) {
					if(bm.ui.buttons.hasOwnProperty(button)) {
						let rect = structuredClone(bm.ui.buttons[button]);
						let center = Rect.center(rect);
						center = [
							Math.floor(center[0]),
							Math.floor(center[1])
						];
						let prefix = PreSuf.get(button);
						let suffix = prefix[1];
						prefix = prefix[0];
						let heading = bm.ui.heading.includes(button);
						let checkbox = bm.ui.checkbox.includes(button);
						let directions = suffix === "directions" && (prefix === "expand" || prefix === "adjust");
						let selected = (
							(prefix === "tool" && !heading && suffix === bm.control.tool)
							||
							(checkbox && bm.control[button])
							||
							(button === "part_symmetry" && bm.control.bodydata_part.symmetry)
							||
							(prefix === "scale" && (suffix === "x" || suffix === "y" || suffix === "z") && bm.control[button])
						);
						selected = Number(selected);
						if(depress && button === depress) {
							selected = posmod(selected + 1, 3);
						};
						if(
							(button === "delete" && bm.disable_delete())
							||
							(button === "part_symmetry" && !selected && bm.has_symmetry(bm.control.bodydata_name))
						) {
							selected = 2;
						};
						if(prefix === "drawsettings") {
							if(suffix === "draw_type") {
								selected = bm.valid[suffix].indexOf(bm.control[suffix]);
							}
							else if(suffix === "skeleton") {
								selected = Number(bm.control.skeleton);
							};
						}
						else if(button === "scale_type") {
							selected = bm.valid[button].indexOf(bm.control[button]);
						};
						let color = bm.color.buttons;
						ctx.strokeStyle = color[posmod(-selected, color.length)];
						ctx.fillStyle = color[posmod(1 - selected, color.length)];
						if(!heading && !checkbox && !directions) {
							ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
							Rect.fauxstroke(rect, ctx);
						};
						if(prefix === "drawsettings" && suffix !== "heading" && suffix !== "draw_type" && suffix !== "skeleton") {
							AAX.ui.draw.drawsettings(ctx, rect, bm.drawsettings, suffix, suffix === "standpoint" ? "double" : "row");
							// row: grid, cell, fineness
							// double: standpoint
						}
						else if(prefix === "color" && suffix !== "heading") {
							AAX.ui.draw.color(ctx, rect, bm.color, suffix);
						}
						else {
							let text = (
								!suffix ? prefix :
								suffix === "heading" ? (
									prefix === "tool" ? prefix + "s" :
									prefix === "template" ? ["shape", prefix + "s"] :
									prefix === "drawsettings" ? "draw settings" :
									prefix === "px" ? ["pixel art", "transfer"] :
									prefix
								) :
								prefix === "part" ? (
									suffix === "name" ? "part: " + bm.control.partname :
									suffix === "image_text" ? "edit image text" :
									(suffix === "prefix1" || suffix === "prefix2") ? bm.control[suffix] :
									suffix === "extra_text" ? "edit extra text" :
									suffix === "hypot" ? (Math.hypot(part.x, part.y, part.z) + "").slice(0, 7) :
									(suffix === "relcoor" || suffix === "abscoor") ? bm.control.pose_part[suffix] :
									suffix
								) :
								directions ? [] :
								(prefix === "expand" && suffix === "number") ? bm.control.expand_number :
								prefix === "scale" ? (
									suffix === "number" ? "x" :
									suffix === "type" ? bm.control[button] :
									suffix
								) :
								(prefix === "drawsettings" && suffix === "draw_type") ? bm.control[suffix] :
								suffix
							);
							let left = [];
							let centered = [];
							let right = [];
							// string arrays. each one is a different alignment,
							// each item is a different row.
							if(prefix === "part" && (suffix === "relcoor" || suffix === "abscoor")) {
								for(i1 = 0; i1 < 3; i1++) {
									text[i1] = (text[i1] > 0 ? "+" : "") + text[i1] + (text[i1]%1 ? "" : "  ");
								}
								// make it a string, add plus signs, and make sure
								// the decimal points align.
								text.splice(0, 0, "");
								left = [suffix.slice(0, 3) + ":", "", "", ""];
							}
							else if(prefix === "part" && suffix === "hypot") {
								left.push("length:");
							}
							else if(prefix === "scale" && suffix === "number") {
								right.push(
									bm.control.scale_denom === 1
									?
									(bm.control.scale_numer + "").slice(0, 5)
									:
									(bm.control.scale_numer + "/" + bm.control.scale_denom)
								);
							};
							//
							if(
								(prefix === "part" && (suffix === "hypot" || suffix === "relcoor" || suffix === "abscoor"))
								||
								(prefix !== "scale" && suffix === "number")
							) {
								if(Array.isArray(text)) {
									right = structuredClone(text);
								}
								else {
									right.push(text);
								};
							}
							else if(
								heading
								||
								(!suffix && prefix !== "expand")
								||
								(prefix === "part" && (suffix === "image_text" || suffix === "extra_text" || suffix === "symmetry"))
								||
								prefix === "px"
								||
								suffix === "x" || suffix === "y" || suffix === "z"
							) {
								if(Array.isArray(text)) {
									centered = structuredClone(text);
								}
								else {
									centered.push(text);
								};
							}
							else {
								if(Array.isArray(text)) {
									left = structuredClone(text);
								}
								else {
									left.push(text);
								};
							};
							//
							if(checkbox) {
								/*
								let box = Rect.expand_all(Rect.new(rect.x, rect.y, AAX.ui.block, AAX.ui.block), -1);
								ctx.fillStyle = bm.color.buttons[1];
								ctx.strokeStyle = bm.color.buttons[0];
								ctx.fillRect(box.x + 1, box.y + 1, box.w, box.h);
								Rect.fauxstroke(box, ctx);
								box = Rect.expand_all(box, -2);
								if(selected) {
									// draw a pink x, or filled box.
									//ctx.strokeStyle = bm.color.buttons[2];
									ctx.strokeStyle = bm.color.buttons[0];
									if(selected === 1) {
										linespecial(ctx, box.x, box.y, box.x + box.w, box.y + box.h);
										linespecial(ctx, box.x + box.w, box.y, box.x, box.y + box.h);
									}
									else if(selected === 2) {
										ctx.fillRect(box.x, box.y, box.w + 1, box.h + 1);
									};
								};
								//*/
								AAX.ui.checkbox(ctx, bm.color.buttons, rect.x, rect.y, selected === 2 ? "special check" : !!selected);
								ctx.strokeStyle = bm.color.buttons[0];
								rect.x += AAX.ui.block;
								rect.w -= AAX.ui.block;
							}
							else if(directions) {
								let selected = prefix === "expand" ? bm.control[prefix] : {
									l: false,
									r: false,
									u: false,
									d: false,
									b: false,
									f: false,
								};
								if(prefix === "adjust" && button === depress && bm.control.last_adjust) {
									selected[bm.control.last_adjust] = true;
								};
								let order = "lrudbf".split("");
								order.sort((a, b) => selected[a] - selected[b]);
								for(i1 = 0; i1 < order.length; i1++) {
									let _i1 = order[i1];
									ctx.fillStyle = bm.color.buttons[selected[_i1] ? 0 : 1];
									ctx.strokeStyle = bm.color.buttons[selected[_i1] ? 2 : 0];
									if(_i1 === "b" || _i1 === "f") {
										let box = Rect.new(rect.x + rect.w*2/3, rect.y, rect.w/3, rect.h/2);
										if(_i1 === "f") {
											box.y += box.h;
										};
										ctx.fillRect(box.x, box.y, box.w, box.h);
										Rect.fauxstroke(box, ctx);
									}
									else {
										let tri = [[1/2, 1/2]];
										tri.push([
										Number(_i1 === "r" || _i1 === "d"),
										Number(_i1 === "d" || _i1 === "l")
										]);
										tri.push([
										Number(_i1 === "u" || _i1 === "r"),
										Number(_i1 === "r" || _i1 === "d")
										]);
										for(i2 = 0; i2 < 3; i2++) {
											tri[i2] = [
											rect.x + tri[i2][0]*rect.w*2/3,
											rect.y + tri[i2][1]*rect.h
											];
										}
										_2dPoly.draw(ctx, tri, "both");
									}
								}
							};
							AAX.ui.button_text(ctx, rect, left, centered, right);
						}
					}
				}
			},
			mousedown: function(e) {
				let click = clickxy(e, "bm");
				bm.control.clicktype = "ui";
				for(let i1 in bm.ui.buttons) {
					if(bm.ui.buttons.hasOwnProperty(i1) && Rect.inside(bm.ui.buttons[i1], ...click)) {
						bm.ui.action(i1, click);
						bm.control.clicktype = null;
					}
				}
				bm.control.clicktype = null;
			},
			action: function(button, click) {
				let i0 = 0;
				let i1 = 0;
				let i2 = 0;
				let i3 = 0;
				let i4 = 0;
				let part = bm.control.bodydata_part;
				let prefix = PreSuf.get(button);
				let suffix = prefix[1];
				prefix = prefix[0];
				let refresh = {};
				for(i1 = 0; i1 < bm.valid.refresh.length; i1++) {
					let _i1 = bm.valid.refresh[i1];
					if(_i1 !== "bodytext") {
						refresh[_i1] = _i1 !== "states";
					}
				}
				// an object of booleans, for which parts of refresh should be
				// done or skipped.
				let no_refresh = false;
				function prompt_number(text, increment, no_negative, allow_inf) {
				// opens a prompt for changing a number. allows fractions.
				// returns null if their input was invalid.
				// - increment: 1 means the input will be truncated to the
				//   nearest integer, .5 means to the nearest .5, etc. 0 or any
				//   non-number will skip this.
				// - invalid inputs:
				//   - cancel
				//   - empty string (or a string that's just whitespace)
				//   - NaN when Number() is used
				//   - Infinity, -Infinity
					let input = prompt(text);
					if(input === null || !input.trim()) {
						return null;
					};
					input = input.split("/").slice(0, 2);
					for(let i1 = 0; i1 < 2; i1++) {
						input[i1] = Number(input[i1] ?? 1);
					}
					input = input[0]/input[1];
					if(typeof increment === "number" && increment) {
						input = Math.trunc(input/increment)*increment;
					};
					return (
						(
							isNaN(input)
							||
							((input === Infinity || input === -Infinity) && !allow_inf)
							||
							(input < 0 && no_negative)
						)
						?
						null
						:
						input
					);
				};
				//
				if(bm.ui.heading.includes(button)) {
					no_refresh = true;
				}
				else if(suffix === "directions" && click) {
					let rect = bm.ui.buttons[button];
					let direction = bm.ui.finddirection(
						(click[0] - rect.x)/rect.w,
						(click[1] - rect.y)/rect.h
					);
					if(prefix === "expand") {
						bm.control.expand[direction] = !bm.control.expand[direction];
					}
					else if(prefix === "adjust") {
						let temp = "lrudbf".indexOf(direction);
						if(bm.control.symmetry === 2 && (temp === 0 || temp === 1)) {
							temp = posmod(temp + 1, 2);
						}
						part["xyz"[Math.floor(temp/2)]] += (temp%2 ? 1 : -1)*(bm.control.adjust_half ? .5 : 1);
						refresh.states = true;
						bm.control.last_adjust = direction;
					}
				}
				else if(suffix === "number") {
					let text = (
						prefix === "scale" ? "enter the scale factor. it can be a fraction." :
						prefix === "expand" ? "enter how much to expand each side by." :
						"enter a number."
					);
					let num = null;
					if(prefix === "scale") {
						text = prompt(text);
						if(text) {
							let temp = text.indexOf("/");
							num = temp === -1 ? [Number(text), 1] : [Number(text.slice(0, temp)), Number(text.slice(temp + 1))];
							if(num[1] < 0) {
								num[0] *= -1;
								num[1] *= -1;
							};
							if(
								isNaN(num[0]) || isNaN(num[1])
								||
								num[0] === Infinity || num[0] === -Infinity
								||
								num[1] === Infinity || num[1] === 0
							) {
								num = null;
							};
						}
					}
					else {
						num = prompt_number(text, prefix === "expand" ? .5 : 0);
					}
					if(num === null) {
						no_refresh = true;
					}
					else {
						if(prefix === "scale") {
							bm.control.scale_numer = num[0];
							bm.control.scale_denom = num[1];
						}
						else {
							bm.control[button] = num;
						}
					};
				}
				else if(bm.ui.checkbox.includes(button) || (prefix === "scale" && (suffix === "x" || suffix === "y" || suffix === "z"))) {
					bm.control[button] = !bm.control[button];
				}
				else if(prefix === "scale" && suffix === "type") {
					let array = bm.valid[button];
					bm.control[button] = array[posmod(array.indexOf(bm.control[button]) + 1, array.length)];
				}
				else if(button === "scale") {
					let numer = bm.control.scale_numer;
					let denom = bm.control.scale_denom;
					let axes = [];
					for(i1 = 0; i1 < 3; i1++) {
						axes.push(bm.control["scale_" + "xyz"[i1]]);
					}
					let position = bm.control.scale_type === "position" || bm.control.scale_type === "both";
					let dimension = bm.control.scale_type === "dimension" || bm.control.scale_type === "both";
					let same_floats = true;
					if((numer !== 1 || denom !== 1) && denom && (position || dimension) && axes.includes(true)) {
						let keep_float = function(num, odd) {
							if(!num) {
								return num;
							};
							let float = odd ? .5 : 0;
							let sign = Math.sign(num);
							num = Math.abs(num);
							num = Math.round(num - float) + float;
							// make sure it has the same float as
							// the original
							return Math.max(num, float)*sign;
							// make sure the rounding didn't invert
							// the sign, reverse the Math.abs
						};
						let order = bm.control.scale_branch ? AAX.getdesc(bm.bodydata, bm.control.bodydata_name) : [];
						order.splice(0, 0, bm.control.bodydata_name);
						let start = part.parent === "standpoint" ? [0, 0, 0] : AAX.abscoor(bm.bodydata, part.parent);
						// position of the selected part's parent
						let all_abs = AAX.all_abs(bm.bodydata);
						// save this before you modify coordinates. that way,
						// ancestors' changes won't have cumulative effects on
						// their descendants.
						for(i0 = 0; i0 < order.length; i0++) {
							let _i0 = order[i0];
							let _part = bm.bodydata[_i0];
							if(position) {
								let coor = Points.subtract(all_abs[_i0], start);
								coor = Points.divide(Points.multiply(coor, numer), denom);
								coor = Points.add(coor, start);
								// multiply or divide its distance from the
								// branch start
								let abs_parent = _part.parent === "standpoint" ? [0, 0, 0] : AAX.abscoor(bm.bodydata, _part.parent);
								//
								for(i1 = 0; i1 < 3; i1++) {
									if(axes[i1]) {
										let num = coor[i1];
										if(same_floats) {
										// keep the same oddness it had before
											num = keep_float(num, !!(all_abs[_i0][i1]%1));
										}
										num = Math.trunc(num*2)/2;
										// make extra sure it's a .0 or .5
										_part["xyz"[i1]] = num - abs_parent[i1];
									};
								}
							}
							if(dimension) {
								let points = structuredClone(bm.body[(bm.has_symmetry(_i0) ? bm.control.prefix1 : "") + _i0].shape.points);
								for(i1 = 0; i1 < points.length; i1++) {
									for(i2 = 0; i2 < points[i1].length; i2++) {
										let point = points[i1][i2];
										if(point.length >= 4 && axes.includes(false)) {
											point[4] ??= point[3];
											point[5] ??= point[3];
										};
										for(i3 = 0; i3 < point.length && i3 < 6; i3++) {
											if(axes[i3%3]) {
												let num = point[i3]*numer/denom;
												if(same_floats) {
													num = i3 < 3 ? keep_float(num, !!(point[i3]%1)) : Math.round(num);
												};
												point[i3] = num;
											}
										}
										if(point.length >= 7 && dimension && (numer/denom) < 0 && axes.includes(false)) {
											point[6] = Quat.mirror.multi(point[6], ...axes);
										}
									}
								}
								bm.replaceshape(_part, {points});
							}
						}
						refresh.states = true;
					}
					else {
						no_refresh = true;
					}
				}
				else if(button === "expand") {
					let parts = bm.control.expand_branch ? AAX.getdesc(bm.bodydata, bm.control.bodydata_name) : [];
					parts.splice(0, 0, bm.control.bodydata_name);
					refresh.states = true;
					no_refresh = true;
					let num = bm.control.expand_number;
					const letters = "lrudbf";
					for(i0 = 0; i0 < (num ? parts.length : 0); i0++) {
						let _part = bm.bodydata[parts[i0]];
						let points = structuredClone(bm.body[bm.body_name(parts[i0])].shape.points);
						let bounds = AAX.Shape.bounds(points);
						if(bounds) {
						// expansion is both movement and scaling of the shape
						// points.
							let _bounds = structuredClone(bounds);
							for(i1 = 0; i1 < letters.length; i1++) {
								let _i1 = i1;
								if((_i1 === 0 || _i1 === 1) && bm.control.symmetry === 2) {
									_i1 = Number(!_i1);
								};
								_i1 = letters[_i1];
								if(bm.control.expand[_i1]) {
									no_refresh = false;
									_bounds[_i1] += (i1%2 ? 1 : -1)*num;
								}
							}
							// get the old box with AAX.Shape.bounds, modify it to get the new box
							if(!no_refresh) {
								let center = [];
								let _center = [];
								let multiply = [];
								let mirror = [];
								for(i1 = 0; i1 < 3; i1++) {
									let neg = letters[2*i1];
									let pos = letters[2*i1 + 1];
									center[i1] = (bounds[neg] + bounds[pos])/2;
									_center[i1] = (_bounds[neg] + _bounds[pos])/2;
									// find the centers of both boxes
									let temp = bounds[pos] - bounds[neg];
									multiply[i1] = temp ? (_bounds[pos] - _bounds[neg])/temp : 1;
									// get multipliers by dividing whatever by
									// whatever
									mirror[i1] = multiply[i1] < 0;
								}
								if(!mirror.includes(false)) {
									mirror = [false, false, false];
								}
								let all_same = multiply[0] === multiply[1] && multiply[1] === multiply[2];
								for(i1 = 0; i1 < points.length; i1++) {
									for(i2 = 0; i2 < points[i1].length; i2++) {
										let point = points[i1][i2];
										if(point.length > 3 && !all_same) {
											// if all the multipliers aren't the same,
											// fill all missing dimensions.
											point[4] ??= point[3];
											point[5] ??= point[3];
										};
										for(i3 = 0; i3 < 3; i3++) {
											point[i3] = (point[i3] - center[i3])*multiply[i3] + _center[i3];
											if(3 + i3 < point.length) {
												point[3 + i3] *= Math.abs(multiply[i3]);
											}
										}
										// for each point, subtract old box's
										// center, scale, add new box's center
										if(point.length >= 7) {
											point[6] = Quat.mirror.multi(point[6], ...mirror);
										}
									}
								}
							}
							bm.replaceshape(_part, {points});
						};
					}
				}
				else if(button === "delete") {
					if(bm.disable_delete()) {
						no_refresh = true;
					}
					else {
						let symmetry = bm.control.symmetry;
						let name = bm.control.bodydata_name;
						let _name = bm.bodydata[name].parent;
						// part that it'll switch to
						if(bm.control.delete_branch) {
							let array = AAX.getdesc(bm.bodydata, name);
							delete bm.bodydata[name];
							for(i1 = 0; i1 < array.length; i1++) {
								delete bm.bodydata[ array[i1] ];
							}
						}
						else {
							let array = AAX.getchildren(bm.bodydata, name);
							for(i1 = 0; i1 < array.length; i1++) {
								let _part = bm.bodydata[ array[i1] ];
								for(i2 = 0; i2 < 3; i2++) {
									_part["xyz"[i2]] += part["xyz"[i2]];
								}
								_part.parent = _name;
								if(part.symmetry) {
									_part.symmetry = true;
								}
							}
							delete bm.bodydata[name];
						};
						if(_name === "standpoint") {
							_name = AAX.getchildren(bm.bodydata, "standpoint")[0];
						};
						bm.control.partname = (bm.has_symmetry(_name) ? bm.control["prefix" + symmetry] : "") + _name;
						// - you have to use has_symmetry, since it might be
						//   symmetrical through an ancestor
						// - if it is symmetrical, match what the deleted part
						//   was
						// - if the deleted part wasn't symmetrical, that
						//   shouldn't be possible. so i'm okay with it causing
						//   undefined error.
						refresh.states = true;
					};
				}
				else if(prefix === "tool") {
					bm.control.tool = suffix;
				}
				else if(prefix === "part") {
					if(suffix === "name") {
						let symmetry = bm.control.symmetry;
						let name = prompt("enter a new name." + (symmetry ? " (leave out symmetry prefixes.)" : ""));
						//let name = prompt("enter a new name to rename the part," + (symmetry ? " (leave out symmetry prefixes.)" : "") + " or enter an existing part to select it.");
						name = (name ?? "").trim();
						if(!name) {
							no_refresh = true;
						}
						else if(name in bm.bodydata) {
							alert("part already exists.");
							no_refresh = true;
						}
						else {
							let _name = bm.control.bodydata_name;
							bm.bodydata[name] = structuredClone(bm.bodydata[_name]);
							delete bm.bodydata[_name];
							for(i1 in bm.bodydata) {
								if(bm.bodydata.hasOwnProperty(i1)) {
									let _part = bm.bodydata[i1];
									if(_part.parent === _name) {
										_part.parent = name;
									};
								}
							}
							bm.control.partname = (symmetry ? bm.control["prefix" + symmetry] : "") + name;
							refresh.states = true;
						};
					}
					else if(suffix === "image_text" || suffix === "extra_text") {
						let temp = part[suffix];
						let dialog = document.getElementById("bm_" + suffix);
						let textarea = document.getElementById("bm_" + suffix + "_input");
						textarea.rows = temp.split("\n").length + 4;
						textarea.value = temp;
						dialog.showModal();
						no_refresh = true;
						// clicking the button just opens the dialog. it doesn't
						// do anything worth refreshing, only the buttons inside
						// it do.
					}
					else if(suffix === "symmetry" || suffix === "prefix1" || suffix === "prefix2") {
						let name = bm.control.bodydata_name;
						let symmetry = bm.control.symmetry;
						if(suffix === "symmetry") {
							if(!bm.control.bodydata_part.symmetry && bm.has_symmetry(bm.control.bodydata_name)) {
							// descendant of a part with true symmetry (ie it
							// must stay false.)
								no_refresh = true;
							}
							else {
								bm.bodydata[name].symmetry = !bm.bodydata[name].symmetry;
								if(bm.bodydata[name].symmetry) {
									// when flipping symmetry on, flip it off for all
									// descendants
									let desc = AAX.getdesc(bm.bodydata, name);
									for(i1 = 0; i1 < desc.length; i1++) {
										bm.bodydata[ desc[i1] ].symmetry = false;
									}
									//
								}
								bm.control.partname = (bm.bodydata[name].symmetry ? bm.control.prefix1 : "") + name;
								// in either case, update partname
								refresh.states = true;
							}
						}
						else if(suffix === "prefix1" || suffix === "prefix2") {
							let text = prompt("enter a new prefix for " + (suffix === "prefix2" ? "mirrored" : "unmirrored") + " symmetrical parts.") ?? "";
							text = text.replaceAll(",", "").replaceAll("(", "").replaceAll(")", "").trim();
							// forbid parentheses and commas, for syntax reasons
							if(text && text !== bm.control["prefix" + (suffix === "prefix2" ? "1" : "2")]) {
								bm.control[suffix] = text;
								bm.control.partname = (symmetry ? bm.control["prefix" + symmetry] : "") + name;
								// update partname
								refresh.states = true;
								// prefixes are part of states.
							}
							else {
								no_refresh = true;
							}
						}
					}
				}
				else if(prefix === "template") {
					let temp = part.image_text.split("\n||\n");
					temp[0] = AAX.Shape.templates[suffix];
					part.image_text = temp.join("\n||\n");
					refresh.states = true;
				}
				else if(prefix === "drawsettings") {
					let ref = bm.drawsettings;
					if(suffix === "background") {
						let num = AAX.valid[suffix].indexOf(bm.drawsettings[suffix]);
						num = (num + 1)%3;
						if(num === 2) {
							num = (num + 1)%3;
						}
						bm.drawsettings[suffix] = AAX.valid[suffix][num];
					}
					else if(suffix === "draw_type") {
						let num = bm.valid[suffix].indexOf(bm.control[suffix]);
						num = (num + 1)%3;
						bm.control[suffix] = bm.valid[suffix][num];
						ref.silhouette = AAX.valid.silhouette[num === 1 ? 2 : 0];
						ref.parts = AAX.valid.parts[num === 0 ? 2 : 0];
					}
					else if(suffix === "skeleton") {
					// skeletons and nodes share one toggle.
						let bool = ref.skeleton && ref.nodes;
						ref.skeleton = !bool;
						ref.nodes = !bool;
					}
					else {
						no_refresh = AAX.ui.action.drawsettings(ref, suffix);
						if(!no_refresh && suffix === "fineness") {
							// clear the cache
							// - fineness affects the shape, the rest affect
							//   perspective.
							for(i1 in bm.pose) {
								if(bm.pose.hasOwnProperty(i1)) {
									// for every body part.
									AAX.clearcache(bm.pose, i1, "orientedshape");
									// this isn't an AAX., so we
									// can't use the method.
								}
							}
						};
					}
				}
				else if(prefix === "color") {
					no_refresh = AAX.ui.action.color(bm.color, suffix, click, bm.ui.buttons[button]);
				}
				else if(prefix === "px") {
					changefocus("px");
					px.transfer(bm.ctx, suffix === "replace");
					//px.transfer(bm.ctx, suffix === "replace", true, bm.drawsettings.cell.w, bm.drawsettings.cell.w);
					no_refresh = true;
				}
				else if(!suffix) {
					if(prefix === "undo") {
						bm.states.undo();
						no_refresh = true;
						// refresh already happens in undo/redo.
					}
					else if(prefix === "redo") {
						bm.states.redo();
						no_refresh = true;
					}
					else if(prefix === "save") {
						bm.save();
						no_refresh = true;
						// save doesn't do anything that requires a refresh
					}
					else if(prefix === "load") {
						bm.load();
						no_refresh = true;
						// load already refreshes
					};
				};
				// expand
				//  expand
				//  number
				//  directions
				//  no heading
				// adjust
				//  directions
				// shape templates
				//  sphere
				//  pelvis
				//  torso
				//  head
				//  cranium
				//  jaw
				// scale
				//  scale
				//  number
				//  divide
				//  no heading
				//
				if(bm.ui.depress.includes(button)) {
					refresh.ui = false;
					// it'll get redrawn for the depressing, so the other refresh
					// would just be redundant.
					bm.ui.draw(button);
					// draw the button depressed
					setTimeout(bm.ui.draw, 1000*AAX.ui.depress);
					// draw it undepressed after a little bit.
				}
				refresh.bodytext = refresh.states;
				let temp = [];
				for(i1 = 0; i1 < bm.valid.refresh.length; i1++) {
					let _i1 = bm.valid.refresh[i1];
					if(!refresh[_i1]) {
						temp.push(_i1);
					};
				}
				// now it's an array of what to skip.
				if(!no_refresh) {
					bm.refresh(temp);
				}
			},
		},
		nodes: [[], []],
		image_front: null,
		image_right: null,
		pasteimages: function(right) {
		// pastes image_front or image_right over the canvas, to reverse
		// graphical changes or correct overflow.
			bm.ctx.putImageData(bm["image_" + (right ? "right" : "front")], (right ? bm.drawsettings.cell.w : 0), 0);
		},
		writecoordinates: function(text) {
			AAX.writecoordinates(document.getElementById("bm_coor"), text);
		},
		nodeline: function(ctx, x1, y1, x2, y2, view, viewoffset) {
			let temp = bm.coortocanvas([0, 0, 0], view, true, viewoffset);
			temp[0] += .5;
			temp[1] += .5;
			// center of the standpoint pixel
			linespecial(ctx, x1, y1, x2, y2, temp);
		},
		draw_background: function() {
			AAX.draw_background(bm.ctx, bm.drawsettings, bm.color, false, "multi2");
		},
		draw: function() {
			AAX.draw(
				bm.ctx, bm.drawsettings, bm.color, false, "multi2",
				bm.pose, bm.nodes, bm.control.strokecache
			);
		},
		save: function() {
			AAX.save("bm " + filedate() + ".txt", bm.bodytext);
		},
		load: function() {
			AAX.load(bm.readfile);
		},
		readfile: function(file) {
		// run by load and the drag-and-drop event listener.
			if(!file) {
				console.log("this shouldn't happen");
				return;
			};
			let temp = file.name.lastIndexOf(".");
			let reader = new FileReader();
			reader.onload = function() {
				bm.bodytext_change(reader.result);
			};
			reader.readAsText(file);
		},
		version_history: "v1.0".split(" "),
		get version() {
			return bm.version_history[bm.version_history.length - 1];
		},
	};
	//bm.initialize();
	//
	document.write(`\n<div id="px_div"></div>`);
	let px = null;
	//let px = new PixelArt(document.getElementById("px_div"));
	//
	document.write(`\n<div id="se_div"></div>`);
	let se = {
		initialize: function() {
			let i1 = 0;
			let i2 = 0;
			let html = [
				"<textarea name=\"shape\" cols=48></textarea>",
				"<br><label><input type=\"number\" name=\"spacing\" style=\"width: 3em\" step=1 value=1> cross section spacing</label>",
				"<br><label><input type=\"number\" name=\"fineness\" style=\"width: 3em\" step=1 value=4> spheroid fineness</label>",
				"<br><button name=\"update\">update</button>",
				"<br><br><canvas></canvas>",
				"<br><label><input type=\"range\" name=\"scan range\"><br><input type=\"number\" name=\"scan\"> scan</label>",
				// any changes to the tickbox apply to the slider, and vice versa.
				"<br><label><input type=\"checkbox\" name=\"flip\"> flip</label>"
			].join("\n");
			this.html = {};
			this.html.container = document.getElementById("se_div");
			let container = this.html.container;
			container.innerHTML = html;
			let desc = htmldescendants(container);
			for(i1 = 0; i1 < desc.length; i1++) {
				let ref = desc[i1];
				let name = (
					ref.name
					??
					(
						"name" in ref.attributes ? ref.attributes.name.value :
						ref.tagName.toLowerCase() === "button" ? ref.innerHTML :
						""
					)
				);
				if(name) {
					this.html[name] = ref;
				};
			}
			//this.html.shape.value = AAX.Shape.templates.sphere;
			this.html.shape.value = AAX.Shape.templates.head + " / | / 0, 0, 0, 10 / 8, -14, 8".replaceAll(" / ", "\n");
			this.html.canvas = container.querySelector("canvas");
			this.html.canvas.style["image-rendering"] = "crisp-edges";
			this.ctx = this.html.canvas.getContext("2d");
			let _this = this;
			this.html.shape.onkeydown = textarea_autosize;
			textarea_autosize(this.html.shape);
			this.html.update.onclick = function(e) { _this.update(_this) };
			this.html.scan.onchange = function(e) {
				_this.html["scan range"].value = _this.html.scan.value;
				_this.redraw(_this);
			};
			this.html["scan range"].onchange = function(e) {
				_this.html.scan.value = _this.html["scan range"].value;
				_this.redraw(_this);
			};
			this.html.scan.min = 0;
			this.html.scan.step = 1;
			this.html["scan range"].min = 0;
			this.html["scan range"].step = 1;
			this.html.flip.onchange = function(e) { _this.redraw(_this) };
			this.update();
		},
		update: function(_this) {
			_this ??= this;
			let i0 = 0;
			let i1 = 0;
			let i2 = 0;
			let i3 = 0;
			let shape = AAX.Shape.new(_this.html.shape.value);
			let spacing = readnumber(_this.html.spacing.value);
			let fineness = readnumber(_this.html.fineness.value);
			if(spacing === null || spacing <= 0) {
				return;
			};
			let points = shape.points;
			let bounds = AAX.Shape.bounds(points);
			if(!bounds) {
				alert("invalid shape. there are no points, or one of the dimensions is zero.");
				return;
			};
			let dim = 0;
			for(i1 = 0; i1 < 6; i1++) {
				dim = Math.max(dim, Math.abs(bounds["lrudbf"[i1]]));
			}
			let slice_count = 2*Math.floor(dim/spacing) + 1;
			dim++;
			dim *= 2;
			// dim is used for the dimensions of all views. the views will
			// always show a cube-shaped area centered on [0, 0, 0], so it has
			// to be whatever number will contain the whole shape.
			let _points = [];
			for(i1 = 0; i1 < points.length; i1++) {
				_points.push(addspheroids(points[i1], fineness));
				/*
				for(i2 = 0; i2 < _points[i1].length; i2++) {
					_points[i1][i2][0] += .5;
					_points[i1][i2][1] += .5;
					_points[i1][i2][2] += .5;
				}
				//*/
			}
			_this.control.slices = {xy: [], xz: [], yz: []};
			// square rasters for every slice of every axis, showing which
			// pixels are part of the cross section.
			_this.control.sectors = {xy: [], xz: [], yz: []};
			// similar, but not quite the same.
			// - a sector is the shape created by convexing together two slices.
			// - this is what is actually shown, since that looks smoother, and
			//   is closer to what the shape looks like.
			// - the only reason slices are kept around is so that it can color
			//   stuff differently if it's inside the shape because of scanning
			//   is being used.
			//   - you see, it's inside if it's the layer one scan away from
			//     being hidden, but...
			//   - sectors are 3d shapes, not the 2d cross section. so coloring
			//     the whole sector would be overboard.
			//   - it doesn't make that much of a difference, but i don't wanna
			//     half-ass it.
			// - there is always one more sector than there are slices, since
			//   slices are divisions between sectors.
			//   - sector[0], slice[0], sector[1], slice[1], etc. sector[index]
			//     between slice[index - 1] and slice[index].
			let rect = Rect.new(-dim/2, -dim/2, dim, dim);
			for(i0 = 0; i0 < 3; i0++) {
			// for each axis, make a set of cross sections
				let axis = "xyz".replace("xyz"[2 - i0], "");
				let quat = Quat.new();
				if(axis === "xz") {
					quat = Quat.rotate(quat, "yz", Math.PI/2);
				}
				else if(axis === "yz") {
					quat = Quat.rotate(quat, "xz", -Math.PI/2);
				};
				//
				let data = [];
				let center = Points.multiply(Quat.basis(quat)[2], -((slice_count - 1)/2)*spacing);
				for(i1 = 0; i1 < _points.length; i1++) {
					data.push(shapeslices(_points[i1], quat, center, slice_count, spacing, true));
					// (points, quat, center, slice_count, slice_spacing, convert) {
				}
				// a shapeslices for each axis, which will be used to make slices
				// and sectors.
				for(i1 = 0; i1 <= 2*slice_count; i1++) {
				// make each slice and sector.
					let _i1 = Math.floor(i1/2);
					let image = [];
					for(i2 = 0; i2 < dim**2; i2++) {
						image.push(false);
					}
					for(i2 = 0; i2 < _points.length; i2++) {
					// for each point group, add it to the image
						let shape = null;
						if(i1%2) {
						// for a slice, just take the slice shapeslices made.
							shape = data[i2].slices[_i1];
						}
						else {
						// for a sector, combine the slices that are the
						// boundaries of the sector, or if it's at the end,
						// include the points outside all slices.
							let start = _i1 ? data[i2].slices[_i1 - 1] : data[i2].neg;
							let end = _i1 < slice_count ? data[i2].slices[_i1] : data[i2].pos;
							shape = _2dPoly.convexed(structuredClone(start).concat(structuredClone(end)));
						};
						if(shape && shape.length) {
							let _shape = structuredClone(shape);
							let _rect = Rect.frompoints(shape);
							_rect = Rect.round_out(_rect);
							shape = _2dPoly.getdata(shape, true);
							// convert that from a shape to pixels
							if(!Rect.encloses(shape.rect, _rect)) {
								let temp = Rect.overlap(shape.rect, _rect);
								temp = temp ? temp.w*temp.h : 0;
								temp = temp/(_rect.w*_rect.h);
								if(temp < .9) {
									console.log("-");
									console.log([axis, (i1%2 ? "slice" : "sector"), _i1].join(" "));
									console.log(_rect);
									console.log(shape.rect);
									console.log("coverage: " + temp);
									console.log(_shape);
								}
							}
							for(i3 = 0; i3 < shape.within.length; i3++) {
							// add those pixels to within.
								if(shape.within[i3]) {
									let index = Rect.convertindex(shape.rect, rect, i3);
									if(index === -1) {
										console.log("this shouldn't happen");
									}
									else {
										image[index] = true;
									}
								}
							}
						}
					}
					_this.control[i1%2 ? "slices" : "sectors"][axis].push(image);
				}
			}
			_this.html.scan.max = slice_count - 1;
			_this.html.scan.value = 0;
			_this.html["scan range"].max = slice_count - 1;
			_this.html["scan range"].value = 0;
			_this.control.dim = dim;
			_this.html.flip.checked = false;
			_this.redraw();
		},
		redraw: function(_this) {
		// refreshes the image, to apply the changes of a shape update, or a
		// change to scan or flip.
			_this ??= this;
			let i0 = 0;
			let i1 = 0;
			let i2 = 0;
			let ctx = _this.ctx;
			let dim = _this.control.dim;
			let margin = Math.floor(dim/4);
			let _dim = dim + 2*margin;
			let flip = _this.html.flip.checked;
			let scan = Math.max(0, readnumber(_this.html.scan.value) ?? 0);
			ctx.canvas.width = 2*_dim;
			ctx.canvas.height = 2*_dim;
			ctx.clearRect(0, 0, 2*_dim, 2*_dim);
			ctx.fillStyle = "#181";
			ctx.fillRect(0, 0, 2*_dim, 2*_dim);
			let rect = Rect.new(-dim/2, -dim/2, dim, dim);
			for(i0 = 0; i0 < 3; i0++) {
				let axis = "xyz".replace("xyz"[2 - i0], "");
				let sectors = _this.control.sectors[axis];
				let x = (axis === "yz" ? 3 : 1)*_dim/2;
				let y = (axis === "xz" ? 1 : 3)*_dim/2;
				for(i1 = 0; i1 < sectors.length - scan; i1++) {
					let _i1 = flip ? (sectors.length - 1 - i1) : i1;
					let sector = sectors[_i1];
					let inside = scan && i1 === sectors.length - 1 - scan;
					// if at least one sector has been hidden by scan, and this
					// is the closest unhidden sector, some pixels should be
					// marked as being inside.
					let color = i1/(sectors.length - 1);
					inside = (
						inside
						?
						{
							color: "rgb(255, " + (127 + Math.round(128*color)) + ", 127)",
							slice: _this.control.slices[axis][_i1],
						}
						:
						null
					);
					color = "rgb(255, " + Math.round(255*color) + ", 0)";
					ctx.fillStyle = color;
					for(i2 = 0; i2 < sector.length; i2++) {
						if(sector[i2]) {
							let coor = Rect.getcoor(rect, i2);
							if(flip) {
							// flip doesn't just mean reversing the order, it's
							// mean to emulate looking at the back, left, and
							// bottom. so, flip it so it's actually analogous.
								coor[axis === "xz" ? 1 : 0] *= -1;
							};
							if(inside) {
							// if the inside stuff applies AND this pixel is
							// also in the slice, use the inside color.
								ctx.fillStyle = inside.slice[i2] ? inside.color : color;
							};
							ctx.fillRect(x + coor[0], y + coor[1], 1, 1);
						};
					}
				}
			}
		},
		control: {
			dim: 0,
			slices: null,
			sectors: null,
		},
	};
	//se.initialize();
	//
	document.write(`\n<div id="bg_div"></div>`);
	let bg = {
		initialize: function() {
			let i1 = 0;
			let html = [
				"<canvas name=\"canvas\"></canvas>",
				"<br><button name=\"render\">render</button>"
			].join("\n");
			this.container = document.getElementById("bg_div");
			this.container.innerHTML = html;
			this.html = {};
			let list = htmldescendants(this.container);
			for(i1 = 0; i1 < list.length; i1++) {
				let name = list[i1].name || list[i1].attributes?.name?.value || "";
				if(name) {
					name = name.replaceAll(" ", "_");
					this.html[name] = list[i1];
				}
			}
			this.ctx = this.html.canvas.getContext("2d");
			let _this = this;
			this.html.render.onclick = function() {
				let paper = new Paper();
				// - viewer
				// - w, h
				// - bg
				// - fineness
				// - light
				//   - x, y, z
				//   - light_value, dark_value
				// - sheets
				for(let i1 = 0; i1 < 6; i1++) {
				// create a cube. left, right, up, down, back, front.
					let w = paper.w;
					let h = (i1 === 2 || i1 === 3) ? paper.w : paper.h;
					paper.sheets[i1] = new Paper.Sheet(w, h);
					// - color
					// - x, y, z
					// - center
					//   - x, y
					// - quat
					// - shapes
					// - neighbors
					let ref = paper.sheets[i1];
					ref.color = "red orange yellow green blue purple".split(" ")[i1];
					ref.x = ((i1 === 1 || i1 === 5) ? 1 : -1)*w/2;
					ref.y = (i1 === 3 ? 1 : -1)*h/2;
					ref.z = ((i1 === 0 || i1 === 2 || i1 === 5) ? 1 : -1)*w/2;
					// the position should be the upper left corner of the
					// rectangle, so...
					// - l: l u f
					// - r: r u b
					// - u: l u f
					// - d: l d b
					// - b: l u b
					// - f: r u f
					ref.quat = (
						i1 === 2 ? Quat.new("yz", -Math.PI/2) :
						i1 === 3 ? Quat.new("yz", Math.PI/2) :
						i1 === 4 ? Quat.new() :
						Quat.new("xz", (i1 === 0 ? 3 : i1 === 1 ? 1 : i1 === 5 ? 2 : 0)*Math.PI/2)
					);
					/*
					console.log("lrudbf"[i1]);
					for(let i2 = 0; i2 < 4; i2++) {
						let point = [Number(i2%2), Number(i2 >= 2), 0];
						//console.log(structuredClone(point));
						point = Points.multiply(point, [w, h, 1]);
						//console.log(structuredClone(point));
						point = Quat.apply(ref.quat, point);
						//console.log(structuredClone(point));
						point = Points.add(Points.convert(ref), point);
						//console.log(structuredClone(point));
						point = Points.divide(point, [paper.w, paper.h, paper.w]);
						//console.log(structuredClone(point));
						point = Points.applyfunc(point, Math.sign);
						point = (
							"-0+"[point[0] + 1]
							+
							"-0+"[point[1] + 1]
							+
							"-0+"[point[2] + 1]
						);
						console.log(point);
					}
					//*/
				}
				paper.render(_this.ctx);
			};
		},
	};
	//bg.initialize();
	//
	let temp = document.getElementsByName("userfocus");
	for(let i1 in temp) {
		if(temp.hasOwnProperty(i1)) {
			let focus = temp[i1].value;
			document.getElementById(focus + "_div").hidden = true;
			temp[i1].onchange = function(e) {
				if(e.target.checked) {
					changefocus(e.target.value);
				}
			}
		}
	}
	let userfocus_init = [];
	// lists strings that userfocus has been set to, so that it can initialize
	// the tools only the first time you use them.
	function changefocus(focusname) {
		userfocus = focusname;
		if(!userfocus_init.includes(userfocus)) {
		// initializing happens here, mostly because it's a little wasteful for
		// shape examiner to generate all those cross sections if the user
		// doesn't even open it.
			userfocus_init.push(userfocus);
			if(userfocus === "aa") {
				aa.initialize();
			}
			else if(userfocus === "bm") {
				bm.initialize();
			}
			else if(userfocus === "px") {
				px = new PixelArt(document.getElementById("px_div"));
				//px.html.anim_vertical.checked = true;
				// it shouldn't be checked by default most of the time, but it
				// should for this page, to match how aa exports animations.
			}
			else if(userfocus === "se") {
				se.initialize();
			}
			else if(userfocus === "bg") {
				bg.initialize();
			};
		};
		document.getElementsByName("userfocus").forEach(function(element) {
			element.checked = element.value === userfocus;
			document.getElementById(element.value + "_div").hidden = !element.checked;
		});
		document.getElementById("desc").innerHTML = (
			userfocus === "aa" ? "a character animation system that's featured out the ass. works better with a mouse. read the manual." :
			userfocus === "bm" ? "a tool for creating bodytexts you can use in armature artist. make sure to read the manual of that to get how bodytext works. or what a bodytext is." :
			userfocus === "px" ? "a pixel art tool. lets you edit images from armature artist or body maker into proper sprites." :
			userfocus === "se" ? "lets you examine the 3d shapes you can use in armature artist and body maker. the 3d system doesn't show inner outlines or lighting, so this lets you look at cross sections to get an idea of its form." :
			userfocus === "bg" ? "uses a scripting system to generate backgrounds out of 2d shapes oriented in 3d space." :
			""
		);
	};
	changefocus("aa");
	//
	addEventListener("load", function() {
	// this is so stupid. but i'm cryin tears of joy that it works.
	// - the font in the ui graphics is blurry until the first page refresh or
	//   ui refresh, since the page/canvas loads faster than the font. this
	//   triggers a ui refresh after the page fully loads.
		if(userfocus === "aa") {
			let skip = structuredClone(AAX.valid.refresh);
			skip.splice(skip.indexOf("ui"), 1);
			aa.refresh(skip);
		}
		else if(userfocus === "bm") {
			let skip = structuredClone(bm.valid.refresh);
			skip.splice(skip.indexOf("ui"), 1);
			bm.refresh(skip);
		};
	}, false);
	</script>
	</body>
</html>
